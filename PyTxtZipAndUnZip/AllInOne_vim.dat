" These are the mappings for snipMate.vim. Putting it here ensures that it
" will be mapped after other plugins such as supertab.vim.
if !exists('loaded_snips') || exists('s:did_snips_mappings')
	finish
endif
let s:did_snips_mappings = 1

" This is put here in the 'after' directory in order for snipMate to override
" other plugin mappings (e.g., supertab).
"
" You can safely adjust these mappings to your preferences (as explained in
" :help snipMate-remap).
ino <silent> <tab> <c-r>=TriggerSnippet()<cr>
snor <silent> <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>
ino <silent> <s-tab> <c-r>=BackwardsSnippet()<cr>
snor <silent> <s-tab> <esc>i<right><c-r>=BackwardsSnippet()<cr>
ino <silent> <c-r><tab> <c-r>=ShowAvailableSnips()<cr>

" The default mappings for these are annoying & sometimes break snipMate.
" You can change them back if you want, I've put them here for convenience.
snor <bs> b<bs>
snor <right> <esc>a
snor <left> <esc>bi
snor ' b<bs>'
snor ` b<bs>`
snor % b<bs>%
snor U b<bs>U
snor ^ b<bs>^
snor \ b<bs>\
snor <c-x> b<bs><c-x>

" By default load snippets in snippets_dir
if empty(snippets_dir)
	finish
endif

call GetSnippets(snippets_dir, '_') " Get global snippets

au FileType * if &ft != 'help' | call GetSnippets(snippets_dir, &ft) | endif
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/after/plugin/snipMate.vim
'Tlist_Auto_Highlight_Tag'	taglist.txt	/*'Tlist_Auto_Highlight_Tag'*
'Tlist_Auto_Open'	taglist.txt	/*'Tlist_Auto_Open'*
'Tlist_Auto_Update'	taglist.txt	/*'Tlist_Auto_Update'*
'Tlist_Close_On_Select'	taglist.txt	/*'Tlist_Close_On_Select'*
'Tlist_Compact_Format'	taglist.txt	/*'Tlist_Compact_Format'*
'Tlist_Ctags_Cmd'	taglist.txt	/*'Tlist_Ctags_Cmd'*
'Tlist_Display_Prototype'	taglist.txt	/*'Tlist_Display_Prototype'*
'Tlist_Display_Tag_Scope'	taglist.txt	/*'Tlist_Display_Tag_Scope'*
'Tlist_Enable_Fold_Column'	taglist.txt	/*'Tlist_Enable_Fold_Column'*
'Tlist_Exit_OnlyWindow'	taglist.txt	/*'Tlist_Exit_OnlyWindow'*
'Tlist_File_Fold_Auto_Close'	taglist.txt	/*'Tlist_File_Fold_Auto_Close'*
'Tlist_GainFocus_On_ToggleOpen'	taglist.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
'Tlist_Highlight_Tag_On_BufEnter'	taglist.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
'Tlist_Inc_Winwidth'	taglist.txt	/*'Tlist_Inc_Winwidth'*
'Tlist_Max_Submenu_Items'	taglist.txt	/*'Tlist_Max_Submenu_Items'*
'Tlist_Max_Tag_Length'	taglist.txt	/*'Tlist_Max_Tag_Length'*
'Tlist_Process_File_Always'	taglist.txt	/*'Tlist_Process_File_Always'*
'Tlist_Show_Menu'	taglist.txt	/*'Tlist_Show_Menu'*
'Tlist_Show_One_File'	taglist.txt	/*'Tlist_Show_One_File'*
'Tlist_Sort_Type'	taglist.txt	/*'Tlist_Sort_Type'*
'Tlist_Use_Horiz_Window'	taglist.txt	/*'Tlist_Use_Horiz_Window'*
'Tlist_Use_Right_Window'	taglist.txt	/*'Tlist_Use_Right_Window'*
'Tlist_Use_SingleClick'	taglist.txt	/*'Tlist_Use_SingleClick'*
'Tlist_WinHeight'	taglist.txt	/*'Tlist_WinHeight'*
'Tlist_WinWidth'	taglist.txt	/*'Tlist_WinWidth'*
:TlistAddFiles	taglist.txt	/*:TlistAddFiles*
:TlistAddFilesRecursive	taglist.txt	/*:TlistAddFilesRecursive*
:TlistClose	taglist.txt	/*:TlistClose*
:TlistDebug	taglist.txt	/*:TlistDebug*
:TlistHighlightTag	taglist.txt	/*:TlistHighlightTag*
:TlistLock	taglist.txt	/*:TlistLock*
:TlistMessages	taglist.txt	/*:TlistMessages*
:TlistOpen	taglist.txt	/*:TlistOpen*
:TlistSessionLoad	taglist.txt	/*:TlistSessionLoad*
:TlistSessionSave	taglist.txt	/*:TlistSessionSave*
:TlistShowPrototype	taglist.txt	/*:TlistShowPrototype*
:TlistShowTag	taglist.txt	/*:TlistShowTag*
:TlistToggle	taglist.txt	/*:TlistToggle*
:TlistUndebug	taglist.txt	/*:TlistUndebug*
:TlistUnlock	taglist.txt	/*:TlistUnlock*
:TlistUpdate	taglist.txt	/*:TlistUpdate*
Tlist_Get_Tag_Prototype_By_Line()	taglist.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tagname_By_Line()	taglist.txt	/*Tlist_Get_Tagname_By_Line()*
Tlist_Set_App()	taglist.txt	/*Tlist_Set_App()*
Tlist_Update_File_Tags()	taglist.txt	/*Tlist_Update_File_Tags()*
taglist-commands	taglist.txt	/*taglist-commands*
taglist-debug	taglist.txt	/*taglist-debug*
taglist-extend	taglist.txt	/*taglist-extend*
taglist-faq	taglist.txt	/*taglist-faq*
taglist-functions	taglist.txt	/*taglist-functions*
taglist-install	taglist.txt	/*taglist-install*
taglist-internet	taglist.txt	/*taglist-internet*
taglist-intro	taglist.txt	/*taglist-intro*
taglist-keys	taglist.txt	/*taglist-keys*
taglist-license	taglist.txt	/*taglist-license*
taglist-menu	taglist.txt	/*taglist-menu*
taglist-options	taglist.txt	/*taglist-options*
taglist-requirements	taglist.txt	/*taglist-requirements*
taglist-session	taglist.txt	/*taglist-session*
taglist-todo	taglist.txt	/*taglist-todo*
taglist-using	taglist.txt	/*taglist-using*
taglist.txt	taglist.txt	/*taglist.txt*
zhimakaimen:/doc/tags
*snipMate.txt*  Plugin for using TextMate-style snippets in Vim.

snipMate                                       *snippet* *snippets* *snipMate*
Last Change: December 27, 2009

|snipMate-description|   Description
|snipMate-syntax|        Snippet syntax
|snipMate-usage|         Usage
|snipMate-settings|      Settings
|snipMate-features|      Features
|snipMate-disadvantages| Disadvantages to TextMate
|snipMate-contact|       Contact
|snipMate-license|       License

For Vim version 7.0 or later.
This plugin only works if 'compatible' is not set.
{Vi does not have any of these features.}

==============================================================================
DESCRIPTION                                             *snipMate-description*

snipMate.vim implements some of TextMate's snippets features in Vim. A
snippet is a piece of often-typed text that you can insert into your
document using a trigger word followed by a <tab>.

For instance, in a C file using the default installation of snipMate.vim, if
you type "for<tab>" in insert mode, it will expand a typical for loop in C: >

 for (i = 0; i < count; i++) {

 }


To go to the next item in the loop, simply <tab> over to it; if there is
repeated code, such as the "i" variable in this example, you can simply
start typing once it's highlighted and all the matches specified in the
snippet will be updated. To go in reverse, use <shift-tab>.

==============================================================================
SYNTAX                                                        *snippet-syntax*

Snippets can be defined in two ways. They can be in their own file, named
after their trigger in 'snippets/<filetype>/<trigger>.snippet', or they can be
defined together in a 'snippets/<filetype>.snippets' file. Note that dotted
'filetype' syntax is supported -- e.g., you can use >

	:set ft=html.eruby

to activate snippets for both HTML and eRuby for the current file.

The syntax for snippets in *.snippets files is the following: >

 snippet trigger
 	expanded text
	more expanded text

Note that the first hard tab after the snippet trigger is required, and not
expanded in the actual snippet. The syntax for *.snippet files is the same,
only without the trigger declaration and starting indentation.

Also note that snippets must be defined using hard tabs. They can be expanded
to spaces later if desired (see |snipMate-indenting|).

"#" is used as a line-comment character in *.snippets files; however, they can
only be used outside of a snippet declaration. E.g.: >

 # this is a correct comment
 snippet trigger
 	expanded text
 snippet another_trigger
 	# this isn't a comment!
	expanded text
<
This should hopefully be obvious with the included syntax highlighting.

                                                               *snipMate-${#}*
Tab stops ~

By default, the cursor is placed at the end of a snippet. To specify where the
cursor is to be placed next, use "${#}", where the # is the number of the tab
stop. E.g., to place the cursor first on the id of a <div> tag, and then allow
the user to press <tab> to go to the middle of it:
 >
 snippet div
 	<div id="${1}">
		${2}
	</div>
<
                        *snipMate-placeholders* *snipMate-${#:}* *snipMate-$#*
Placeholders ~

Placeholder text can be supplied using "${#:text}", where # is the number of
the tab stop. This text then can be copied throughout the snippet using "$#",
given # is the same number as used before. So, to make a C for loop: >

 snippet for
 	for (${2:i}; $2 < ${1:count}; $1++) {
		${4}
	}

This will cause "count" to first be selected and change if the user starts
typing. When <tab> is pressed, the "i" in ${2}'s position will be selected;
all $2 variables will default to "i" and automatically be updated if the user
starts typing.
NOTE: "$#" syntax is used only for variables, not for tab stops as in TextMate.

Variables within variables are also possible. For instance: >

 snippet opt
 	<option value="${1:option}">${2:$1}</option>

Will, as usual, cause "option" to first be selected and update all the $1
variables if the user starts typing. Since one of these variables is inside of
${2}, this text will then be used as a placeholder for the next tab stop,
allowing the user to change it if he wishes.

To copy a value throughout a snippet without supplying default text, simply
use the "${#:}" construct without the text; e.g.: >

 snippet foo
 	${1:}bar$1
<                                                          *snipMate-commands*
Interpolated Vim Script ~

Snippets can also contain Vim script commands that are executed (via |eval()|)
when the snippet is inserted. Commands are given inside backticks (`...`); for
TextMates's functionality, use the |system()| function. E.g.: >

 snippet date
 	`system("date +%Y-%m-%d")`

will insert the current date, assuming you are on a Unix system. Note that you
can also (and should) use |strftime()| for this example.

Filename([{expr}] [, {defaultText}])             *snipMate-filename* *Filename()*

Since the current filename is used often in snippets, a default function
has been defined for it in snipMate.vim, appropriately called Filename().

With no arguments, the default filename without an extension is returned;
the first argument specifies what to place before or after the filename,
and the second argument supplies the default text to be used if the file
has not been named. "$1" in the first argument is replaced with the filename;
if you only want the filename to be returned, the first argument can be left
blank. Examples: >

 snippet filename
 	`Filename()`
 snippet filename_with_default
 	`Filename('', 'name')`
 snippet filename_foo
 	`filename('$1_foo')`

The first example returns the filename if it the file has been named, and an
empty string if it hasn't. The second returns the filename if it's been named,
and "name" if it hasn't. The third returns the filename followed by "_foo" if
it has been named, and an empty string if it hasn't.

                                                                   *multi_snip*
To specify that a snippet can have multiple matches in a *.snippets file, use
this syntax: >

 snippet trigger A description of snippet #1
 	expand this text
 snippet trigger A description of snippet #2
 	expand THIS text!

In this example, when "trigger<tab>" is typed, a numbered menu containing all
of the descriptions of the "trigger" will be shown; when the user presses the
corresponding number, that snippet will then be expanded.

To create a snippet with multiple matches using *.snippet files,
simply place all the snippets in a subdirectory with the trigger name:
'snippets/<filetype>/<trigger>/<name>.snippet'.

==============================================================================
USAGE                                                         *snipMate-usage*

                                                 *'snippets'* *g:snippets_dir*
Snippets are by default looked for any 'snippets' directory in your
'runtimepath'. Typically, it is located at '~/.vim/snippets/' on *nix or
'$HOME\vimfiles\snippets\' on Windows. To change that location or add another
one, change the g:snippets_dir variable in your |.vimrc| to your preferred
directory, or use the |ExtractSnips()|function. This will be used by the
|globpath()| function, and so accepts the same syntax as it (e.g.,
comma-separated paths).

ExtractSnipsFile({directory}, {filetype})     *ExtractSnipsFile()* *.snippets*

ExtractSnipsFile() extracts the specified *.snippets file for the given
filetype. A .snippets file contains multiple snippet declarations for the
filetype. It is further explained above, in |snippet-syntax|.

ExtractSnips({directory}, {filetype})             *ExtractSnips()* *.snippet*

ExtractSnips() extracts *.snippet files from the specified directory and
defines them as snippets for the given filetype. The directory tree should
look like this: 'snippets/<filetype>/<trigger>.snippet'. If the snippet has
multiple matches, it should look like this:
'snippets/<filetype>/<trigger>/<name>.snippet' (see |multi_snip|).

ResetAllSnippets()                                       *ResetAllSnippets()*
ResetAllSnippets() removes all snippets from memory. This is useful to put at
the top of a snippet setup file for if you would like to |:source| it multiple
times.

ResetSnippets({filetype})                                   *ResetSnippets()*
ResetSnippets() removes all snippets from memory for the given filetype.

ReloadAllSnippets()                                     *ReloadAllSnippets()*
ReloadAllSnippets() reloads all snippets for all filetypes. This is useful for
testing and debugging.

ReloadSnippets({filetype})                                 *ReloadSnippets()*
ReloadSnippets() reloads all snippets for the given filetype.

                                             *list-snippets* *i_CTRL-R_<Tab>*
If you would like to see what snippets are available, simply type <c-r><tab>
in the current buffer to show a list via |popupmenu-completion|.

==============================================================================
SETTINGS                                  *snipMate-settings* *g:snips_author*

The g:snips_author string (similar to $TM_FULLNAME in TextMate) should be set
to your name; it can then be used in snippets to automatically add it. E.g.: >

 let g:snips_author = 'Hubert Farnsworth'
 snippet name
 	`g:snips_author`
<
                                     *snipMate-expandtab* *snipMate-indenting*
If you would like your snippets to be expanded using spaces instead of tabs,
just enable 'expandtab' and set 'softtabstop' to your preferred amount of
spaces. If 'softtabstop' is not set, 'shiftwidth' is used instead.

                                                              *snipMate-remap*
snipMate does not come with a setting to customize the trigger key, but you
can remap it easily in the two lines it's defined in the 'after' directory
under 'plugin/snipMate.vim'. For instance, to change the trigger key
to CTRL-J, just change this: >

 ino <tab> <c-r>=TriggerSnippet()<cr>
 snor <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>

to this: >
 ino <c-j> <c-r>=TriggerSnippet()<cr>
 snor <c-j> <esc>i<right><c-r>=TriggerSnippet()<cr>

==============================================================================
FEATURES                                                   *snipMate-features*

snipMate.vim has the following features among others:
  - The syntax of snippets is very similar to TextMate's, allowing
    easy conversion.
  - The position of the snippet is kept transparently (i.e. it does not use
    markers/placeholders written to the buffer), which allows you to escape
    out of an incomplete snippet, something particularly useful in Vim.
  - Variables in snippets are updated as-you-type.
  - Snippets can have multiple matches.
  - Snippets can be out of order. For instance, in a do...while loop, the
    condition can be added before the code.
  - [New] File-based snippets are supported.
  - [New] Triggers after non-word delimiters are expanded, e.g. "foo"
    in "bar.foo".
  - [New] <shift-tab> can now be used to jump tab stops in reverse order.

==============================================================================
DISADVANTAGES                                         *snipMate-disadvantages*

snipMate.vim currently has the following disadvantages to TextMate's snippets:
    - There is no $0; the order of tab stops must be explicitly stated.
    - Placeholders within placeholders are not possible. E.g.: >

      '<div${1: id="${2:some_id}}">${3}</div>'
<
      In TextMate this would first highlight ' id="some_id"', and if
      you hit delete it would automatically skip ${2} and go to ${3}
      on the next <tab>, but if you didn't delete it it would highlight
      "some_id" first. You cannot do this in snipMate.vim.
    - Regex cannot be performed on variables, such as "${1/.*/\U&}"
    - Placeholders cannot span multiple lines.
    - Activating snippets in different scopes of the same file is
      not possible.

Perhaps some of these features will be added in a later release.

==============================================================================
CONTACT                                   *snipMate-contact* *snipMate-author*

To contact the author (Michael Sanders), please email:
 msanders42+snipmate <at> gmail <dot> com

I greatly appreciate any suggestions or improvements offered for the script.

==============================================================================
LICENSE                                                     *snipMate-license*

snipMate is released under the MIT license:

Copyright 2009-2010 Michael Sanders. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The software is provided "as is", without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in the
software.

==============================================================================

vim:tw=78:ts=8:ft=help:norl:
zhimakaimen:/doc/snipMate.txt
*taglist.txt*	Plugin for browsing source code

Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
For Vim version 6.0 and above
Last change: 2007 May 24

1. Overview 					|taglist-intro|
2. Taglist on the internet			|taglist-internet|
3. Requirements					|taglist-requirements|
4. Installation 				|taglist-install|
5. Usage 					|taglist-using|
6. Options 					|taglist-options|
7. Commands 					|taglist-commands|
8. Global functions 				|taglist-functions|
9. Extending 					|taglist-extend|
10. FAQ 					|taglist-faq|
11. License 					|taglist-license|
12. Todo					|taglist-todo|

==============================================================================
						*taglist-intro*
1. Overview~

The "Tag List" plugin is a source code browser plugin for Vim. This plugin
allows you to efficiently browse through source code files for different
programming languages. The "Tag List" plugin provides the following features:

    * Displays the tags (functions, classes, structures, variables, etc.) 
      defined in a file in a vertically or horizontally split Vim window.
    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
      in the popup menu.
    * Automatically updates the taglist window as you switch between
      files/buffers. As you open new files, the tags defined in the new files
      are added to the existing file list and the tags defined in all the
      files are displayed grouped by the filename.
    * When a tag name is selected from the taglist window, positions the
      cursor at the definition of the tag in the source file.
    * Automatically highlights the current tag name.
    * Groups the tags by their type and displays them in a foldable tree.
    * Can display the prototype and scope of a tag.
    * Can optionally display the tag prototype instead of the tag name in the
      taglist window.
    * The tag list can be sorted either by name or by chronological order.
    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
      SML, Sql, TCL, Verilog, Vim and Yacc.
    * Can be easily extended to support new languages. Support for
      existing languages can be modified easily.
    * Provides functions to display the current tag name in the Vim status
      line or the window title bar.
    * The list of tags and files in the taglist can be saved and
      restored across Vim sessions.
    * Provides commands to get the name and prototype of the current tag.
    * Runs in both console/terminal and GUI versions of Vim.
    * Works with the winmanager plugin. Using the winmanager plugin, you
      can use Vim plugins like the file explorer, buffer explorer and the
      taglist plugin at the same time like an IDE.
    * Can be used in both Unix and MS-Windows systems.

==============================================================================
						*taglist-internet*
2. Taglist on the internet~

The home page of the taglist plugin is at:
>
	http://vim-taglist.sourceforge.net/
<
You can subscribe to the taglist mailing list to post your questions or
suggestions for improvement or to send bug reports. Visit the following page
for subscribing to the mailing list:
>
	http://groups.yahoo.com/group/taglist
<
==============================================================================
						*taglist-requirements*
3. Requirements~

The taglist plugin requires the following:

    * Vim version 6.0 and above
    * Exuberant ctags 5.0 and above

The taglist plugin will work on all the platforms where the exuberant ctags
utility and Vim are supported (this includes MS-Windows and Unix based
systems).

The taglist plugin relies on the exuberant ctags utility to dynamically
generate the tag listing.  The exuberant ctags utility must be installed in
your system to use this plugin.  The exuberant ctags utility is shipped with
most of the Linux distributions.  You can download the exuberant ctags utility
from
>
	http://ctags.sourceforge.net
<
The taglist plugin doesn't use or create a tags file and there is no need to
create a tags file to use this plugin. The taglist plugin will not work with
the GNU ctags or the Unix ctags utility.

This plugin relies on the Vim "filetype" detection mechanism to determine the
type of the current file. You have to turn on the Vim filetype detection by
adding the following line to your .vimrc file:
>
	filetype on
<
The taglist plugin will not work if you run Vim in the restricted mode (using
the -Z command-line argument).

The taglist plugin uses the Vim system() function to invoke the exuberant
ctags utility. If Vim is compiled without the system() function then you
cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
Vim without the system() function for security reasons.

==============================================================================
						*taglist-install*
4. Installation~

1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
   have the following two files (the directory structure should be preserved):

	plugin/taglist.vim - main taglist plugin file
	doc/taglist.txt    - documentation (help) file

   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
   details about installing Vim plugins.
2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
   directory, start Vim and run the ":helptags ." command to process the
   taglist help file. Without this step, you cannot jump to the taglist help
   topics.
3. If the exuberant ctags utility is not present in one of the directories in
   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
   point to the location of the exuberant ctags utility (not to the directory)
   in the .vimrc file.
4. If you are running a terminal/console version of Vim and the terminal
   doesn't support changing the window width then set the
   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
5. Restart Vim.
6. You can now use the ":TlistToggle" command to open/close the taglist
   window. You can use the ":help taglist" command to get more information
   about using the taglist plugin.

To uninstall the taglist plugin, remove the plugin/taglist.vim and
doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.

==============================================================================
						*taglist-using*
5. Usage~

The taglist plugin can be used in several different ways.

1. You can keep the taglist window open during the entire editing session. On
   opening the taglist window, the tags defined in all the files in the Vim
   buffer list will be displayed in the taglist window. As you edit files, the
   tags defined in them will be added to the taglist window. You can select a
   tag from the taglist window and jump to it. The current tag will be
   highlighted in the taglist window. You can close the taglist window when
   you no longer need the window.
2. You can configure the taglist plugin to process the tags defined in all the
   edited files always. In this configuration, even if the taglist window is
   closed and the taglist menu is not displayed, the taglist plugin will
   processes the tags defined in newly edited files. You can then open the
   taglist window only when you need to select a tag and then automatically
   close the taglist window after selecting the tag.
3. You can configure the taglist plugin to display only the tags defined in
   the current file in the taglist window. By default, the taglist plugin
   displays the tags defined in all the files in the Vim buffer list. As you
   switch between files, the taglist window will be refreshed to display only
   the tags defined in the current file.
4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
   taglist plugin to display the tags defined in the current file and select a
   tag to jump to it. You can use the menu without opening the taglist window.
   By default, the Tags menu is disabled.
5. You can configure the taglist plugin to display the name of the current tag
   in the Vim window status line or in the Vim window title bar. For this to
   work without the taglist window or menu, you need to configure the taglist
   plugin to process the tags defined in a file always.
6. You can save the tags defined in multiple files to a taglist session file
   and load it when needed. You can also configure the taglist plugin to not
   update the taglist window when editing new files. You can then manually add
   files to the taglist window.

Opening the taglist window~
You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
commands. The ":TlistOpen" command opens the taglist window and jumps to it.
The ":TlistToggle" command opens or closes (toggle) the taglist window and the
cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
variable is set to 1, then the ":TlistToggle" command opens the taglist window
and moves the cursor to the taglist window.

You can map a key to invoke these commands. For example, the following command
creates a normal mode mapping for the <F8> key to toggle the taglist window.
>
	nnoremap <silent> <F8> :TlistToggle<CR>
<
Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.

To automatically open the taglist window on Vim startup, set the
'Tlist_Auto_Open' variable to 1.

You can also open the taglist window on startup using the following command
line:
>
	$ vim +TlistOpen
<
Closing the taglist window~
You can close the taglist window from the taglist window by pressing 'q' or
using the Vim ":q" command. You can also use any of the Vim window commands to
close the taglist window. Invoking the ":TlistToggle" command when the taglist
window is opened, closes the taglist window. You can also use the
":TlistClose" command to close the taglist window.

To automatically close the taglist window when a tag or file is selected, you
can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.

Jumping to a tag or a file~
You can select a tag in the taglist window either by pressing the <Enter> key
or by double clicking the tag name using the mouse. To jump to a tag on a
single mouse click set the 'Tlist_Use_SingleClick' variable to 1.

If the selected file is already opened in a window, then the cursor is moved
to that window. If the file is not currently opened in a window then the file
is opened in the window used by the taglist plugin to show the previously
selected file. If there are no usable windows, then the file is opened in a
new window.  The file is not opened in special windows like the quickfix
window, preview window and windows containing buffer with the 'buftype' option
set.

To jump to the tag in a new window, press the 'o' key. To open the file in the
previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
to the tag but still keep the cursor in the taglist window (preview).

To open the selected file in a tab, use the 't' key.  If the file is already
present in a tab then the cursor is moved to that tab otherwise the file is
opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
window is automatically opened in the newly created tab.

Instead of jumping to a tag, you can open a file by pressing the <Enter> key
or by double clicking the file name using the mouse.

In the taglist window, you can use the [[ or <Backspace> key to jump to the
beginning of the previous file. You can use the ]] or <Tab> key to jump to the
beginning of the next file. When you reach the first or last file, the search
wraps around and the jumps to the next/previous file.

Highlighting the current tag~
The taglist plugin automatically highlights the name of the current tag in the
taglist window. The Vim |CursorHold| autocmd event is used for this. If the
current tag name is not visible in the taglist window, then the taglist window
contents are scrolled to make that tag name visible. You can also use the
":TlistHighlightTag" command to force the highlighting of the current tag.

The tag name is highlighted if no activity is performed for |'updatetime'|
milliseconds. The default value for this Vim option is 4 seconds. To avoid
unexpected problems, you should not set the |'updatetime'| option to a very
low value.

To disable the automatic highlighting of the current tag name in the taglist
window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.

When entering a Vim buffer/window, the taglist plugin automatically highlights
the current tag in that buffer/window.  If you like to disable the automatic
highlighting of the current tag when entering a buffer, set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero.

Adding files to the taglist~
When the taglist window is opened, all the files in the Vim buffer list are
processed and the supported files are added to the taglist.  When you edit a
file in Vim, the taglist plugin automatically processes this file and adds it
to the taglist. If you close the taglist window, the tag information in the
taglist is retained.

To process files even when the taglist window is not open, set the
'Tlist_Process_File_Always' variable to 1.

You can manually add multiple files to the taglist without opening them using
the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.

For example, to add all the C files in the /my/project/dir directory to the
taglist, you can use the following command:
>
	:TlistAddFiles /my/project/dir/*.c
<
Note that when adding several files with a large number of tags or a large
number of files, it will take several seconds to several minutes for the
taglist plugin to process all the files. You should not interrupt the taglist
plugin by pressing <CTRL-C>.

You can recursively add multiple files from a directory tree using the
":TlistAddFilesRecursive" command:
>
	:TlistAddFilesRecursive /my/project/dir *.c
<
This command takes two arguments. The first argument specifies the directory
from which to recursively add the files. The second optional argument
specifies the wildcard matching pattern for selecting the files to add. The
default pattern is * and all the files are added.

Displaying tags for only one file~
The taglist window displays the tags for all the files in the Vim buffer list
and all the manually added files. To display the tags for only the current
active buffer, set the 'Tlist_Show_One_File' variable to 1.

Removing files from the taglist~
You can remove a file from the taglist window, by pressing the 'd' key when the
cursor is on one of the tags listed for the file in the taglist window. The
removed file will no longer be displayed in the taglist window in the current
Vim session. To again display the tags for the file, open the file in a Vim
window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
to add the file to the taglist.

When a buffer is removed from the Vim buffer list using the ":bdelete" or the
":bwipeout" command, the taglist is updated to remove the stored information
for this buffer.

Updating the tags displayed for a file~
The taglist plugin keeps track of the modification time of a file. When the
modification time changes (the file is modified), the taglist plugin
automatically updates the tags listed for that file. The modification time of
a file is checked when you enter a window containing that file or when you
load that file.

You can also update or refresh the tags displayed for a file by pressing the
"u" key in the taglist window. If an existing file is modified, after the file
is saved, the taglist plugin automatically updates the tags displayed for the
file.

You can also use the ":TlistUpdate" command to update the tags for the current
buffer after you made some changes to it. You should save the modified buffer
before you update the taglist window. Otherwise the listed tags will not
include the new tags created in the buffer. 

If you have deleted the tags displayed for a file in the taglist window using
the 'd' key, you can again display the tags for that file using the
":TlistUpdate" command.

Controlling the taglist updates~
To disable the automatic processing of new files or modified files, you can
set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
zero, the taglist is updated only when you use the ":TlistUpdate" command or
the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
this option to control which files are added to the taglist.

You can use the ":TlistLock" command to lock the taglist contents. After this
command is executed, new files are not automatically added to the taglist.
When the taglist is locked, you can use the ":TlistUpdate" command to add the
current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
command.

Displaying the tag prototype~
To display the prototype of the tag under the cursor in the taglist window,
press the space bar. If you place the cursor on a tag name in the taglist
window, then the tag prototype is displayed at the Vim status line after
|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
option is 4 seconds.

You can get the name and prototype of a tag without opening the taglist window
and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
commands. These commands will work only if the current file is already present
in the taglist. To use these commands without opening the taglist window, set
the 'Tlist_Process_File_Always' variable to 1.

You can use the ":TlistShowTag" command to display the name of the tag at or
before the specified line number in the specified file.  If the file name and
line number are not supplied, then this command will display the name of the
current tag. For example,
>
	:TlistShowTag
	:TlistShowTag myfile.java 100
<
You can use the ":TlistShowPrototype" command to display the prototype of the
tag at or before the specified line number in the specified file.  If the file
name and the line number are not supplied, then this command will display the
prototype of the current tag.  For example,
>
	:TlistShowPrototype
	:TlistShowPrototype myfile.c 50
<
In the taglist window, when the mouse is moved over a tag name, the tag
prototype is displayed in a balloon. This works only in GUI versions where
balloon evaluation is supported.

Taglist window contents~
The taglist window contains the tags defined in various files in the taglist
grouped by the filename and by the tag type (variable, function, class, etc.).
For tags with scope information (like class members, structures inside
structures, etc.), the scope information is displayed in square brackets "[]"
after the tag name.

The contents of the taglist buffer/window are managed by the taglist plugin.
The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
|'modifiable'| option is turned off for the taglist buffer. You should not
manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
manually edit the taglist buffer contents, then the taglist plugin will be out
of sync with the taglist buffer contents and the plugin will no longer work
correctly. To redisplay the taglist buffer contents again, close the taglist
window and reopen it.

Opening and closing the tag and file tree~
In the taglist window, the tag names are displayed as a foldable tree using
the Vim folding support. You can collapse the tree using the '-' key or using
the Vim |zc| fold command. You can open the tree using the '+' key or using
the Vim |zo| fold command. You can open all the folds using the '*' key or
using the Vim |zR| fold command. You can also use the mouse to open/close the
folds. You can close all the folds using the '=' key. You should not manually
create or delete the folds in the taglist window.

To automatically close the fold for the inactive files/buffers and open only
the fold for the current buffer in the taglist window, set the
'Tlist_File_Fold_Auto_Close' variable to 1.

Sorting the tags for a file~
The tags displayed in the taglist window can be sorted either by their name or
by their chronological order. The default sorting method is by the order in
which the tags appear in a file. You can change the default sort method by
setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
sort the tags by their name by pressing the "s" key in the taglist window. You
can again sort the tags by their chronological order using the "s" key. Each
file in the taglist window can be sorted using different order.

Zooming in and out of the taglist window~
You can press the 'x' key in the taglist window to maximize the taglist
window width/height. The window will be maximized to the maximum possible
width/height without closing the other existing windows. You can again press
'x' to restore the taglist window to the default width/height.

						*taglist-session*
Taglist Session~
A taglist session refers to the group of files and their tags stored in the
taglist in a Vim session.

You can save and restore a taglist session (and all the displayed tags) using
the ":TlistSessionSave" and ":TlistSessionLoad" commands.

To save the information about the tags and files in the taglist to a file, use
the ":TlistSessionSave" command and specify the filename:
>
	:TlistSessionSave <file name>
<
To load a saved taglist session, use the ":TlistSessionLoad" command: >

	:TlistSessionLoad <file name>
<
When you load a taglist session file, the tags stored in the file will be
added to the tags already stored in the taglist.

The taglist session feature can be used to save the tags for large files or a
group of frequently used files (like a project). By using the taglist session
file, you can minimize the amount to time it takes to load/refresh the taglist
for multiple files.

You can create more than one taglist session file for multiple groups of
files.

Displaying the tag name in the Vim status line or the window title bar~
You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
plugin to display the current tag name in the Vim status line or the window
title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
function to display the current tag prototype in the Vim status line or the
window title bar.

For example, the following command can be used to display the current tag name
in the status line:
>
	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
<
The following command can be used to display the current tag name in the
window title bar:
>
	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
<
Note that the current tag name can be displayed only after the file is
processed by the taglist plugin. For this, you have to either set the
'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
the taglist menu. For more information about configuring the Vim status line,
refer to the documentation for the Vim |'statusline'| option.

Changing the taglist window highlighting~
The following Vim highlight groups are defined and used to highlight the
various entities in the taglist window:

    TagListTagName  - Used for tag names
    TagListTagScope - Used for tag scope
    TagListTitle    - Used for tag titles
    TagListComment  - Used for comments
    TagListFileName - Used for filenames

By default, these highlight groups are linked to the standard Vim highlight
groups. If you want to change the colors used for these highlight groups,
prefix the highlight group name with 'My' and define it in your .vimrc or
.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
MyTagListComment and MyTagListFileName.  For example, to change the colors
used for tag names, you can use the following command:
>
    :highlight MyTagListTagName guifg=blue ctermfg=blue
<
Controlling the taglist window~
To use a horizontally split taglist window, instead of a vertically split
window, set the 'Tlist_Use_Horiz_Window' variable to 1.

To use a vertically split taglist window on the rightmost side of the Vim
window, set the 'Tlist_Use_Right_Window' variable to 1.

You can specify the width of the vertically split taglist window, by setting
the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
split taglist window, by setting the 'Tlist_WinHeight' variable.

When opening a vertically split taglist window, the Vim window width is
increased to accommodate the new taglist window. When the taglist window is
closed, the Vim window is reduced. To disable this, set the
'Tlist_Inc_Winwidth' variable to zero.

To reduce the number of empty lines in the taglist window, set the
'Tlist_Compact_Format' variable to 1.

To not display the Vim fold column in the taglist window, set the
'Tlist_Enable_Fold_Column' variable to zero.

To display the tag prototypes instead of the tag names in the taglist window,
set the 'Tlist_Display_Prototype' variable to 1.

To not display the scope of the tags next to the tag names, set the
'Tlist_Display_Tag_Scope' variable to zero.

						*taglist-keys*
Taglist window key list~
The following table lists the description of the keys that can be used
in the taglist window.

  Key           Description~

  <CR>          Jump to the location where the tag under cursor is
                defined.
  o             Jump to the location where the tag under cursor is
                defined in a new window.
  P             Jump to the tag in the previous (Ctrl-W_p) window.
  p             Display the tag definition in the file window and
                keep the cursor in the taglist window itself.
  t             Jump to the tag in a new tab. If the file is already
                opened in a tab, move to that tab.
  Ctrl-t	Jump to the tag in a new tab.
  <Space>       Display the prototype of the tag under the cursor.
  		For file names, display the full path to the file,
		file type and the number of tags. For tag types, display the
		tag type and the number of tags.
  u             Update the tags listed in the taglist window
  s             Change the sort order of the tags (by name or by order)
  d             Remove the tags for the file under the cursor
  x             Zoom-in or Zoom-out the taglist window
  +             Open a fold
  -             Close a fold
  *             Open all folds
  =             Close all folds
  [[		Jump to the beginning of the previous file
  <Backspace>	Jump to the beginning of the previous file
  ]]		Jump to the beginning of the next file
  <Tab>		Jump to the beginning of the next file
  q             Close the taglist window
  <F1>          Display help

The above keys will work in both the normal mode and the insert mode.

						*taglist-menu*
Taglist menu~
When using GUI Vim, the taglist plugin can display the tags defined in the
current file in the drop-down menu and the popup menu. By default, this
feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
variable to 1.

You can jump to a tag by selecting the tag name from the menu. You can use the
taglist menu independent of the taglist window i.e. you don't need to open the
taglist window to get the taglist menu.

When you switch between files/buffers, the taglist menu is automatically
updated to display the tags defined in the current file/buffer.

The tags are grouped by their type (variables, functions, classes, methods,
etc.) and displayed as a separate sub-menu for each type. If all the tags
defined in a file are of the same type (e.g. functions), then the sub-menu is
not used.

If the number of items in a tag type submenu exceeds the value specified by
the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
The first and last tag names in the submenu are used to form the submenu name.
The menu items are prefixed by alpha-numeric characters for easy selection by
keyboard.

If the popup menu support is enabled (the |'mousemodel'| option contains
"popup"), then the tags menu is added to the popup menu. You can access
the popup menu by right clicking on the GUI window.

You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
You can sort the tags listed in the menu either by name or by order by
selecting the 'Tags->Sort menu by->Name/Order' menu entry.

You can tear-off the Tags menu and keep it on the side of the Vim window
for quickly locating the tags.

Using the taglist plugin with the winmanager plugin~
You can use the taglist plugin with the winmanager plugin. This will allow you
to use the file explorer, buffer explorer and the taglist plugin at the same
time in different windows. To use the taglist plugin with the winmanager
plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
to use the file explorer plugin and the taglist plugin at the same time, use
the following setting: >

	let winManagerWindowLayout = 'FileExplorer|TagList'
<
Getting help~
If you have installed the taglist help file (this file), then you can use the
Vim ":help taglist-<keyword>" command to get help on the various taglist
topics.

You can press the <F1> key in the taglist window to display the help
information about using the taglist window. If you again press the <F1> key,
the help information is removed from the taglist window.

						*taglist-debug*
Debugging the taglist plugin~
You can use the ":TlistDebug" command to enable logging of the debug messages
from the taglist plugin. To display the logged debug messages, you can use the
":TlistMessages" command. To disable the logging of the debug messages, use
the ":TlistUndebug" command.

You can specify a file name to the ":TlistDebug" command to log the debug
messages to a file. Otherwise, the debug messages are stored in a script-local
variable. In the later case, to minimize memory usage, only the last 3000
characters from the debug messages are stored.

==============================================================================
						*taglist-options*
6. Options~

A number of Vim variables control the behavior of the taglist plugin. These
variables are initialized to a default value. By changing these variables you
can change the behavior of the taglist plugin. You need to change these
settings only if you want to change the behavior of the taglist plugin. You
should use the |:let| command in your .vimrc file to change the setting of any
of these variables. 

The configurable taglist variables are listed below. For a detailed
description of these variables refer to the text below this table.

|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
				taglist.
|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
|'Tlist_Auto_Update'|		Automatically update the taglist to include
				newly edited files.
|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
				selected.
|'Tlist_Compact_Format'|	Remove extra information and blank lines from
       				the taglist window.
|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
				window.
|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
				window.
|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
|'Tlist_GainFocus_On_ToggleOpen'|
				Jump to taglist window on open.
|'Tlist_Highlight_Tag_On_BufEnter'|
				On entering a buffer, automatically highlight
				the current tag.
|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
				the taglist window.
|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
|'Tlist_Process_File_Always'|	Process files even when the taglist window is
				closed.
|'Tlist_Show_Menu'|		Display the tags menu.
|'Tlist_Show_One_File'|		Show tags for the current buffer only.
|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
				taglist window.
|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
|'Tlist_WinHeight'|		Horizontally split taglist window height.
|'Tlist_WinWidth'|		Vertically split taglist window width.

						*'Tlist_Auto_Highlight_Tag'*
Tlist_Auto_Highlight_Tag~
The taglist plugin will automatically highlight the current tag in the taglist
window. If you want to disable this, then you can set the
'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
tag highlighting is disabled, the tags for a new file will still be added to
the taglist window.
>
	let Tlist_Auto_Highlight_Tag = 0
<
With the above variable set to 1, you can use the ":TlistHighlightTag" command
to highlight the current tag.

						*'Tlist_Auto_Open'*
Tlist_Auto_Open~
To automatically open the taglist window, when you start Vim, you can set the
'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
the taglist window will not be opened automatically on Vim startup.
>
	let Tlist_Auto_Open = 1
<
The taglist window is opened only when a supported type of file is opened on
Vim startup. For example, if you open text files, then the taglist window will
not be opened.

						*'Tlist_Auto_Update'*
Tlist_Auto_Update~
When a new file is edited, the tags defined in the file are automatically
processed and added to the taglist. To stop adding new files to the taglist,
set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
to 1.
>
	let Tlist_Auto_Update = 0
<
With the above variable set to 1, you can use the ":TlistUpdate" command to
add the tags defined in the current file to the taglist.

						*'Tlist_Close_On_Select'*
Tlist_Close_On_Select~
If you want to close the taglist window when a file or tag is selected, then
set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
set zero and when you select a tag or file from the taglist window, the window
is not closed.
>
	let Tlist_Close_On_Select = 1
<
						*'Tlist_Compact_Format'*
Tlist_Compact_Format~
By default, empty lines are used to separate different tag types displayed for
a file and the tags displayed for different files in the taglist window. If
you want to display as many tags as possible in the taglist window, you can
set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
>
	let Tlist_Compact_Format = 1
<
						*'Tlist_Ctags_Cmd'*
Tlist_Ctags_Cmd~
The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
ctags utility. If exuberant ctags is present in any one of the directories in
the PATH environment variable, then there is no need to set this variable.

The exuberant ctags tool can be installed under different names.  When the
taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
the PATH environment variable.  If any one of the named executable is found,
then the Tlist_Ctags_Cmd variable is set to that name.

If exuberant ctags is not present in one of the directories specified in the
PATH environment variable, then set this variable to point to the location of
the ctags utility in your system. Note that this variable should point to the
fully qualified exuberant ctags location and NOT to the directory in which
exuberant ctags is installed. If the exuberant ctags tool is not found in
either PATH or in the specified location, then the taglist plugin will not be
loaded. Examples:
>
	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
<
						*'Tlist_Display_Prototype'*
Tlist_Display_Prototype~
By default, only the tag name will be displayed in the taglist window. If you
like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
variable to 1. By default, this variable is set to zero and only tag names
will be displayed.
>
	let Tlist_Display_Prototype = 1
<
						*'Tlist_Display_Tag_Scope'*
Tlist_Display_Tag_Scope~
By default, the scope of a tag (like a C++ class) will be displayed in
square brackets next to the tag name. If you don't want the tag scopes
to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
this variable is set to 1 and the tag scopes will be displayed.
>
	let Tlist_Display_Tag_Scope = 0
<
						*'Tlist_Enable_Fold_Column'*
Tlist_Enable_Fold_Column~
By default, the Vim fold column is enabled and displayed in the taglist
window. If you wish to disable this (for example, when you are working with a
narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
variable to zero.
>
	let Tlist_Enable_Fold_Column = 1
<
						*'Tlist_Exit_OnlyWindow'*
Tlist_Exit_OnlyWindow~
If you want to exit Vim if only the taglist window is currently opened, then
set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
set to zero and the Vim instance will not be closed if only the taglist window
is present.
>
	let Tlist_Exit_OnlyWindow = 1
<
						*'Tlist_File_Fold_Auto_Close'*
Tlist_File_Fold_Auto_Close~
By default, the tags tree displayed in the taglist window for all the files is
opened. You can close/fold the tags tree for the files manually. To
automatically close the tags tree for inactive files, you can set the
'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
the tags tree for the current buffer is automatically opened and for all the
other buffers is closed.
>
	let Tlist_File_Fold_Auto_Close = 1
<
					    *'Tlist_GainFocus_On_ToggleOpen'*
Tlist_GainFocus_On_ToggleOpen~
When the taglist window is opened using the ':TlistToggle' command, this
option controls whether the cursor is moved to the taglist window or remains
in the current window. By default, this option is set to 0 and the cursor
remains in the current window. When this variable is set to 1, the cursor
moves to the taglist window after opening the taglist window.
>
	let Tlist_GainFocus_On_ToggleOpen = 1
<
					    *'Tlist_Highlight_Tag_On_BufEnter'*
Tlist_Highlight_Tag_On_BufEnter~
When you enter a Vim buffer/window, the current tag in that buffer/window is
automatically highlighted in the taglist window. If the current tag name is
not visible in the taglist window, then the taglist window contents are
scrolled to make that tag name visible. If you like to disable the automatic
highlighting of the current tag when entering a buffer, you can set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
this variable is 1.
>
	let Tlist_Highlight_Tag_On_BufEnter = 0
<
						*'Tlist_Inc_Winwidth'*
Tlist_Inc_Winwidth~
By default, when the width of the window is less than 100 and a new taglist
window is opened vertically, then the window width is increased by the value
set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
of this variable is used only if you are using a vertically split taglist
window.

If your terminal doesn't support changing the window width from Vim (older
version of xterm running in a Unix system) or if you see any weird problems in
the screen due to the change in the window width or if you prefer not to
adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
window then you must set this variable to zero, otherwise the system may hang
due to a Vim limitation (explained in :help win32-problems)
>
	let Tlist_Inc_Winwidth = 0
<
						*'Tlist_Max_Submenu_Items'*
Tlist_Max_Submenu_Items~
If a file contains too many tags of a particular type (function, variable,
class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
variable, then the menu for that tag type will be split into multiple
sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
>
	let Tlist_Max_Submenu_Items = 20
<
The name of the submenu is formed using the names of the first and the last
tag entries in that submenu.

						*'Tlist_Max_Tag_Length'*
Tlist_Max_Tag_Length~
Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
used to form the tag type submenu name. The default value for this variable is
10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
less characters:
>
	let Tlist_Max_Tag_Length = 10
<
						*'Tlist_Process_File_Always'*
Tlist_Process_File_Always~
By default, the taglist plugin will generate and process the tags defined in
the newly opened files only when the taglist window is opened or when the
taglist menu is enabled. When the taglist window is closed, the taglist plugin
will stop processing the tags for newly opened files.

You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
of tags for new files even when the taglist window is closed and the taglist
menu is disabled.
>
	let Tlist_Process_File_Always = 1
<
To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
taglist window and the taglist menu, you should set this variable to 1.

						*'Tlist_Show_Menu'*
Tlist_Show_Menu~
When using GUI Vim, you can display the tags defined in the current file in a
menu named "Tags". By default, this feature is turned off. To turn on this
feature, set the 'Tlist_Show_Menu' variable to 1:
>
	let Tlist_Show_Menu = 1
<
						*'Tlist_Show_One_File'*
Tlist_Show_One_File~
By default, the taglist plugin will display the tags defined in all the loaded
buffers in the taglist window. If you prefer to display the tags defined only
in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
this variable is set to 1, as you switch between buffers, the taglist window
will be refreshed to display the tags for the current buffer and the tags for
the previous buffer will be removed.
>
	let Tlist_Show_One_File = 1
<
						*'Tlist_Sort_Type'*
Tlist_Sort_Type~
The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
taglist window. The tags can be sorted either alphabetically by their name or
by the order of their appearance in the file (chronological order). By
default, the tag names will be listed by the order in which they are defined
in the file. You can change the sort type (from name to order or from order to
name) by pressing the "s" key in the taglist window. You can also change the
default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
>
	let Tlist_Sort_Type = "name"
<
						*'Tlist_Use_Horiz_Window'*
Tlist_Use_Horiz_Window~
Be default, the tag names are displayed in a vertically split window. If you
prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
command window, then you should use a horizontally split window instead of a
vertically split window. Also, if you are using an older version of xterm in a
Unix system that doesn't support changing the xterm window width, you should
use a horizontally split window.
>
	let Tlist_Use_Horiz_Window = 1
<
						*'Tlist_Use_Right_Window'*
Tlist_Use_Right_Window~
By default, the vertically split taglist window will appear on the left hand
side. If you prefer to open the window on the right hand side, you can set the
'Tlist_Use_Right_Window' variable to 1:
>
	let Tlist_Use_Right_Window = 1
<
						*'Tlist_Use_SingleClick'*
Tlist_Use_SingleClick~
By default, when you double click on the tag name using the left mouse 
button, the cursor will be positioned at the definition of the tag. You 
can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
you single click on the tag name using the mouse. By default this variable
is set to zero.
>
	let Tlist_Use_SingleClick = 1
<
Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
the taglist window using the mouse, then Vim will crash. This problem is fixed
in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
using the mouse, you can use normal Vim window resizing commands to resize the
taglist window.

						*'Tlist_WinHeight'*
Tlist_WinHeight~
The default height of the horizontally split taglist window is 10. This can be
changed by modifying the 'Tlist_WinHeight' variable:
>
	let Tlist_WinHeight = 20
<
The |'winfixheight'| option is set for the taglist window, to maintain the
height of the taglist window, when new Vim windows are opened and existing
windows are closed.

						*'Tlist_WinWidth'*
Tlist_WinWidth~
The default width of the vertically split taglist window is 30. This can be
changed by modifying the 'Tlist_WinWidth' variable:
>
	let Tlist_WinWidth = 20
<
Note that the value of the |'winwidth'| option setting determines the minimum
width of the current window. If you set the 'Tlist_WinWidth' variable to a
value less than that of the |'winwidth'| option setting, then Vim will use the
value of the |'winwidth'| option.

When new Vim windows are opened and existing windows are closed, the taglist
plugin will try to maintain the width of the taglist window to the size
specified by the 'Tlist_WinWidth' variable.

==============================================================================
						*taglist-commands*
7. Commands~

The taglist plugin provides the following ex-mode commands:

|:TlistAddFiles|	Add multiple files to the taglist.
|:TlistAddFilesRecursive|
			Add files recursively to the taglist.
|:TlistClose|		Close the taglist window.
|:TlistDebug|		Start logging of taglist debug messages.
|:TlistLock|		Stop adding new files to the taglist.
|:TlistMessages|	Display the logged taglist plugin debug messages.
|:TlistOpen|		Open and jump to the taglist window.
|:TlistSessionSave|	Save the information about files and tags in the
			taglist to a session file.
|:TlistSessionLoad|	Load the information about files and tags stored
			in a session file to taglist.
|:TlistShowPrototype|	Display the prototype of the tag at or before the
		    	specified line number.
|:TlistShowTag|		Display the name of the tag defined at or before the
			specified line number.
|:TlistHighlightTag|	Highlight the current tag in the taglist window.
|:TlistToggle|		Open or close (toggle) the taglist window.
|:TlistUndebug|		Stop logging of taglist debug messages.
|:TlistUnlock|		Start adding new files to the taglist.
|:TlistUpdate|		Update the tags for the current buffer.

						*:TlistAddFiles*
:TlistAddFiles {file(s)} [file(s) ...]
		Add one or more specified files to the taglist. You can
		specify multiple filenames using wildcards. To specify a
		file name with space character, you should escape the space
		character with a backslash.
		Examples:
>
		    :TlistAddFiles *.c *.cpp
		    :TlistAddFiles file1.html file2.html
<
		If you specify a large number of files, then it will take some
		time for the taglist plugin to process all of them. The
		specified files will not be edited in a Vim window and will
		not be added to the Vim buffer list.

						*:TlistAddFilesRecursive*
:TlistAddFilesRecursive {directory} [ {pattern} ]
		Add files matching {pattern} recursively from the specified
		{directory} to the taglist. If {pattern} is not specified,
		then '*' is assumed. To specify the current directory, use "."
		for {directory}. To specify a directory name with space
		character, you should escape the space character with a
		backslash.
		Examples:
>
		    :TlistAddFilesRecursive myproject *.java
		    :TlistAddFilesRecursive smallproject
<
		If large number of files are present in the specified
		directory tree, then it will take some time for the taglist
		plugin to process all of them.

						*:TlistClose*
:TlistClose	Close the taglist window. This command can be used from any
		one of the Vim windows.

						*:TlistDebug*
:TlistDebug [filename]
		Start logging of debug messages from the taglist plugin.
		If {filename} is specified, then the debug messages are stored
		in the specified file. Otherwise, the debug messages are
		stored in a script local variable. If the file {filename} is
		already present, then it is overwritten.

						*:TlistLock*
:TlistLock
		Lock the taglist and don't process new files. After this
		command is executed, newly edited files will not be added to
		the taglist.

						*:TlistMessages*
:TlistMessages
		Display the logged debug messages from the taglist plugin
		in a window.  This command works only when logging to a
		script-local variable.

						*:TlistOpen*
:TlistOpen	Open and jump to the taglist window. Creates the taglist
		window, if the window is not opened currently. After executing
		this command, the cursor is moved to the taglist window.  When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags defined in them
		are displayed in the taglist window.

						*:TlistSessionSave*
:TlistSessionSave {filename}
		Saves the information about files and tags in the taglist to
		the specified file. This command can be used to save and
		restore the taglist contents across Vim sessions.

						*:TlistSessionLoad*
:TlistSessionLoad {filename}
		Load the information about files and tags stored in the
		specified session file to the taglist.

						*:TlistShowPrototype*
:TlistShowPrototype [filename] [linenumber]
		Display the prototype of the tag at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the prototype for the tag for any line number in this
		range. 

						*:TlistShowTag*
:TlistShowTag [filename] [linenumber]
		Display the name of the tag defined at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the tag name for any line number in this range. 

						*:TlistHighlightTag*
:TlistHighlightTag
		Highlight the current tag in the taglist window. By default,
		the taglist plugin periodically updates the taglist window to
		highlight the current tag. This command can be used to force
		the taglist plugin to highlight the current tag.

						*:TlistToggle*
:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
		window, if the window is not opened currently. Closes the
		taglist window, if the taglist window is already opened. When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags are displayed in
		the taglist window. After executing this command, the cursor
		is not moved from the current window to the taglist window.

						*:TlistUndebug*
:TlistUndebug
		Stop logging of debug messages from the taglist plugin.

						*:TlistUnlock*
:TlistUnlock
		Unlock the taglist and start processing newly edited files.

						*:TlistUpdate*
:TlistUpdate	Update the tags information for the current buffer. This
		command can be used to re-process the current file/buffer and
		get the tags information. As the taglist plugin uses the file
		saved in the disk (instead of the file displayed in a Vim
		buffer), you should save a modified buffer before you update
		the taglist. Otherwise the listed tags will not include the
		new tags created in the buffer. You can use this command even
		when the taglist window is not opened.

==============================================================================
						*taglist-functions*
8. Global functions~

The taglist plugin provides several global functions that can be used from
other Vim plugins to interact with the taglist plugin. These functions are
described below.

|Tlist_Update_File_Tags()|		Update the tags for the specified file
|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
				    	before the specified line number in the
				    	specified file.
|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
					before the specified line number in
					the specified file.
|Tlist_Set_App()|			Set the name of the application
					controlling the taglist window.

					    *Tlist_Update_File_Tags()*
Tlist_Update_File_Tags({filename}, {filetype})
		Update the tags for the file {filename}. The second argument
		specifies the Vim filetype for the file. If the taglist plugin
		has not processed the file previously, then the exuberant
		ctags tool is invoked to generate the tags for the file.

					    *Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
		Return the prototype of the tag at or before the specified
		line number in the specified file. If the filename and line
		number are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Get_Tagname_By_Line()*
Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
		Return the name of the tag at or before the specified line
		number in the specified file. If the filename and line number
		are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Set_App()*
Tlist_Set_App({appname})
		Set the name of the plugin that controls the taglist plugin
		window and buffer. This can be used to integrate the taglist
		plugin with other Vim plugins.
		
		For example, the winmanager plugin and the Cream package use
		this function and specify the appname as "winmanager" and
		"cream" respectively.
		
		By default, the taglist plugin is a stand-alone plugin and
		controls the taglist window and buffer. If the taglist window
		is controlled by an external plugin, then the appname should
		be set appropriately.

==============================================================================
						*taglist-extend*
9. Extending~

The taglist plugin supports all the languages supported by the exuberant ctags
tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
TCL, Verilog, Vim and Yacc.

You can extend the taglist plugin to add support for new languages and also
modify the support for the above listed languages.

You should NOT make modifications to the taglist plugin script file to add
support for new languages. You will lose these changes when you upgrade to the
next version of the taglist plugin. Instead you should follow the below
described instructions to extend the taglist plugin.

You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
file. The name of these variables depends on the language name and is
described below.

Modifying support for an existing language~
To modify the support for an already supported language, you have to set the
tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
with the Vim filetype name for the language file.  For example, to modify the
support for the perl language files, you have to set the tlist_perl_settings
variable. To modify the support for java files, you have to set the
tlist_java_settings variable.

To determine the filetype name used by Vim for a file, use the following
command in the buffer containing the file:

	:set filetype

The above command will display the Vim filetype for the current buffer.

The format of the value set in the tlist_xxx_settings variable is

    <language_name>;flag1:name1;flag2:name2;flag3:name3

The different fields in the value are separated by the ';' character.

The first field 'language_name' is the name used by exuberant ctags to refer
to this language file. This name can be different from the file type name used
by Vim. For example, for C++, the language name used by ctags is 'c++' but the
filetype name used by Vim is 'cpp'. To get the list of language names
supported by exuberant ctags, use the following command:

	$ ctags --list-maps=all

The remaining fields follow the format "flag:name". The sub-field 'flag' is
the language specific flag used by exuberant ctags to generate the
corresponding tags. For example, for the C language, to list only the
functions, the 'f' flag is used. To get the list of flags supported by
exuberant ctags for the various languages use the following command:

	$ ctags --list-kinds=all

The sub-field 'name' specifies the title text to use for displaying the tags
of a particular type. For example, 'name' can be set to 'functions'. This
field can be set to any text string name.

For example, to list only the classes and functions defined in a C++ language
file, add the following line to your .vimrc file:

	let tlist_cpp_settings = 'c++;c:class;f:function'

In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
exuberant ctags to list C++ classes and functions and 'class' is the title
used for the class tags and 'function' is the title used for the function tags
in the taglist window.

For example, to display only functions defined in a C file and to use "My
Functions" as the title for the function tags, use

	let tlist_c_settings = 'c;f:My Functions'

When you set the tlist_xxx_settings variable, you will override the default
setting used by the taglist plugin for the 'xxx' language. You cannot add to
the default options used by the taglist plugin for a particular file type. To
add to the options used by the taglist plugin for a language, copy the option
values from the taglist plugin file to your .vimrc file and modify it.

Adding support for a new language~
If you want to add support for a new language to the taglist plugin, you need
to first extend the exuberant ctags tool. For more information about extending
exuberant ctags, visit the following page:

    http://ctags.sourceforge.net/EXTENDING.html

To add support for a new language, set the tlist_xxx_settings variable in the
~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
name with the Vim filetype name for the new language.

For example, to extend the taglist plugin to support the latex language, you
can use the following line (assuming, you have already extended exuberant
ctags to support the latex language):

	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'

With the above line, when you edit files of filetype "tex" in Vim, the taglist
plugin will invoke the exuberant ctags tool passing the "latex" filetype and
the flags b, c and l to generate the tags. The text heading 'bibitem',
'command' and 'label' will be used in the taglist window for the tags which
are generated for the flags b, c and l respectively.

==============================================================================
						*taglist-faq*
10. Frequently Asked Questions~

Q. The taglist plugin doesn't work. The taglist window is empty and the tags
   defined in a file are not displayed. 
A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
   features supported by Vim version 6.0 and above. You can use the following
   command to get the Vim version:
>
	$ vim --version
<
   Are you using exuberant ctags version 5.0 and above? The taglist plugin
   relies on the features supported by exuberant ctags and will not work with
   GNU ctags or the Unix ctags utility. You can use the following command to
   determine whether the ctags installed in your system is exuberant ctags:
>
	$ ctags --version
<
   Is exuberant ctags present in one of the directories in your PATH? If not,
   you need to set the Tlist_Ctags_Cmd variable to point to the location of
   exuberant ctags. Use the following Vim command to verify that this is setup
   correctly:
>
	:echo system(Tlist_Ctags_Cmd . ' --version')
<
   The above command should display the version information for exuberant
   ctags.

   Did you turn on the Vim filetype detection? The taglist plugin relies on
   the filetype detected by Vim and passes the filetype to the exuberant ctags
   utility to parse the tags. Check the output of the following Vim command:
>
	:filetype
<
   The output of the above command should contain "filetype detection:ON".
   To turn on the filetype detection, add the following line to the .vimrc or
   _vimrc file:
>
	filetype on
<
   Is your version of Vim compiled with the support for the system() function?
   The following Vim command should display 1:
>
	:echo exists('*system')
<
   In some Linux distributions (particularly Suse Linux), the default Vim
   installation is built without the support for the system() function. The
   taglist plugin uses the system() function to invoke the exuberant ctags
   utility. You need to rebuild Vim after enabling the support for the
   system() function. If you use the default build options, the system()
   function will be supported. 

   Do you have the |'shellslash'| option set? You can try disabling the
   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
   utility with the path to the file, if the incorrect slashes are used, then
   you will see errors.
   
   Check the shell related Vim options values using the following command:
>
	:set shell? shellcmdflag? shellpipe?
	:set shellquote? shellredir? shellxquote?
<
   If these options are set in your .vimrc or _vimrc file, try removing those
   lines.

   Are you using a Unix shell in a MS-Windows environment? For example,
   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
   set to point to this shell? You can try resetting the SHELL environment
   variable.

   If you are using a Unix shell on MS-Windows, you should try to use
   exuberant ctags that is compiled for Unix-like environments so that
   exuberant ctags will understand path names with forward slash characters.

   Is your filetype supported by the exuberant ctags utility? The file types
   supported by the exuberant ctags utility are listed in the ctags help. If a
   file type is not supported, you have to extend exuberant ctags. You can use
   the following command to list the filetypes supported by exuberant ctags:
>
	ctags --list-languages
<
   Run the following command from the shell prompt and check whether the tags
   defined in your file are listed in the output from exuberant ctags:
>
	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
<
   If you see your tags in the output from the above command, then the
   exuberant ctags utility is properly parsing your file.

   Do you have the .ctags or _ctags or the ctags.cnf file in your home
   directory for specifying default options or for extending exuberant ctags?
   If you do have this file, check the options in this file and make sure
   these options are not interfering with the operation of the taglist plugin.

   If you are using MS-Windows, check the value of the TEMP and TMP
   environment variables. If these environment variables are set to a path
   with space characters in the name, then try using the DOS 8.3 short name
   for the path or set them to a path without the space characters in the
   name. For example, if the temporary directory name is "C:\Documents and
   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
   the following:
>
	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
<
   If exuberant ctags is installed in a directory with space characters in the
   name, then try adding the directory to the PATH environment variable or try
   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
   or try copying the exuberant ctags to a path without space characters in
   the name. For example, if exuberant ctags is installed in the directory
   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
   as below:
>
	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
<
   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
   make sure that either you have the cygwin compiled sort utility installed
   and available in your PATH or compile exuberant ctags with internal sort
   support. Otherwise, when exuberant ctags sorts the tags output by invoking
   the sort utility, it may end up invoking the MS-Windows version of
   sort.exe, thereby resulting in failure.

Q. When I try to open the taglist window, I am seeing the following error
   message. How do I fix this problem?

   Taglist: Failed to generate tags for /my/path/to/file
   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...

A. The taglist plugin will work only with the exuberant ctags tool. You
   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
   You will see an error message similar to the one shown above, if you try
   use a non-exuberant ctags program with Vim. To fix this problem, either add
   the exuberant ctags tool location to the PATH environment variable or set
   the 'Tlist_Ctags_Cmd' variable.

Q. A file has more than one tag with the same name. When I select a tag name
   from the taglist window, the cursor is positioned at the incorrect tag
   location. 
A. The taglist plugin uses the search pattern generated by the exuberant ctags
   utility to position the cursor at the location of a tag definition. If a
   file has more than one tag with the same name and same prototype, then the
   search pattern will be the same. In this case, when searching for the tag
   pattern, the cursor may be positioned at the incorrect location. 

Q. I have made some modifications to my file and introduced new
   functions/classes/variables. I have not yet saved my file. The taglist
   plugin is not displaying the new tags when I update the taglist window.
A. The exuberant ctags utility will process only files that are present in the
   disk. To list the tags defined in a file, you have to save the file and
   then update the taglist window. 

Q. I have created a ctags file using the exuberant ctags utility for my source
   tree. How do I configure the taglist plugin to use this tags file? 
A. The taglist plugin doesn't use a tags file stored in disk. For every opened
   file, the taglist plugin invokes the exuberant ctags utility to get the
   list of tags dynamically. The Vim system() function is used to invoke
   exuberant ctags and get the ctags output. This function internally uses a
   temporary file to store the output. This file is deleted after the output
   from the command is read. So you will never see the file that contains the
   output of exuberant ctags.

Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
   I keep pressing a key with the taglist window open, the current buffer
   contents are changed. Why is this?
A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
   If the |'updatetime'| option is set to a low value, then the CursorHold
   autocmd will be triggered frequently. As the taglist plugin changes
   the focus to the taglist window to highlight the current tag, this could
   interfere with the key movement resulting in changing the contents of
   the current buffer. The workaround for this problem is to not set the
   |'updatetime'| option to a low value.

==============================================================================
						*taglist-license*
11. License~
Permission is hereby granted to use and distribute the taglist plugin, with or
without modifications, provided that this copyright notice is copied with it.
Like anything else that's free, taglist.vim is provided *as is* and comes with
no warranty of any kind, either expressed or implied. In no event will the
copyright holder be liable for any damamges resulting from the use of this
software.

==============================================================================
						*taglist-todo*
12. Todo~

1. Group tags according to the scope and display them. For example,
   group all the tags belonging to a C++/Java class 
2. Support for displaying tags in a modified (not-yet-saved) file. 
3. Automatically open the taglist window only for selected filetypes.
   For other filetypes, close the taglist window. 
4. When using the shell from the MKS toolkit, the taglist plugin 
   doesn't work.
5. The taglist plugin doesn't work with files edited remotely using the
   netrw plugin. The exuberant ctags utility cannot process files over
   scp/rcp/ftp, etc.

==============================================================================

vim:tw=78:ts=8:noet:ft=help:
zhimakaimen:/doc/taglist.txt
" ============================================================================
" File:        NERD_tree.vim
" Description: vim global plugin that provides a nice tree explorer
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 28 December, 2011
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
"
" SECTION: Script init stuff {{{1
"============================================================
if exists("loaded_nerd_tree")
    finish
endif
if v:version < 700
    echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_tree = 1

"for line continuation - i.e dont want C in &cpo
let s:old_cpo = &cpo
set cpo&vim

"Function: s:initVariable() function {{{2
"This function is used to initialise a given variable to a given value. The
"variable is only initialised if it does not exist prior
"
"Args:
"var: the name of the var to be initialised
"value: the value to initialise var to
"
"Returns:
"1 if the var is set, 0 otherwise
function! s:initVariable(var, value)
    if !exists(a:var)
        exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
        return 1
    endif
    return 0
endfunction

"SECTION: Init variable calls and other random constants {{{2
call s:initVariable("g:NERDChristmasTree", 1)
call s:initVariable("g:NERDTreeAutoCenter", 1)
call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
call s:initVariable("g:NERDTreeChDirMode", 0)
call s:initVariable("g:NERDTreeMinimalUI", 0)
if !exists("g:NERDTreeIgnore")
    let g:NERDTreeIgnore = ['\~$']
endif
call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
call s:initVariable("g:NERDTreeHighlightCursorline", 1)
call s:initVariable("g:NERDTreeHijackNetrw", 1)
call s:initVariable("g:NERDTreeMouseMode", 1)
call s:initVariable("g:NERDTreeNotificationThreshold", 100)
call s:initVariable("g:NERDTreeQuitOnOpen", 0)
call s:initVariable("g:NERDTreeShowBookmarks", 0)
call s:initVariable("g:NERDTreeShowFiles", 1)
call s:initVariable("g:NERDTreeShowHidden", 0)
call s:initVariable("g:NERDTreeShowLineNumbers", 0)
call s:initVariable("g:NERDTreeSortDirs", 1)
call s:initVariable("g:NERDTreeDirArrows", !nerdtree#runningWindows())
call s:initVariable("g:NERDTreeCasadeOpenSingleChildDir", 1)

if !exists("g:NERDTreeSortOrder")
    let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
else
    "if there isnt a * in the sort sequence then add one
    if count(g:NERDTreeSortOrder, '*') < 1
        call add(g:NERDTreeSortOrder, '*')
    endif
endif

if !exists('g:NERDTreeStatusline')

    "the exists() crap here is a hack to stop vim spazzing out when
    "loading a session that was created with an open nerd tree. It spazzes
    "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)
    let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"

endif
call s:initVariable("g:NERDTreeWinPos", "left")
call s:initVariable("g:NERDTreeWinSize", 31)

"init the shell commands that will be used to copy nodes, and remove dir trees
"
"Note: the space after the command is important
if nerdtree#runningWindows()
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
else
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
    call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
endif


"SECTION: Init variable calls for key mappings {{{2
call s:initVariable("g:NERDTreeMapActivateNode", "o")
call s:initVariable("g:NERDTreeMapChangeRoot", "C")
call s:initVariable("g:NERDTreeMapChdir", "cd")
call s:initVariable("g:NERDTreeMapCloseChildren", "X")
call s:initVariable("g:NERDTreeMapCloseDir", "x")
call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
call s:initVariable("g:NERDTreeMapMenu", "m")
call s:initVariable("g:NERDTreeMapHelp", "?")
call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
call s:initVariable("g:NERDTreeMapJumpParent", "p")
call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
call s:initVariable("g:NERDTreeMapJumpRoot", "P")
call s:initVariable("g:NERDTreeMapOpenExpl", "e")
call s:initVariable("g:NERDTreeMapOpenInTab", "t")
call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
call s:initVariable("g:NERDTreeMapOpenSplit", "i")
call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
call s:initVariable("g:NERDTreeMapQuit", "q")
call s:initVariable("g:NERDTreeMapRefresh", "r")
call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
call s:initVariable("g:NERDTreeMapToggleFiles", "F")
call s:initVariable("g:NERDTreeMapToggleFilters", "f")
call s:initVariable("g:NERDTreeMapToggleHidden", "I")
call s:initVariable("g:NERDTreeMapToggleZoom", "A")
call s:initVariable("g:NERDTreeMapUpdir", "u")
call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
call s:initVariable("g:NERDTreeMapCWD", "CD")

"SECTION: Load class files{{{2
call nerdtree#loadClassFiles()

" SECTION: Commands {{{1
"============================================================
"init the command that users start the nerd tree with
command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.TogglePrimary('<args>')
command! -n=0 -bar NERDTreeClose :call nerdtree#closeTreeIfOpen()
command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
command! -n=0 -bar NERDTreeFind call nerdtree#findAndRevealPath()
command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
" SECTION: Auto commands {{{1
"============================================================
augroup NERDTree
    "Save the cursor position whenever we close the nerd tree
    exec "autocmd BufWinLeave ". g:NERDTreeCreator.BufNamePrefix() ."* call nerdtree#saveScreenState()"

    "disallow insert mode in the NERDTree
    exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
augroup END

if g:NERDTreeHijackNetrw
    augroup NERDTreeHijackNetrw
        autocmd VimEnter * silent! autocmd! FileExplorer
        au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
    augroup END
endif

" SECTION: Public API {{{1
"============================================================
function! NERDTreeAddMenuItem(options)
    call g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddMenuSeparator(...)
    let opts = a:0 ? a:1 : {}
    call g:NERDTreeMenuItem.CreateSeparator(opts)
endfunction

function! NERDTreeAddSubmenu(options)
    return g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddKeyMap(options)
    call g:NERDTreeKeyMap.Create(a:options)
endfunction

function! NERDTreeRender()
    call nerdtree#renderView()
endfunction

function! NERDTreeFocus()
    if nerdtree#isTreeOpen()
        call nerdtree#putCursorInTreeWin()
    else
        call g:NERDTreeCreator.TogglePrimary("")
    endif
endfunction

function! NERDTreeCWD()
    call NERDTreeFocus()
    call nerdtree#chRootCwd()
endfunction
" SECTION: Post Source Actions {{{1
call nerdtree#postSourceActions()

"reset &cpo back to users setting
let &cpo = s:old_cpo

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/plugin/NERD_tree.vim
" File: taglist.vim
" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
" Version: 4.5
" Last Modified: September 21, 2007
" Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
"            Permission is hereby granted to use and distribute this code,
"            with or without modifications, provided that this copyright
"            notice is copied with it. Like anything else that's free,
"            taglist.vim is provided *as is* and comes with no warranty of any
"            kind, either expressed or implied. In no event will the copyright
"            holder be liable for any damamges resulting from the use of this
"            software.
"
" The "Tag List" plugin is a source code browser plugin for Vim and provides
" an overview of the structure of the programming language files and allows
" you to efficiently browse through source code files for different
" programming languages.  You can visit the taglist plugin home page for more
" information:
"
"       http://vim-taglist.sourceforge.net
"
" You can subscribe to the taglist mailing list to post your questions
" or suggestions for improvement or to report bugs. Visit the following
" page for subscribing to the mailing list:
"
"       http://groups.yahoo.com/group/taglist/
"
" For more information about using this plugin, after installing the
" taglist plugin, use the ":help taglist" command.
"
" Installation
" ------------
" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
"    unzip the following two files (the directory structure should be
"    preserved):
"
"       plugin/taglist.vim - main taglist plugin file
"       doc/taglist.txt    - documentation (help) file
"
"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
"    Vim help pages for more details about installing Vim plugins.
" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
"    command to process the taglist help file.
" 3. If the exuberant ctags utility is not present in your PATH, then set the
"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
"    utility (not to the directory) in the .vimrc file.
" 4. If you are running a terminal/console version of Vim and the
"    terminal doesn't support changing the window width then set the
"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
" 5. Restart Vim.
" 6. You can now use the ":TlistToggle" command to open/close the taglist
"    window. You can use the ":help taglist" command to get more
"    information about using the taglist plugin.
"
" ****************** Do not modify after this line ************************

" Line continuation used here
let s:cpo_save = &cpo
set cpo&vim

if !exists('loaded_taglist')
    " First time loading the taglist plugin
    "
    " To speed up the loading of Vim, the taglist plugin uses autoload
    " mechanism to load the taglist functions.
    " Only define the configuration variables, user commands and some
    " auto-commands and finish sourcing the file

    " The taglist plugin requires the built-in Vim system() function. If this
    " function is not available, then don't load the plugin.
    if !exists('*system')
        echomsg 'Taglist: Vim system() built-in function is not available. ' .
                    \ 'Plugin is not loaded.'
        let loaded_taglist = 'no'
        let &cpo = s:cpo_save
        finish
    endif

    " Location of the exuberant ctags tool
    if !exists('Tlist_Ctags_Cmd')
        if executable('exuberant-ctags')
            " On Debian Linux, exuberant ctags is installed
            " as exuberant-ctags
            let Tlist_Ctags_Cmd = 'exuberant-ctags'
        elseif executable('exctags')
            " On Free-BSD, exuberant ctags is installed as exctags
            let Tlist_Ctags_Cmd = 'exctags'
        elseif executable('ctags')
            let Tlist_Ctags_Cmd = 'ctags'
        elseif executable('ctags.exe')
            let Tlist_Ctags_Cmd = 'ctags.exe'
        elseif executable('tags')
            let Tlist_Ctags_Cmd = 'tags'
        else
            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
                        \ 'not found in PATH. Plugin is not loaded.'
            " Skip loading the plugin
            let loaded_taglist = 'no'
            let &cpo = s:cpo_save
            finish
        endif
    endif


    " Automatically open the taglist window on Vim startup
    if !exists('Tlist_Auto_Open')
        let Tlist_Auto_Open = 0
    endif

    " When the taglist window is toggle opened, move the cursor to the
    " taglist window
    if !exists('Tlist_GainFocus_On_ToggleOpen')
        let Tlist_GainFocus_On_ToggleOpen = 0
    endif

    " Process files even when the taglist window is not open
    if !exists('Tlist_Process_File_Always')
        let Tlist_Process_File_Always = 0
    endif

    if !exists('Tlist_Show_Menu')
        let Tlist_Show_Menu = 0
    endif

    " Tag listing sort type - 'name' or 'order'
    if !exists('Tlist_Sort_Type')
        let Tlist_Sort_Type = 'order'
    endif

    " Tag listing window split (horizontal/vertical) control
    if !exists('Tlist_Use_Horiz_Window')
        let Tlist_Use_Horiz_Window = 0
    endif

    " Open the vertically split taglist window on the left or on the right
    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
    " zero (i.e.  only for vertically split windows)
    if !exists('Tlist_Use_Right_Window')
        let Tlist_Use_Right_Window = 0
    endif

    " Increase Vim window width to display vertically split taglist window.
    " For MS-Windows version of Vim running in a MS-DOS window, this must be
    " set to 0 otherwise the system may hang due to a Vim limitation.
    if !exists('Tlist_Inc_Winwidth')
        if (has('win16') || has('win95')) && !has('gui_running')
            let Tlist_Inc_Winwidth = 0
        else
            let Tlist_Inc_Winwidth = 1
        endif
    endif

    " Vertically split taglist window width setting
    if !exists('Tlist_WinWidth')
        let Tlist_WinWidth = 30
    endif

    " Horizontally split taglist window height setting
    if !exists('Tlist_WinHeight')
        let Tlist_WinHeight = 10
    endif

    " Display tag prototypes or tag names in the taglist window
    if !exists('Tlist_Display_Prototype')
        let Tlist_Display_Prototype = 0
    endif

    " Display tag scopes in the taglist window
    if !exists('Tlist_Display_Tag_Scope')
        let Tlist_Display_Tag_Scope = 1
    endif

    " Use single left mouse click to jump to a tag. By default this is disabled.
    " Only double click using the mouse will be processed.
    if !exists('Tlist_Use_SingleClick')
        let Tlist_Use_SingleClick = 0
    endif

    " Control whether additional help is displayed as part of the taglist or
    " not.  Also, controls whether empty lines are used to separate the tag
    " tree.
    if !exists('Tlist_Compact_Format')
        let Tlist_Compact_Format = 0
    endif

    " Exit Vim if only the taglist window is currently open. By default, this is
    " set to zero.
    if !exists('Tlist_Exit_OnlyWindow')
        let Tlist_Exit_OnlyWindow = 0
    endif

    " Automatically close the folds for the non-active files in the taglist
    " window
    if !exists('Tlist_File_Fold_Auto_Close')
        let Tlist_File_Fold_Auto_Close = 0
    endif

    " Close the taglist window when a tag is selected
    if !exists('Tlist_Close_On_Select')
        let Tlist_Close_On_Select = 0
    endif

    " Automatically update the taglist window to display tags for newly
    " edited files
    if !exists('Tlist_Auto_Update')
        let Tlist_Auto_Update = 1
    endif

    " Automatically highlight the current tag
    if !exists('Tlist_Auto_Highlight_Tag')
        let Tlist_Auto_Highlight_Tag = 1
    endif
    
    " Automatically highlight the current tag on entering a buffer
    if !exists('Tlist_Highlight_Tag_On_BufEnter')
        let Tlist_Highlight_Tag_On_BufEnter = 1
    endif

    " Enable fold column to display the folding for the tag tree
    if !exists('Tlist_Enable_Fold_Column')
        let Tlist_Enable_Fold_Column = 1
    endif

    " Display the tags for only one file in the taglist window
    if !exists('Tlist_Show_One_File')
        let Tlist_Show_One_File = 0
    endif

    if !exists('Tlist_Max_Submenu_Items')
        let Tlist_Max_Submenu_Items = 20
    endif

    if !exists('Tlist_Max_Tag_Length')
        let Tlist_Max_Tag_Length = 10
    endif

    " Do not change the name of the taglist title variable. The winmanager
    " plugin relies on this name to determine the title for the taglist
    " plugin.
    let TagList_title = "__Tag_List__"

    " Taglist debug messages
    let s:tlist_msg = ''

    " Define the taglist autocommand to automatically open the taglist window
    " on Vim startup
    if g:Tlist_Auto_Open
        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
    endif

    " Refresh the taglist
    if g:Tlist_Process_File_Always
        autocmd BufEnter * call s:Tlist_Refresh()
    endif

    if g:Tlist_Show_Menu
        autocmd GUIEnter * call s:Tlist_Menu_Init()
    endif

    " When the taglist buffer is created when loading a Vim session file,
    " the taglist buffer needs to be initialized. The BufFilePost event
    " is used to handle this case.
    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()

    " Define the user commands to manage the taglist window
    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
    " For backwards compatiblity define the Tlist command
    command! -nargs=0 -bar Tlist TlistToggle
    command! -nargs=+ -complete=file TlistAddFiles
                \  call s:Tlist_Add_Files(<f-args>)
    command! -nargs=+ -complete=dir TlistAddFilesRecursive
                \ call s:Tlist_Add_Files_Recursive(<f-args>)
    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
    " For backwards compatiblity define the TlistSync command
    command! -nargs=0 -bar TlistSync TlistHighlightTag
    command! -nargs=* -complete=buffer TlistShowPrototype
                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
    command! -nargs=* -complete=buffer TlistShowTag
                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
    command! -nargs=* -complete=file TlistSessionLoad
                \ call s:Tlist_Session_Load(<q-args>)
    command! -nargs=* -complete=file TlistSessionSave
                \ call s:Tlist_Session_Save(<q-args>)
    command! -bar TlistLock let Tlist_Auto_Update=0
    command! -bar TlistUnlock let Tlist_Auto_Update=1

    " Commands for enabling/disabling debug and to display debug messages
    command! -nargs=? -complete=file -bar TlistDebug
                \ call s:Tlist_Debug_Enable(<q-args>)
    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()

    " Define autocommands to autoload the taglist plugin when needed.

    " Trick to get the current script ID
    map <SID>xx <SID>xx
    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
                                \ '\1', '')
    unmap <SID>xx

    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined TagList_* source ' .
                \ escape(expand('<sfile>'), ' ')

    let loaded_taglist = 'fast_load_done'

    if g:Tlist_Show_Menu && has('gui_running')
        call s:Tlist_Menu_Init()
    endif

    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

if !exists('s:tlist_sid')
    " Two or more versions of taglist plugin are installed. Don't
    " load this version of the plugin.
    finish
endif

unlet! s:tlist_sid

if loaded_taglist != 'fast_load_done'
    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

" Taglist plugin functionality is available
let loaded_taglist = 'available'

"------------------- end of user configurable options --------------------

" Default language specific settings for supported file types and tag types
"
" Variable name format:
"
"       s:tlist_def_{vim_ftype}_settings
" 
" vim_ftype - Filetype detected by Vim
"
" Value format:
"
"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
"
" ctags_ftype - File type supported by exuberant ctags
" flag        - Flag supported by exuberant ctags to generate a tag type
" name        - Name of the tag type used in the taglist window to display the
"               tags of this type
"

" assembly language
let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'

" aspperl language
let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'

" aspvbs language
let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'

" awk language
let s:tlist_def_awk_settings = 'awk;f:function'

" beta language
let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'

" c language
let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
                           \ 'v:variable;f:function'

" c++ language
let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
                             \ 'c:class;g:enum;s:struct;u:union;f:function'

" c# language
let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
                             \ 'E:event;g:enum;s:struct;i:interface;' .
                             \ 'p:properties;m:method'

" cobol language
let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
                               \ 'P:program;s:section'

" eiffel language
let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'

" erlang language
let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'

" expect (same as tcl) language
let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'

" fortran language
let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'

" HTML language
let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'

" java language
let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
                              \ 'f:field;m:method'

" javascript language
let s:tlist_def_javascript_settings = 'javascript;f:function'

" lisp language
let s:tlist_def_lisp_settings = 'lisp;f:function'

" lua language
let s:tlist_def_lua_settings = 'lua;f:function'

" makefiles
let s:tlist_def_make_settings = 'make;m:macro'

" pascal language
let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'

" perl language
let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'

" php language
let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'

" python language
let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'

" rexx language
let s:tlist_def_rexx_settings = 'rexx;s:subroutine'

" ruby language
let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
                              \ 'm:singleton method'

" scheme language
let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'

" shell language
let s:tlist_def_sh_settings = 'sh;f:function'

" C shell language
let s:tlist_def_csh_settings = 'sh;f:function'

" Z shell language
let s:tlist_def_zsh_settings = 'sh;f:function'

" slang language
let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'

" sml language
let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
                             \ 'r:structure;t:type;v:value;f:function'

" sql language
let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'

" tcl language
let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'

" vera language
let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
                                \ 'f:function;g:enum;m:member;p:program;' .
                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
                                \ 'x:externvar'

"verilog language
let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'

" vim language
let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'

" yacc language
let s:tlist_def_yacc_settings = 'yacc;l:label'

"------------------- end of language specific options --------------------

" Vim window size is changed by the taglist plugin or not
let s:tlist_winsize_chgd = -1
" Taglist window is maximized or not
let s:tlist_win_maximized = 0
" Name of files in the taglist
let s:tlist_file_names=''
" Number of files in the taglist
let s:tlist_file_count = 0
" Number of filetypes supported by taglist
let s:tlist_ftype_count = 0
" Is taglist part of other plugins like winmanager or cream?
let s:tlist_app_name = "none"
" Are we displaying brief help text
let s:tlist_brief_help = 1
" List of files removed on user request
let s:tlist_removed_flist = ""
" Index of current file displayed in the taglist window
let s:tlist_cur_file_idx = -1
" Taglist menu is empty or not
let s:tlist_menu_empty = 1

" An autocommand is used to refresh the taglist window when entering any
" buffer. We don't want to refresh the taglist window if we are entering the
" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
" variable is used to skip the refresh of the taglist window and is set
" and cleared appropriately.
let s:Tlist_Skip_Refresh = 0

" Tlist_Window_Display_Help()
function! s:Tlist_Window_Display_Help()
    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    if s:tlist_brief_help
        " Add the brief help
        call append(0, '" Press <F1> to display help text')
    else
        " Add the extensive help
        call append(0, '" <enter> : Jump to tag definition')
        call append(1, '" o : Jump to tag definition in new window')
        call append(2, '" p : Preview the tag definition')
        call append(3, '" <space> : Display tag prototype')
        call append(4, '" u : Update tag list')
        call append(5, '" s : Select sort field')
        call append(6, '" d : Remove file from taglist')
        call append(7, '" x : Zoom-out/Zoom-in taglist window')
        call append(8, '" + : Open a fold')
        call append(9, '" - : Close a fold')
        call append(10, '" * : Open all folds')
        call append(11, '" = : Close all folds')
        call append(12, '" [[ : Move to the start of previous file')
        call append(13, '" ]] : Move to the start of next file')
        call append(14, '" q : Close the taglist window')
        call append(15, '" <F1> : Remove help text')
    endif
endfunction

" Tlist_Window_Toggle_Help_Text()
" Toggle taglist plugin help text between the full version and the brief
" version
function! s:Tlist_Window_Toggle_Help_Text()
    if g:Tlist_Compact_Format
        " In compact display mode, do not display help
        return
    endif

    " Include the empty line displayed after the help text
    let brief_help_size = 1
    let full_help_size = 16

    setlocal modifiable

    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Remove the currently highlighted tag. Otherwise, the help text
    " might be highlighted by mistake
    match none

    " Toggle between brief and full help text
    if s:tlist_brief_help
        let s:tlist_brief_help = 0

        " Remove the previous help
        exe '1,' . brief_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
    else
        let s:tlist_brief_help = 1

        " Remove the previous help
        exe '1,' . full_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
    endif

    call s:Tlist_Window_Display_Help()

    " Restore the report option
    let &report = old_report

    setlocal nomodifiable
endfunction

" Taglist debug support
let s:tlist_debug = 0

" File for storing the debug messages
let s:tlist_debug_file = ''

" Tlist_Debug_Enable
" Enable logging of taglist debug messages.
function! s:Tlist_Debug_Enable(...)
    let s:tlist_debug = 1

    " Check whether a valid file name is supplied.
    if a:1 != ''
        let s:tlist_debug_file = fnamemodify(a:1, ':p')

        " Empty the log file
        exe 'redir! > ' . s:tlist_debug_file
        redir END

        " Check whether the log file is present/created
        if !filewritable(s:tlist_debug_file)
            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
                        \ . s:tlist_debug_file)
            let s:tlist_debug_file = ''
        endif
    endif
endfunction

" Tlist_Debug_Disable
" Disable logging of taglist debug messages.
function! s:Tlist_Debug_Disable(...)
    let s:tlist_debug = 0
    let s:tlist_debug_file = ''
endfunction

" Tlist_Debug_Show
" Display the taglist debug messages in a new window
function! s:Tlist_Debug_Show()
    if s:tlist_msg == ''
        call s:Tlist_Warning_Msg('Taglist: No debug messages')
        return
    endif

    " Open a new window to display the taglist debug messages
    new taglist_debug.txt
    " Delete all the lines (if the buffer already exists)
    silent! %delete _
    " Add the messages
    silent! put =s:tlist_msg
    " Move the cursor to the first line
    normal! gg
endfunction

" Tlist_Log_Msg
" Log the supplied debug message along with the time
function! s:Tlist_Log_Msg(msg)
    if s:tlist_debug
        if s:tlist_debug_file != ''
            exe 'redir >> ' . s:tlist_debug_file
            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
            redir END
        else
            " Log the message into a variable
            " Retain only the last 3000 characters
            let len = strlen(s:tlist_msg)
            if len > 3000
                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
            endif
            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
                        \ a:msg . "\n"
        endif
    endif
endfunction

" Tlist_Warning_Msg()
" Display a message using WarningMsg highlight group
function! s:Tlist_Warning_Msg(msg)
    echohl WarningMsg
    echomsg a:msg
    echohl None
endfunction

" Last returned file index for file name lookup.
" Used to speed up file lookup
let s:tlist_file_name_idx_cache = -1

" Tlist_Get_File_Index()
" Return the index of the specified filename
function! s:Tlist_Get_File_Index(fname)
    if s:tlist_file_count == 0 || a:fname == ''
        return -1
    endif

    " If the new filename is same as the last accessed filename, then
    " return that index
    if s:tlist_file_name_idx_cache != -1 &&
                \ s:tlist_file_name_idx_cache < s:tlist_file_count
        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
            " Same as the last accessed file
            return s:tlist_file_name_idx_cache
        endif
    endif

    " First, check whether the filename is present
    let s_fname = a:fname . "\n"
    let i = stridx(s:tlist_file_names, s_fname)
    if i == -1
        let s:tlist_file_name_idx_cache = -1
        return -1
    endif

    " Second, compute the file name index
    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
    let s:tlist_file_name_idx_cache = strlen(nl_txt)
    return s:tlist_file_name_idx_cache
endfunction

" Last returned file index for line number lookup.
" Used to speed up file lookup
let s:tlist_file_lnum_idx_cache = -1

" Tlist_Window_Get_File_Index_By_Linenum()
" Return the index of the filename present in the specified line number
" Line number refers to the line number in the taglist window
function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')

    " First try to see whether the new line number is within the range
    " of the last returned file
    if s:tlist_file_lnum_idx_cache != -1 &&
                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
            return s:tlist_file_lnum_idx_cache
        endif
    endif

    let fidx = -1

    if g:Tlist_Show_One_File
        " Displaying only one file in the taglist window. Check whether
        " the line is within the tags displayed for that file
        if s:tlist_cur_file_idx != -1
            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
                let fidx = s:tlist_cur_file_idx
            endif

        endif
    else
        " Do a binary search in the taglist
        let left = 0
        let right = s:tlist_file_count - 1

        while left < right
            let mid = (left + right) / 2

            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
                let s:tlist_file_lnum_idx_cache = mid
                return mid
            endif

            if a:lnum < s:tlist_{mid}_start
                let right = mid - 1
            else
                let left = mid + 1
            endif
        endwhile

        if left >= 0 && left < s:tlist_file_count
                    \ && a:lnum >= s:tlist_{left}_start
                    \ && a:lnum <= s:tlist_{left}_end
            let fidx = left
        endif
    endif

    let s:tlist_file_lnum_idx_cache = fidx

    return fidx
endfunction

" Tlist_Exe_Cmd_No_Acmds
" Execute the specified Ex command after disabling autocommands
function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
    let old_eventignore = &eventignore
    set eventignore=all
    exe a:cmd
    let &eventignore = old_eventignore
endfunction

" Tlist_Skip_File()
" Check whether tag listing is supported for the specified file
function! s:Tlist_Skip_File(filename, ftype)
    " Skip buffers with no names and buffers with filetype not set
    if a:filename == '' || a:ftype == ''
        return 1
    endif

    " Skip files which are not supported by exuberant ctags
    " First check whether default settings for this filetype are available.
    " If it is not available, then check whether user specified settings are
    " available. If both are not available, then don't list the tags for this
    " filetype
    let var = 's:tlist_def_' . a:ftype . '_settings'
    if !exists(var)
        let var = 'g:tlist_' . a:ftype . '_settings'
        if !exists(var)
            return 1
        endif
    endif

    " Skip files which are not readable or files which are not yet stored
    " to the disk
    if !filereadable(a:filename)
        return 1
    endif

    return 0
endfunction

" Tlist_User_Removed_File
" Returns 1 if a file is removed by a user from the taglist
function! s:Tlist_User_Removed_File(filename)
    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
endfunction

" Tlist_Update_Remove_List
" Update the list of user removed files from the taglist
" add == 1, add the file to the removed list
" add == 0, delete the file from the removed list
function! s:Tlist_Update_Remove_List(filename, add)
    if a:add
        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
    else
        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
        let text_before = strpart(s:tlist_removed_flist, 0, idx)
        let rem_text = strpart(s:tlist_removed_flist, idx)
        let next_idx = stridx(rem_text, "\n")
        let text_after = strpart(rem_text, next_idx + 1)

        let s:tlist_removed_flist = text_before . text_after
    endif
endfunction

" Tlist_FileType_Init
" Initialize the ctags arguments and tag variable for the specified
" file type
function! s:Tlist_FileType_Init(ftype)
    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
    " If the user didn't specify any settings, then use the default
    " ctags args. Otherwise, use the settings specified by the user
    let var = 'g:tlist_' . a:ftype . '_settings'
    if exists(var)
        " User specified ctags arguments
        let settings = {var} . ';'
    else
        " Default ctags arguments
        let var = 's:tlist_def_' . a:ftype . '_settings'
        if !exists(var)
            " No default settings for this file type. This filetype is
            " not supported
            return 0
        endif
        let settings = s:tlist_def_{a:ftype}_settings . ';'
    endif

    let msg = 'Taglist: Invalid ctags option setting - ' . settings

    " Format of the option that specifies the filetype and ctags arugments:
    "
    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
    "

    " Extract the file type to pass to ctags. This may be different from the
    " file type detected by Vim
    let pos = stridx(settings, ';')
    if pos == -1
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    let ctags_ftype = strpart(settings, 0, pos)
    if ctags_ftype == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    " Make sure a valid filetype is supplied. If the user didn't specify a
    " valid filetype, then the ctags option settings may be treated as the
    " filetype
    if ctags_ftype =~ ':'
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Remove the file type from settings
    let settings = strpart(settings, pos + 1)
    if settings == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Process all the specified ctags flags. The format is
    " flag1:name1;flag2:name2;flag3:name3
    let ctags_flags = ''
    let cnt = 0
    while settings != ''
        " Extract the flag
        let pos = stridx(settings, ':')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let flag = strpart(settings, 0, pos)
        if flag == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        " Remove the flag from settings
        let settings = strpart(settings, pos + 1)

        " Extract the tag type name
        let pos = stridx(settings, ';')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let name = strpart(settings, 0, pos)
        if name == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let settings = strpart(settings, pos + 1)

        let cnt = cnt + 1

        let s:tlist_{a:ftype}_{cnt}_name = flag
        let s:tlist_{a:ftype}_{cnt}_fullname = name
        let ctags_flags = ctags_flags . flag
    endwhile

    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
    let s:tlist_{a:ftype}_count = cnt
    let s:tlist_{a:ftype}_ctags_flags = ctags_flags

    " Save the filetype name
    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
    let s:tlist_ftype_count = s:tlist_ftype_count + 1

    return 1
endfunction

" Tlist_Detect_Filetype
" Determine the filetype for the specified file using the filetypedetect
" autocmd.
function! s:Tlist_Detect_Filetype(fname)
    " Ignore the filetype autocommands
    let old_eventignore = &eventignore
    set eventignore=FileType

    " Save the 'filetype', as this will be changed temporarily
    let old_filetype = &filetype

    " Run the filetypedetect group of autocommands to determine
    " the filetype
    exe 'doautocmd filetypedetect BufRead ' . a:fname

    " Save the detected filetype
    let ftype = &filetype

    " Restore the previous state
    let &filetype = old_filetype
    let &eventignore = old_eventignore

    return ftype
endfunction

" Tlist_Get_Buffer_Filetype
" Get the filetype for the specified buffer
function! s:Tlist_Get_Buffer_Filetype(bnum)
    let buf_ft = getbufvar(a:bnum, '&filetype')

    if bufloaded(a:bnum)
        " For loaded buffers, the 'filetype' is already determined
        return buf_ft
    endif

    " For unloaded buffers, if the 'filetype' option is set, return it
    if buf_ft != ''
        return buf_ft
    endif

    " Skip non-existent buffers
    if !bufexists(a:bnum)
        return ''
    endif

    " For buffers whose filetype is not yet determined, try to determine
    " the filetype
    let bname = bufname(a:bnum)

    return s:Tlist_Detect_Filetype(bname)
endfunction

" Tlist_Discard_TagInfo
" Discard the stored tag information for a file
function! s:Tlist_Discard_TagInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    let ftype = s:tlist_{a:fidx}_filetype

    " Discard information about the tags defined in the file
    let i = 1
    while i <= s:tlist_{a:fidx}_tag_count
        let fidx_i = 's:tlist_' . a:fidx . '_' . i
        unlet! {fidx_i}_tag
        unlet! {fidx_i}_tag_name
        unlet! {fidx_i}_tag_type
        unlet! {fidx_i}_ttype_idx
        unlet! {fidx_i}_tag_proto
        unlet! {fidx_i}_tag_searchpat
        unlet! {fidx_i}_tag_linenum
        let i = i + 1
    endwhile

    let s:tlist_{a:fidx}_tag_count = 0

    " Discard information about tag type groups
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{a:fidx}_{ttype} != ''
            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
            let {fidx_ttype} = ''
            let {fidx_ttype}_offset = 0
            let cnt = {fidx_ttype}_count
            let {fidx_ttype}_count = 0
            let j = 1
            while j <= cnt
                unlet! {fidx_ttype}_{j}
                let j = j + 1
            endwhile
        endif
        let i = i + 1
    endwhile

    " Discard the stored menu command also
    let s:tlist_{a:fidx}_menu_cmd = ''
endfunction

" Tlist_Window_Update_Line_Offsets
" Update the line offsets for tags for files starting from start_idx
" and displayed in the taglist window by the specified offset
function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
    let i = a:start_idx

    while i < s:tlist_file_count
        if s:tlist_{i}_visible
            " Update the start/end line number only if the file is visible
            if a:increment
                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
            else
                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
            endif
        endif
        let i = i + 1
    endwhile
endfunction

" Tlist_Discard_FileInfo
" Discard the stored information for a file
function! s:Tlist_Discard_FileInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    call s:Tlist_Discard_TagInfo(a:fidx)

    let ftype = s:tlist_{a:fidx}_filetype

    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        unlet! s:tlist_{a:fidx}_{ttype}
        unlet! s:tlist_{a:fidx}_{ttype}_offset
        unlet! s:tlist_{a:fidx}_{ttype}_count
        let i = i + 1
    endwhile

    unlet! s:tlist_{a:fidx}_filename
    unlet! s:tlist_{a:fidx}_sort_type
    unlet! s:tlist_{a:fidx}_filetype
    unlet! s:tlist_{a:fidx}_mtime
    unlet! s:tlist_{a:fidx}_start
    unlet! s:tlist_{a:fidx}_end
    unlet! s:tlist_{a:fidx}_valid
    unlet! s:tlist_{a:fidx}_visible
    unlet! s:tlist_{a:fidx}_tag_count
    unlet! s:tlist_{a:fidx}_menu_cmd
endfunction

" Tlist_Window_Remove_File_From_Display
" Remove the specified file from display
function! s:Tlist_Window_Remove_File_From_Display(fidx)
    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
                \ s:tlist_{a:fidx}_filename . ')')
    " If the file is not visible then no need to remove it
    if !s:tlist_{a:fidx}_visible
        return
    endif

    " Remove the tags displayed for the specified file from the window
    let start = s:tlist_{a:fidx}_start
    " Include the empty line after the last line also
    if g:Tlist_Compact_Format
        let end = s:tlist_{a:fidx}_end
    else
        let end = s:tlist_{a:fidx}_end + 1
    endif

    setlocal modifiable
    exe 'silent! ' . start . ',' . end . 'delete _'
    setlocal nomodifiable

    " Correct the start and end line offsets for all the files following
    " this file, as the tags for this file are removed
    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
endfunction

" Tlist_Remove_File
" Remove the file under the cursor or the specified file index
" user_request - User requested to remove the file from taglist
function! s:Tlist_Remove_File(file_idx, user_request)
    let fidx = a:file_idx

    if fidx == -1
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif
    endif
    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')

    let save_winnr = winnr()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Taglist window is open, remove the file from display

        if save_winnr != winnum
            let old_eventignore = &eventignore
            set eventignore=all
            exe winnum . 'wincmd w'
        endif

        call s:Tlist_Window_Remove_File_From_Display(fidx)

        if save_winnr != winnum
            exe save_winnr . 'wincmd w'
            let &eventignore = old_eventignore
        endif
    endif

    let fname = s:tlist_{fidx}_filename

    if a:user_request
        " As the user requested to remove the file from taglist,
        " add it to the removed list
        call s:Tlist_Update_Remove_List(fname, 1)
    endif

    " Remove the file name from the taglist list of filenames
    let idx = stridx(s:tlist_file_names, fname . "\n")
    let text_before = strpart(s:tlist_file_names, 0, idx)
    let rem_text = strpart(s:tlist_file_names, idx)
    let next_idx = stridx(rem_text, "\n")
    let text_after = strpart(rem_text, next_idx + 1)
    let s:tlist_file_names = text_before . text_after

    call s:Tlist_Discard_FileInfo(fidx)

    " Shift all the file variables by one index
    let i = fidx + 1

    while i < s:tlist_file_count
        let j = i - 1

        let s:tlist_{j}_filename = s:tlist_{i}_filename
        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
        let s:tlist_{j}_start = s:tlist_{i}_start
        let s:tlist_{j}_end = s:tlist_{i}_end
        let s:tlist_{j}_valid = s:tlist_{i}_valid
        let s:tlist_{j}_visible = s:tlist_{i}_visible
        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd

        let k = 1
        while k <= s:tlist_{j}_tag_count
            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
            let k = k + 1
        endwhile

        let ftype = s:tlist_{i}_filetype

        let k = 1
        while k <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{k}_name
            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
            if s:tlist_{j}_{ttype} != ''
                let l = 1
                while l <= s:tlist_{j}_{ttype}_count
                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
                    let l = l + 1
                endwhile
            endif
            let k = k + 1
        endwhile

        " As the file and tag information is copied to the new index,
        " discard the previous information
        call s:Tlist_Discard_FileInfo(i)

        let i = i + 1
    endwhile

    " Reduce the number of files displayed
    let s:tlist_file_count = s:tlist_file_count - 1

    if g:Tlist_Show_One_File
        " If the tags for only one file is displayed and if we just
        " now removed that file, then invalidate the current file idx
        if s:tlist_cur_file_idx == fidx
            let s:tlist_cur_file_idx = -1
        endif
    endif
endfunction

" Tlist_Window_Goto_Window
" Goto the taglist window
function! s:Tlist_Window_Goto_Window()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        if winnr() != winnum
            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
        endif
    endif
endfunction

" Tlist_Window_Create
" Create a new taglist window. If it is already open, jump to it
function! s:Tlist_Window_Create()
    call s:Tlist_Log_Msg('Tlist_Window_Create()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    " If used with winmanager don't open windows. Winmanager will handle
    " the window/buffer management
    if s:tlist_app_name == "winmanager"
        return
    endif

    " Create a new window. If user prefers a horizontal window, then open
    " a horizontally split window. Otherwise open a vertically split
    " window
    if g:Tlist_Use_Horiz_Window
        " Open a horizontally split window
        let win_dir = 'botright'
        " Horizontal window height
        let win_size = g:Tlist_WinHeight
    else
        if s:tlist_winsize_chgd == -1
            " Open a vertically split window. Increase the window size, if
            " needed, to accomodate the new window
            if g:Tlist_Inc_Winwidth &&
                        \ &columns < (80 + g:Tlist_WinWidth)
                " Save the original window position
                let s:tlist_pre_winx = getwinposx()
                let s:tlist_pre_winy = getwinposy()

                " one extra column is needed to include the vertical split
                let &columns= &columns + g:Tlist_WinWidth + 1

                let s:tlist_winsize_chgd = 1
            else
                let s:tlist_winsize_chgd = 0
            endif
        endif

        if g:Tlist_Use_Right_Window
            " Open the window at the rightmost place
            let win_dir = 'botright vertical'
        else
            " Open the window at the leftmost place
            let win_dir = 'topleft vertical'
        endif
        let win_size = g:Tlist_WinWidth
    endif

    " If the tag listing temporary buffer already exists, then reuse it.
    " Otherwise create a new buffer
    let bufnum = bufnr(g:TagList_title)
    if bufnum == -1
        " Create a new buffer
        let wcmd = g:TagList_title
    else
        " Edit the existing buffer
        let wcmd = '+buffer' . bufnum
    endif

    " Create the taglist window
    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd

    " Save the new window position
    let s:tlist_winx = getwinposx()
    let s:tlist_winy = getwinposy()

    " Initialize the taglist window
    call s:Tlist_Window_Init()
endfunction

" Tlist_Window_Zoom
" Zoom (maximize/minimize) the taglist window
function! s:Tlist_Window_Zoom()
    if s:tlist_win_maximized
        " Restore the window back to the previous size
        if g:Tlist_Use_Horiz_Window
            exe 'resize ' . g:Tlist_WinHeight
        else
            exe 'vert resize ' . g:Tlist_WinWidth
        endif
        let s:tlist_win_maximized = 0
    else
        " Set the window size to the maximum possible without closing other
        " windows
        if g:Tlist_Use_Horiz_Window
            resize
        else
            vert resize
        endif
        let s:tlist_win_maximized = 1
    endif
endfunction

" Tlist_Ballon_Expr
" When the mouse cursor is over a tag in the taglist window, display the
" tag prototype (balloon)
function! Tlist_Ballon_Expr()
    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
    if fidx == -1
        return ''
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
    if tidx == 0
        return ''
    endif

    " Get the tag search pattern and display it
    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Window_Check_Width
" Check the width of the taglist window. For horizontally split windows, the
" 'winfixheight' option is used to fix the height of the window. For
" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
" need to handle window width changes from this function.
function! s:Tlist_Window_Check_Width()
    let tlist_winnr = bufwinnr(g:TagList_title)
    if tlist_winnr == -1
        return
    endif

    let width = winwidth(tlist_winnr)
    if width != g:Tlist_WinWidth
        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
                    \ "width from " . width . " to " . g:Tlist_WinWidth)
        let save_winnr = winnr()
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
        endif
        exe 'vert resize ' . g:Tlist_WinWidth
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Window_Exit_Only_Window
" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
" taglist window is present.
function! s:Tlist_Window_Exit_Only_Window()
    " Before quitting Vim, delete the taglist buffer so that
    " the '0 mark is correctly set to the previous buffer.
    if v:version < 700
	if winbufnr(2) == -1
	    bdelete
	    quit
	endif
    else
	if winbufnr(2) == -1
	    if tabpagenr('$') == 1
		" Only one tag page is present
		bdelete
		quit
	    else
		" More than one tab page is present. Close only the current
		" tab page
		close
	    endif
	endif
    endif
endfunction

" Tlist_Window_Init
" Set the default options for the taglist window
function! s:Tlist_Window_Init()
    call s:Tlist_Log_Msg('Tlist_Window_Init()')

    " The 'readonly' option should not be set for the taglist buffer.
    " If Vim is started as "view/gview" or if the ":view" command is
    " used, then the 'readonly' option is set for all the buffers.
    " Unset it for the taglist buffer
    setlocal noreadonly

    " Set the taglist buffer filetype to taglist
    setlocal filetype=taglist

    " Define taglist window element highlighting
    syntax match TagListComment '^" .*'
    syntax match TagListFileName '^[^" ].*$'
    syntax match TagListTitle '^  \S.*$'
    syntax match TagListTagScope  '\s\[.\{-\}\]$'

    " Define the highlighting only if colors are supported
    if has('gui_running') || &t_Co > 2
        " Colors to highlight various taglist window elements
        " If user defined highlighting group exists, then use them.
        " Otherwise, use default highlight groups.
        if hlexists('MyTagListTagName')
            highlight link TagListTagName MyTagListTagName
        else
            highlight default link TagListTagName Search
        endif
        " Colors to highlight comments and titles
        if hlexists('MyTagListComment')
            highlight link TagListComment MyTagListComment
        else
            highlight clear TagListComment
            highlight default link TagListComment Comment
        endif
        if hlexists('MyTagListTitle')
            highlight link TagListTitle MyTagListTitle
        else
            highlight clear TagListTitle
            highlight default link TagListTitle Title
        endif
        if hlexists('MyTagListFileName')
            highlight link TagListFileName MyTagListFileName
        else
            highlight clear TagListFileName
            highlight default TagListFileName guibg=Grey ctermbg=darkgray
                        \ guifg=white ctermfg=white
        endif
        if hlexists('MyTagListTagScope')
            highlight link TagListTagScope MyTagListTagScope
        else
            highlight clear TagListTagScope
            highlight default link TagListTagScope Identifier
        endif
    else
        highlight default TagListTagName term=reverse cterm=reverse
    endif

    " Folding related settings
    setlocal foldenable
    setlocal foldminlines=0
    setlocal foldmethod=manual
    setlocal foldlevel=9999
    if g:Tlist_Enable_Fold_Column
        setlocal foldcolumn=3
    else
        setlocal foldcolumn=0
    endif
    setlocal foldtext=v:folddashes.getline(v:foldstart)

    if s:tlist_app_name != "winmanager"
        " Mark buffer as scratch
        silent! setlocal buftype=nofile
        if s:tlist_app_name == "none"
            silent! setlocal bufhidden=delete
        endif
        silent! setlocal noswapfile
        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
        " buffers. So if the taglist buffer is unlisted, multiple taglist
        " windows will be opened. This bug is fixed in Vim 6.1 and above
        if v:version >= 601
            silent! setlocal nobuflisted
        endif
    endif

    silent! setlocal nowrap

    " If the 'number' option is set in the source window, it will affect the
    " taglist window. So forcefully disable 'number' option for the taglist
    " window
    silent! setlocal nonumber

    " Use fixed height when horizontally split window is used
    if g:Tlist_Use_Horiz_Window
        if v:version >= 602
            set winfixheight
        endif
    endif
    if !g:Tlist_Use_Horiz_Window && v:version >= 700
        set winfixwidth
    endif

    " Setup balloon evaluation to display tag prototype
    if v:version >= 700 && has('balloon_eval')
        setlocal balloonexpr=Tlist_Ballon_Expr()
        set ballooneval
    endif

    " Setup the cpoptions properly for the maps to work
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    " Create buffer local mappings for jumping to the tags and sorting the list
    nnoremap <buffer> <silent> <CR>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> o
                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    nnoremap <buffer> <silent> p
                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    nnoremap <buffer> <silent> P
                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    nnoremap <buffer> <silent> t
                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    nnoremap <buffer> <silent> <C-t>
                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    nnoremap <buffer> <silent> <2-LeftMouse>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> s
                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    nnoremap <buffer> <silent> + :silent! foldopen<CR>
    nnoremap <buffer> <silent> - :silent! foldclose<CR>
    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    nnoremap <buffer> <silent> q :close<CR>

    " Insert mode mappings
    inoremap <buffer> <silent> <CR>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    " Windows needs return
    inoremap <buffer> <silent> <Return>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> o
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    inoremap <buffer> <silent> p
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    inoremap <buffer> <silent> P
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    inoremap <buffer> <silent> t
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    inoremap <buffer> <silent> <C-t>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    inoremap <buffer> <silent> <2-LeftMouse>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> s
                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> <Space>       <C-o>:call
                                    \ <SID>Tlist_Window_Show_Info()<CR>
    inoremap <buffer> <silent> u
                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    inoremap <buffer> <silent> q    <C-o>:close<CR>

    " Map single left mouse click if the user wants this functionality
    if g:Tlist_Use_SingleClick == 1
        " Contributed by Bindu Wavell
        " attempt to perform single click mapping, it would be much
        " nicer if we could nnoremap <buffer> ... however vim does
        " not fire the <buffer> <leftmouse> when you use the mouse
        " to enter a buffer.
        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
                    \ '<bar> endif <CR>'
        if maparg('<leftmouse>', 'n') == ''
            " no mapping for leftmouse
            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
        else
            " we have a mapping
            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
            let mapcmd = mapcmd . substitute(substitute(
                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
                        \ '\c^<leftmouse>', '', '')
            let mapcmd = mapcmd . clickmap
            exe mapcmd
        endif
    endif

    " Define the taglist autocommands
    augroup TagListAutoCmds
        autocmd!
        " Display the tag prototype for the tag under the cursor.
        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
        " Highlight the current tag periodically
        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)

        " Adjust the Vim window width when taglist window is closed
        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
        " Close the fold for this buffer when leaving the buffer
        if g:Tlist_File_Fold_Auto_Close
            autocmd BufEnter * silent
                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
        endif
        " Exit Vim itself if only the taglist window is present (optional)
        if g:Tlist_Exit_OnlyWindow
	    autocmd BufEnter __Tag_List__ nested
			\ call s:Tlist_Window_Exit_Only_Window()
        endif
        if s:tlist_app_name != "winmanager" &&
                    \ !g:Tlist_Process_File_Always &&
                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
            " Auto refresh the taglist window
            autocmd BufEnter * call s:Tlist_Refresh()
        endif

        if !g:Tlist_Use_Horiz_Window
            if v:version < 700
                autocmd WinEnter * call s:Tlist_Window_Check_Width()
            endif
        endif
        if v:version >= 700
            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
        endif
    augroup end

    " Restore the previous cpoptions settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Window_Refresh
" Display the tags for all the files in the taglist window
function! s:Tlist_Window_Refresh()
    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Mark the buffer as modifiable
    setlocal modifiable

    " Delete the contents of the buffer to the black-hole register
    silent! %delete _

    " As we have cleared the taglist window, mark all the files
    " as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    if g:Tlist_Compact_Format == 0
        " Display help in non-compact mode
        call s:Tlist_Window_Display_Help()
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " If the tags for only one file should be displayed in the taglist
    " window, then no need to add the tags here. The bufenter autocommand
    " will add the tags for that file.
    if g:Tlist_Show_One_File
        return
    endif

    " List all the tags for the previously processed files
    " Do this only if taglist is configured to display tags for more than
    " one file. Otherwise, when Tlist_Show_One_File is configured,
    " tags for the wrong file will be displayed.
    let i = 0
    while i < s:tlist_file_count
        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
                    \ s:tlist_{i}_filetype)
        let i = i + 1
    endwhile

    if g:Tlist_Auto_Update
        " Add and list the tags for all buffers in the Vim buffer list
        let i = 1
        let last_bufnum = bufnr('$')
        while i <= last_bufnum
            if buflisted(i)
                let fname = fnamemodify(bufname(i), ':p')
                let ftype = s:Tlist_Get_Buffer_Filetype(i)
                " If the file doesn't support tag listing, skip it
                if !s:Tlist_Skip_File(fname, ftype)
                    call s:Tlist_Window_Refresh_File(fname, ftype)
                endif
            endif
            let i = i + 1
        endwhile
    endif

    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
    if g:Tlist_File_Fold_Auto_Close
        " Close all the folds
        silent! %foldclose
    endif

    " Move the cursor to the top of the taglist window
    normal! gg
endfunction

" Tlist_Post_Close_Cleanup()
" Close the taglist window and adjust the Vim window width
function! s:Tlist_Post_Close_Cleanup()
    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
    " Mark all the files as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    " Remove the taglist autocommands
    silent! autocmd! TagListAutoCmds

    " Clear all the highlights
    match none

    silent! syntax clear TagListTitle
    silent! syntax clear TagListComment
    silent! syntax clear TagListTagScope

    " Remove the left mouse click mapping if it was setup initially
    if g:Tlist_Use_SingleClick
        if hasmapto('<LeftMouse>')
            nunmap <LeftMouse>
        endif
    endif

    if s:tlist_app_name != "winmanager"
    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
                \ s:tlist_winsize_chgd != 1 ||
                \ &columns < (80 + g:Tlist_WinWidth)
        " No need to adjust window width if using horizontally split taglist
        " window or if columns is less than 101 or if the user chose not to
        " adjust the window width
    else
        " If the user didn't manually move the window, then restore the window
        " position to the pre-taglist position
        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
                    \ getwinposx() == s:tlist_winx &&
                    \ getwinposy() == s:tlist_winy
            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
        endif

        " Adjust the Vim window width
        let &columns= &columns - (g:Tlist_WinWidth + 1)
    endif
    endif

    let s:tlist_winsize_chgd = -1

    " Reset taglist state variables
    if s:tlist_app_name == "winmanager"
        let s:tlist_app_name = "none"
    endif
    let s:tlist_window_initialized = 0
endfunction

" Tlist_Window_Refresh_File()
" List the tags defined in the specified file in a Vim window
function! s:Tlist_Window_Refresh_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx != -1
        let file_listed = 1
    else
        let file_listed = 0
    endif

    if !file_listed
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(a:filename)
            return
        endif
    endif

    if file_listed && s:tlist_{fidx}_visible
        " Check whether the file tags are currently valid
        if s:tlist_{fidx}_valid
            " Goto the first line in the file
            exe s:tlist_{fidx}_start

            " If the line is inside a fold, open the fold
            if foldclosed('.') != -1
                exe "silent! " . s:tlist_{fidx}_start . "," .
                            \ s:tlist_{fidx}_end . "foldopen!"
            endif
            return
        endif

        " Discard and remove the tags for this file from display
        call s:Tlist_Discard_TagInfo(fidx)
        call s:Tlist_Window_Remove_File_From_Display(fidx)
    endif

    " Process and generate a list of tags defined in the file
    if !file_listed || !s:tlist_{fidx}_valid
        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
        if ret_fidx == -1
            return
        endif
        let fidx = ret_fidx
    endif

    " Set report option to a huge value to prevent informational messages
    " while adding lines to the taglist window
    let old_report = &report
    set report=99999

    if g:Tlist_Show_One_File
        " Remove the previous file
        if s:tlist_cur_file_idx != -1
            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
            let s:tlist_{s:tlist_cur_file_idx}_start = 0
            let s:tlist_{s:tlist_cur_file_idx}_end = 0
        endif
        let s:tlist_cur_file_idx = fidx
    endif

    " Mark the buffer as modifiable
    setlocal modifiable

    " Add new files to the end of the window. For existing files, add them at
    " the same line where they were previously present. If the file is not
    " visible, then add it at the end
    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
        if g:Tlist_Compact_Format
            let s:tlist_{fidx}_start = line('$')
        else
            let s:tlist_{fidx}_start = line('$') + 1
        endif
    endif

    let s:tlist_{fidx}_visible = 1

    " Goto the line where this file should be placed
    if g:Tlist_Compact_Format
        exe s:tlist_{fidx}_start
    else
        exe s:tlist_{fidx}_start - 1
    endif

    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
    if g:Tlist_Compact_Format == 0
        silent! put =txt
    else
        silent! put! =txt
        " Move to the next line
        exe line('.') + 1
    endif
    let file_start = s:tlist_{fidx}_start

    " Add the tag names grouped by tag type to the buffer with a title
    let i = 1
    let ttype_cnt = s:tlist_{a:ftype}_count
    while i <= ttype_cnt
        let ttype = s:tlist_{a:ftype}_{i}_name
        " Add the tag type only if there are tags for that type
        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
        let ttype_txt = {fidx_ttype}
        if ttype_txt != ''
            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
            if g:Tlist_Compact_Format == 0
                let ttype_start_lnum = line('.') + 1
                silent! put =txt
            else
                let ttype_start_lnum = line('.')
                silent! put! =txt
            endif
            silent! put =ttype_txt

            let {fidx_ttype}_offset = ttype_start_lnum - file_start

            " create a fold for this tag type
            let fold_start = ttype_start_lnum
            let fold_end = fold_start + {fidx_ttype}_count
            exe fold_start . ',' . fold_end  . 'fold'

            " Adjust the cursor position
            if g:Tlist_Compact_Format == 0
                exe ttype_start_lnum + {fidx_ttype}_count
            else
                exe ttype_start_lnum + {fidx_ttype}_count + 1
            endif

            if g:Tlist_Compact_Format == 0
                " Separate the tag types by a empty line
                silent! put =''
            endif
        endif
        let i = i + 1
    endwhile

    if s:tlist_{fidx}_tag_count == 0
        if g:Tlist_Compact_Format == 0
            silent! put =''
        endif
    endif

    let s:tlist_{fidx}_end = line('.') - 1

    " Create a fold for the entire file
    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                \ s:tlist_{fidx}_end . 'foldopen!'

    " Goto the starting line for this file,
    exe s:tlist_{fidx}_start

    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " Update the start and end line numbers for all the files following this
    " file
    let start = s:tlist_{fidx}_start
    " include the empty line after the last line
    if g:Tlist_Compact_Format
        let end = s:tlist_{fidx}_end
    else
        let end = s:tlist_{fidx}_end + 1
    endif
    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)

    " Now that we have updated the taglist window, update the tags
    " menu (if present)
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Init_File
" Initialize the variables for a new file
function! s:Tlist_Init_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
    " Add new files at the end of the list
    let fidx = s:tlist_file_count
    let s:tlist_file_count = s:tlist_file_count + 1
    " Add the new file name to the taglist list of file names
    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"

    " Initialize the file variables
    let s:tlist_{fidx}_filename = a:filename
    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
    let s:tlist_{fidx}_filetype = a:ftype
    let s:tlist_{fidx}_mtime = -1
    let s:tlist_{fidx}_start = 0
    let s:tlist_{fidx}_end = 0
    let s:tlist_{fidx}_valid = 0
    let s:tlist_{fidx}_visible = 0
    let s:tlist_{fidx}_tag_count = 0
    let s:tlist_{fidx}_menu_cmd = ''

    " Initialize the tag type variables
    let i = 1
    while i <= s:tlist_{a:ftype}_count
        let ttype = s:tlist_{a:ftype}_{i}_name
        let s:tlist_{fidx}_{ttype} = ''
        let s:tlist_{fidx}_{ttype}_offset = 0
        let s:tlist_{fidx}_{ttype}_count = 0
        let i = i + 1
    endwhile

    return fidx
endfunction

" Tlist_Get_Tag_Type_By_Tag
" Return the tag type for the specified tag index
function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'

    " Already parsed and have the tag name
    if exists(ttype_var)
        return {ttype_var}
    endif

    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)

    return {ttype_var}
endfunction

" Tlist_Get_Tag_Prototype
function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'

    " Already parsed and have the tag prototype
    if exists(tproto_var)
        return {tproto_var}
    endif

    " Parse and extract the tag prototype
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let tag_proto = strpart(tag_line, start, end - start)
    let {tproto_var} = substitute(tag_proto, '\s*', '', '')

    return {tproto_var}
endfunction

" Tlist_Get_Tag_SearchPat
function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'

    " Already parsed and have the tag search pattern
    if exists(tpat_var)
        return {tpat_var}
    endif

    " Parse and extract the tag search pattern
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
                        \ (tag_line[end] == '$' ? '\$' : '')

    return {tpat_var}
endfunction

" Tlist_Get_Tag_Linenum
" Return the tag line number, given the tag index
function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'

    " Already parsed and have the tag line number
    if exists(tline_var)
        return {tline_var}
    endif

    " Parse and extract the tag line number
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = strridx(tag_line, 'line:') + 5
    let end = strridx(tag_line, "\t")
    if end < start
        let {tline_var} = strpart(tag_line, start) + 0
    else
        let {tline_var} = strpart(tag_line, start, end - start) + 0
    endif

    return {tline_var}
endfunction

" Tlist_Parse_Tagline
" Parse a tag line from the ctags output. Separate the tag output based on the
" tag type and store it in the tag type variable.
" The format of each line in the ctags output is:
"
"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
"
function! s:Tlist_Parse_Tagline(tag_line)
    if a:tag_line == ''
        " Skip empty lines
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)

    " Make sure the tag type is a valid and supported one
    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
        " Line is not in proper tags format or Tag type is not supported
        return
    endif

    " Update the total tag count
    let s:tidx = s:tidx + 1

    " The following variables are used to optimize this code.  Vim is slow in
    " using curly brace names. To reduce the amount of processing needed, the
    " curly brace variables are pre-processed here
    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype

    " Update the count of this tag type
    let ttype_idx = {fidx_ttype}_count + 1
    let {fidx_ttype}_count = ttype_idx

    " Store the ctags output for this tag
    let {fidx_tidx}_tag = a:tag_line

    " Store the tag index and the tag type index (back pointers)
    let {fidx_ttype}_{ttype_idx} = s:tidx
    let {fidx_tidx}_ttype_idx = ttype_idx

    " Extract the tag name
    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))

    " Extract the tag scope/prototype
    if g:Tlist_Display_Prototype
        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
    else
        let ttxt = '    ' . tag_name

        " Add the tag scope, if it is available and is configured. Tag
        " scope is the last field after the 'line:<num>\t' field
        if g:Tlist_Display_Tag_Scope
            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
            if tag_scope != ''
                let ttxt = ttxt . ' [' . tag_scope . ']'
            endif
        endif
    endif

    " Add this tag to the tag type variable
    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

    " Save the tag name
    let {fidx_tidx}_tag_name = tag_name
endfunction

" Tlist_Process_File
" Get the list of tags defined in the specified file and store them
" in Vim variables. Returns the file index where the tags are stored.
function! s:Tlist_Process_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
                \ a:ftype . ')')
    " Check whether this file is supported
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return -1
    endif

    " If the tag types for this filetype are not yet created, then create
    " them now
    let var = 's:tlist_' . a:ftype . '_count'
    if !exists(var)
        if s:Tlist_FileType_Init(a:ftype) == 0
            return -1
        endif
    endif

    " If this file is already processed, then use the cached values
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " First time, this file is loaded
        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
    else
        " File was previously processed. Discard the tag information
        call s:Tlist_Discard_TagInfo(fidx)
    endif

    let s:tlist_{fidx}_valid = 1

    " Exuberant ctags arguments to generate a tag list
    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '

    " Form the ctags argument depending on the sort type
    if s:tlist_{fidx}_sort_type == 'name'
        let ctags_args = ctags_args . '--sort=yes'
    else
        let ctags_args = ctags_args . '--sort=no'
    endif

    " Add the filetype specific arguments
    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args

    " Ctags command to produce output with regexp for locating the tags
    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'

    if &shellxquote == '"'
        " Double-quotes within double-quotes will not work in the
        " command-line.If the 'shellxquote' option is set to double-quotes,
        " then escape the double-quotes in the ctags command-line.
        let ctags_cmd = escape(ctags_cmd, '"')
    endif

    " In Windows 95, if not using cygwin, disable the 'shellslash'
    " option. Otherwise, this will cause problems when running the
    " ctags command.
    if has('win95') && !has('win32unix')
        let old_shellslash = &shellslash
        set noshellslash
    endif

    if has('win32') && !has('win32unix') && !has('win95')
                \ && (&shell =~ 'cmd.exe')
        " Windows does not correctly deal with commands that have more than 1
        " set of double quotes.  It will strip them all resulting in:
        " 'C:\Program' is not recognized as an internal or external command
        " operable program or batch file.  To work around this, place the
        " command inside a batch file and call the batch file.
        " Do this only on Win2K, WinXP and above.
        " Contributed by: David Fishburn.
        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
                    \ '\taglist.cmd'
        exe 'redir! > ' . s:taglist_tempfile
        silent echo ctags_cmd
        redir END

        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
        let ctags_cmd = '"' . s:taglist_tempfile . '"'
    endif

    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)

    " Run ctags and get the tag list
    let cmd_output = system(ctags_cmd)

    " Restore the value of the 'shellslash' option.
    if has('win95') && !has('win32unix')
        let &shellslash = old_shellslash
    endif

    if exists('s:taglist_tempfile')
        " Delete the temporary cmd file created on MS-Windows
        call delete(s:taglist_tempfile)
    endif

    " Handle errors
    if v:shell_error
        let msg = "Taglist: Failed to generate tags for " . a:filename
        call s:Tlist_Warning_Msg(msg)
        if cmd_output != ''
            call s:Tlist_Warning_Msg(cmd_output)
        endif
        return fidx
    endif

    " Store the modification time for the file
    let s:tlist_{fidx}_mtime = getftime(a:filename)

    " No tags for current file
    if cmd_output == ''
        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
        return fidx
    endif

    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)

    if v:version > 601
        " The following script local variables are used by the
        " Tlist_Parse_Tagline() function.
        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let s:fidx = fidx
        let s:tidx = 0

        " Process the ctags output one line at a time.  The substitute()
        " command is used to parse the tag lines instead of using the
        " matchstr()/stridx()/strpart() functions for performance reason
        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = s:tidx

        " The following script local variables are no longer needed
        unlet! s:ctags_flags
        unlet! s:tidx
        unlet! s:fidx
    else
        " Due to a bug in Vim earlier than version 6.1,
        " we cannot use substitute() to parse the ctags output.
        " Instead the slow str*() functions are used
        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let tidx = 0

        while cmd_output != ''
            " Extract one line at a time
            let idx = stridx(cmd_output, "\n")
            let one_line = strpart(cmd_output, 0, idx)
            " Remove the line from the tags output
            let cmd_output = strpart(cmd_output, idx + 1)

            if one_line == ''
                " Line is not in proper tags format
                continue
            endif

            " Extract the tag type
            let ttype = s:Tlist_Extract_Tagtype(one_line)

            " Make sure the tag type is a valid and supported one
            if ttype == '' || stridx(ctags_flags, ttype) == -1
                " Line is not in proper tags format or Tag type is not
                " supported
                continue
            endif

            " Update the total tag count
            let tidx = tidx + 1

            " The following variables are used to optimize this code.  Vim is
            " slow in using curly brace names. To reduce the amount of
            " processing needed, the curly brace variables are pre-processed
            " here
            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype

            " Update the count of this tag type
            let ttype_idx = {fidx_ttype}_count + 1
            let {fidx_ttype}_count = ttype_idx

            " Store the ctags output for this tag
            let {fidx_tidx}_tag = one_line

            " Store the tag index and the tag type index (back pointers)
            let {fidx_ttype}_{ttype_idx} = tidx
            let {fidx_tidx}_ttype_idx = ttype_idx

            " Extract the tag name
            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))

            " Extract the tag scope/prototype
            if g:Tlist_Display_Prototype
                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
            else
                let ttxt = '    ' . tag_name

                " Add the tag scope, if it is available and is configured. Tag
                " scope is the last field after the 'line:<num>\t' field
                if g:Tlist_Display_Tag_Scope
                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
                    if tag_scope != ''
                        let ttxt = ttxt . ' [' . tag_scope . ']'
                    endif
                endif
            endif

            " Add this tag to the tag type variable
            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

            " Save the tag name
            let {fidx_tidx}_tag_name = tag_name
        endwhile

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = tidx
    endif

    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
                \ ' tags in ' . a:filename)

    return fidx
endfunction

" Tlist_Update_File
" Update the tags for a file (if needed)
function! Tlist_Update_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return
    endif

    " Convert the file name to a full path
    let fname = fnamemodify(a:filename, ':p')

    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(fname)

    if fidx != -1 && s:tlist_{fidx}_valid
        " File exists and the tags are valid
        " Check whether the file was modified after the last tags update
        " If it is modified, then update the tags
        if s:tlist_{fidx}_mtime == getftime(fname)
            return
        endif
    else
        " If the tags were removed previously based on a user request,
        " as we are going to update the tags (based on the user request),
        " remove the filename from the deleted list
        call s:Tlist_Update_Remove_List(fname, 0)
    endif

    " If the taglist window is opened, update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        " Taglist window is not present. Just update the taglist
        " and return
        call s:Tlist_Process_File(fname, a:ftype)
    else
        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
            " If tags for only one file are displayed and we are not
            " updating the tags for that file, then no need to
            " refresh the taglist window. Otherwise, the taglist
            " window should be updated.
            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
                call s:Tlist_Process_File(fname, a:ftype)
                return
            endif
        endif

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Save the cursor position
        let save_line = line('.')
        let save_col = col('.')

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(fname, a:ftype)

        " Restore the cursor position
        if v:version >= 601
            call cursor(save_line, save_col)
        else
            exe save_line
            exe 'normal! ' . save_col . '|'
        endif

        if winnr() != save_winnr
            " Go back to the original window
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Window_Close
" Close the taglist window
function! s:Tlist_Window_Close()
    call s:Tlist_Log_Msg('Tlist_Window_Close()')
    " Make sure the taglist window exists
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    if winnr() == winnum
        " Already in the taglist window. Close it and return
        if winbufnr(2) != -1
            " If a window other than the taglist window is open,
            " then only close the taglist window.
            close
        endif
    else
        " Goto the taglist window, close it and then come back to the
        " original window
        let curbufnr = bufnr('%')
        exe winnum . 'wincmd w'
        close
        " Need to jump back to the original window only if we are not
        " already in that window
        let winnum = bufwinnr(curbufnr)
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
    endif
endfunction

" Tlist_Window_Mark_File_Window
" Mark the current window as the file window to use when jumping to a tag.
" Only if the current window is a non-plugin, non-preview and non-taglist
" window
function! s:Tlist_Window_Mark_File_Window()
    if getbufvar('%', '&buftype') == '' && !&previewwindow
        let w:tlist_file_window = "yes"
    endif
endfunction

" Tlist_Window_Open
" Open and refresh the taglist window
function! s:Tlist_Window_Open()
    call s:Tlist_Log_Msg('Tlist_Window_Open()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    if s:tlist_app_name == "winmanager"
        " Taglist plugin is no longer part of the winmanager app
        let s:tlist_app_name = "none"
    endif

    " Get the filename and filetype for the specified buffer
    let curbuf_name = fnamemodify(bufname('%'), ':p')
    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
    let cur_lnum = line('.')

    " Mark the current window as the desired window to open a file when a tag
    " is selected.
    call s:Tlist_Window_Mark_File_Window()

    " Open the taglist window
    call s:Tlist_Window_Create()

    call s:Tlist_Window_Refresh()

    if g:Tlist_Show_One_File
        " Add only the current buffer and file
        "
        " If the file doesn't support tag listing, skip it
        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
        endif
    endif

    if g:Tlist_File_Fold_Auto_Close
        " Open the fold for the current file, as all the folds in
        " the taglist window are closed
        let fidx = s:Tlist_Get_File_Index(curbuf_name)
        if fidx != -1
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen!"
        endif
    endif

    " Highlight the current tag
    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
endfunction

" Tlist_Window_Toggle()
" Open or close a taglist window
function! s:Tlist_Window_Toggle()
    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
    " If taglist window is open then close it.
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        call s:Tlist_Window_Close()
        return
    endif

    call s:Tlist_Window_Open()

    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
    " set
    if !g:Tlist_GainFocus_On_ToggleOpen
        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Process_Filelist
" Process multiple files. Each filename is separated by "\n"
" Returns the number of processed files
function! s:Tlist_Process_Filelist(file_names)
    let flist = a:file_names

    " Enable lazy screen updates
    let old_lazyredraw = &lazyredraw
    set lazyredraw

    " Keep track of the number of processed files
    let fcnt = 0

    " Process one file at a time
    while flist != ''
        let nl_idx = stridx(flist, "\n")
        let one_file = strpart(flist, 0, nl_idx)

        " Remove the filename from the list
        let flist = strpart(flist, nl_idx + 1)

        if one_file == ''
            continue
        endif

        " Skip directories
        if isdirectory(one_file)
            continue
        endif

        let ftype = s:Tlist_Detect_Filetype(one_file)

        echon "\r                                                              "
        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')

        let fcnt = fcnt + 1

        call Tlist_Update_File(one_file, ftype)
    endwhile

    " Clear the displayed informational messages
    echon "\r                                                            "

    " Restore the previous state
    let &lazyredraw = old_lazyredraw

    return fcnt
endfunction

" Tlist_Process_Dir
" Process the files in a directory matching the specified pattern
function! s:Tlist_Process_Dir(dir_name, pat)
    let flist = glob(a:dir_name . '/' . a:pat) . "\n"

    let fcnt = s:Tlist_Process_Filelist(flist)

    let len = strlen(a:dir_name)
    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
        let glob_expr = a:dir_name . '*'
    else
        let glob_expr = a:dir_name . '/*'
    endif
    let all_files = glob(glob_expr) . "\n"

    while all_files != ''
        let nl_idx = stridx(all_files, "\n")
        let one_file = strpart(all_files, 0, nl_idx)

        let all_files = strpart(all_files, nl_idx + 1)
        if one_file == ''
            continue
        endif

        " Skip non-directory names
        if !isdirectory(one_file)
            continue
        endif

        echon "\r                                                              "
        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
    endwhile

    return fcnt
endfunction

" Tlist_Add_Files_Recursive
" Add files recursively from a directory
function! s:Tlist_Add_Files_Recursive(dir, ...)
    let dir_name = fnamemodify(a:dir, ':p')
    if !isdirectory(dir_name)
        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
        return
    endif

    if a:0 == 1
        " User specified file pattern
        let pat = a:1
    else
        " Default file pattern
        let pat = '*'
    endif

    echon "\r                                                              "
    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
    let fcnt = s:Tlist_Process_Dir(dir_name, pat)

    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Add_Files
" Add the specified list of files to the taglist
function! s:Tlist_Add_Files(...)
    let flist = ''
    let i = 1

    " Get all the files matching the file patterns supplied as argument
    while i <= a:0
        let flist = flist . glob(a:{i}) . "\n"
        let i = i + 1
    endwhile

    if flist == ''
        call s:Tlist_Warning_Msg('Error: No matching files are found')
        return
    endif

    let fcnt = s:Tlist_Process_Filelist(flist)
    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Extract_Tagtype
" Extract the tag type from the tag text
function! s:Tlist_Extract_Tagtype(tag_line)
    " The tag type is after the tag prototype field. The prototype field
    " ends with the /;"\t string. We add 4 at the end to skip the characters
    " in this special string..
    let start = strridx(a:tag_line, '/;"' . "\t") + 4
    let end = strridx(a:tag_line, 'line:') - 1
    let ttype = strpart(a:tag_line, start, end - start)

    return ttype
endfunction

" Tlist_Extract_Tag_Scope
" Extract the tag scope from the tag text
function! s:Tlist_Extract_Tag_Scope(tag_line)
    let start = strridx(a:tag_line, 'line:')
    let end = strridx(a:tag_line, "\t")
    if end <= start
        return ''
    endif

    let tag_scope = strpart(a:tag_line, end + 1)
    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)

    return tag_scope
endfunction

" Tlist_Refresh()
" Refresh the taglist
function! s:Tlist_Refresh()
    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
    " If we are entering the buffer from one of the taglist functions, then
    " no need to refresh the taglist window again.
    if s:Tlist_Skip_Refresh
        " We still need to update the taglist menu
        if g:Tlist_Show_Menu
            call s:Tlist_Menu_Update_File(0)
        endif
        return
    endif

    " If part of the winmanager plugin and not configured to process
    " tags always and not configured to display the tags menu, then return
    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
                \ && !g:Tlist_Show_Menu
        return
    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let tlist_win = bufwinnr(g:TagList_title)

    " If the taglist window is not opened and not configured to process
    " tags always and not displaying the tags menu, then return
    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " If the taglist should not be auto updated, then return
        if !g:Tlist_Auto_Update
            return
        endif
    endif

    let cur_lnum = line('.')

    if fidx == -1
        " Update the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
    else
        let mtime = getftime(filename)
        if s:tlist_{fidx}_mtime != mtime
            " Invalidate the tags listed for this file
            let s:tlist_{fidx}_valid = 0

            " Update the taglist and the window
            call Tlist_Update_File(filename, ftype)

            " Store the new file modification time
            let s:tlist_{fidx}_mtime = mtime
        endif
    endif

    " Update the taglist window
    if tlist_win != -1
        " Disable screen updates
        let old_lazyredraw = &lazyredraw
        set nolazyredraw

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
            " Save the cursor position
            let save_line = line('.')
            let save_col = col('.')
        endif

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(filename, ftype)

        " Open the fold for the file
        exe "silent! " . s:tlist_{fidx}_start . "," .
                    \ s:tlist_{fidx}_end . "foldopen!"

        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
                " If displaying tags for only one file in the taglist
                " window and about to display the tags for a new file,
                " then center the current tag line for the new file
                let center_tag_line = 1
            else
                let center_tag_line = 0
            endif

            " Highlight the current tag
            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
        else
            " Restore the cursor position
            if v:version >= 601
                call cursor(save_line, save_col)
            else
                exe save_line
                exe 'normal! ' . save_col . '|'
            endif
        endif

        " Jump back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif

        " Restore screen updates
        let &lazyredraw = old_lazyredraw
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Change_Sort()
" Change the sort order of the tag listing
" caller == 'cmd', command used in the taglist window
" caller == 'menu', taglist menu
" action == 'toggle', toggle sort from name to order and vice versa
" action == 'set', set the sort order to sort_type
function! s:Tlist_Change_Sort(caller, action, sort_type)
    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
    if a:caller == 'cmd'
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif

        " Remove the previous highlighting
        match none
    elseif a:caller == 'menu'
        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
        if fidx == -1
            return
        endif
    endif

    if a:action == 'toggle'
        let sort_type = s:tlist_{fidx}_sort_type

        " Toggle the sort order from 'name' to 'order' and vice versa
        if sort_type == 'name'
            let s:tlist_{fidx}_sort_type = 'order'
        else
            let s:tlist_{fidx}_sort_type = 'name'
        endif
    else
        let s:tlist_{fidx}_sort_type = a:sort_type
    endif

    " Invalidate the tags listed for this file
    let s:tlist_{fidx}_valid = 0

    if a:caller  == 'cmd'
        " Save the current line for later restoration
        let curline = '\V\^' . getline('.') . '\$'

        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                    \   s:tlist_{fidx}_filetype)

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

        " Go back to the cursor line before the tag list is sorted
        call search(curline, 'w')

        call s:Tlist_Menu_Update_File(1)
    else
        call s:Tlist_Menu_Remove_File()

        call s:Tlist_Refresh()
    endif
endfunction

" Tlist_Update_Current_File()
" Update taglist for the current buffer by regenerating the tag list
" Contributed by WEN Guopeng.
function! s:Tlist_Update_Current_File()
    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
    if winnr() == bufwinnr(g:TagList_title)
        " In the taglist window. Update the current file
        call s:Tlist_Window_Update_File()
    else
        " Not in the taglist window. Update the current buffer
        let filename = fnamemodify(bufname('%'), ':p')
        let fidx = s:Tlist_Get_File_Index(filename)
        if fidx != -1
            let s:tlist_{fidx}_valid = 0
        endif
        let ft = s:Tlist_Get_Buffer_Filetype('%')
        call Tlist_Update_File(filename, ft)
    endif
endfunction

" Tlist_Window_Update_File()
" Update the tags displayed in the taglist window
function! s:Tlist_Window_Update_File()
    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    " Remove the previous highlighting
    match none

    " Save the current line for later restoration
    let curline = '\V\^' . getline('.') . '\$'

    let s:tlist_{fidx}_valid = 0

    " Update the taglist window
    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                \ s:tlist_{fidx}_filetype)

    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

    " Go back to the tag line before the list is updated
    call search(curline, 'w')
endfunction

" Tlist_Window_Get_Tag_Type_By_Linenum()
" Return the tag type index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
    let ftype = s:tlist_{a:fidx}_filetype

    " Determine to which tag type the current line number belongs to using the
    " tag type start line number and the number of tags in a tag type
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        let start_lnum =
                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
        if a:lnum >= start_lnum && a:lnum <= end
            break
        endif
        let i = i + 1
    endwhile

    " Current line doesn't belong to any of the displayed tag types
    if i > s:tlist_{ftype}_count
        return ''
    endif

    return ttype
endfunction

" Tlist_Window_Get_Tag_Index()
" Return the tag index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)

    " Current line doesn't belong to any of the displayed tag types
    if ttype == ''
        return 0
    endif

    " Compute the index into the displayed tags for the tag type
    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
    let tidx = a:lnum - ttype_lnum
    if tidx == 0
        return 0
    endif

    " Get the corresponding tag line and return it
    return s:tlist_{a:fidx}_{ttype}_{tidx}
endfunction

" Tlist_Window_Highlight_Line
" Highlight the current line
function! s:Tlist_Window_Highlight_Line()
    " Clear previously selected name
    match none

    " Highlight the current line
    if g:Tlist_Display_Prototype == 0
        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
    else
        let pat = '/\%' . line('.') . 'l.*/'
    endif

    exe 'match TagListTagName ' . pat
endfunction

" Tlist_Window_Open_File
" Open the specified file in either a new window or an existing window
" and place the cursor at the specified tag pattern
function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
                \ a:win_ctrl . ')')
    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
    let s:Tlist_Skip_Refresh = 1

    if s:tlist_app_name == "winmanager"
        " Let the winmanager edit the file
        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
    else

    if a:win_ctrl == 'newtab'
        " Create a new tab
        exe 'tabnew ' . escape(a:filename, ' ')
        " Open the taglist window in the new tab
        call s:Tlist_Window_Open()
    endif

    if a:win_ctrl == 'checktab'
        " Check whether the file is present in any of the tabs.
        " If the file is present in the current tab, then use the
        " current tab.
        if bufwinnr(a:filename) != -1
            let file_present_in_tab = 1
            let i = tabpagenr()
        else
            let i = 1
            let bnum = bufnr(a:filename)
            let file_present_in_tab = 0
            while i <= tabpagenr('$')
                if index(tabpagebuflist(i), bnum) != -1
                    let file_present_in_tab = 1
                    break
                endif
                let i += 1
            endwhile
        endif

        if file_present_in_tab
            " Goto the tab containing the file
            exe 'tabnext ' . i
        else
            " Open a new tab
            exe 'tabnew ' . escape(a:filename, ' ')

            " Open the taglist window
            call s:Tlist_Window_Open()
        endif
    endif

    let winnum = -1
    if a:win_ctrl == 'prevwin'
        " Open the file in the previous window, if it is usable
        let cur_win = winnr()
        wincmd p
        if &buftype == '' && !&previewwindow
            exe "edit " . escape(a:filename, ' ')
            let winnum = winnr()
        else
            " Previous window is not usable
            exe cur_win . 'wincmd w'
        endif
    endif

    " Goto the window containing the file.  If the window is not there, open a
    " new window
    if winnum == -1
        let winnum = bufwinnr(a:filename)
    endif

    if winnum == -1
        " Locate the previously used window for opening a file
        let fwin_num = 0
        let first_usable_win = 0

        let i = 1
        let bnum = winbufnr(i)
        while bnum != -1
            if getwinvar(i, 'tlist_file_window') == 'yes'
                let fwin_num = i
                break
            endif
            if first_usable_win == 0 &&
                        \ getbufvar(bnum, '&buftype') == '' &&
                        \ !getwinvar(i, '&previewwindow')
                " First non-taglist, non-plugin and non-preview window
                let first_usable_win = i
            endif
            let i = i + 1
            let bnum = winbufnr(i)
        endwhile

        " If a previously used window is not found, then use the first
        " non-taglist window
        if fwin_num == 0
            let fwin_num = first_usable_win
        endif

        if fwin_num != 0
            " Jump to the file window
            exe fwin_num . "wincmd w"

            " If the user asked to jump to the tag in a new window, then split
            " the existing window into two.
            if a:win_ctrl == 'newwin'
                split
            endif
            exe "edit " . escape(a:filename, ' ')
        else
            " Open a new window
            if g:Tlist_Use_Horiz_Window
                exe 'leftabove split ' . escape(a:filename, ' ')
            else
                if winbufnr(2) == -1
                    " Only the taglist window is present
                    if g:Tlist_Use_Right_Window
                        exe 'leftabove vertical split ' .
                                    \ escape(a:filename, ' ')
                    else
                        exe 'rightbelow vertical split ' .
                                    \ escape(a:filename, ' ')
                    endif

                    " Go to the taglist window to change the window size to
                    " the user configured value
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                    if g:Tlist_Use_Horiz_Window
                        exe 'resize ' . g:Tlist_WinHeight
                    else
                        exe 'vertical resize ' . g:Tlist_WinWidth
                    endif
                    " Go back to the file window
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                else
                    " A plugin or help window is also present
                    wincmd w
                    exe 'leftabove split ' . escape(a:filename, ' ')
                endif
            endif
        endif
        " Mark the window, so that it can be reused.
        call s:Tlist_Window_Mark_File_Window()
    else
        if v:version >= 700
            " If the file is opened in more than one window, then check
            " whether the last accessed window has the selected file.
            " If it does, then use that window.
            let lastwin_bufnum = winbufnr(winnr('#'))
            if bufnr(a:filename) == lastwin_bufnum
                let winnum = winnr('#')
            endif
        endif
        exe winnum . 'wincmd w'

        " If the user asked to jump to the tag in a new window, then split the
        " existing window into two.
        if a:win_ctrl == 'newwin'
            split
        endif
    endif
    endif

    " Jump to the tag
    if a:tagpat != ''
        " Add the current cursor position to the jump list, so that user can
        " jump back using the ' and ` marks.
        mark '
        silent call search(a:tagpat, 'w')

        " Bring the line to the middle of the window
        normal! z.

        " If the line is inside a fold, open the fold
        if foldclosed('.') != -1
            .foldopen
        endif
    endif

    " If the user selects to preview the tag then jump back to the
    " taglist window
    if a:win_ctrl == 'preview'
        " Go back to the taglist window
        let winnum = bufwinnr(g:TagList_title)
        exe winnum . 'wincmd w'
    else
        " If the user has selected to close the taglist window, when a
        " tag is selected, close the taglist  window
        if g:Tlist_Close_On_Select
            call s:Tlist_Window_Goto_Window()
            close

            " Go back to the window displaying the selected file
            let wnum = bufwinnr(a:filename)
            if wnum != -1 && wnum != winnr()
                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
            endif
        endif
    endif

    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
endfunction

" Tlist_Window_Jump_To_Tag()
" Jump to the location of the current tag
" win_ctrl == useopen - Reuse the existing file window
" win_ctrl == newwin - Open a new window
" win_ctrl == preview - Preview the tag
" win_ctrl == prevwin - Open in previous window
" win_ctrl == newtab - Open in new tab
function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a closed fold, then use the first line of the fold
    " and jump to the file.
    let lnum = foldclosed('.')
    if lnum == -1
        " Jump to the selected tag or file
        let lnum = line('.')
    else
        " Open the closed fold
        .foldopen!
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    " Get the tag output for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx != 0
        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)

        " Highlight the tagline
        call s:Tlist_Window_Highlight_Line()
    else
        " Selected a line which is not a tag name. Just edit the file
        let tagpat = ''
    endif

    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
endfunction

" Tlist_Window_Show_Info()
" Display information about the entry under the cursor
function! s:Tlist_Window_Show_Info()
    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')

    " Clear the previously displayed line
    echo

    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a fold, then don't display the prototype
    if foldclosed('.') != -1
        return
    endif

    let lnum = line('.')

    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    if lnum == s:tlist_{fidx}_start
        " Cursor is on a file name
        let fname = s:tlist_{fidx}_filename
        if strlen(fname) > 50
            let fname = fnamemodify(fname, ':t')
        endif
        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
        return
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx == 0
        " Cursor is on a tag type
        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
        if ttype == ''
            return
        endif

        let ttype_name = ''

        let ftype = s:tlist_{fidx}_filetype
        let i = 1
        while i <= s:tlist_{ftype}_count
            if ttype == s:tlist_{ftype}_{i}_name
                let ttype_name = s:tlist_{ftype}_{i}_fullname
                break
            endif
            let i = i + 1
        endwhile

        echo 'Tag type=' . ttype_name .
                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
        return
    endif

    " Get the tag search pattern and display it
    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Find_Nearest_Tag_Idx
" Find the tag idx nearest to the supplied line number
" Returns -1, if a tag couldn't be found for the specified line number
function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
    let sort_type = s:tlist_{a:fidx}_sort_type

    let left = 1
    let right = s:tlist_{a:fidx}_tag_count

    if sort_type == 'order'
        " Tags sorted by order, use a binary search.
        " The idea behind this function is taken from the ctags.vim script (by
        " Alexey Marinichev) available at the Vim online website.

        " If the current line is the less than the first tag, then no need to
        " search
        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)

        if a:linenum < first_lnum
            return -1
        endif

        while left < right
            let middle = (right + left + 1) / 2
            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)

            if middle_lnum == a:linenum
                let left = middle
                break
            endif

            if middle_lnum > a:linenum
                let right = middle - 1
            else
                let left = middle
            endif
        endwhile
    else
        " Tags sorted by name, use a linear search. (contributed by Dave
        " Eggum).
        " Look for a tag with a line number less than or equal to the supplied
        " line number. If multiple tags are found, then use the tag with the
        " line number closest to the supplied line number. IOW, use the tag
        " with the highest line number.
        let closest_lnum = 0
        let final_left = 0
        while left <= right
            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)

            if lnum < a:linenum && lnum > closest_lnum
                let closest_lnum = lnum
                let final_left = left
            elseif lnum == a:linenum
                let closest_lnum = lnum
                let final_left = left
                break
            else
                let left = left + 1
            endif
        endwhile
        if closest_lnum == 0
            return -1
        endif
        if left >= right
            let left = final_left
        endif
    endif

    return left
endfunction

" Tlist_Window_Highlight_Tag()
" Highlight the current tag
" cntx == 1, Called by the taglist plugin itself
" cntx == 2, Forced by the user through the TlistHighlightTag command
" center = 1, move the tag line to the center of the taglist window
function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
    " Highlight the current tag only if the user configured the
    " taglist plugin to do so or if the user explictly invoked the
    " command to highlight the current tag.
    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
        return
    endif

    if a:filename == ''
        return
    endif

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        return
    endif

    " If the file is currently not displayed in the taglist window, then retrn
    if !s:tlist_{fidx}_visible
        return
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return
    endif

    " Ignore all autocommands
    let old_ei = &eventignore
    set eventignore=all

    " Save the original window number
    let org_winnr = winnr()

    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    " Go to the taglist window
    if !in_taglist_window
        exe winnum . 'wincmd w'
    endif

    " Clear previously selected name
    match none

    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
    if tidx == -1
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        let lnum = line('.')

        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
            " Move the cursor to the beginning of the file
            exe s:tlist_{fidx}_start
        endif

        if foldclosed('.') != -1
            .foldopen
        endif

        call winline()

        if !in_taglist_window
            exe org_winnr . 'wincmd w'
        endif

        " Restore the autocommands
        let &eventignore = old_ei
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)

    " Compute the line number
    " Start of file + Start of tag type + offset
    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
                \ s:tlist_{fidx}_{tidx}_ttype_idx

    " Goto the line containing the tag
    exe lnum

    " Open the fold
    if foldclosed('.') != -1
        .foldopen
    endif

    if a:center
        " Move the tag line to the center of the taglist window
        normal! z.
    else
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        call winline()
    endif

    " Highlight the tag name
    call s:Tlist_Window_Highlight_Line()

    " Go back to the original window
    if !in_taglist_window
        exe org_winnr . 'wincmd w'
    endif

    " Restore the autocommands
    let &eventignore = old_ei
    return
endfunction

" Tlist_Get_Tag_Prototype_By_Line
" Get the prototype for the tag on or before the specified line number in the
" current buffer
function! Tlist_Get_Tag_Prototype_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
                                \ '<line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Expand the file to a fully qualified name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag text using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Get_Tagname_By_Line
" Get the tag name on or before the specified line number in the
" current buffer
function! Tlist_Get_Tagname_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Make sure the current file has a name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag name using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:tlist_{fidx}_{tidx}_tag_name
endfunction

" Tlist_Window_Move_To_File
" Move the cursor to the beginning of the current file or the next file
" or the previous file in the taglist window
" dir == -1, move to start of current or previous function
" dir == 1, move to start of next function
function! s:Tlist_Window_Move_To_File(dir)
    if foldlevel('.') == 0
        " Cursor is on a non-folded line (it is not in any of the files)
        " Move it to a folded line
        if a:dir == -1
            normal! zk
        else
            " While moving down to the start of the next fold,
            " no need to do go to the start of the next file.
            normal! zj
            return
        endif
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    let cur_lnum = line('.')

    if a:dir == -1
        if cur_lnum > s:tlist_{fidx}_start
            " Move to the beginning of the current file
            exe s:tlist_{fidx}_start
            return
        endif

        if fidx != 0
            " Move to the beginning of the previous file
            let fidx = fidx - 1
        else
            " Cursor is at the first file, wrap around to the last file
            let fidx = s:tlist_file_count - 1
        endif

        exe s:tlist_{fidx}_start
        return
    else
        " Move to the beginning of the next file
        let fidx = fidx + 1

        if fidx >= s:tlist_file_count
            " Cursor is at the last file, wrap around to the first file
            let fidx = 0
        endif

        if s:tlist_{fidx}_start != 0
            exe s:tlist_{fidx}_start
        endif
        return
    endif
endfunction

" Tlist_Session_Load
" Load a taglist session (information about all the displayed files
" and the tags) from the specified file
function! s:Tlist_Session_Load(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
        return
    endif

    let sessionfile = a:1

    if !filereadable(sessionfile)
        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
        call s:Tlist_Warning_Msg(msg)
        return
    endif

    " Mark the current window as the file window
    call s:Tlist_Window_Mark_File_Window()

    " Source the session file
    exe 'source ' . sessionfile

    let new_file_count = g:tlist_file_count
    unlet! g:tlist_file_count

    let i = 0
    while i < new_file_count
        let ftype = g:tlist_{i}_filetype
        unlet! g:tlist_{i}_filetype

        if !exists('s:tlist_' . ftype . '_count')
            if s:Tlist_FileType_Init(ftype) == 0
                let i = i + 1
                continue
            endif
        endif

        let fname = g:tlist_{i}_filename
        unlet! g:tlist_{i}_filename

        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            let s:tlist_{fidx}_visible = 0
            let i = i + 1
            continue
        else
            " As we are loading the tags from the session file, if this
            " file was previously deleted by the user, now we need to
            " add it back. So remove the file from the deleted list.
            call s:Tlist_Update_Remove_List(fname, 0)
        endif

        let fidx = s:Tlist_Init_File(fname, ftype)

        let s:tlist_{fidx}_filename = fname

        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
        unlet! g:tlist_{i}_sort_type

        let s:tlist_{fidx}_filetype = ftype
        let s:tlist_{fidx}_mtime = getftime(fname)

        let s:tlist_{fidx}_start = 0
        let s:tlist_{fidx}_end = 0

        let s:tlist_{fidx}_valid = 1

        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
        unlet! g:tlist_{i}_tag_count

        let j = 1
        while j <= s:tlist_{fidx}_tag_count
            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
            unlet! g:tlist_{i}_{j}_tag
            unlet! g:tlist_{i}_{j}_tag_name
            unlet! g:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name

            if exists('g:tlist_' . i . '_' . ttype)
                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
                unlet! g:tlist_{i}_{ttype}
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
                unlet! g:tlist_{i}_{ttype}_count

                let k = 1
                while k <= s:tlist_{fidx}_{ttype}_count
                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
                    unlet! g:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            else
                let s:tlist_{fidx}_{ttype} = ''
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = 0
            endif

            let j = j + 1
        endwhile

        let i = i + 1
    endwhile

    " If the taglist window is open, then update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Refresh the taglist window
        call s:Tlist_Window_Refresh()

        " Go back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Session_Save
" Save a taglist session (information about all the displayed files
" and the tags) into the specified file
function! s:Tlist_Session_Save(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
        return
    endif

    let sessionfile = a:1

    if s:tlist_file_count == 0
        " There is nothing to save
        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
        return
    endif

    if filereadable(sessionfile)
        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
        if ans !=? 'y'
            return
        endif

        echo "\n"
    endif

    let old_verbose = &verbose
    set verbose&vim

    exe 'redir! > ' . sessionfile

    silent! echo '" Taglist session file. This file is auto-generated.'
    silent! echo '" File information'
    silent! echo 'let tlist_file_count = ' . s:tlist_file_count

    let i = 0

    while i < s:tlist_file_count
        " Store information about the file
        silent! echo 'let tlist_' . i . "_filename = '" .
                                            \ s:tlist_{i}_filename . "'"
        silent! echo 'let tlist_' . i . '_sort_type = "' .
                                                \ s:tlist_{i}_sort_type . '"'
        silent! echo 'let tlist_' . i . '_filetype = "' .
                                            \ s:tlist_{i}_filetype . '"'
        silent! echo 'let tlist_' . i . '_tag_count = ' .
                                                        \ s:tlist_{i}_tag_count
        " Store information about all the tags
        let j = 1
        while j <= s:tlist_{i}_tag_count
            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
                        \ s:tlist_{i}_{j}_tag_name . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
                        \ s:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        " Store information about all the tags grouped by their type
        let ftype = s:tlist_{i}_filetype
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{i}_{ttype}_count != 0
                let txt = escape(s:tlist_{i}_{ttype}, '"\')
                let txt = substitute(txt, "\n", "\\\\n", 'g')
                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
                                                \ txt . '"'
                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
                                                     \ s:tlist_{i}_{ttype}_count
                let k = 1
                while k <= s:tlist_{i}_{ttype}_count
                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            endif
            let j = j + 1
        endwhile

        silent! echo

        let i = i + 1
    endwhile

    redir END

    let &verbose = old_verbose
endfunction

" Tlist_Buffer_Removed
" A buffer is removed from the Vim buffer list. Remove the tags defined
" for that file
function! s:Tlist_Buffer_Removed(filename)
    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')

    " Make sure a valid filename is supplied
    if a:filename == ''
        return
    endif

    " Get tag list index of the specified file
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " File not present in the taglist
        return
    endif

    " Remove the file from the list
    call s:Tlist_Remove_File(fidx, 0)
endfunction

" When a buffer is deleted, remove the file from the taglist
autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))

" Tlist_Window_Open_File_Fold
" Open the fold for the specified file and close the fold for all the
" other files
function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
        return
    endif

    " Save the original window number
    let org_winnr = winnr()
    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    if in_taglist_window
        " When entering the taglist window, no need to update the folds
        return
    endif

    " Go to the taglist window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
    endif

    " Close all the folds
    silent! %foldclose

    " Get tag list index of the specified file
    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    if filereadable(fname)
        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            " Open the fold for the file
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen"
        endif
    endif

    " Go back to the original window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
    endif
endfunction

" Tlist_Window_Check_Auto_Open
" Open the taglist window automatically on Vim startup.
" Open the window only when files present in any of the Vim windows support
" tags.
function! s:Tlist_Window_Check_Auto_Open()
    let open_window = 0

    let i = 1
    let buf_num = winbufnr(i)
    while buf_num != -1
        let filename = fnamemodify(bufname(buf_num), ':p')
        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
        if !s:Tlist_Skip_File(filename, ft)
            let open_window = 1
            break
        endif
        let i = i + 1
        let buf_num = winbufnr(i)
    endwhile

    if open_window
        call s:Tlist_Window_Toggle()
    endif
endfunction

" Tlist_Refresh_Folds
" Remove and create the folds for all the files displayed in the taglist
" window. Used after entering a tab. If this is not done, then the folds
" are not properly created for taglist windows displayed in multiple tabs.
function! s:Tlist_Refresh_Folds()
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        return
    endif

    let save_wnum = winnr()
    exe winnum . 'wincmd w'

    " First remove all the existing folds
    normal! zE

    " Create the folds for each in the tag list
    let fidx = 0
    while fidx < s:tlist_file_count
        let ftype = s:tlist_{fidx}_filetype

        " Create the folds for each tag type in a file
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{fidx}_{ttype}_count
                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
                let e = s + s:tlist_{fidx}_{ttype}_count
                exe s . ',' . e . 'fold'
            endif
            let j = j + 1
        endwhile

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                    \ s:tlist_{fidx}_end . 'foldopen!'
        let fidx = fidx + 1
    endwhile

    exe save_wnum . 'wincmd w'
endfunction

function! s:Tlist_Menu_Add_Base_Menu()
    call s:Tlist_Log_Msg('Adding the base menu')

    " Add the menu
    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Name
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Order
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
    anoremenu T&ags.-SEP1-           :

    if &mousemodel =~ 'popup'
        anoremenu <silent> PopUp.T&ags.Refresh\ menu
                    \ :call <SID>Tlist_Menu_Refresh()<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
        anoremenu PopUp.T&ags.-SEP1-           :
    endif
endfunction

let s:menu_char_prefix =
            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

" Tlist_Menu_Get_Tag_Type_Cmd
" Get the menu command for the specified tag type
" fidx - File type index
" ftype - File Type
" add_ttype_name - To add or not to add the tag type name to the menu entries
" ttype_idx - Tag type index
function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
    " Curly brace variable name optimization
    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx

    let ttype = s:tlist_{ftype_ttype_idx}_name
    if a:add_ttype_name
        " If the tag type name contains space characters, escape it. This
        " will be used to create the menu entries.
        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
    endif

    " Curly brace variable name optimization
    let fidx_ttype = a:fidx . '_' . ttype

    " Number of tag entries for this tag type
    let tcnt = s:tlist_{fidx_ttype}_count
    if tcnt == 0 " No entries for this tag type
        return ''
    endif

    let mcmd = ''

    " Create the menu items for the tags.
    " Depending on the number of tags of this type, split the menu into
    " multiple sub-menus, if needed.
    if tcnt > g:Tlist_Max_Submenu_Items
        let j = 1
        while j <= tcnt
            let final_index = j + g:Tlist_Max_Submenu_Items - 1
            if final_index > tcnt
                let final_index = tcnt
            endif

            " Extract the first and last tag name and form the
            " sub-menu name
            let tidx = s:tlist_{fidx_ttype}_{j}
            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            let tidx = s:tlist_{fidx_ttype}_{final_index}
            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            " Truncate the names, if they are greater than the
            " max length
            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)

            " Form the menu command prefix
            let m_prefix = 'anoremenu <silent> T\&ags.'
            if a:add_ttype_name
                let m_prefix = m_prefix . ttype_fullname . '.'
            endif
            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'

            " Character prefix used to number the menu items (hotkey)
            let m_prefix_idx = 0

            while j <= final_index
                let tidx = s:tlist_{fidx_ttype}_{j}

                let tname = s:tlist_{a:fidx}_{tidx}_tag_name

                let mcmd = mcmd . m_prefix . '\&' .
                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
                            \ tidx . ')<CR>|'

                let m_prefix_idx = m_prefix_idx + 1
                let j = j + 1
            endwhile
        endwhile
    else
        " Character prefix used to number the menu items (hotkey)
        let m_prefix_idx = 0

        let m_prefix = 'anoremenu <silent> T\&ags.'
        if a:add_ttype_name
            let m_prefix = m_prefix . ttype_fullname . '.'
        endif
        let j = 1
        while j <= tcnt
            let tidx = s:tlist_{fidx_ttype}_{j}

            let tname = s:tlist_{a:fidx}_{tidx}_tag_name

            let mcmd = mcmd . m_prefix . '\&' .
                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
                        \ . ')<CR>|'

            let m_prefix_idx = m_prefix_idx + 1
            let j = j + 1
        endwhile
    endif

    return mcmd
endfunction

" Update the taglist menu with the tags for the specified file
function! s:Tlist_Menu_File_Refresh(fidx)
    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
    " The 'B' flag is needed in the 'cpoptions' option
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    exe s:tlist_{a:fidx}_menu_cmd

    " Update the popup menu (if enabled)
    if &mousemodel =~ 'popup'
        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
                                        \ ' PopUp.T\\\&ags.', "g")
        exe cmd
    endif

    " The taglist menu is not empty now
    let s:tlist_menu_empty = 0

    " Restore the 'cpoptions' settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Menu_Update_File
" Add the taglist menu
function! s:Tlist_Menu_Update_File(clear_menu)
    if !has('gui_running')
        " Not running in GUI mode
        return
    endif

    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)

    " Remove the tags menu
    if a:clear_menu
        call s:Tlist_Menu_Remove_File()

    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1 || !s:tlist_{fidx}_valid
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " Process the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
        if fidx == -1
            return
        endif
    endif

    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
    if fname != ''
        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
        anoremenu T&ags.-SEP2-           :
    endif

    if !s:tlist_{fidx}_tag_count
        return
    endif

    if s:tlist_{fidx}_menu_cmd != ''
        " Update the menu with the cached command
        call s:Tlist_Menu_File_Refresh(fidx)

        return
    endif

    " We are going to add entries to the tags menu, so the menu won't be
    " empty
    let s:tlist_menu_empty = 0

    let cmd = ''

    " Determine whether the tag type name needs to be added to the menu
    " If more than one tag type is present in the taglisting for a file,
    " then the tag type name needs to be present
    let add_ttype_name = -1
    let i = 1
    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{fidx}_{ttype}_count
            let add_ttype_name = add_ttype_name + 1
        endif
        let i = i + 1
    endwhile

    " Process the tags by the tag type and get the menu command
    let i = 1
    while i <= s:tlist_{ftype}_count
        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
        if mcmd != ''
            let cmd = cmd . mcmd
        endif

        let i = i + 1
    endwhile

    " Cache the menu command for reuse
    let s:tlist_{fidx}_menu_cmd = cmd

    " Update the menu
    call s:Tlist_Menu_File_Refresh(fidx)
endfunction

" Tlist_Menu_Remove_File
" Remove the tags displayed in the tags menu
function! s:Tlist_Menu_Remove_File()
    if !has('gui_running') || s:tlist_menu_empty
        return
    endif

    call s:Tlist_Log_Msg('Removing the tags menu for a file')

    " Cleanup the Tags menu
    silent! unmenu T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu PopUp.T&ags
    endif

    " Add a dummy menu item to retain teared off menu
    noremenu T&ags.Dummy l

    silent! unmenu! T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu! PopUp.T&ags
    endif

    call s:Tlist_Menu_Add_Base_Menu()

    " Remove the dummy menu item
    unmenu T&ags.Dummy

    let s:tlist_menu_empty = 1
endfunction

" Tlist_Menu_Refresh
" Refresh the taglist menu
function! s:Tlist_Menu_Refresh()
    call s:Tlist_Log_Msg('Refreshing the tags menu')
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx != -1
        " Invalidate the cached menu command
        let s:tlist_{fidx}_menu_cmd = ''
    endif

    " Update the taglist, menu and window
    call s:Tlist_Update_Current_File()
endfunction

" Tlist_Menu_Jump_To_Tag
" Jump to the selected tag
function! s:Tlist_Menu_Jump_To_Tag(tidx)
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx == -1
        return
    endif

    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
    if tagpat == ''
        return
    endif

    " Add the current cursor position to the jump list, so that user can
    " jump back using the ' and ` marks.
    mark '

    silent call search(tagpat, 'w')

    " Bring the line to the middle of the window
    normal! z.

    " If the line is inside a fold, open the fold
    if foldclosed('.') != -1
        .foldopen
    endif
endfunction

" Tlist_Menu_Init
" Initialize the taglist menu
function! s:Tlist_Menu_Init()
    call s:Tlist_Menu_Add_Base_Menu()

    " Automatically add the tags defined in the current file to the menu
    augroup TagListMenuCmds
        autocmd!

        if !g:Tlist_Process_File_Always
            autocmd BufEnter * call s:Tlist_Refresh()
        endif
        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
    augroup end

    call s:Tlist_Menu_Update_File(0)
endfunction

" Tlist_Vim_Session_Load
" Initialize the taglist window/buffer, which is created when loading
" a Vim session file.
function! s:Tlist_Vim_Session_Load()
    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')

    " Initialize the taglist window
    call s:Tlist_Window_Init()

    " Refresh the taglist window
    call s:Tlist_Window_Refresh()
endfunction

" Tlist_Set_App
" Set the name of the external plugin/application to which taglist
" belongs.
" Taglist plugin is part of another plugin like cream or winmanager.
function! Tlist_Set_App(name)
    if a:name == ""
        return
    endif

    let s:tlist_app_name = a:name
endfunction

" Winmanager integration

" Initialization required for integration with winmanager
function! TagList_Start()
    " If current buffer is not taglist buffer, then don't proceed
    if bufname('%') != '__Tag_List__'
        return
    endif

    call Tlist_Set_App('winmanager')

    " Get the current filename from the winmanager plugin
    let bufnum = WinManagerGetLastEditedFile()
    if bufnum != -1
        let filename = fnamemodify(bufname(bufnum), ':p')
        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
    endif

    " Initialize the taglist window, if it is not already initialized
    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
        call s:Tlist_Window_Init()
        call s:Tlist_Window_Refresh()
        let s:tlist_window_initialized = 1
    endif

    " Update the taglist window
    if bufnum != -1
        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
            call s:Tlist_Window_Refresh_File(filename, ftype)
        endif
    endif
endfunction

function! TagList_IsValid()
    return 0
endfunction

function! TagList_WrapUp()
    return 0
endfunction

" restore 'cpo'
let &cpo = s:cpo_save
unlet s:cpo_save

zhimakaimen:/plugin/taglist.vim
" File:          snipMate.vim
" Author:        Michael Sanders
" Version:       0.84
" Description:   snipMate.vim implements some of TextMate's snippets features in
"                Vim. A snippet is a piece of often-typed text that you can
"                insert into your document using a trigger word followed by a "<tab>".
"
"                For more help see snipMate.txt; you can do this by using:
"                :helptags ~/.vim/doc
"                :h snipMate.txt

if exists('loaded_snips') || &cp || version < 700
	finish
endif
let loaded_snips = 1
if !exists('snips_author') | let snips_author = 'Me' | endif

au BufRead,BufNewFile *.snippets\= set ft=snippet
au FileType snippet setl noet fdm=indent

let s:snippets = {} | let s:multi_snips = {}

if !exists('snippets_dir')
	let snippets_dir = substitute(globpath(&rtp, 'snippets/'), "\n", ',', 'g')
endif

fun! MakeSnip(scope, trigger, content, ...)
	let multisnip = a:0 && a:1 != ''
	let var = multisnip ? 's:multi_snips' : 's:snippets'
	if !has_key({var}, a:scope) | let {var}[a:scope] = {} | endif
	if !has_key({var}[a:scope], a:trigger)
		let {var}[a:scope][a:trigger] = multisnip ? [[a:1, a:content]] : a:content
	elseif multisnip | let {var}[a:scope][a:trigger] += [[a:1, a:content]]
	else
		echom 'Warning in snipMate.vim: Snippet '.a:trigger.' is already defined.'
				\ .' See :h multi_snip for help on snippets with multiple matches.'
	endif
endf

fun! ExtractSnips(dir, ft)
	for path in split(globpath(a:dir, '*'), "\n")
		if isdirectory(path)
			let pathname = fnamemodify(path, ':t')
			for snipFile in split(globpath(path, '*.snippet'), "\n")
				call s:ProcessFile(snipFile, a:ft, pathname)
			endfor
		elseif fnamemodify(path, ':e') == 'snippet'
			call s:ProcessFile(path, a:ft)
		endif
	endfor
endf

" Processes a single-snippet file; optionally add the name of the parent
" directory for a snippet with multiple matches.
fun s:ProcessFile(file, ft, ...)
	let keyword = fnamemodify(a:file, ':t:r')
	if keyword  == '' | return | endif
	try
		let text = join(readfile(a:file), "\n")
	catch /E484/
		echom "Error in snipMate.vim: couldn't read file: ".a:file
	endtry
	return a:0 ? MakeSnip(a:ft, a:1, text, keyword)
			\  : MakeSnip(a:ft, keyword, text)
endf

fun! ExtractSnipsFile(file, ft)
	if !filereadable(a:file) | return | endif
	let text = readfile(a:file)
	let inSnip = 0
	for line in text + ["\n"]
		if inSnip && (line[0] == "\t" || line == '')
			let content .= strpart(line, 1)."\n"
			continue
		elseif inSnip
			call MakeSnip(a:ft, trigger, content[:-2], name)
			let inSnip = 0
		endif

		if line[:6] == 'snippet'
			let inSnip = 1
			let trigger = strpart(line, 8)
			let name = ''
			let space = stridx(trigger, ' ') + 1
			if space " Process multi snip
				let name = strpart(trigger, space)
				let trigger = strpart(trigger, 0, space - 1)
			endif
			let content = ''
		endif
	endfor
endf

" Reset snippets for filetype.
fun! ResetSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	for dict in [s:snippets, s:multi_snips, g:did_ft]
		if has_key(dict, ft)
			unlet dict[ft]
		endif
	endfor
endf

" Reset snippets for all filetypes.
fun! ResetAllSnippets()
	let s:snippets = {} | let s:multi_snips = {} | let g:did_ft = {}
endf

" Reload snippets for filetype.
fun! ReloadSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	call ResetSnippets(ft)
	call GetSnippets(g:snippets_dir, ft)
endf

" Reload snippets for all filetypes.
fun! ReloadAllSnippets()
	for ft in keys(g:did_ft)
		call ReloadSnippets(ft)
	endfor
endf

let g:did_ft = {}
fun! GetSnippets(dir, filetypes)
	for ft in split(a:filetypes, '\.')
		if has_key(g:did_ft, ft) | continue | endif
		call s:DefineSnips(a:dir, ft, ft)
		if ft == 'objc' || ft == 'cpp' || ft == 'cs'
			call s:DefineSnips(a:dir, 'c', ft)
		elseif ft == 'xhtml'
			call s:DefineSnips(a:dir, 'html', 'xhtml')
		endif
		let g:did_ft[ft] = 1
	endfor
endf

" Define "aliasft" snippets for the filetype "realft".
fun s:DefineSnips(dir, aliasft, realft)
	for path in split(globpath(a:dir, a:aliasft.'/')."\n".
					\ globpath(a:dir, a:aliasft.'-*/'), "\n")
		call ExtractSnips(path, a:realft)
	endfor
	for path in split(globpath(a:dir, a:aliasft.'.snippets')."\n".
					\ globpath(a:dir, a:aliasft.'-*.snippets'), "\n")
		call ExtractSnipsFile(path, a:realft)
	endfor
endf

fun! TriggerSnippet()
	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingForward == "<tab>"
			let SuperTabKey = "\<c-n>"
		elseif g:SuperTabMappingBackward == "<tab>"
			let SuperTabKey = "\<c-p>"
		endif
	endif

	if pumvisible() " Update snippet if completion is used, or deal with supertab
		if exists('SuperTabKey')
			call feedkeys(SuperTabKey) | return ''
		endif
		call feedkeys("\<esc>a", 'n') " Close completion menu
		call feedkeys("\<tab>") | return ''
	endif

	if exists('g:snipPos') | return snipMate#jumpTabStop(0) | endif

	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let [trigger, snippet] = s:GetSnippet(word, scope)
		" If word is a trigger for a snippet, delete the trigger & expand
		" the snippet.
		if snippet != ''
			let col = col('.') - len(trigger)
			sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
			return snipMate#expandSnip(snippet, col)
		endif
	endfor

	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<tab>"
endf

fun! BackwardsSnippet()
	if exists('g:snipPos') | return snipMate#jumpTabStop(1) | endif

	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingBackward == "<s-tab>"
			let SuperTabKey = "\<c-p>"
		elseif g:SuperTabMappingForward == "<s-tab>"
			let SuperTabKey = "\<c-n>"
		endif
	endif
	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<s-tab>"
endf

" Check if word under cursor is snippet trigger; if it isn't, try checking if
" the text after non-word characters is (e.g. check for "foo" in "bar.foo")
fun s:GetSnippet(word, scope)
	let word = a:word | let snippet = ''
	while snippet == ''
		if exists('s:snippets["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:snippets[a:scope][word]
		elseif exists('s:multi_snips["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:ChooseSnippet(a:scope, word)
			if snippet == '' | break | endif
		else
			if match(word, '\W') == -1 | break | endif
			let word = substitute(word, '.\{-}\W', '', '')
		endif
	endw
	if word == '' && a:word != '.' && stridx(a:word, '.') != -1
		let [word, snippet] = s:GetSnippet('.', a:scope)
	endif
	return [word, snippet]
endf

fun s:ChooseSnippet(scope, trigger)
	let snippet = []
	let i = 1
	for snip in s:multi_snips[a:scope][a:trigger]
		let snippet += [i.'. '.snip[0]]
		let i += 1
	endfor
	if i == 2 | return s:multi_snips[a:scope][a:trigger][0][1] | endif
	let num = inputlist(snippet) - 1
	return num == -1 ? '' : s:multi_snips[a:scope][a:trigger][num][1]
endf

fun! ShowAvailableSnips()
	let line  = getline('.')
	let col   = col('.')
	let word  = matchstr(getline('.'), '\S\+\%'.col.'c')
	let words = [word]
	if stridx(word, '.')
		let words += split(word, '\.', 1)
	endif
	let matchlen = 0
	let matches = []
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let triggers = has_key(s:snippets, scope) ? keys(s:snippets[scope]) : []
		if has_key(s:multi_snips, scope)
			let triggers += keys(s:multi_snips[scope])
		endif
		for trigger in triggers
			for word in words
				if word == ''
					let matches += [trigger] " Show all matches if word is empty
				elseif trigger =~ '^'.word
					let matches += [trigger]
					let len = len(word)
					if len > matchlen | let matchlen = len | endif
				endif
			endfor
		endfor
	endfor

	" This is to avoid a bug with Vim when using complete(col - matchlen, matches)
	" (Issue#46 on the Google Code snipMate issue tracker).
	call setline(line('.'), substitute(line, repeat('.', matchlen).'\%'.col.'c', '', ''))
	call complete(col, matches)
	return ''
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/plugin/snipMate.vim
" ============================================================================
" File:        NERD_commenter.vim
" Description: vim global plugin that provides easy code commenting
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Version:     2.3.0
" Last Change: Wed Dec 14 08:00 AM 2011 EST
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================

" Section: script init stuff {{{1
if exists("loaded_nerd_comments")
    finish
endif
if v:version < 700
    echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_comments = 1

" Function: s:InitVariable() function {{{2
" This function is used to initialise a given variable to a given value. The
" variable is only initialised if it does not exist prior
"
" Args:
"   -var: the name of the var to be initialised
"   -value: the value to initialise var to
"
" Returns:
"   1 if the var is set, 0 otherwise
function s:InitVariable(var, value)
    if !exists(a:var)
        execute 'let ' . a:var . ' = ' . "'" . a:value . "'"
        return 1
    endif
    return 0
endfunction

" Section: space string init{{{2
" When putting spaces after the left delim and before the right we use
" s:spaceStr for the space char. This way we can make it add anything after
" the left and before the right by modifying this variable
let s:spaceStr = ' '
let s:lenSpaceStr = strlen(s:spaceStr)

" Section: variable initialization {{{2
call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)
call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)
call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)
call s:InitVariable("g:NERDCompactSexyComs", 0)
call s:InitVariable("g:NERDCreateDefaultMappings", 1)
call s:InitVariable("g:NERDDefaultNesting", 1)
call s:InitVariable("g:NERDMenuMode", 3)
call s:InitVariable("g:NERDLPlace", "[>")
call s:InitVariable("g:NERDUsePlaceHolders", 1)
call s:InitVariable("g:NERDRemoveAltComs", 1)
call s:InitVariable("g:NERDRemoveExtraSpaces", 0)
call s:InitVariable("g:NERDRPlace", "<]")
call s:InitVariable("g:NERDSpaceDelims", 0)

let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"

let s:delimiterMap = {
    \ 'aap': { 'left': '#' },
    \ 'abc': { 'left': '%' },
    \ 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ada': { 'left': '--', 'leftAlt': '--  ' },
    \ 'ahdl': { 'left': '--' },
    \ 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'amiga': { 'left': ';' },
    \ 'aml': { 'left': '/*' },
    \ 'ampl': { 'left': '#' },
    \ 'apache': { 'left': '#' },
    \ 'apachestyle': { 'left': '#' },
    \ 'asciidoc': { 'left': '//' },
    \ 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'armasm': { 'left': ';' },
    \ 'asm68k': { 'left': ';' },
    \ 'asm': { 'left': ';', 'leftAlt': '#' },
    \ 'asn': { 'left': '--' },
    \ 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'asterisk': { 'left': ';' },
    \ 'asy': { 'left': '//' },
    \ 'atlas': { 'left': 'C', 'right': '$' },
    \ 'autohotkey': { 'left': ';' },
    \ 'autoit': { 'left': ';' },
    \ 'ave': { 'left': "'" },
    \ 'awk': { 'left': '#' },
    \ 'basic': { 'left': "'", 'leftAlt': 'REM ' },
    \ 'bbx': { 'left': '%' },
    \ 'bc': { 'left': '#' },
    \ 'bib': { 'left': '%' },
    \ 'bindzone': { 'left': ';' },
    \ 'bst': { 'left': '%' },
    \ 'btm': { 'left': '::' },
    \ 'cabal': { 'left': '--' },
    \ 'caos': { 'left': '*' },
    \ 'calibre': { 'left': '//' },
    \ 'catalog': { 'left': '--', 'right': '--' },
    \ 'c': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'cf': { 'left': '<!---', 'right': '--->' },
    \ 'cfg': { 'left': '#' },
    \ 'cg': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ch': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cl': { 'left': '#' },
    \ 'clean': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clipper': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clojure': { 'left': ';' },
    \ 'cmake': { 'left': '#' },
    \ 'coffee': { 'left': '#' },
    \ 'conkyrc': { 'left': '#' },
    \ 'context': { 'left': '%', 'leftAlt': '--' },
    \ 'cpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cuda': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'crontab': { 'left': '#' },
    \ 'cs': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'csp': { 'left': '--' },
    \ 'cterm': { 'left': '*' },
    \ 'cucumber': { 'left': '#' },
    \ 'cvs': { 'left': 'CVS:' },
    \ 'd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dcl': { 'left': '$!' },
    \ 'dakota': { 'left': '#' },
    \ 'debcontrol': { 'left': '#' },
    \ 'debsources': { 'left': '#' },
    \ 'def': { 'left': ';' },
    \ 'desktop': { 'left': '#' },
    \ 'dhcpd': { 'left': '#' },
    \ 'diff': { 'left': '#' },
    \ 'django': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'docbk': { 'left': '<!--', 'right': '-->' },
    \ 'dns': { 'left': ';' },
    \ 'dosbatch': { 'left': 'REM ', 'leftAlt': '::' },
    \ 'dosini': { 'left': ';' },
    \ 'dot': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dracula': { 'left': ';' },
    \ 'dsl': { 'left': ';' },
    \ 'dtml': { 'left': '<dtml-comment>', 'right': '</dtml-comment>' },
    \ 'dylan': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ebuild': { 'left': '#' },
    \ 'ecd': { 'left': '#' },
    \ 'eclass': { 'left': '#' },
    \ 'eiffel': { 'left': '--' },
    \ 'elf': { 'left': "'" },
    \ 'elmfilt': { 'left': '#' },
    \ 'erlang': { 'left': '%', 'leftAlt': '%%' },
    \ 'eruby': { 'left': '<%#', 'right': '%>', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'expect': { 'left': '#' },
    \ 'exports': { 'left': '#' },
    \ 'fancy': { 'left': '#' },
    \ 'factor': { 'left': '! ', 'leftAlt': '!# ' },
    \ 'fgl': { 'left': '#' },
    \ 'focexec': { 'left': '-*' },
    \ 'form': { 'left': '*' },
    \ 'foxpro': { 'left': '*' },
    \ 'fsharp': { 'left': '(*', 'right': '*)', 'leftAlt': '//' },
    \ 'fstab': { 'left': '#' },
    \ 'fvwm': { 'left': '#' },
    \ 'fx': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gams': { 'left': '*' },
    \ 'gdb': { 'left': '#' },
    \ 'gdmo': { 'left': '--' },
    \ 'geek': { 'left': 'GEEK_COMMENT:' },
    \ 'genshi': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'gentoo-conf-d': { 'left': '#' },
    \ 'gentoo-env-d': { 'left': '#' },
    \ 'gentoo-init-d': { 'left': '#' },
    \ 'gentoo-make-conf': { 'left': '#' },
    \ 'gentoo-package-keywords': { 'left': '#' },
    \ 'gentoo-package-mask': { 'left': '#' },
    \ 'gentoo-package-use': { 'left': '#' },
    \ 'gitcommit': { 'left': '#' },
    \ 'gitconfig': { 'left': ';' },
    \ 'gitrebase': { 'left': '#' },
    \ 'gnuplot': { 'left': '#' },
    \ 'go': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'groovy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gsp': { 'left': '<%--', 'right': '--%>', 'leftAlt': '<!--','rightAlt': '-->'},
    \ 'gtkrc': { 'left': '#' },
    \ 'haskell': { 'left': '{-','right': '-}', 'leftAlt': '--' },
    \ 'hb': { 'left': '#' },
    \ 'h': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'haml': { 'left': '-#', 'leftAlt': '/' },
    \ 'haxe': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hercules': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hog': { 'left': '#' },
    \ 'hostsaccess': { 'left': '#' },
    \ 'htmlcheetah': { 'left': '##' },
    \ 'htmldjango': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'htmlos': { 'left': '#', 'right': '/#' },
    \ 'hxml': { 'left': '#' },
    \ 'ia64': { 'left': '#' },
    \ 'icon': { 'left': '#' },
    \ 'idlang': { 'left': ';' },
    \ 'idl': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'inform': { 'left': '!' },
    \ 'inittab': { 'left': '#' },
    \ 'ishd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'iss': { 'left': ';' },
    \ 'ist': { 'left': '%' },
    \ 'jade': { 'left': '//-', 'leftAlt': '//' },
    \ 'java': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javacc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript.jquery': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'jess': { 'left': ';' },
    \ 'jgraph': { 'left': '(*', 'right': '*)' },
    \ 'jproperties': { 'left': '#' },
    \ 'jsp': { 'left': '<%--', 'right': '--%>' },
    \ 'kix': { 'left': ';' },
    \ 'kscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'lace': { 'left': '--' },
    \ 'ldif': { 'left': '#' },
    \ 'less': { 'left': '/*','right': '*/' },
    \ 'lhaskell': { 'left': '>{-','right': '-}', 'leftAlt': '>-- ' },
    \ 'lilo': { 'left': '#' },
    \ 'lilypond': { 'left': '%' },
    \ 'liquid': { 'left': '{% comment %}', 'right': '{% endcomment %}' },
    \ 'lisp': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'llvm': { 'left': ';' },
    \ 'lotos': { 'left': '(*', 'right': '*)' },
    \ 'lout': { 'left': '#' },
    \ 'lprolog': { 'left': '%' },
    \ 'lscript': { 'left': "'" },
    \ 'lss': { 'left': '#' },
    \ 'lua': { 'left': '--', 'leftAlt': '--[[', 'rightAlt': ']]' },
    \ 'lynx': { 'left': '#' },
    \ 'lytex': { 'left': '%' },
    \ 'mail': { 'left': '> ' },
    \ 'mako': { 'left': '##' },
    \ 'man': { 'left': '."' },
    \ 'map': { 'left': '%' },
    \ 'maple': { 'left': '#' },
    \ 'markdown': { 'left': '<!--', 'right': '-->' },
    \ 'masm': { 'left': ';' },
    \ 'mason': { 'left': '<% #', 'right': '%>' },
    \ 'master': { 'left': '$' },
    \ 'matlab': { 'left': '%' },
    \ 'mel': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'mib': { 'left': '--' },
    \ 'mirah': {'left': '#'},
    \ 'mkd': { 'left': '>' },
    \ 'mma': { 'left': '(*', 'right': '*)' },
    \ 'model': { 'left': '$', 'right': '$' },
    \ 'moduala.': { 'left': '(*', 'right': '*)' },
    \ 'modula2': { 'left': '(*', 'right': '*)' },
    \ 'modula3': { 'left': '(*', 'right': '*)' },
    \ 'monk': { 'left': ';' },
    \ 'mush': { 'left': '#' },
    \ 'mustache': { 'left': '{{!', 'right': '}}' },
    \ 'named': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'nasm': { 'left': ';' },
    \ 'nastran': { 'left': '$' },
    \ 'natural': { 'left': '/*' },
    \ 'ncf': { 'left': ';' },
    \ 'newlisp': { 'left': ';' },
    \ 'nginx': { 'left': '#' },
    \ 'nimrod': { 'left': '#' },
    \ 'nroff': { 'left': '\"' },
    \ 'nsis': { 'left': '#' },
    \ 'ntp': { 'left': '#' },
    \ 'objc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objcpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objj': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ocaml': { 'left': '(*', 'right': '*)' },
    \ 'occam': { 'left': '--' },
    \ 'octave': { 'left': '%', 'leftAlt': '#' },
    \ 'omlet': { 'left': '(*', 'right': '*)' },
    \ 'omnimark': { 'left': ';' },
    \ 'ooc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'openroad': { 'left': '//' },
    \ 'opl': { 'left': "REM" },
    \ 'ora': { 'left': '#' },
    \ 'ox': { 'left': '//' },
    \ 'pascal': { 'left': '{','right': '}', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'patran': { 'left': '$', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pcap': { 'left': '#' },
    \ 'pccts': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pdf': { 'left': '%' },
    \ 'perl': { 'left': '#' },
    \ 'pfmain': { 'left': '//' },
    \ 'php': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pic': { 'left': ';' },
    \ 'pike': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pilrc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pine': { 'left': '#' },
    \ 'plm': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'plsql': { 'left': '-- ', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'po': { 'left': '#' },
    \ 'postscr': { 'left': '%' },
    \ 'pov': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'povini': { 'left': ';' },
    \ 'ppd': { 'left': '%' },
    \ 'ppwiz': { 'left': ';;' },
    \ 'processing': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'prolog': { 'left': '%', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ps1': { 'left': '#' },
    \ 'psf': { 'left': '#' },
    \ 'ptcap': { 'left': '#' },
    \ 'puppet': { 'left': '#' },
    \ 'python': { 'left': '#' },
    \ 'radiance': { 'left': '#' },
    \ 'ratpoison': { 'left': '#' },
    \ 'r': { 'left': '#' },
    \ 'rc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'rebol': { 'left': ';' },
    \ 'registry': { 'left': ';' },
    \ 'remind': { 'left': '#' },
    \ 'resolv': { 'left': '#' },
    \ 'rgb': { 'left': '!' },
    \ 'rib': { 'left': '#' },
    \ 'robots': { 'left': '#' },
    \ 'rspec': { 'left': '#' },
    \ 'ruby': { 'left': '#' },
    \ 'sa': { 'left': '--' },
    \ 'samba': { 'left': ';', 'leftAlt': '#' },
    \ 'sass': { 'left': '//', 'leftAlt': '/*' },
    \ 'sather': { 'left': '--' },
    \ 'scala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'scons': { 'left': '#' },
    \ 'scheme': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'scilab': { 'left': '//' },
    \ 'scsh': { 'left': ';' },
    \ 'scss': { 'left': '/*', 'right': '*/', 'leftAlt': '//' },
    \ 'sed': { 'left': '#' },
    \ 'sgmldecl': { 'left': '--', 'right': '--' },
    \ 'sgmllnx': { 'left': '<!--', 'right': '-->' },
    \ 'sh': { 'left': '#' },
    \ 'sicad': { 'left': '*' },
    \ 'simula': { 'left': '%', 'leftAlt': '--' },
    \ 'sinda': { 'left': '$' },
    \ 'skill': { 'left': ';' },
    \ 'slang': { 'left': '%' },
    \ 'slice': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'slim': { 'left': '/', 'leftAlt': '/!' },
    \ 'slrnrc': { 'left': '%' },
    \ 'sm': { 'left': '#' },
    \ 'smarty': { 'left': '{*', 'right': '*}' },
    \ 'smil': { 'left': '<!', 'right': '>' },
    \ 'smith': { 'left': ';' },
    \ 'sml': { 'left': '(*', 'right': '*)' },
    \ 'snnsnet': { 'left': '#' },
    \ 'snnspat': { 'left': '#' },
    \ 'snnsres': { 'left': '#' },
    \ 'snobol4': { 'left': '*' },
    \ 'spec': { 'left': '#' },
    \ 'specman': { 'left': '//' },
    \ 'spectre': { 'left': '//', 'leftAlt': '*' },
    \ 'spice': { 'left': '$' },
    \ 'sql': { 'left': '-- ' },
    \ 'sqlforms': { 'left': '-- ' },
    \ 'sqlj': { 'left': '-- ' },
    \ 'sqr': { 'left': '!' },
    \ 'squid': { 'left': '#' },
    \ 'st': { 'left': '"' },
    \ 'stp': { 'left': '--' },
    \ 'supercollider': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tads': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tags': { 'left': ';' },
    \ 'tak': { 'left': '$' },
    \ 'tasm': { 'left': ';' },
    \ 'tcl': { 'left': '#' },
    \ 'texinfo': { 'left': "@c " },
    \ 'texmf': { 'left': '%' },
    \ 'tf': { 'left': ';' },
    \ 'tidy': { 'left': '#' },
    \ 'tli': { 'left': '#' },
    \ 'tmux': { 'left': '#' },
    \ 'trasys': { 'left': "$" },
    \ 'tsalt': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tsscl': { 'left': '#' },
    \ 'tssgm': { 'left': "comment = '", 'right': "'" },
    \ 'txt2tags': { 'left': '%' },
    \ 'twig': { 'left': '{#', 'right': '#}' },
    \ 'uc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'uil': { 'left': '!' },
    \ 'vala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vb': { 'left': "'" },
    \ 'velocity': { 'left': "##", 'right': "", 'leftAlt': '#*', 'rightAlt': '*#' },
    \ 'vera': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'verilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'verilog_systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vgrindefs': { 'left': '#' },
    \ 'vhdl': { 'left': '--' },
    \ 'vimperator': { 'left': '"' },
    \ 'virata': { 'left': '%' },
    \ 'vrml': { 'left': '#' },
    \ 'vsejcl': { 'left': '/*' },
    \ 'webmacro': { 'left': '##' },
    \ 'wget': { 'left': '#' },
    \ 'Wikipedia': { 'left': '<!--', 'right': '-->' },
    \ 'winbatch': { 'left': ';' },
    \ 'wml': { 'left': '#' },
    \ 'wvdial': { 'left': ';' },
    \ 'xdefaults': { 'left': '!' },
    \ 'xkb': { 'left': '//' },
    \ 'xmath': { 'left': '#' },
    \ 'xpm2': { 'left': '!' },
    \ 'xquery': { 'left': '(:', 'right': ':)' },
    \ 'z8a': { 'left': ';' }
    \ }

if exists("g:NERDCustomDelimiters")
    call extend(s:delimiterMap, g:NERDCustomDelimiters)
endif

" Section: Comment mapping functions, autocommands and commands {{{1
" ============================================================================
" Section: Comment enabler autocommands {{{2
" ============================================================================

augroup NERDCommenter

    "if the user enters a buffer or reads a buffer then we gotta set up
    "the comment delimiters for that new filetype
    autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)

    "if the filetype of a buffer changes, force the script to reset the
    "delims for the buffer
    autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)
augroup END


" Function: s:SetUpForNewFiletype(filetype) function {{{2
" This function is responsible for setting up buffer scoped variables for the
" given filetype.
"
" Args:
"   -filetype: the filetype to set delimiters for
"   -forceReset: 1 if the delimiters should be reset if they have already be
"    set for this buffer.
"
function s:SetUpForNewFiletype(filetype, forceReset)
    let ft = a:filetype

    "for compound filetypes, if we dont know how to handle the full filetype
    "then break it down and use the first part that we know how to handle
    if ft =~ '\.' && !has_key(s:delimiterMap, ft)
        let filetypes = split(a:filetype, '\.')
        for i in filetypes
            if has_key(s:delimiterMap, i)
                let ft = i
                break
            endif
        endfor
    endif

    let b:NERDSexyComMarker = ''

    if has_key(s:delimiterMap, ft)
        let b:NERDCommenterDelims = s:delimiterMap[ft]
        for i in ['left', 'leftAlt', 'right', 'rightAlt']
            if !has_key(b:NERDCommenterDelims, i)
                let b:NERDCommenterDelims[i] = ''
            endif
        endfor
    else
        let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    endif

endfunction

function s:CreateDelimMapFromCms()
    return {
        \ 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''),
        \ 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'),
        \ 'leftAlt': '',
        \ 'rightAlt': '' }
endfunction

" Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2
" This function is used to swap the delimiters that are being used to the
" alternative delimiters for that filetype. For example, if a c++ file is
" being edited and // comments are being used, after this function is called
" /**/ comments will be used.
"
" Args:
"   -printMsgs: if this is 1 then a message is echoed to the user telling them
"    if this function changed the delimiters or not
function s:SwitchToAlternativeDelimiters(printMsgs)
    "if both of the alternative delimiters are empty then there is no
    "alternative comment style so bail out
    if b:NERDCommenterDelims['leftAlt'] == '' && b:NERDCommenterDelims['rightAlt'] == ''
        if a:printMsgs
            call s:NerdEcho("Cannot use alternative delimiters, none are specified", 0)
        endif
        return 0
    endif

    "save the current delimiters
    let tempLeft = s:Left()
    let tempRight = s:Right()

    "swap current delimiters for alternative
    let b:NERDCommenterDelims['left'] = b:NERDCommenterDelims['leftAlt']
    let b:NERDCommenterDelims['right'] = b:NERDCommenterDelims['rightAlt']

    "set the previously current delimiters to be the new alternative ones
    let b:NERDCommenterDelims['leftAlt'] = tempLeft
    let b:NERDCommenterDelims['rightAlt'] = tempRight

    "tell the user what comment delimiters they are now using
    if a:printMsgs
        call s:NerdEcho("Now using " . s:Left() . " " . s:Right() . " to delimit comments", 1)
    endif

    return 1
endfunction

" Section: Comment delimiter add/removal functions {{{1
" ============================================================================
" Function: s:AppendCommentToLine(){{{2
" This function appends comment delimiters at the EOL and places the cursor in
" position to start typing the comment
function s:AppendCommentToLine()
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    " get the len of the right delim
    let lenRight = strlen(right)

    let isLineEmpty = strlen(getline(".")) == 0
    let insOrApp = (isLineEmpty==1 ? 'i' : 'A')

    "stick the delimiters down at the end of the line. We have to format the
    "comment with spaces as appropriate
    execute ":normal! " . insOrApp . (isLineEmpty ? '' : ' ') . left . right . " "

    " if there is a right delimiter then we gotta move the cursor left
    " by the len of the right delimiter so we insert between the delimiters
    if lenRight > 0
        let leftMoveAmount = lenRight
        execute ":normal! " . leftMoveAmount . "h"
    endif
    startinsert
endfunction

" Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2
" This function is used to comment out a region of code. This region is
" specified as a bounding box by arguments to the function.
"
" Args:
"   -top: the line number for the top line of code in the region
"   -bottom: the line number for the bottom line of code in the region
"   -lSide: the column number for the left most column in the region
"   -rSide: the column number for the right most column in the region
"   -forceNested: a flag indicating whether comments should be nested
function s:CommentBlock(top, bottom, lSide, rSide, forceNested )
    " we need to create local copies of these arguments so we can modify them
    let top = a:top
    let bottom = a:bottom
    let lSide = a:lSide
    let rSide = a:rSide

    "if the top or bottom line starts with tabs we have to adjust the left and
    "right boundaries so that they are set as though the tabs were spaces
    let topline = getline(top)
    let bottomline = getline(bottom)
    if s:HasLeadingTabs(topline, bottomline)

        "find out how many tabs are in the top line and adjust the left
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(topline)
        if lSide < numTabs
            let lSide = &ts * lSide
        else
            let lSide = (lSide - numTabs) + (&ts * numTabs)
        endif

        "find out how many tabs are in the bottom line and adjust the right
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(bottomline)
        let rSide = (rSide - numTabs) + (&ts * numTabs)
    endif

    "we must check that bottom IS actually below top, if it is not then we
    "swap top and bottom. Similarly for left and right.
    if bottom < top
        let temp = top
        let top = bottom
        let bottom = top
    endif
    if rSide < lSide
        let temp = lSide
        let lSide = rSide
        let rSide = temp
    endif

    "if the current delimiters arent multipart then we will switch to the
    "alternative delims (if THEY are) as the comment will be better and more
    "accurate with multipart delims
    let switchedDelims = 0
    if !s:Multipart() && g:NERDAllowAnyVisualDelims && s:AltMultipart()
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "start the commenting from the top and keep commenting till we reach the
    "bottom
    let currentLine=top
    while currentLine <= bottom

        "check if we are allowed to comment this line
        if s:CanCommentLine(a:forceNested, currentLine)

            "convert the leading tabs into spaces
            let theLine = getline(currentLine)
            let lineHasLeadTabs = s:HasLeadingTabs(theLine)
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif

            "dont comment lines that begin after the right boundary of the
            "block unless the user has specified to do so
            if theLine !~ '^ \{' . rSide . '\}' || !g:NERDBlockComIgnoreEmpty

                "attempt to place the cursor in on the left of the boundary box,
                "then check if we were successful, if not then we cant comment this
                "line
                call setline(currentLine, theLine)
                if s:CanPlaceCursor(currentLine, lSide)

                    let leftSpaced = s:Left({'space': 1})
                    let rightSpaced = s:Right({'space': 1})

                    "stick the left delimiter down
                    let theLine = strpart(theLine, 0, lSide-1) . leftSpaced . strpart(theLine, lSide-1)

                    if s:Multipart()
                        "stick the right delimiter down
                        let theLine = strpart(theLine, 0, rSide+strlen(leftSpaced)) . rightSpaced . strpart(theLine, rSide+strlen(leftSpaced))

                        let firstLeftDelim = s:FindDelimiterIndex(s:Left(), theLine)
                        let lastRightDelim = s:LastIndexOfDelim(s:Right(), theLine)

                        if firstLeftDelim != -1 && lastRightDelim != -1
                            let searchStr = strpart(theLine, 0, lastRightDelim)
                            let searchStr = strpart(searchStr, firstLeftDelim+strlen(s:Left()))

                            "replace the outter most delims in searchStr with
                            "place-holders
                            let theLineWithPlaceHolders = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, searchStr)

                            "add the right delimiter onto the line
                            let theLine = strpart(theLine, 0, firstLeftDelim+strlen(s:Left())) . theLineWithPlaceHolders . strpart(theLine, lastRightDelim)
                        endif
                    endif
                endif
            endif

            "restore tabs if needed
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingSpacesToTabs(theLine)
            endif

            call setline(currentLine, theLine)
        endif

        let currentLine = currentLine + 1
    endwhile

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif
endfunction

" Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2
" This function comments a range of lines.
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -align: should be "left" or "both" or "none"
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLines(forceNested, align, firstLine, lastLine)
    " we need to get the left and right indexes of the leftmost char in the
    " block of of lines and the right most char so that we can do alignment of
    " the delimiters if the user has specified
    let leftAlignIndx = s:LeftMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)
    let rightAlignIndx = s:RightMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)

    " gotta add the length of the left delimiter onto the rightAlignIndx cos
    " we'll be adding a left delim to the line
    let rightAlignIndx = rightAlignIndx + strlen(s:Left({'space': 1}))

    " now we actually comment the lines. Do it line by line
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanCommentLine(a:forceNested, currentLine)
            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if a:forceNested && g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            " find out if the line is commented using normal delims and/or
            " alternate ones
            let isCommented = s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)

            " check if we can comment this line
            if !isCommented || g:NERDUsePlaceHolders || s:Multipart()
                if a:align == "left" || a:align == "both"
                    let theLine = s:AddLeftDelimAligned(s:Left({'space': 1}), theLine, leftAlignIndx)
                else
                    let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
                endif
                if a:align == "both"
                    let theLine = s:AddRightDelimAligned(s:Right({'space': 1}), theLine, rightAlignIndx)
                else
                    let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
                endif
            endif
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2
" This function comments a range of lines in a minimal style. I
"
" Args:
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesMinimal(firstLine, lastLine)
    "check that minimal comments can be done on this filetype
    if !s:HasMultipartDelims()
        throw 'NERDCommenter.Delimiters exception: Minimal comments can only be used for filetypes that have multipart delimiters'
    endif

    "if we need to use place holders for the comment, make sure they are
    "enabled for this filetype
    if !g:NERDUsePlaceHolders && s:DoesBlockHaveMultipartDelim(a:firstLine, a:lastLine)
        throw 'NERDCommenter.Settings exception: Place holders are required but disabled.'
    endif

    "get the left and right delims to smack on
    let left = s:GetSexyComLeft(g:NERDSpaceDelims,0)
    let right = s:GetSexyComRight(g:NERDSpaceDelims,0)

    "make sure all multipart delims on the lines are replaced with
    "placeholders to prevent illegal syntax
    let currentLine = a:firstLine
    while(currentLine <= a:lastLine)
        let theLine = getline(currentLine)
        let theLine = s:ReplaceDelims(left, right, g:NERDLPlace, g:NERDRPlace, theLine)
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    "add the delim to the top line
    let theLine = getline(a:firstLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddLeftDelim(left, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:firstLine, theLine)

    "add the delim to the bottom line
    let theLine = getline(a:lastLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddRightDelim(right, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:lastLine, theLine)
endfunction

" Function: s:CommentLinesSexy(topline, bottomline) function {{{2
" This function is used to comment lines in the 'Sexy' style. eg in c:
" /*
"  * This is a sexy comment
"  */
" Args:
"   -topline: the line num of the top line in the sexy comment
"   -bottomline: the line num of the bottom line in the sexy comment
function s:CommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0, 0)
    let right = s:GetSexyComRight(0, 0)

    "check if we can do a sexy comment with the available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot perform sexy comments with available delimiters.'
    endif

    "make sure the lines arent already commented sexually
    if !s:CanSexyCommentLines(a:topline, a:bottomline)
        throw 'NERDCommenter.Nesting exception: cannot nest sexy comments'
    endif


    let sexyComMarker = s:GetSexyComMarker(0,0)
    let sexyComMarkerSpaced = s:GetSexyComMarker(1,0)


    " we jam the comment as far to the right as possible
    let leftAlignIndx = s:LeftMostIndx(1, 1, a:topline, a:bottomline)

    "check if we should use the compact style i.e that the left/right
    "delimiters should appear on the first and last lines of the code and not
    "on separate lines above/below the first/last lines of code
    if g:NERDCompactSexyComs
        let spaceString = (g:NERDSpaceDelims ? s:spaceStr : '')

        "comment the top line
        let theLine = getline(a:topline)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif
        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        let theLine = s:AddLeftDelimAligned(left . spaceString, theLine, leftAlignIndx)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        "comment the bottom line
        if a:bottomline != a:topline
            let theLine = getline(a:bottomline)
            let lineHasTabs = s:HasLeadingTabs(theLine)
            if lineHasTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif
            let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        endif
        let theLine = s:AddRightDelim(spaceString . right, theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline, theLine)
    else

        " add the left delimiter one line above the lines that are to be commented
        call cursor(a:topline, 1)
        execute 'normal! O'
        let theLine = repeat(' ', leftAlignIndx) . left

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        " add the right delimiter after bottom line (we have to add 1 cos we moved
        " the lines down when we added the left delim
        call cursor(a:bottomline+1, 1)
        execute 'normal! o'
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . right

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline+2, theLine)

    endif

    " go thru each line adding the sexyComMarker marker to the start of each
    " line in the appropriate place to align them with the comment delims
    let currentLine = a:topline+1
    while currentLine <= a:bottomline + !g:NERDCompactSexyComs
        " get the line and convert the tabs to spaces
        let theLine = getline(currentLine)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif

        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)

        " add the sexyComMarker
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . sexyComMarkerSpaced . strpart(theLine, leftAlignIndx)

        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif


        " set the line and move onto the next one
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2
" Applies "toggle" commenting to the given range of lines
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesToggle(forceNested, firstLine, lastLine)
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanToggleCommentLine(a:forceNested, currentLine)

            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
            let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2
" This function comments chunks of text selected in visual mode.
" It will comment exactly the text that they have selected.
" Args:
"   -topLine: the line num of the top line in the sexy comment
"   -topCol: top left col for this comment
"   -bottomline: the line num of the bottom line in the sexy comment
"   -bottomCol: the bottom right col for this comment
"   -forceNested: whether the caller wants comments to be nested if the
"    line(s) are already commented
function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)

    "switch delims (if we can) if the current set isnt multipart
    let switchedDelims = 0
    if !s:Multipart() && s:AltMultipart() && !g:NERDAllowAnyVisualDelims
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "if there is only one line in the comment then just do it
    if a:topLine == a:bottomLine
        call s:CommentBlock(a:topLine, a:bottomLine, a:topCol, a:bottomCol, a:forceNested)

    "there are multiple lines in the comment
    else
        "comment the top line
        call s:CommentBlock(a:topLine, a:topLine, a:topCol, strlen(getline(a:topLine)), a:forceNested)

        "comment out all the lines in the middle of the comment
        let topOfRange = a:topLine+1
        let bottomOfRange = a:bottomLine-1
        if topOfRange <= bottomOfRange
            call s:CommentLines(a:forceNested, "none", topOfRange, bottomOfRange)
        endif

        "comment the bottom line
        let bottom = getline(a:bottomLine)
        let numLeadingSpacesTabs = strlen(substitute(bottom, '^\([ \t]*\).*$', '\1', ''))
        call s:CommentBlock(a:bottomLine, a:bottomLine, numLeadingSpacesTabs+1, a:bottomCol, a:forceNested)

    endif

    "stick the cursor back on the char it was on before the comment
    call cursor(a:topLine, a:topCol + strlen(s:Left()) + g:NERDSpaceDelims)

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

endfunction

" Function: s:InvertComment(firstLine, lastLine) function {{{2
" Inverts the comments on the lines between and including the given line
" numbers i.e all commented lines are uncommented and vice versa
" Args:
"   -firstLine: the top of the range of lines to be inverted
"   -lastLine: the bottom of the range of lines to be inverted
function s:InvertComment(firstLine, lastLine)

    " go thru all lines in the given range
    let currentLine = a:firstLine
    while currentLine <= a:lastLine
        let theLine = getline(currentLine)

        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)

        " if the line is commented normally, uncomment it
        if s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(currentLine, currentLine)
            let currentLine = currentLine + 1

        " check if the line is commented sexually
        elseif !empty(sexyComBounds)
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()
            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let currentLine = sexyComBounds[1] - (numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved) + 1

        " the line isnt commented
        else
            call s:CommentLinesToggle(1, currentLine, currentLine)
            let currentLine = currentLine + 1
        endif

    endwhile
endfunction

" Function: NERDComment(mode, type) function {{{2
" This function is a Wrapper for the main commenting functions
"
" Args:
"   -mode: a character indicating the mode in which the comment is requested:
"   'n' for Normal mode, 'x' for Visual mode
"   -type: the type of commenting requested. Can be 'Sexy', 'Invert',
"    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',
"    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'
function! NERDComment(mode, type) range
    let isVisual = a:mode =~ '[vsx]'
    " we want case sensitivity when commenting
    let oldIgnoreCase = &ignorecase
    set noignorecase

    if !exists("g:did_load_ftplugin") || g:did_load_ftplugin != 1
        call s:NerdEcho("filetype plugins should be enabled. See :help NERDComInstallation and :help :filetype-plugin-on", 0)
    endif

    if isVisual
        let firstLine = line("'<")
        let lastLine = line("'>")
        let firstCol = col("'<")
        let lastCol = col("'>") - (&selection == 'exclusive' ? 1 : 0)
    else
        let firstLine = a:firstline
        let lastLine = a:lastline
    endif

    let countWasGiven = (!isVisual && firstLine != lastLine)

    let forceNested = (a:type ==? 'Nested' || g:NERDDefaultNesting)

    if a:type ==? 'Comment' || a:type ==? 'Nested'
        if isVisual && visualmode() == "\<C-V>"
            call s:CommentBlock(firstLine, lastLine, firstCol, lastCol, forceNested)
        elseif isVisual && visualmode() == "v" && (g:NERDCommentWholeLinesInVMode==0 || (g:NERDCommentWholeLinesInVMode==2 && s:HasMultipartDelims()))
            call s:CommentRegion(firstLine, firstCol, lastLine, lastCol, forceNested)
        else
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        endif

    elseif a:type ==? 'AlignLeft' || a:type ==? 'AlignBoth'
        let align = "none"
        if a:type ==? "AlignLeft"
            let align = "left"
        elseif a:type ==? "AlignBoth"
            let align = "both"
        endif
        call s:CommentLines(forceNested, align, firstLine, lastLine)

    elseif a:type ==? 'Invert'
        call s:InvertComment(firstLine, lastLine)

    elseif a:type ==? 'Sexy'
        try
            call s:CommentLinesSexy(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        catch /NERDCommenter.Nesting/
            call s:NerdEcho("Sexy comment aborted. Nested sexy cannot be nested", 0)
        endtry

    elseif a:type ==? 'Toggle'
        let theLine = getline(firstLine)

        if s:IsInSexyComment(firstLine) || s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(firstLine, lastLine)
        else
            call s:CommentLinesToggle(forceNested, firstLine, lastLine)
        endif

    elseif a:type ==? 'Minimal'
        try
            call s:CommentLinesMinimal(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:NerdEcho("Minimal comments can only be used for filetypes that have multipart delimiters.", 0)
        catch /NERDCommenter.Settings/
            call s:NerdEcho("Place holders are required but disabled.", 0)
        endtry

    elseif a:type ==? 'ToEOL'
        call s:SaveScreenState()
        call s:CommentBlock(firstLine, firstLine, col("."), col("$")-1, 1)
        call s:RestoreScreenState()

    elseif a:type ==? 'Append'
        call s:AppendCommentToLine()

    elseif a:type ==? 'Insert'
        call s:PlaceDelimitersAndInsBetween()

    elseif a:type ==? 'Uncomment'
        call s:UncommentLines(firstLine, lastLine)

    elseif a:type ==? 'Yank'
        if isVisual
            normal! gvy
        elseif countWasGiven
            execute firstLine .','. lastLine .'yank'
        else
            normal! yy
        endif
        execute firstLine .','. lastLine .'call NERDComment("'. a:mode .'", "Comment")'
    endif

    let &ignorecase = oldIgnoreCase

    if isVisual
        let nlines = lastLine - firstLine
        silent! call repeat#set("V" . nlines . "jo" . "\<Plug>NERDCommenter". a:type)
    else
        silent! call repeat#set("\<Plug>NERDCommenter". a:type)
    endif
endfunction

" Function: s:PlaceDelimitersAndInsBetween() function {{{2
" This is function is called to place comment delimiters down and place the
" cursor between them
function s:PlaceDelimitersAndInsBetween()
    " get the left and right delimiters without any escape chars in them
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    let theLine = getline(".")
    let lineHasLeadTabs = s:HasLeadingTabs(theLine) || (theLine =~ '^ *$' && !&expandtab)

    "convert tabs to spaces and adjust the cursors column to take this into
    "account
    let untabbedCol = s:UntabbedCol(theLine, col("."))
    call setline(line("."), s:ConvertLeadingTabsToSpaces(theLine))
    call cursor(line("."), untabbedCol)

    " get the len of the right delim
    let lenRight = strlen(right)

    let isDelimOnEOL = col(".") >= strlen(getline("."))

    " if the cursor is in the first col then we gotta insert rather than
    " append the comment delimiters here
    let insOrApp = (col(".")==1 ? 'i' : 'a')

    " place the delimiters down. We do it differently depending on whether
    " there is a left AND right delimiter
    if lenRight > 0
        execute ":normal! " . insOrApp . left . right
        execute ":normal! " . lenRight . "h"
    else
        execute ":normal! " . insOrApp . left
    endif
    silent! normal! l

    "if needed convert spaces back to tabs and adjust the cursors col
    "accordingly
    if lineHasLeadTabs
        let tabbedCol = s:TabbedCol(getline("."), col("."))
        call setline(line("."), s:ConvertLeadingSpacesToTabs(getline(".")))
        call cursor(line("."), tabbedCol)
    endif

    if isDelimOnEOL && lenRight == 0
        startinsert!
    else
        startinsert
    endif
endfunction

" Function: s:RemoveDelimiters(left, right, line) {{{2
" this function is called to remove the first left comment delimiter and the
" last right delimiter of the given line.
"
" The args left and right must be strings. If there is no right delimiter (as
" is the case for e.g vim file comments) them the arg right should be ""
"
" Args:
"   -left: the left comment delimiter
"   -right: the right comment delimiter
"   -line: the line to remove the delimiters from
function s:RemoveDelimiters(left, right, line)

    let l:left = a:left
    let l:right = a:right
    let lenLeft = strlen(left)
    let lenRight = strlen(right)

    let delimsSpaced = (g:NERDSpaceDelims || g:NERDRemoveExtraSpaces)

    let line = a:line

    "look for the left delimiter, if we find it, remove it.
    let leftIndx = s:FindDelimiterIndex(a:left, line)
    if leftIndx != -1
        let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+lenLeft)

        "if the user has specified that there is a space after the left delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, leftIndx, s:lenSpaceStr) == s:spaceStr
            let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+s:lenSpaceStr)
        endif
    endif

    "look for the right delimiter, if we find it, remove it
    let rightIndx = s:FindDelimiterIndex(a:right, line)
    if rightIndx != -1
        let line = strpart(line, 0, rightIndx) . strpart(line, rightIndx+lenRight)

        "if the user has specified that there is a space before the right delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, rightIndx-s:lenSpaceStr, s:lenSpaceStr) == s:spaceStr && s:Multipart()
            let line = strpart(line, 0, rightIndx-s:lenSpaceStr) . strpart(line, rightIndx)
        endif
    endif

    return line
endfunction

" Function: s:UncommentLines(topLine, bottomLine) {{{2
" This function uncomments the given lines
"
" Args:
" topLine: the top line of the visual selection to uncomment
" bottomLine: the bottom line of the visual selection to uncomment
function s:UncommentLines(topLine, bottomLine)
    "make local copies of a:firstline and a:lastline and, if need be, swap
    "them around if the top line is below the bottom
    let l:firstline = a:topLine
    let l:lastline = a:bottomLine
    if firstline > lastline
        let firstline = lastline
        let lastline = a:topLine
    endif

    "go thru each line uncommenting each line removing sexy comments
    let currentLine = firstline
    while currentLine <= lastline

        "check the current line to see if it is part of a sexy comment
        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)
        if !empty(sexyComBounds)

            "we need to store the num lines in the buf before the comment is
            "removed so we know how many lines were removed when the sexy com
            "was removed
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()

            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let numLinesRemoved = numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved
            let currentLine = sexyComBounds[1] - numLinesRemoved + 1
            let lastline = lastline - numLinesRemoved

        "no sexy com was detected so uncomment the line as normal
        else
            call s:UncommentLinesNormal(currentLine, currentLine)
            let currentLine = currentLine + 1
        endif
    endwhile

endfunction

" Function: s:UncommentLinesSexy(topline, bottomline) {{{2
" This function removes all the comment characters associated with the sexy
" comment spanning the given lines
" Args:
"   -topline/bottomline: the top/bottom lines of the sexy comment
function s:UncommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0,1)
    let right = s:GetSexyComRight(0,1)


    "check if it is even possible for sexy comments to exist with the
    "available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot uncomment sexy comments with available delimiters.'
    endif

    let leftUnEsc = s:GetSexyComLeft(0,0)
    let rightUnEsc = s:GetSexyComRight(0,0)

    let sexyComMarker = s:GetSexyComMarker(0, 1)
    let sexyComMarkerUnEsc = s:GetSexyComMarker(0, 0)

    "the markerOffset is how far right we need to move the sexyComMarker to
    "line it up with the end of the left delim
    let markerOffset = strlen(leftUnEsc)-strlen(sexyComMarkerUnEsc)

    " go thru the intermediate lines of the sexy comment and remove the
    " sexy comment markers (eg the '*'s on the start of line in a c sexy
    " comment)
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        " remove the sexy comment marker from the line. We also remove the
        " space after it if there is one and if appropriate options are set
        let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
        if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)

        let theLine = s:ConvertLeadingWhiteSpace(theLine)

        " move onto the next line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    " gotta make a copy of a:bottomline cos we modify the position of the
    " last line  it if we remove the topline
    let bottomline = a:bottomline

    " get the first line so we can remove the left delim from it
    let theLine = getline(a:topline)

    " if the first line contains only the left delim then just delete it
    if theLine =~ '^[ \t]*' . left . '[ \t]*$' && !g:NERDCompactSexyComs
        call cursor(a:topline, 1)
        normal! dd
        let bottomline = bottomline - 1

    " topline contains more than just the left delim
    else

        " remove the delim. If there is a space after it
        " then remove this too if appropriate
        let delimIndx = stridx(theLine, leftUnEsc)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc))
        endif
        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(a:topline, theLine)
    endif

    " get the last line so we can remove the right delim
    let theLine = getline(bottomline)

    " if the bottomline contains only the right delim then just delete it
    if theLine =~ '^[ \t]*' . right . '[ \t]*$'
        call cursor(bottomline, 1)
        normal! dd

    " the last line contains more than the right delim
    else
        " remove the right delim. If there is a space after it and
        " if the appropriate options are set then remove this too.
        let delimIndx = s:LastIndexOfDelim(rightUnEsc, theLine)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc))
        endif

        " if the last line also starts with a sexy comment marker then we
        " remove this as well
        if theLine =~ '^[ \t]*' . sexyComMarker

            " remove the sexyComMarker. If there is a space after it then
            " remove that too
            let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
            if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
            else
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
            endif
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(bottomline, theLine)
    endif
endfunction

" Function: s:UncommentLineNormal(line) {{{2
" uncomments the given line and returns the result
" Args:
"   -line: the line to uncomment
function s:UncommentLineNormal(line)
    let line = a:line

    "get the positions of all delim types on the line
    let indxLeft = s:FindDelimiterIndex(s:Left(), line)
    let indxLeftAlt = s:FindDelimiterIndex(s:Left({'alt': 1}), line)
    let indxRight = s:FindDelimiterIndex(s:Right(), line)
    let indxRightAlt = s:FindDelimiterIndex(s:Right({'alt': 1}), line)

    "get the comment status on the line so we know how it is commented
    let lineCommentStatus =  s:IsCommentedOuttermost(s:Left(), s:Right(), s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is commented with s:Left() and s:Right() so remove these delims
    if lineCommentStatus == 1
        let line = s:RemoveDelimiters(s:Left(), s:Right(), line)

    "it is commented with s:Left({'alt': 1}) and s:Right({'alt': 1}) so remove these delims
    elseif lineCommentStatus == 2 && g:NERDRemoveAltComs
        let line = s:RemoveDelimiters(s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is not properly commented with any delims so we check if it has
    "any random left or right delims on it and remove the outtermost ones
    else
        "remove the outter most left comment delim
        if indxLeft != -1 && (indxLeft < indxLeftAlt || indxLeftAlt == -1)
            let line = s:RemoveDelimiters(s:Left(), '', line)
        elseif indxLeftAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters(s:Left({'alt': 1}), '', line)
        endif

        "remove the outter most right comment delim
        if indxRight != -1 && (indxRight < indxRightAlt || indxRightAlt == -1)
            let line = s:RemoveDelimiters('', s:Right(), line)
        elseif indxRightAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters('', s:Right({'alt': 1}), line)
        endif
    endif


    let indxLeftPlace = s:FindDelimiterIndex(g:NERDLPlace, line)
    let indxRightPlace = s:FindDelimiterIndex(g:NERDRPlace, line)

    let right = s:Right()
    let left = s:Left()
    if !s:Multipart()
        let right = s:Right({'alt': 1})
        let left = s:Left({'alt': 1})
    endif


    "if there are place-holders on the line then we check to see if they are
    "the outtermost delimiters on the line. If so then we replace them with
    "real delimiters
    if indxLeftPlace != -1
        if (indxLeftPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif
    elseif indxRightPlace != -1
        if (indxRightPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif

    endif

    let line = s:ConvertLeadingWhiteSpace(line)

    return line
endfunction

" Function: s:UncommentLinesNormal(topline, bottomline) {{{2
" This function is called to uncomment lines that arent a sexy comment
" Args:
"   -topline/bottomline: the top/bottom line numbers of the comment
function s:UncommentLinesNormal(topline, bottomline)
    let currentLine = a:topline
    while currentLine <= a:bottomline
        let line = getline(currentLine)
        call setline(currentLine, s:UncommentLineNormal(line))
        let currentLine = currentLine + 1
    endwhile
endfunction


" Section: Other helper functions {{{1
" ============================================================================

" Function: s:AddLeftDelim(delim, theLine) {{{2
" Args:
function s:AddLeftDelim(delim, theLine)
    return substitute(a:theLine, '^\([ \t]*\)', '\1' . a:delim, '')
endfunction

" Function: s:AddLeftDelimAligned(delim, theLine) {{{2
" Args:
function s:AddLeftDelimAligned(delim, theLine, alignIndx)

    "if the line is not long enough then bung some extra spaces on the front
    "so we can align the delim properly
    let theLine = a:theLine
    if strlen(theLine) < a:alignIndx
        let theLine = repeat(' ', a:alignIndx - strlen(theLine))
    endif

    return strpart(theLine, 0, a:alignIndx) . a:delim . strpart(theLine, a:alignIndx)
endfunction

" Function: s:AddRightDelim(delim, theLine) {{{2
" Args:
function s:AddRightDelim(delim, theLine)
    if a:delim == ''
        return a:theLine
    else
        return substitute(a:theLine, '$', a:delim, '')
    endif
endfunction

" Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2
" Args:
function s:AddRightDelimAligned(delim, theLine, alignIndx)
    if a:delim == ""
        return a:theLine
    else

        " when we align the right delim we are just adding spaces
        " so we get a string containing the needed spaces (it
        " could be empty)
        let extraSpaces = ''
        let extraSpaces = repeat(' ', a:alignIndx-strlen(a:theLine))

        " add the right delim
        return substitute(a:theLine, '$', extraSpaces . a:delim, '')
    endif
endfunction

" Function: s:AltMultipart() {{{2
" returns 1 if the alternative delims are multipart
function s:AltMultipart()
    return b:NERDCommenterDelims['rightAlt'] != ''
endfunction

" Function: s:CanCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -forceNested: a flag indicating whether the caller wants comments to be nested
"    if the current line is already commented
"   -lineNum: the line num of the line to check for commentability
function s:CanCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    let isCommented = s:IsCommentedNormOrSexy(a:lineNum)

    "if the line isnt commented return true
    if !isCommented
        return 1
    endif

    "if the line is commented but nesting is allowed then return true
    if a:forceNested && (!s:Multipart() || g:NERDUsePlaceHolders)
        return 1
    endif

    return 0
endfunction

" Function: s:CanPlaceCursor(line, col) {{{2
" returns 1 if the cursor can be placed exactly in the given position
function s:CanPlaceCursor(line, col)
    let c = col(".")
    let l = line(".")
    call cursor(a:line, a:col)
    let success = (line(".") == a:line && col(".") == a:col)
    call cursor(l,c)
    return success
endfunction

" Function: s:CanSexyCommentLines(topline, bottomline) {{{2
" Return: 1 if the given lines can be commented sexually, 0 otherwise
function s:CanSexyCommentLines(topline, bottomline)
    " see if the selected regions have any sexy comments
    let currentLine = a:topline
    while(currentLine <= a:bottomline)
        if s:IsInSexyComment(currentLine)
            return 0
        endif
        let currentLine = currentLine + 1
    endwhile
    return 1
endfunction
" Function: s:CanToggleCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be toggle commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -lineNum: the line num of the line to check for commentability
function s:CanToggleCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)
    if (s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)) && !a:forceNested
        return 0
    endif

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    return 1
endfunction

" Function: s:ConvertLeadingSpacesToTabs(line) {{{2
" This function takes a line and converts all leading tabs on that line into
" spaces
"
" Args:
"   -line: the line whose leading tabs will be converted
function s:ConvertLeadingSpacesToTabs(line)
    let toReturn  = a:line
    while toReturn =~ '^\t*' . s:TabSpace() . '\(.*\)$'
        let toReturn = substitute(toReturn, '^\(\t*\)' . s:TabSpace() . '\(.*\)$'  ,  '\1\t\2' , "")
    endwhile

    return toReturn
endfunction


" Function: s:ConvertLeadingTabsToSpaces(line) {{{2
" This function takes a line and converts all leading spaces on that line into
" tabs
"
" Args:
"   -line: the line whose leading spaces will be converted
function s:ConvertLeadingTabsToSpaces(line)
    let toReturn  = a:line
    while toReturn =~ '^\( *\)\t'
        let toReturn = substitute(toReturn, '^\( *\)\t',  '\1' . s:TabSpace() , "")
    endwhile

    return toReturn
endfunction

" Function: s:ConvertLeadingWhiteSpace(line) {{{2
" Converts the leading white space to tabs/spaces depending on &ts
"
" Args:
"   -line: the line to convert
function s:ConvertLeadingWhiteSpace(line)
    let toReturn = a:line
    while toReturn =~ '^ *\t'
        let toReturn = substitute(toReturn, '^ *\zs\t\ze', s:TabSpace(), "g")
    endwhile

    if !&expandtab
        let toReturn = s:ConvertLeadingSpacesToTabs(toReturn)
    endif

    return toReturn
endfunction


" Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2
" This function counts the number of substrings contained in another string.
" These substrings are only counted if they are not escaped with escChar
" Args:
"   -str: the string to look for searchstr in
"   -searchstr: the substring to search for in str
"   -escChar: the escape character which, when preceding an instance of
"    searchstr, will cause it not to be counted
function s:CountNonESCedOccurances(str, searchstr, escChar)
    "get the index of the first occurrence of searchstr
    let indx = stridx(a:str, a:searchstr)

    "if there is an instance of searchstr in str process it
    if indx != -1
        "get the remainder of str after this instance of searchstr is removed
        let lensearchstr = strlen(a:searchstr)
        let strLeft = strpart(a:str, indx+lensearchstr)

        "if this instance of searchstr is not escaped, add one to the count
        "and recurse. If it is escaped, just recurse
        if !s:IsEscaped(a:str, indx, a:escChar)
            return 1 + s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        else
            return s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        endif
    endif
endfunction
" Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2
" Returns 1 if the given block of lines has a delimiter (a:delim) in it
" Args:
"   -delim: the comment delimiter to check the block for
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveDelim(delim, top, bottom)
    let currentLine = a:top
    while currentLine < a:bottom
        let theline = getline(currentLine)
        if s:FindDelimiterIndex(a:delim, theline) != -1
            return 1
        endif
        let currentLine = currentLine + 1
    endwhile
    return 0
endfunction

" Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2
" Returns 1 if the given block has a >= 1 multipart delimiter in it
" Args:
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveMultipartDelim(top, bottom)
    if s:HasMultipartDelims()
        if s:Multipart()
            return s:DoesBlockHaveDelim(s:Left(), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right(), a:top, a:bottom)
        else
            return s:DoesBlockHaveDelim(s:Left({'alt': 1}), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right({'alt': 1}), a:top, a:bottom)
        endif
    endif
    return 0
endfunction


" Function: s:Esc(str) {{{2
" Escapes all the tricky chars in the given string
function s:Esc(str)
    let charsToEsc = '*/\."&$+'
    return escape(a:str, charsToEsc)
endfunction

" Function: s:FindDelimiterIndex(delimiter, line) {{{2
" This function is used to get the string index of the input comment delimiter
" on the input line. If no valid comment delimiter is found in the line then
" -1 is returned
" Args:
"   -delimiter: the delimiter we are looking to find the index of
"   -line: the line we are looking for delimiter on
function s:FindDelimiterIndex(delimiter, line)

    "make sure the delimiter isnt empty otherwise we go into an infinite loop.
    if a:delimiter == ""
        return -1
    endif


    let l:delimiter = a:delimiter
    let lenDel = strlen(l:delimiter)

    "get the index of the first occurrence of the delimiter
    let delIndx = stridx(a:line, l:delimiter)

    "keep looping thru the line till we either find a real comment delimiter
    "or run off the EOL
    while delIndx != -1

        "if we are not off the EOL get the str before the possible delimiter
        "in question and check if it really is a delimiter. If it is, return
        "its position
        if delIndx != -1
            if s:IsDelimValid(l:delimiter, delIndx, a:line)
                return delIndx
            endif
        endif

        "we have not yet found a real comment delimiter so move past the
        "current one we are lookin at
        let restOfLine = strpart(a:line, delIndx + lenDel)
        let distToNextDelim = stridx(restOfLine , l:delimiter)

        "if distToNextDelim is -1 then there is no more potential delimiters
        "on the line so set delIndx to -1. Otherwise, move along the line by
        "distToNextDelim
        if distToNextDelim == -1
            let delIndx = -1
        else
            let delIndx = delIndx + lenDel + distToNextDelim
        endif
    endwhile

    "there is no comment delimiter on this line
    return -1
endfunction

" Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2
" This function takes in a line number and tests whether this line number is
" the top/bottom/middle line of a sexy comment. If it is then the top/bottom
" lines of the sexy comment are returned
" Args:
"   -lineNum: the line number that is to be tested whether it is the
"    top/bottom/middle line of a sexy com
" Returns:
"   A string that has the top/bottom lines of the sexy comment encoded in it.
"   The format is 'topline,bottomline'. If a:lineNum turns out not to be the
"   top/bottom/middle of a sexy comment then -1 is returned
function s:FindBoundingLinesOfSexyCom(lineNum)

    "find which delimiters to look for as the start/end delims of the comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left({'esc': 1})
        let right = s:Right({'esc': 1})
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1, 'esc': 1})
        let right = s:Right({'alt': 1, 'esc': 1})
    else
        return []
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "initialise the top/bottom line numbers of the sexy comment to -1
    let top = -1
    let bottom = -1

    let currentLine = a:lineNum
    while top == -1 || bottom == -1
        let theLine = getline(currentLine)

        "check if the current line is the top of the sexy comment
        if currentLine <= a:lineNum && theLine =~ '^[ \t]*' . left && theLine !~ '.*' . right && currentLine < s:NumLinesInBuf()
            let top = currentLine
            let currentLine = a:lineNum

        "check if the current line is the bottom of the sexy comment
        elseif theLine =~ '^[ \t]*' . right && theLine !~ '.*' . left && currentLine > 1
            let bottom = currentLine

        "the right delimiter is on the same line as the last sexyComMarker
        elseif theLine =~ '^[ \t]*' . sexyComMarker . '.*' . right
            let bottom = currentLine

        "we have not found the top or bottom line so we assume currentLine is an
        "intermediate line and look to prove otherwise
        else

            "if the line doesnt start with a sexyComMarker then it is not a sexy
            "comment
            if theLine !~ '^[ \t]*' . sexyComMarker
                return []
            endif

        endif

        "if top is -1 then we havent found the top yet so keep looking up
        if top == -1
            let currentLine = currentLine - 1
        "if we have found the top line then go down looking for the bottom
        else
            let currentLine = currentLine + 1
        endif

    endwhile

    return [top, bottom]
endfunction


" Function: s:GetSexyComMarker() {{{2
" Returns the sexy comment marker for the current filetype.
"
" C style sexy comments are assumed if possible. If not then the sexy comment
" marker is the last char of the delimiter pair that has both left and right
" delims and has the longest left delim
"
" Args:
"   -space: specifies whether the marker is to have a space string after it
"    (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the marker are to be ESCed
function s:GetSexyComMarker(space, esc)
    let sexyComMarker = b:NERDSexyComMarker

    "if there is no hardcoded marker then we find one
    if sexyComMarker == ''

        "if the filetype has c style comments then use standard c sexy
        "comments
        if s:HasCStyleComments()
            let sexyComMarker = '*'
        else
            "find a comment marker by getting the longest available left delim
            "(that has a corresponding right delim) and taking the last char
            let lenLeft = strlen(s:Left())
            let lenLeftAlt = strlen(s:Left({'alt': 1}))
            let left = ''
            let right = ''
            if s:Multipart() && lenLeft >= lenLeftAlt
                let left = s:Left()
            elseif s:AltMultipart()
                let left = s:Left({'alt': 1})
            else
                return -1
            endif

            "get the last char of left
            let sexyComMarker = strpart(left, strlen(left)-1)
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let sexyComMarker = sexyComMarker . s:spaceStr
    endif

    if a:esc
        let sexyComMarker = s:Esc(sexyComMarker)
    endif

    return sexyComMarker
endfunction

" Function: s:GetSexyComLeft(space, esc) {{{2
" Returns the left delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible
" Args:
"   -space: specifies if the delim has a space string on the end
"   (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComLeft(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let left = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let left = '/*'
    else
        "grab the longest left delim that has a right
        if s:Multipart() && lenLeft >= lenLeftAlt
            let left = s:Left()
        elseif s:AltMultipart()
            let left = s:Left({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let left = left . s:spaceStr
    endif

    if a:esc
        let left = s:Esc(left)
    endif

    return left
endfunction

" Function: s:GetSexyComRight(space, esc) {{{2
" Returns the right delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible.
" Args:
"   -space: specifies if the delim has a space string on the start
"   (the space string will only be added if NERDSpaceDelims
"   is specified for the current filetype)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComRight(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let right = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let right = '*/'
    else
        "grab the right delim that pairs with the longest left delim
        if s:Multipart() && lenLeft >= lenLeftAlt
            let right = s:Right()
        elseif s:AltMultipart()
            let right = s:Right({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let right = s:spaceStr . right
    endif

    if a:esc
        let right = s:Esc(right)
    endif

    return right
endfunction

" Function: s:HasMultipartDelims() {{{2
" Returns 1 iff the current filetype has at least one set of multipart delims
function s:HasMultipartDelims()
    return s:Multipart() || s:AltMultipart()
endfunction

" Function: s:HasLeadingTabs(...) {{{2
" Returns 1 if any of the given strings have leading tabs
function s:HasLeadingTabs(...)
    for s in a:000
        if s =~ '^\t.*'
            return 1
        end
    endfor
    return 0
endfunction
" Function: s:HasCStyleComments() {{{2
" Returns 1 iff the current filetype has c style comment delimiters
function s:HasCStyleComments()
    return (s:Left() == '/*' && s:Right() == '*/') || (s:Left({'alt': 1}) == '/*' && s:Right({'alt': 1}) == '*/')
endfunction

" Function: s:IsCommentedNormOrSexy(lineNum) {{{2
"This function is used to determine whether the given line is commented with
"either set of delimiters or if it is part of a sexy comment
"
" Args:
"   -lineNum: the line number of the line to check
function s:IsCommentedNormOrSexy(lineNum)
    let theLine = getline(a:lineNum)

    "if the line is commented normally return 1
    if s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)
        return 1
    endif

    "if the line is part of a sexy comment return 1
    if s:IsInSexyComment(a:lineNum)
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommented(left, right, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters
"
" Args:
"   -line: the line that to check if commented
"   -left/right: the left and right delimiters to check for
function s:IsCommented(left, right, line)
    "if the line isnt commented return true
    if s:FindDelimiterIndex(a:left, a:line) != -1 && (s:FindDelimiterIndex(a:right, a:line) != -1 || !s:Multipart())
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommentedFromStartOfLine(left, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters at the start of the line i.e the left delimiter is the
"first thing on the line (apart from spaces\tabs)
"
" Args:
"   -line: the line that to check if commented
"   -left: the left delimiter to check for
function s:IsCommentedFromStartOfLine(left, line)
    let theLine = s:ConvertLeadingTabsToSpaces(a:line)
    let numSpaces = strlen(substitute(theLine, '^\( *\).*$', '\1', ''))
    let delimIndx = s:FindDelimiterIndex(a:left, theLine)
    return delimIndx == numSpaces
endfunction

" Function: s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line) {{{2
" Finds the type of the outtermost delims on the line
"
" Args:
"   -line: the line that to check if the outtermost comments on it are
"    left/right
"   -left/right: the left and right delimiters to check for
"   -leftAlt/rightAlt: the left and right alternative delimiters to check for
"
" Returns:
"   0 if the line is not commented with either set of delims
"   1 if the line is commented with the left/right delim set
"   2 if the line is commented with the leftAlt/rightAlt delim set
function s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line)
    "get the first positions of the left delims and the last positions of the
    "right delims
    let indxLeft = s:FindDelimiterIndex(a:left, a:line)
    let indxLeftAlt = s:FindDelimiterIndex(a:leftAlt, a:line)
    let indxRight = s:LastIndexOfDelim(a:right, a:line)
    let indxRightAlt = s:LastIndexOfDelim(a:rightAlt, a:line)

    "check if the line has a left delim before a leftAlt delim
    if (indxLeft <= indxLeftAlt || indxLeftAlt == -1) && indxLeft != -1
        "check if the line has a right delim after any rightAlt delim
        if (indxRight > indxRightAlt && indxRight > indxLeft) || !s:Multipart()
            return 1
        endif

        "check if the line has a leftAlt delim before a left delim
    elseif (indxLeftAlt <= indxLeft || indxLeft == -1) && indxLeftAlt != -1
        "check if the line has a rightAlt delim after any right delim
        if (indxRightAlt > indxRight && indxRightAlt > indxLeftAlt) || !s:AltMultipart()
            return 2
        endif
    else
        return 0
    endif

    return 0

endfunction


" Function: s:IsDelimValid(delimiter, delIndx, line) {{{2
" This function is responsible for determining whether a given instance of a
" comment delimiter is a real delimiter or not. For example, in java the
" // string is a comment delimiter but in the line:
"               System.out.println("//");
" it does not count as a comment delimiter. This function is responsible for
" distinguishing between such cases. It does so by applying a set of
" heuristics that are not fool proof but should work most of the time.
"
" Args:
"   -delimiter: the delimiter we are validating
"   -delIndx: the position of delimiter in line
"   -line: the line that delimiter occurs in
"
" Returns:
" 0 if the given delimiter is not a real delimiter (as far as we can tell) ,
" 1 otherwise
function s:IsDelimValid(delimiter, delIndx, line)
    "get the delimiter without the escchars
    let l:delimiter = a:delimiter

    "get the strings before and after the delimiter
    let preComStr = strpart(a:line, 0, a:delIndx)
    let postComStr = strpart(a:line, a:delIndx+strlen(delimiter))

    "to check if the delimiter is real, make sure it isnt preceded by
    "an odd number of quotes and followed by the same (which would indicate
    "that it is part of a string and therefore is not a comment)
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, '"', "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "'", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "'", "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "`", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "`", "\\"))
        return 0
    endif


    "if the comment delimiter is escaped, assume it isnt a real delimiter
    if s:IsEscaped(a:line, a:delIndx, "\\")
        return 0
    endif

    "vim comments are so fuckin stupid!! Why the hell do they have comment
    "delimiters that are used elsewhere in the syntax?!?! We need to check
    "some conditions especially for vim
    if &filetype == "vim"
        if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\"))
            return 0
        endif

        "if the delimiter is on the very first char of the line or is the
        "first non-tab/space char on the line then it is a valid comment delimiter
        if a:delIndx == 0 || a:line =~ "^[ \t]\\{" . a:delIndx . "\\}\".*$"
            return 1
        endif

        let numLeftParen =s:CountNonESCedOccurances(preComStr, "(", "\\")
        let numRightParen =s:CountNonESCedOccurances(preComStr, ")", "\\")

        "if the quote is inside brackets then assume it isnt a comment
        if numLeftParen > numRightParen
            return 0
        endif

        "if the line has an even num of unescaped "'s then we can assume that
        "any given " is not a comment delimiter
        if s:IsNumEven(s:CountNonESCedOccurances(a:line, "\"", "\\"))
            return 0
        endif
    endif

    return 1

endfunction

" Function: s:IsNumEven(num) {{{2
" A small function the returns 1 if the input number is even and 0 otherwise
" Args:
"   -num: the number to check
function s:IsNumEven(num)
    return (a:num % 2) == 0
endfunction

" Function: s:IsEscaped(str, indx, escChar) {{{2
" This function takes a string, an index into that string and an esc char and
" returns 1 if the char at the index is escaped (i.e if it is preceded by an
" odd number of esc chars)
" Args:
"   -str: the string to check
"   -indx: the index into str that we want to check
"   -escChar: the escape char the char at indx may be ESCed with
function s:IsEscaped(str, indx, escChar)
    "initialise numEscChars to 0 and look at the char before indx
    let numEscChars = 0
    let curIndx = a:indx-1

    "keep going back thru str until we either reach the start of the str or
    "run out of esc chars
    while curIndx >= 0 && strpart(a:str, curIndx, 1) == a:escChar

        "we have found another esc char so add one to the count and move left
        "one char
        let numEscChars  = numEscChars + 1
        let curIndx = curIndx - 1

    endwhile

    "if there is an odd num of esc chars directly before the char at indx then
    "the char at indx is escaped
    return !s:IsNumEven(numEscChars)
endfunction

" Function: s:IsInSexyComment(line) {{{2
" returns 1 if the given line number is part of a sexy comment
function s:IsInSexyComment(line)
    return !empty(s:FindBoundingLinesOfSexyCom(a:line))
endfunction

" Function: s:IsSexyComment(topline, bottomline) {{{2
" This function takes in 2 line numbers and returns 1 if the lines between and
" including the given line numbers are a sexy comment. It returns 0 otherwise.
" Args:
"   -topline: the line that the possible sexy comment starts on
"   -bottomline: the line that the possible sexy comment stops on
function s:IsSexyComment(topline, bottomline)

    "get the delim set that would be used for a sexy comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    else
        return 0
    endif

    "swap the top and bottom line numbers around if need be
    let topline = a:topline
    let bottomline = a:bottomline
    if bottomline < topline
        topline = bottomline
        bottomline = a:topline
    endif

    "if there is < 2 lines in the comment it cannot be sexy
    if (bottomline - topline) <= 0
        return 0
    endif

    "if the top line doesnt begin with a left delim then the comment isnt sexy
    if getline(a:topline) !~ '^[ \t]*' . left
        return 0
    endif

    "if there is a right delim on the top line then this isnt a sexy comment
    if s:FindDelimiterIndex(right, getline(a:topline)) != -1
        return 0
    endif

    "if there is a left delim on the bottom line then this isnt a sexy comment
    if s:FindDelimiterIndex(left, getline(a:bottomline)) != -1
        return 0
    endif

    "if the bottom line doesnt begin with a right delim then the comment isnt
    "sexy
    if getline(a:bottomline) !~ '^.*' . right . '$'
        return 0
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "check each of the intermediate lines to make sure they start with a
    "sexyComMarker
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        if theLine !~ '^[ \t]*' . sexyComMarker
            return 0
        endif

        "if there is a right delim in an intermediate line then the block isnt
        "a sexy comment
        if s:FindDelimiterIndex(right, theLine) != -1
            return 0
        endif

        let currentLine = currentLine + 1
    endwhile

    "we have not found anything to suggest that this isnt a sexy comment so
    return 1

endfunction

" Function: s:LastIndexOfDelim(delim, str) {{{2
" This function takes a string and a delimiter and returns the last index of
" that delimiter in string
" Args:
"   -delim: the delimiter to look for
"   -str: the string to look for delim in
function s:LastIndexOfDelim(delim, str)
    let delim = a:delim
    let lenDelim = strlen(delim)

    "set index to the first occurrence of delim. If there is no occurrence then
    "bail
    let indx = s:FindDelimiterIndex(delim, a:str)
    if indx == -1
        return -1
    endif

    "keep moving to the next instance of delim in str till there is none left
    while 1

        "search for the next delim after the previous one
        let searchStr = strpart(a:str, indx+lenDelim)
        let indx2 = s:FindDelimiterIndex(delim, searchStr)

        "if we find a delim update indx to record the position of it, if we
        "dont find another delim then indx is the last one so break out of
        "this loop
        if indx2 != -1
            let indx = indx + indx2 + lenDelim
        else
            break
        endif
    endwhile

    return indx

endfunction

" Function: s:Left(...) {{{2
" returns left delimiter data
function s:Left(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['leftAlt'] : b:NERDCommenterDelims['left'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = delim . s:spaceStr
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the left most
" char (that is not a space or a tab) on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)

    " declare the left most index as an extreme value
    let leftMostIndx = 1000

    " go thru the block line by line updating leftMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and if it is allowed to be commented, or is not
        " commented, check it
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'
            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))
                " convert spaces to tabs and get the number of leading spaces for
                " this line and update leftMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let leadSpaceOfLine = strlen( substitute(theLine, '\(^[ \t]*\).*$','\1','') )
                if leadSpaceOfLine < leftMostIndx
                    let leftMostIndx = leadSpaceOfLine
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    if leftMostIndx == 1000
        return 0
    else
        return leftMostIndx
    endif
endfunction

" Function: s:Multipart() {{{2
" returns 1 if the current delims are multipart
function s:Multipart()
    return s:Right() != ''
endfunction

" Function: s:NerdEcho(msg, typeOfMsg) {{{2
" Args:
"   -msg: the message to echo
"   -typeOfMsg: 0 = warning message
"               1 = normal message
function s:NerdEcho(msg, typeOfMsg)
    if a:typeOfMsg == 0
        echohl WarningMsg
        echom 'NERDCommenter:' . a:msg
        echohl None
    elseif a:typeOfMsg == 1
        echom 'NERDCommenter:' . a:msg
    endif
endfunction

" Function: s:NumberOfLeadingTabs(s) {{{2
" returns the number of leading tabs in the given string
function s:NumberOfLeadingTabs(s)
    return strlen(substitute(a:s, '^\(\t*\).*$', '\1', ""))
endfunction

" Function: s:NumLinesInBuf() {{{2
" Returns the number of lines in the current buffer
function s:NumLinesInBuf()
    return line('$')
endfunction

" Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2
" This function takes in a string, 2 delimiters in that string and 2 strings
" to replace these delimiters with.
"
" Args:
"   -toReplace1: the first delimiter to replace
"   -toReplace2: the second delimiter to replace
"   -replacor1: the string to replace toReplace1 with
"   -replacor2: the string to replace toReplace2 with
"   -str: the string that the delimiters to be replaced are in
function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)
    let line = s:ReplaceLeftMostDelim(a:toReplace1, a:replacor1, a:str)
    let line = s:ReplaceRightMostDelim(a:toReplace2, a:replacor2, line)
    return line
endfunction

" Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the left most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
function s:ReplaceLeftMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    "get the left most occurrence of toReplace
    let indxToReplace = s:FindDelimiterIndex(toReplace, a:str)

    "if there IS an occurrence of toReplace in str then replace it and return
    "the resulting string
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
        return line
    endif

    return a:str
endfunction

" Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the right most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
"
function s:ReplaceRightMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    let lenToReplace = strlen(toReplace)

    "get the index of the last delim in str
    let indxToReplace = s:LastIndexOfDelim(toReplace, a:str)

    "if there IS a delimiter in str, replace it and return the result
    let line = a:str
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
    endif
    return line
endfunction

"FUNCTION: s:RestoreScreenState() {{{2
"
"Sets the screen state back to what it was when s:SaveScreenState was last
"called.
"
function s:RestoreScreenState()
    if !exists("t:NERDComOldTopLine") || !exists("t:NERDComOldPos")
        throw 'NERDCommenter exception: cannot restore screen'
    endif

    call cursor(t:NERDComOldTopLine, 0)
    normal! zt
    call setpos(".", t:NERDComOldPos)
endfunction

" Function: s:Right(...) {{{2
" returns right delimiter data
function s:Right(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['rightAlt'] : b:NERDCommenterDelims['right'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = s:spaceStr . delim
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the right most
" char on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)
    let rightMostIndx = -1

    " go thru the block line by line updating rightMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and see if it is commentable, otherwise it doesnt
        " count
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'

            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))

                " update rightMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let lineLen = strlen(theLine)
                if lineLen > rightMostIndx
                    let rightMostIndx = lineLen
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    return rightMostIndx
endfunction

"FUNCTION: s:SaveScreenState() {{{2
"Saves the current cursor position in the current buffer and the window
"scroll position
function s:SaveScreenState()
    let t:NERDComOldPos = getpos(".")
    let t:NERDComOldTopLine = line("w0")
endfunction

" Function: s:SwapOutterMultiPartDelimsForPlaceHolders(line) {{{2
" This function takes a line and swaps the outter most multi-part delims for
" place holders
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterMultiPartDelimsForPlaceHolders(line)
    " find out if the line is commented using normal delims and/or
    " alternate ones
    let isCommented = s:IsCommented(s:Left(), s:Right(), a:line)
    let isCommentedAlt = s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), a:line)

    let line2 = a:line

    "if the line is commented and there is a right delimiter, replace
    "the delims with place-holders
    if isCommented && s:Multipart()
        let line2 = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, a:line)

    "similarly if the line is commented with the alternative
    "delimiters
    elseif isCommentedAlt && s:AltMultipart()
        let line2 = s:ReplaceDelims(s:Left({'alt': 1}), s:Right({'alt': 1}), g:NERDLPlace, g:NERDRPlace, a:line)
    endif

    return line2
endfunction

" Function: s:SwapOutterPlaceHoldersForMultiPartDelims(line) {{{2
" This function takes a line and swaps the outtermost place holders for
" multi-part delims
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterPlaceHoldersForMultiPartDelims(line)
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    endif

    let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, a:line)
    return line
endfunction
" Function: s:TabbedCol(line, col) {{{2
" Gets the col number for given line and existing col number. The new col
" number is the col number when all leading spaces are converted to tabs
" Args:
"   -line:the line to get the rel col for
"   -col: the abs col
function s:TabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineSpacesToTabs = substitute(lineTruncated, s:TabSpace(), '\t', 'g')
    return strlen(lineSpacesToTabs)
endfunction
"FUNCTION: s:TabSpace() {{{2
"returns a string of spaces equal in length to &tabstop
function s:TabSpace()
    let tabSpace = ""
    let spacesPerTab = &tabstop
    while spacesPerTab > 0
        let tabSpace = tabSpace . " "
        let spacesPerTab = spacesPerTab - 1
    endwhile
    return tabSpace
endfunction

" Function: s:UnEsc(str, escChar) {{{2
" This function removes all the escape chars from a string
" Args:
"   -str: the string to remove esc chars from
"   -escChar: the escape char to be removed
function s:UnEsc(str, escChar)
    return substitute(a:str, a:escChar, "", "g")
endfunction

" Function: s:UntabbedCol(line, col) {{{2
" Takes a line and a col and returns the absolute column of col taking into
" account that a tab is worth 3 or 4 (or whatever) spaces.
" Args:
"   -line:the line to get the abs col for
"   -col: the col that doesnt take into account tabs
function s:UntabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineTabsToSpaces = substitute(lineTruncated, '\t', s:TabSpace(), 'g')
    return strlen(lineTabsToSpaces)
endfunction
" Section: Comment mapping and menu item setup {{{1
" ===========================================================================

" Create menu items for the specified modes.  If a:combo is not empty, then
" also define mappings and show a:combo in the menu items.
function! s:CreateMaps(modes, target, desc, combo)
    " Build up a map command like
    " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'
    let plug = '<plug>NERDCommenter' . a:target
    let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'
    let plug_end = '", "' . a:target . '")<cr>'
    " Build up a menu command like
    " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'
    let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'],
                \ g:NERDMenuMode, '')
    let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
    if strlen(a:combo)
        let leader = exists('g:mapleader') ? g:mapleader : '\'
        let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
    endif
    let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
    " Execute the commands built above for each requested mode.
    for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')
        if strlen(a:combo)
            execute mode . plug_start . mode . plug_end
            if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                execute mode . 'map <leader>' . a:combo . ' ' . plug
            endif
        endif
        " Check if the user wants the menu to be displayed.
        if g:NERDMenuMode != 0
            execute mode . menu_command
        endif
    endfor
endfunction
call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')
call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
call s:CreateMaps('n',  'Append',     'Append', 'cA')
call s:CreateMaps('',   ':',          '-Sep-', '')
call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
call s:CreateMaps('',   ':',          '-Sep2-', '')
call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
call s:CreateMaps('',   ':',          '-Sep3-', '')
call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')

inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>

" switch to/from alternative delimiters (does not use wrapper function)
nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>
" vim: set foldmethod=marker :
zhimakaimen:/plugin/NERD_commenter.vim
au BufNewFile,BufRead *.sv,*.svi,*.svh	set filetype=systemverilog
zhimakaimen:/ftdetect/systemverilog.vim
# snippets for making snippets :)
snippet snip
	snippet ${1:trigger}
		${2}
snippet msnip
	snippet ${1:trigger} ${2:description}
		${3}
zhimakaimen:/snippets/snippet.snippets
# #!/bin/zsh
snippet #!
	#!/bin/zsh

snippet if
	if ${1:condition}; then
		${2:# statements}
	fi
snippet ife
	if ${1:condition}; then
		${2:# statements}
	else
		${3:# statements}
	fi
snippet elif
	elif ${1:condition} ; then
		${2:# statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:# statements}
	done
snippet fore
	for ${1:item} in ${2:list}; do
		${3:# statements}
	done
snippet wh
	while ${1:condition}; do
		${2:# statements}
	done
snippet until
	until ${1:condition}; do
		${2:# statements}
	done
snippet repeat
	repeat ${1:integer}; do
		${2:# statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
snippet select
	select ${1:answer} in ${2:choices}; do
		${3:# statements}
	done
snippet (
	( ${1:#statements} )
snippet {
	{ ${1:#statements} }
snippet [
	[[ ${1:test} ]]
snippet always
	{ ${1:try} } always { ${2:always} }
snippet fun
	function ${1:name} (${2:args}) {
		${3:# body}
	}
zhimakaimen:/snippets/zsh.snippets
# #!/bin/bash
snippet #!
	#!/bin/bash
	
snippet if
	if [[ ${1:condition} ]]; then
		${2:#statements}
	fi
snippet elif
	elif [[ ${1:condition} ]]; then
		${2:#statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:#statements}
	done
snippet wh
	while [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet until
	until [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
zhimakaimen:/snippets/sh.snippets
# #import <...>
snippet Imp
	#import <${1:Cocoa/Cocoa.h}>${2}
# #import "..."
snippet imp
	#import "${1:`Filename()`.h}"${2}
# @selector(...)
snippet sel
	@selector(${1:method}:)${3}
# @"..." string
snippet s
	@"${1}"${2}
# Object
snippet o
	${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};${5}
# NSLog(...)
snippet log
	NSLog(@"${1:%@}"${2});${3}
# Class
snippet objc
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{
	}
	@end

	@implementation $1
	${3}
	@end
# Class Interface
snippet int
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
snippet @interface
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
# Class Implementation
snippet impl
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
snippet @implementation
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
# Protocol
snippet pro
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
snippet @protocol
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
# init Definition
snippet init
	- (id)init
	{
		if (self = [super init]) {
			${1}
		}
		return self;
	}
# dealloc Definition
snippet dealloc
	- (void) dealloc
	{
		${1:deallocations}
		[super dealloc];
	}
snippet su
	[super ${1:init}]${2}
snippet ibo
	IBOutlet ${1:NSSomeClass} *${2:$1};${3}
# Category
snippet cat
	@interface ${1:NSObject} (${2:MyCategory})
	@end

	@implementation $1 ($2)
	${3}
	@end
# Category Interface
snippet cath
	@interface ${1:`Filename('$1', 'NSObject')`} (${2:MyCategory})
	${3}
	@end
# Method
snippet m
	- (${1:id})${2:method}
	{
		${3}
	}
# Method declaration
snippet md
	- (${1:id})${2:method};${3}
# IBAction declaration
snippet ibad
	- (IBAction)${1:method}:(${2:id})sender;${3}
# IBAction method
snippet iba
	- (IBAction)${1:method}:(${2:id})sender
	{
		${3}
	}
# awakeFromNib method
snippet wake
	- (void)awakeFromNib
	{
		${1}
	}
# Class Method
snippet M
	+ (${1:id})${2:method}
	{
		${3:return nil;}
	}
# Sub-method (Call super)
snippet sm
	- (${1:id})${2:method}
	{
		[super $2];${3}
		return self;
	}
# Accessor Methods For:
# Object
snippet objacc
	- (${1:id})${2:thing}
	{
		return $2;
	}

	- (void)set$2:($1)${3:new$2}
	{
		[$3 retain];
		[$2 release];
		$2 = $3;
	}${4}
# for (object in array)
snippet forin
	for (${1:Class} *${2:some$1} in ${3:array}) {
		${4}
	}
snippet fore
	for (${1:object} in ${2:array}) {
		${3:statements}
	}
snippet forarray
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
snippet fora
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
# Try / Catch Block
snippet	@try
	@try {
		${1:statements}
	}
	@catch (NSException * e) {
		${2:handler}
	}
	@finally {
		${3:statements}
	}
snippet @catch
	@catch (${1:exception}) {
		${2:handler}
	}
snippet @finally
	@finally {
		${1:statements}
	}
# IBOutlet
# @property (Objective-C 2.0)
snippet prop
	@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};${4}
# @synthesize (Objective-C 2.0)
snippet syn
	@synthesize ${1:property};${2}
# [[ alloc] init]
snippet alloc
	[[${1:foo} alloc] init${2}];${3}
snippet a
	[[${1:foo} alloc] init${2}];${3}
# retain
snippet ret
	[${1:foo} retain];${2}
# release
snippet rel
	[${1:foo} release];
# autorelease
snippet arel
	[${1:foo} autorelease];
# autorelease pool
snippet pool
	NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];
	${2:/* code */}
	[$1 drain];
# Throw an exception
snippet except
	NSException *${1:badness};
	$1 = [NSException exceptionWithName:@"${2:$1Name}"
	                             reason:@"${3}"
	                           userInfo:nil];
	[$1 raise];
snippet prag
	#pragma mark ${1:-}
snippet cl
	@class ${1:Foo};${2}
snippet color
	[[NSColor ${1:blackColor}] set];
# NSArray
snippet array
	NSMutableArray *${1:array} = [NSMutable array];${2}
snippet nsa
	NSArray ${1}
snippet nsma
	NSMutableArray ${1}
snippet aa
	NSArray * array;${1}
snippet ma
	NSMutableArray * array;${1}
# NSDictionary
snippet dict
	NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];${2}
snippet nsd
	NSDictionary ${1}
snippet nsmd
	NSMutableDictionary ${1}
# NSString
snippet nss
	NSString ${1}
snippet nsms
	NSMutableString ${1}
zhimakaimen:/snippets/objc.snippets
snippet php
	<?php
	${1}
	?>
snippet ec
	echo "${1:string}"${2};
snippet inc
	include '${1:file}';${2}
snippet inc1
	include_once '${1:file}';${2}
snippet req
	require '${1:file}';${2}
snippet req1
	require_once '${1:file}';${2}
# $GLOBALS['...']
snippet globals
	$GLOBALS['${1:variable}']${2: = }${3:something}${4:;}${5}
snippet $_ COOKIE['...']
	$_COOKIE['${1:variable}']${2}
snippet $_ ENV['...']
	$_ENV['${1:variable}']${2}
snippet $_ FILES['...']
	$_FILES['${1:variable}']${2}
snippet $_ Get['...']
	$_GET['${1:variable}']${2}
snippet $_ POST['...']
	$_POST['${1:variable}']${2}
snippet $_ REQUEST['...']
	$_REQUEST['${1:variable}']${2}
snippet $_ SERVER['...']
	$_SERVER['${1:variable}']${2}
snippet $_ SESSION['...']
	$_SESSION['${1:variable}']${2}
# Start Docblock
snippet /*
	/**
	 * ${1}
	 **/
# Class - post doc
snippet doc_cp
	/**
	 * ${1:undocumented class}
	 *
	 * @package ${2:default}
	 * @author ${3:`g:snips_author`}
	**/${4}
# Class Variable - post doc
snippet doc_vp
	/**
	 * ${1:undocumented class variable}
	 *
	 * @var ${2:string}
	 **/${3}
# Class Variable
snippet doc_v
	/**
	 * ${3:undocumented class variable}
	 *
	 * @var ${4:string}
	 **/
	${1:var} $${2};${5}
# Class
snippet doc_c
	/**
	 * ${3:undocumented class}
	 *
	 * @packaged ${4:default}
	 * @author ${5:`g:snips_author`}
	 **/
	${1:}class ${2:}
	{${6}
	} // END $1class $2
# Constant Definition - post doc
snippet doc_dp
	/**
	 * ${1:undocumented constant}
	 **/${2}
# Constant Definition
snippet doc_d
	/**
	 * ${3:undocumented constant}
	 **/
	define(${1}, ${2});${4}
# Function - post doc
snippet doc_fp
	/**
	 * ${1:undocumented function}
	 *
	 * @return ${2:void}
	 * @author ${3:`g:snips_author`}
	 **/${4}
# Function signature
snippet doc_s
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3});${7}
# Function
snippet doc_f
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3})
	{${7}
	}
# Header
snippet doc_h
	/**
	 * ${1}
	 *
	 * @author ${2:`g:snips_author`}
	 * @version ${3:$Id$}
	 * @copyright ${4:$2}, `strftime('%d %B, %Y')`
	 * @package ${5:default}
	 **/
	
	/**
	 * Define DocBlock
	 *//
# Interface
snippet doc_i
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 **/
	interface ${1:}
	{${5}
	} // END interface $1
# class ...
snippet class
	/**
	 * ${1}
	 **/
	class ${2:ClassName}
	{
		${3}
		function ${4:__construct}(${5:argument})
		{
			${6:// code...}
		}
	}
# define(...)
snippet def
	define('${1}'${2});${3}
# defined(...)
snippet def?
	${1}defined('${2}')${3}
snippet wh
	while (${1:/* condition */}) {
		${2:// code...}
	}
# do ... while
snippet do
	do {
		${2:// code... }
	} while (${1:/* condition */});
snippet if
	if (${1:/* condition */}) {
		${2:// code...}
	}
snippet ife
	if (${1:/* condition */}) {
		${2:// code...}
	} else {
		${3:// code...}
	}
	${4}
snippet else
	else {
		${1:// code...}
	}
snippet elseif
	elseif (${1:/* condition */}) {
		${2:// code...}
	}
# Tertiary conditional
snippet t
	$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};${5}
snippet switch
	switch ($${1:variable}) {
		case '${2:value}':
			${3:// code...}
			break;
		${5}
		default:
			${4:// code...}
			break;
	}
snippet case
	case '${1:value}':
		${2:// code...}
		break;${3}
snippet for
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4: // code...}
	}
snippet foreach
	foreach ($${1:variable} as $${2:key}) {
		${3:// code...}
	}
snippet fun
	${1:public }function ${2:FunctionName}(${3})
	{
		${4:// code...}
	}
# $... = array (...)
snippet array
	$${1:arrayName} = array('${2}' => ${3});${4}
zhimakaimen:/snippets/php.snippets
# #!/usr/bin/perl
snippet #!
	#!/usr/bin/perl

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	}
	else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression} if ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression} unless ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression} while ${2:condition};${3}
# C-style For Loop
snippet cfor
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4:# body...}
	}
# For loop one-line
snippet xfor
	${1:expression} for @${2:array};${3}
# Foreach Loop
snippet for
	foreach my $${1:x} (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet fore
	${1:expression} foreach @${2:array};${3}
# Package
snippet cl
	package ${1:ClassName};

	use base qw(${2:ParentClass});

	sub new {
		my $class = shift;
		$class = ref $class if ref $class;
		my $self = bless {}, $class;
		$self;
	}

	1;${3}
# Read File
snippet slurp
	my $${1:var};
	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}
zhimakaimen:/snippets/perl.snippets
# \begin{}...\end{}
snippet begin
	\begin{${1:env}}
		${2}
	\end{$1}
# Tabular
snippet tab
	\begin{${1:tabular}}{${2:c}}
	${3}
	\end{$1}
# Align(ed)
snippet ali
	\begin{align${1:ed}}
		${2}
	\end{align$1}
# Gather(ed)
snippet gat
	\begin{gather${1:ed}}
		${2}
	\end{gather$1}
# Equation
snippet eq
	\begin{equation}
		${1}
	\end{equation}
# Unnumbered Equation
snippet \
	\\[
		${1}
	\\]
# Enumerate
snippet enum
	\begin{enumerate}
		\item ${1}
	\end{enumerate}
# Itemize
snippet item
	\begin{itemize}
		\item ${1}
	\end{itemize}
# Description
snippet desc
	\begin{description}
		\item[${1}] ${2}
	\end{description}
# Matrix
snippet mat
	\begin{${1:p/b/v/V/B/small}matrix}
		${2}
	\end{$1matrix}
# Cases
snippet cas
	\begin{cases}
		${1:equation}, &\text{ if }${2:case}\\
		${3}
	\end{cases}
# Split
snippet spl
	\begin{split}
		${1}
	\end{split}
# Part
snippet part
	\part{${1:part name}} % (fold)
	\label{prt:${2:$1}}
	${3}
	% part $2 (end)
# Chapter
snippet cha
	\chapter{${1:chapter name}} % (fold)
	\label{cha:${2:$1}}
	${3}
	% chapter $2 (end)
# Section
snippet sec
	\section{${1:section name}} % (fold)
	\label{sec:${2:$1}}
	${3}
	% section $2 (end)
# Sub Section
snippet sub
	\subsection{${1:subsection name}} % (fold)
	\label{sub:${2:$1}}
	${3}
	% subsection $2 (end)
# Sub Sub Section
snippet subs
	\subsubsection{${1:subsubsection name}} % (fold)
	\label{ssub:${2:$1}}
	${3}
	% subsubsection $2 (end)
# Paragraph
snippet par
	\paragraph{${1:paragraph name}} % (fold)
	\label{par:${2:$1}}
	${3}
	% paragraph $2 (end)
# Sub Paragraph
snippet subp
	\subparagraph{${1:subparagraph name}} % (fold)
	\label{subp:${2:$1}}
	${3}
	% subparagraph $2 (end)
snippet itd
	\item[${1:description}] ${2:item}
snippet figure
	${1:Figure}~\ref{${2:fig:}}${3}
snippet table
	${1:Table}~\ref{${2:tab:}}${3}
snippet listing
	${1:Listing}~\ref{${2:list}}${3}
snippet section
	${1:Section}~\ref{${2:sec:}}${3}
snippet page
	${1:page}~\pageref{${2}}${3}
zhimakaimen:/snippets/tex.snippets
# a farbox header snip
snippet til
	Title: ${1}
	Status: ${2:Public}
	Tags: ${3}
	Date: time${4}

	[TOC]
# a code block snip
# a bug occurs starting with ``
snippet code
	```${1:verilog}
	${2}
	```

# a Tex numbered equation block snip
snippet equ
	$$
	\begin{equation}
		${1:your equation}
	\end{equation}
	$$

# \begin{}...\end{}
snippet begin
	$$
	\begin{${1:env}}
		${2}
	\end{$1}
	$$

# linker snip
snippet lin
	[${1}](${2:http://}${3})

zhimakaimen:/snippets/markdown.snippets
# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet req
	require "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet deft
	def test_${1:case_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end		
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end	
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eaid
	each_index do |${1:i}|
	end
snippet eak
	each_key { |${1:key}| ${2} }
snippet eakd
	each_key do |${1:key}|
		${2}
	end
snippet eal
	each_line { |${1:line}| ${2} }
snippet eald
	each_line do |${1:line}|
		${2}
	end		
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${3}
	end			
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet easd-
	each_slice(${1:2}) do |${2:group}|
		${3}
	end		
snippet eav
	each_value { |${1:val}| ${2} }
snippet eavd
	each_value do |${1:val}| 
		${2}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet eawid
	each_with_index do |${1:e},${2:i}|
		${3}
	end
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet reved
	reverse_each do |${1:e}|
		${2}
	end	
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end		
snippet map
	map { |${1:e}| ${2} }
snippet mapd
	map do |${1:e}| 
		${2}
	end		
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet cold
	collect do |${1:e}|
		${2}
	end
snippet det
	detect { |${1:e}| ${2} }
snippet detd
	detect do |${1:e}|
		${2}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet find
	find do |${1:e}|
		${2}
	end		
snippet fina
	find_all { |${1:e}| ${2} }
snippet finad
	find_all do |${1:e}|
		${2}
	end			
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end		
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet pard
	partition do |${1:e}|
		${2}
	end		
snippet rej
	reject { |${1:e}| ${2} }
snippet rejd
	reject do |${1:e}|
		${2}
	end
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end		
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet :
	:${1:key} => ${2:"value"}${3}
snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
snippet patfh
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end
zhimakaimen:/snippets/ruby.snippets
# module and export all
snippet mod
	-module(${1:`Filename('', 'my')`}).
	
	-compile([export_all]).
	
	start() ->
	    ${2}
	
	stop() ->
	    ok.
# define directive
snippet def
	-define(${1:macro}, ${2:body}).${3}
# export directive
snippet exp
	-export([${1:function}/${2:arity}]).
# include directive
snippet inc
	-include("${1:file}").${2}
# behavior directive
snippet beh
	-behaviour(${1:behaviour}).${2}
# if expression
snippet if
	if
	    ${1:guard} ->
	        ${2:body}
	end
# case expression
snippet case
	case ${1:expression} of
	    ${2:pattern} ->
	        ${3:body};
	end
# record directive
snippet rec
	-record(${1:record}, {
	    ${2:field}=${3:value}}).${4}
zhimakaimen:/snippets/erlang.snippets
# Read File Into Vector
snippet readfile
	std::vector<char> v;
	if (FILE *${2:fp} = fopen(${1:"filename"}, "r")) {
		char buf[1024];
		while (size_t len = fread(buf, 1, sizeof(buf), $2))
			v.insert(v.end(), buf, buf + len);
		fclose($2);
	}${3}
# std::map
snippet map
	std::map<${1:key}, ${2:value}> map${3};
# std::vector
snippet vector
	std::vector<${1:char}> v${2};
# Namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* $1 */
# Class
snippet cl
	class ${1:`Filename('$1_t', 'name')`} {
	public:
		$1 (${2:arguments});
		virtual ~$1 ();

	private:
		${3:/* data */}
	};
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4:/* code */}
	}
zhimakaimen:/snippets/cpp.snippets
snippet #!
	#!/usr/bin/env python

snippet imp
	import ${1:module}
# Module Docstring
snippet docs
	'''
	File: ${1:`Filename('$1.py', 'foo.py')`}
	Author: ${2:`g:snips_author`}
	Description: ${3}
	'''
snippet wh
	while ${1:condition}:
		${2:# code...}
snippet for
	for ${1:needle} in ${2:haystack}:
		${3:# code...}
# New Class
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${6}
# New Function
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${4:pass}
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${3}
# New Method
snippet defs
	def ${1:mname}(self, ${2:arg}):
		${3:pass}
# New Property
snippet property
	def ${1:foo}():
		doc = "${2:The $1 property.}"
		def fget(self):
			${3:return self._$1}
		def fset(self, value):
			${4:self._$1 = value}
# Lambda
snippet ld
	${1:var} = lambda ${2:vars} : ${3:action}
snippet .
	self.
snippet try Try/Except
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
snippet try Try/Except/Else
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
snippet try Try/Except/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	finally:
		${5:pass}
snippet try Try/Except/Else/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
	finally:
		${6:pass}
# if __name__ == '__main__':
snippet ifmain
	if __name__ == '__main__':
		${1:main()}
# __magic__
snippet _
	__${1:init}__${2}
zhimakaimen:/snippets/python.snippets
snippet header
	" File: ${1:`expand('%:t')`}
	" Author: ${2:`g:snips_author`}
	" Description: ${3}
	${4:" Last Modified: `strftime("%B %d, %Y")`}
snippet guard
	if exists('${1:did_`Filename()`}') || &cp${2: || version < 700}
		finish
	endif
	let $1 = 1${3}
snippet f
	fun ${1:function_name}(${2})
		${3:" code}
	endf
snippet for
	for ${1:needle} in ${2:haystack}
		${3:" code}
	endfor
snippet wh
	while ${1:condition}
		${2:" code}
	endw
snippet if
	if ${1:condition}
		${2:" code}
	endif
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	endif
zhimakaimen:/snippets/vim.snippets
snippet .
	.${1:class_name}
	{
		${2:font-size:}
	}
	
snippet sel
	${1:selector_name}
	{
		${2:font-size:}
	}
	
snippet #
	#${1:id_name}
	{
		${2:font-size:}
	}
zhimakaimen:/snippets/css.snippets
zhimakaimen:/snippets/.gitignore
snippet if
	If ${1:condition} Then
		${2:; True code}
	EndIf
snippet el
	Else
		${1}
snippet elif
	ElseIf ${1:condition} Then
		${2:; True code}
# If/Else block
snippet ifel
	If ${1:condition} Then
		${2:; True code}
	Else
		${3:; Else code}
	EndIf
# If/ElseIf/Else block
snippet ifelif
	If ${1:condition 1} Then
		${2:; True code}
	ElseIf ${3:condition 2} Then
		${4:; True code}
	Else
		${5:; Else code}
	EndIf
# Switch block
snippet switch
	Switch (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSwitch
# Select block
snippet select
	Select (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSelect
# While loop
snippet while
	While (${1:condition})
		${2:; code...}
	WEnd
# For loop
snippet for
	For ${1:n} = ${3:1} to ${2:count}
		${4:; code...}
	Next
# New Function
snippet func
	Func ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${4:Return}
	EndFunc
# Message box
snippet msg
	MsgBox(${3:MsgType}, ${1:"Title"}, ${2:"Message Text"})
# Debug Message
snippet debug
	MsgBox(0, "Debug", ${1:"Debug Message"})
# Show Variable Debug Message
snippet showvar
	MsgBox(0, "${1:VarName}", $1)
zhimakaimen:/snippets/autoit.snippets
# #!/usr/bin/env tclsh
snippet #!
	#!/usr/bin/env tclsh
	
# Process
snippet pro
	proc ${1:function_name} {${2:args}} {
		${3:#body ...}
	}
#xif
snippet xif
	${1:expr}? ${2:true} : ${3:false}
# Conditional
snippet if
	if {${1}} {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if {${1}} {
		${2:# body...}
	} else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if {${1}} {
		${2:# body...}
	} elseif {${3}} {
		${4:# elsif...}
	} else {
		${5:# else...}
	}
# If catch then
snippet ifc
	if { [catch {${1:#do something...}} ${2:err}] } {
		${3:# handle failure...}
	}
# Catch
snippet catch
	catch {${1}} ${2:err} ${3:options}
# While Loop
snippet wh
	while {${1}} {
		${2:# body...}
	}
# For Loop
snippet for
	for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {
		${4:# body...}
	}
# Foreach Loop
snippet fore
	foreach ${1:x} {${2:#list}} {
		${3:# body...}
	}
# after ms script...
snippet af
	after ${1:ms} ${2:#do something}
# after cancel id
snippet afc
	after cancel ${1:id or script}
# after idle
snippet afi
	after idle ${1:script}
# after info id
snippet afin
	after info ${1:id}
# Expr
snippet exp
	expr {${1:#expression here}}
# Switch
snippet sw
	switch ${1:var} {
		${3:pattern 1} {
			${4:#do something}
		}
		default {
			${2:#do something}
		}
	}
# Case
snippet ca
	${1:pattern} {
		${2:#do something}
	}${3}
# Namespace eval
snippet ns
	namespace eval ${1:path} {${2:#script...}}
# Namespace current
snippet nsc
	namespace current
zhimakaimen:/snippets/tcl.snippets
# a verilog header 
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Device: ${2:EP2C35}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//
# the revision details
snippet rev
	
	//`strftime("%c")`: ${1:created}
# module extract
snippet mod
	module ${1:name_of_module} 
	(
		${2:input}
	);
	endmodule
# module with parameters
snippet mp
	module ${1:name_of_module} 
	#(
	//parameter declaration
		parameter
	)
	(
		${2:input}
	);
	endmodule
# initial block
snippet ini
	initial
	begin
		${1:/*statements*/}
	end
# begin-end pair
snippet beg
	begin
		${1:/*statements*/}
	end
# fork-join pair
snippet fo
	fork
		${1:/*statements*/}
	join
# a wire variables declare
snippet wire
	wire [${2:7}:${1:0}] ${3:/*variables*/};
# a reg variables declare 
snippet reg
	reg [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare
snippet input
	input [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet output
	output [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet inout
	inout [${2:7}:${1:0}] ${3:/*variables*/};
# module inst boost
snippet inst a autoinst snip
	${1:name_of_module} m$1 
	(/*autoinst*/);
# inst with parameters
snippet ip
	${1:name_of_module} 
	#(/*autoinstparam*/)
	m$1 
	(/*autoinst*/);

# else if statement
# snippet eif
# 	else if (${1} ${2:=}= ${3})
# 	begin
# 		${4:/*statements*/}
# 	end
# if statement
snippet if
	if (${1:a} ${2:=}= ${3:b})
	begin
		${4:/*statements*/}
	end
# assign statement
snippet ass
	assign
		${1} = ${2};
# always block statement
snippet alw a combinational always block
	always @(${1:/*autosense*/})
	begin
		${2:/*statements*/}
	end
snippet alw a clk triggered always block
	always @(${1:pos}edge ${2:clk})
	begin
		${3:/*statements*/}
	end
snippet alw a clk triggered always block with reset signal
	always @(${1:pos}edge ${2:clk} or ${3:neg}edge ${4:rst_n})
	begin
		if (!$4)
		begin
			${5:/*autoreset*/}
		end
		else
		begin
			${6:/*statements*/}
		end
	end
# time scale statement
snippet ts
	`timescale 1ns/${1:100ps}
# include statement
snippet inc
	`include "${1:define}.v"
# else block
snippet else
	else
	begin
		${1}
	end
# an inc snip
snippet acc
	${1:var} <= $1 + ${2:8}'d1;
# state machine snip
snippet sm
	//state reg
	(* syn_encoding = "safe" *)reg [${1:7}:0] ns_$2, cs_${2:mmm};
	//state parameters
	localparam 
		${5:sIDLE} = 0,
	always @(posedge ${3:clk} or negedge ${4:rst_n})
		if (!$4)
			cs_$2 <= $5;
		else
			cs_$2 <= ns_$2;

	always @(*)
	begin
		ns_$2 = cs_$2;
		case (cs_$2)
			$5:
			default:
				ns_$2 = $5;
		endcase
	end
# parameterized bit oprand
snippet p0
	{(${1:pWIDTH}){1'b0}};
snippet p1
	{{(${1:pWIDTH}-1){1'b0}}, 1'b1};
# Altera Synthesis Attributes
snippet sa full case
	(* full_case *)
snippet sa parallel case
	(* parallel_case *)
snippet sa keep
	(* keep *)
snippet sa preserve
	(* preserve *)
snippet sa noprune
	(* noprune *)
snippet sa encoding
	(* syn_encoding = "safe" *)
# end of verilog snippets

zhimakaimen:/snippets/verilog.snippets
# my snippet

The verilog.snippets file is with verilog-mode compatibility.
zhimakaimen:/snippets/README.markdown
#derived from verilog.snippets
# a header 
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Device: ${2}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//
# the revision details
snippet rev
	
	//`strftime("%c")`: ${1:created}
# module extract
snippet mod
	module ${1:name_of_module} 
	(
		${2:input}
	);
	endmodule: $1
# module with parameters
snippet mp
	module ${1:name_of_module} 
	#(
	//parameter declaration
		parameter
	)
	(
		${2:input}
	);
	endmodule: $1
# package
snippet pk
	package ${1};
	endpackage
# class
snippet cl
	class ${1:foo};
		function new();
		endfunction
	endclass: $1
# constraint
snippet cons
	constraint ${1}{
		${2}
	};
# property
snippet pro
	property ${1};
	endproperty
# sequence
snippet seq
	sequence ${1};
	endsequence
# covergroup
snippet cov
	covergroup ${1};
	endgroup
# function
snippet fun
	function ${1:void} ${2:foo} (
	);
		${4}
	endfunction: $2
# task
snippet task
	task ${1:foo} (
	);
	endtask: $1
# initial block
snippet ini
	initial
	begin
		${1:}
	end
# begin-end pair
snippet beg
	begin
		${1:}
	end
# fork-join pair
snippet fo
	fork
		${1:}
	join
# a wire variables declare
snippet wire
	wire [${2:7}:${1:0}] ${3:/*variables*/};
# a reg variables declare 
snippet reg
	reg [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare
snippet input
	input [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet output
	output [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet inout
	inout [${2:7}:${1:0}] ${3:/*variables*/};
# module inst boost
snippet inst a autoinst snip
	${1:name_of_module} m$1 
	(/*autoinst*/);
# inst with parameters
snippet ip
	${1:name_of_module} 
	#(/*autoinstparam*/)
	m$1 
	(/*autoinst*/);

# else if statement
# snippet eif
# 	else if (${1} ${2:=}= ${3})
# 	begin
# 		${4:/*statements*/}
# 	end
# if statement
snippet if
	if (${1:a} ${2:=}= ${3:b})
	begin
		${4:/*statements*/}
	end
# assign statement
snippet ass
	assign
		${1} = ${2};
# always block statement
snippet alw a combinational always block
	always @(${1:/*autosense*/})
	begin
		${2:/*statements*/}
	end
snippet alw a clk triggered always block
	always @(${1:pos}edge ${2:clk})
	begin
		${3:/*statements*/}
	end
snippet alw a clk triggered always block with reset signal
	always @(${1:pos}edge ${2:clk} or ${3:neg}edge ${4:rst_n})
	begin
		if (!$4)
		begin
			${5:/*autoreset*/}
		end
		else
		begin
			${6:/*statements*/}
		end
	end
# time scale statement
snippet ts
	`timescale 1ns/${1:100ps}
# include statement
snippet inc
	`include "${1:define}.v"
# else block
snippet else
	else
	begin
		${1}
	end
# an inc snip
snippet acc
	${1:var} <= $1 + ${2:8}'d1;
# state machine snip
snippet sm
	//state reg
	(* syn_encoding = "safe" *)reg [${1:7}:0] ns_$2, cs_${2:mmm};
	//state parameters
	localparam 
		${5:sIDLE} = 0,
	always @(posedge ${3:clk} or negedge ${4:rst_n})
		if (!$4)
			cs_$2 <= $5;
		else
			cs_$2 <= ns_$2;

	always @(*)
	begin
		ns_$2 = cs_$2;
		case (cs_$2)
			$5:
			default:
				ns_$2 = $5;
		endcase
	end
# parameterized bit oprand
snippet p0
	{(${1:pWIDTH}){1'b0}};
snippet p1
	{{(${1:pWIDTH}-1){1'b0}}, 1'b1};
# Altera Synthesis Attributes
snippet sa full case
	(* full_case *)
snippet sa parallel case
	(* parallel_case *)
snippet sa keep
	(* keep *)
snippet sa preserve
	(* preserve *)
snippet sa noprune
	(* noprune *)
snippet sa encoding
	(* syn_encoding = "safe" *)
#display
snippet dis basic
	$display("${1}");
snippet dis with timestamp
	$display("[@%t]----->", $stime);
# info
snippet info info
	`uvm_info("${2}", "${3}", UVM_${1:MEDIUM})
snippet info warning
	`uvm_warning("${1}", "${2}")
snippet info error
	`uvm_error("${1}", "${2}")
snippet info fatal
	`uvm_fatal("${1}", "${2}")
# uvm components
snippet com component
	class ${1:foo} extends uvm_${2:component};
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com test
	class ${1:foo} extends uvm_test;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com env
	class ${1:foo} extends uvm_env;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com agent
	class ${1:foo} extends uvm_agent;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com scoreboard
	class ${1:foo} extends uvm_scoreboard;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com driver
	class ${1:foo} extends uvm_driver;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com monitor
	class ${1:foo} extends uvm_monitor;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com subscriber
	class ${1:foo} extends uvm_subscriber;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com sequencer
	class ${1:foo} extends uvm_sequencer;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
# uvm objects
snippet obj object
	class ${1:foo} extends uvm_${2:object};
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
	endclass
snippet obj transaction
	class ${1:foo} extends uvm_sequence_item;
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
	endclass
snippet obj sequence
	class ${1:foo} extends uvm_sequence;
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
		task body();
		endtask
	endclass
# config db 
snippet set config db
	uvm_config_db #(${1})::set(${2:null}, "${3:*}", "${4:cif}", $4);
snippet get config db
	uvm_config_db #(${1})::get(${2:null}, "${3:*}", "${4:cif}", $4);
# phase 
snippet pha phase
	function void ${1:connect}_phase(uvm_phase phase);
		super.$1_phase(phase);
	endfunction
snippet pha connect
	function void connect_phase(uvm_phase phase);
		super.connect_phase(phase);
	endfunction
snippet pha report
	function void report_phase(uvm_phase phase);
		super.report_phase(phase);
	endfunction
snippet pha task phase
	task ${1:main}_phase(uvm_phase phase);
		phase.raise_objection(this);
		super.$1_phase(phase);
		phase.drop_objection(this);
	endtask
# uvm field
snippet field uvm_field
	\`uvm_object_utils_begin(${1:trans});
		\`uvm_field_${2:int}(${3}, ${4:UVM_ALL_ON})
	\`uvm_object_utils_end
# end of systemverilog snippets

zhimakaimen:/snippets/systemverilog.snippets
# a c header
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Project: ${2:sup}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//Author: Zhou Chuanrui
	//E-mail: zhouchuanrui@foxmail.com
	//
# main()
snippet main
	int main(int argc, const char *argv[])
	{
		${1}
		return 0;
	}
snippet mainn
	int main(void)
	{
		${1}
		return 0;
	}
# #include <...>
snippet inc
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet def
	#define
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
snippet once
	#ifndef ${1:`toupper(Filename('$1_H', 'UNTITLED_H'))`}

	#define $1

	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if (${1:/* condition */}) 
	{
		${2:/* code */}
	}
snippet el
	else
	{
		${1}
	}
# Ternary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do
	{
		${2:/* code */}
	} while (${1:/* condition */});
# While Loop
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# For Loop
snippet for
	for (${2:i} = 0; $2 < ${1:count}; $2${3:++})
	{
		${4:/* code */}
	}
# Custom For Loop
snippet forr
	for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
	{
		${5:/* code */}
	}
# Function
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Function Declaration
snippet fund
	${1:void} ${2:function_name}(${3});${4}
# Typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};${3}
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	}${3: /* optional variable list */};${4}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }
	{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Typdef enum
snippet tde
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
# printf
# unfortunately version this isn't as nice as TextMates's, given the lack of a
# dynamic `...`
snippet pr
	printf("${1:%s}\n"${2});${3}
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
# This is kind of convenient
snippet .
	[${1}]${2}
zhimakaimen:/snippets/c.snippets
# Prototype
snippet proto
	${1:class_name}.prototype.${2:method_name} =
	function(${3:first_argument}) {
		${4:// body...}
	};
# Function
snippet fun
	function ${1:function_name} (${2:argument}) {
		${3:// body...}
	}
# Anonymous Function
snippet f
	function(${1}) {${2}};
# if
snippet if
	if (${1:true}) {${2}}
# if ... else
snippet ife
	if (${1:true}) {${2}}
	else{${3}}
# tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# switch
snippet switch
	switch(${1:expression}) {
		case '${3:case}':
			${4:// code}
			break;
		${5}
		default:
			${2:// code}
	}
# case
snippet case
	case '${1:case}':
		${2:// code}
		break;
	${3}
# for (...) {...}
snippet for
	for (var ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {
		${4:$1[$2]}
	};
# for (...) {...} (Improved Native For-Loop)
snippet forr
	for (var ${2:i} = ${1:Things}.length - 1; $2 >= 0; $2${3:--}) {
		${4:$1[$2]}
	};
# while (...) {...}
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# do...while
snippet do
	do {
		${2:/* code */}
	} while (${1:/* condition */});
# Object Method
snippet :f
	${1:method_name}: function(${2:attribute}) {
		${4}
	}${3:,}
# setTimeout function
snippet timeout
	setTimeout(function() {${3}}${2}, ${1:10};
# Get Elements
snippet get
	getElementsBy${1:TagName}('${2}')${3}
# Get Element
snippet gett
	getElementBy${1:Id}('${2}')${3}
zhimakaimen:/snippets/javascript.snippets
snippet main
	public static void main (String [] args)
	{
		${1:/* code */}
	}
snippet pu
	public
snippet po
	protected
snippet pr
	private
snippet st
	static
snippet fi
	final
snippet ab
	abstract
snippet re
	return
snippet br
	break;
snippet de
	default:
		${1}
snippet ca
	catch(${1:Exception} ${2:e}) ${3}
snippet th
	throw 
snippet sy
	synchronized
snippet im
	import
snippet imp
	implements
snippet ext
	extends 
snippet j.u
	java.util
snippet j.i
	java.io.
snippet j.b
	java.beans.
snippet j.n
	java.net.
snippet j.m
	java.math.
snippet if
	if (${1}) ${2}
snippet el
	else 
snippet elif
	else if (${1}) ${2}
snippet wh
	while (${1}) ${2}
snippet for
	for (${1}; ${2}; ${3}) ${4}
snippet fore
	for (${1} : ${2}) ${3}
snippet sw
	switch (${1}) ${2}
snippet cs
	case ${1}:
		${2}
	${3}
snippet tc
	public class ${1:`Filename()`} extends ${2:TestCase}
snippet t
	public void test${1:Name}() throws Exception ${2}
snippet cl
	class ${1:`Filename("", "untitled")`} ${2}
snippet in
	interface ${1:`Filename("", "untitled")`} ${2:extends Parent}${3}
snippet m
	${1:void} ${2:method}(${3}) ${4:throws }${5}
snippet v
	${1:String} ${2:var}${3: = null}${4};${5}
snippet co
	static public final ${1:String} ${2:var} = ${3};${4}
snippet cos
	static public final String ${1:var} = "${2}";${3}
snippet as
	assert ${1:test} : "${2:Failure message}";${3}
snippet try
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	}
snippet tryf
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
snippet rst
	ResultSet ${1:rst}${2: = null}${3};${4}
zhimakaimen:/snippets/java.snippets
snippet ram
	movf    ${1:reg}, wreg
	movwf   $1_BUF
snippet reg
	movf    ${1:reg}_BUF, wreg
	movwf   $1
zhimakaimen:/snippets/asm.snippets
snippet def
	<%def name="${1:name}">
		${2:}
	</%def>
snippet call
	<%call expr="${1:name}">
		${2:}
	</%call>
snippet doc
	<%doc>
		${1:}
	</%doc>
snippet text
	<%text>
		${1:}
	</%text>
snippet for
	% for ${1:i} in ${2:iter}:
		${3:}
	% endfor
snippet if if
	% if ${1:condition}:
		${2:}
	% endif
snippet if if/else
	% if ${1:condition}:
		${2:}
	% else:
		${3:}
	% endif
snippet try
	% try:
		${1:}
	% except${2:}:
		${3:pass}
	% endtry
snippet wh
	% while ${1:}:
		${2:}
	% endwhile
snippet $
	${ ${1:} }
snippet <%
	<% ${1:} %>
snippet <!%
	<!% ${1:} %>
snippet inherit
	<%inherit file="${1:filename}" />
snippet include
	<%include file="${1:filename}" />
snippet namespace
	<%namespace file="${1:name}" />
snippet page
	<%page args="${1:}" />
zhimakaimen:/snippets/mako.snippets
let g:netrw_dirhistmax  =10
let g:netrw_dirhist_cnt =0
zhimakaimen:/vimfiles/.netrwhist~
" Vim color file
" author: Mr.Zhou <zhouchuanrui@foxmail.com>


" cool help screens
" :he group-name
" :he highlight-groups
" :he cterm-colors

" Remove all existing highlighting and set the defaults.
hi clear
" Load the syntax highlighting defaults, if it's enabled.
if exists("syntax_on")
  syntax reset
endif

let g:colors_name="myscheme"

" global setting
" the color good for your eyes
hi Normal guibg=#ccefcf

" highlight groups
hi LineNr guibg=black guifg=white 
"hi LineNr guibg=#00BFFF guifg=white 
hi Title	guifg=red
hi TabLineSel guibg=black guifg=white
hi StatusLine guibg=cyan
"hi TabLine guibg = #ccefcf
hi Visual guibg=yellow

" syntax highlighting groups
"hi Comment	guifg=#cdad00
"hi Comment	guifg= DarkYellow
hi Comment	guifg= #7f9f6f 
hi Constant	guifg= #00bfff gui = bold
hi Statement guifg = #b8af43
hi Special guifg = #7f9f6f
hi PreProc guifg = #b9663e

"vim: sw=4

"" all colors are set by originally
"" $VIMRUNTIME/syntax/syncolor.vim

"-----use :hi to list all the currently used item-settings
"-----use :so $VIMRUNTIME\syntax\hitest.vim to generate a buffer which
"			lists all the item settings"
"-----use :verbose hi <group-name> , it returns the directory 
"			to see where the group item is set "

"Suggested color names (these are available on most systems):
"Red		LightRed	DarkRed
"Green	LightGreen	DarkGreen	SeaGreen
"Blue	LightBlue	DarkBlue	SlateBlue
"Cyan	LightCyan	DarkCyan
"Magenta	LightMagenta	DarkMagenta
"Yellow	LightYellow	Brown		DarkYellow
"Gray	LightGray	DarkGray
"Black	White
"Orange	Purple		Violet

"-----hilight group explains
"-----use :hi to list all the currently used item-settings
"--Item--|--Explain--
" Normal - global words
" LineNr - line number
"ColorColumn	used for the columns set with 'colorcolumn'
"Conceal		placeholder characters substituted for concealed
"				text (see 'conceallevel')
"Cursor			the character under the cursor
"CursorIM		like Cursor, but used when in IME mode |CursorIM|
"CursorColumn	the screen column that the cursor is in when 'cursorcolumn' is
"				set
"CursorLine		the screen line that the cursor is in when 'cursorline' is
"				set
"Directory		directory names (and other special names in listings)
"DiffAdd		diff mode: Added line |diff.txt|
"DiffChange		diff mode: Changed line |diff.txt|
"DiffDelete		diff mode: Deleted line |diff.txt|
"DiffText		diff mode: Changed text within a changed line |diff.txt|
"ErrorMsg		error messages on the command line
"VertSplit		the column separating vertically split windows
"Folded			line used for closed folds
"FoldColumn		'foldcolumn'
"SignColumn		column where |signs| are displayed
"IncSearch		'incsearch' highlighting; also used for the text replaced with
"				":s///c"
"LineNr			Line number for ":number" and ":#" commands, and when 'number'
"				or 'relativenumber' option is set.
"CursorLineNr	Like LineNr when 'cursorline' or 'relativenumber' is set for
"				the cursor line.
"MatchParen		The character under the cursor or just before it, if it
"				is a paired bracket, and its match. |pi_paren.txt|
"ModeMsg		'showmode' message (e.g., "-- INSERT --")
"MoreMsg		|more-prompt|
"NonText		'~' and '@' at the end of the window, characters from
"				'showbreak' and other characters that do not really exist in
"				the text (e.g., ">" displayed when a double-wide character
"				doesn't fit at the end of the line).
"Normal			normal text
"Pmenu			Popup menu: normal item.
"PmenuSel		Popup menu: selected item.
"PmenuSbar		Popup menu: scrollbar.
"PmenuThumb		Popup menu: Thumb of the scrollbar.
"Question		|hit-enter| prompt and yes/no questions
"Search			Last search pattern highlighting (see 'hlsearch').
"				Also used for highlighting the current line in the quickfix
"				window and similar items that need to stand out.
"SpecialKey		Meta and special keys listed with ":map", also for text used
"				to show unprintable characters in the text, 'listchars'.
"				Generally: text that is displayed differently from what it
"				really is.
"SpellBad		Word that is not recognized by the spellchecker. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellCap		Word that should start with a capital. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellLocal		Word that is recognized by the spellchecker as one that is
"				used in another region. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellRare		Word that is recognized by the spellchecker as one that is
"				hardly ever used. |spell|
"				This will be combined with the highlighting used otherwise.
"StatusLine		status line of current window
"StatusLineNC	status lines of not-current windows
"				Note: if this is equal to "StatusLine" Vim will use "^^^" in
"				the status line of the current window.
"TabLine		tab pages line, not active tab page label
"TabLineFill	tab pages line, where there are no labels
"TabLineSel		tab pages line, active tab page label
"Title			titles for output from ":set all", ":autocmd" etc.
"Visual			Visual mode selection
"VisualNOS		Visual mode selection when vim is "Not Owning the Selection".
"				Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
"WarningMsg		warning messages
"WildMenu		current match in 'wildmenu' completion
"

"------highlight syntax items"
"*Comment	any comment

"*Constant	any constant
 "String		a string constant: "this is a string"
 "Character	a character constant: 'c', '\n'
 "Number		a number constant: 234, 0xff
 "Boolean	a boolean constant: TRUE, false
 "Float		a floating point constant: 2.3e10

"*Identifier	any variable name
 "Function	function name (also: methods for classes)

"*Statement	any statement
 "Conditional	if, then, else, endif, switch, etc.
 "Repeat		for, do, while, etc.
 "Label		case, default, etc.
 "Operator	"sizeof", "+", "*", etc.
 "Keyword	any other keyword
 "Exception	try, catch, throw

"*PreProc	generic Preprocessor
 "Include	preprocessor #include
 "Define		preprocessor #define
 "Macro		same as Define
 "PreCondit	preprocessor #if, #else, #endif, etc.

"*Type		int, long, char, etc.
 "StorageClass	static, register, volatile, etc.
 "Structure	struct, union, enum, etc.
 "Typedef	A typedef

"*Special	any special symbol
 "SpecialChar	special character in a constant
 "Tag		you can use CTRL-] on this
 "Delimiter	character that needs attention
 "SpecialComment	special things inside a comment
 "Debug		debugging statements

"*Underlined	text that stands out, HTML links

"*Ignore		left blank, hidden  |hl-Ignore|

"*Error		any erroneous construct

"*Todo		anything that needs extra attention; mostly the
		"keywords TODO FIXME and XXX

zhimakaimen:/vimfiles/colors/myscheme.vim
zhimakaimen:/vimfiles/bundle/d2utmp7Hku98
Copyright (C) 2010 http://github.com/gmarik

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
zhimakaimen:/vimfiles/bundle/vundle/LICENSE-MIT.txt
doc/tags
.netrwhist
zhimakaimen:/vimfiles/bundle/vundle/.gitignore
*vundle.txt* Vundle the plug-in manager for Vim.     *vundle*

CONTENTS ~
                                                   *vundle-contents*
===========================================================================

1. About                                           |vundle-about|
2. Why Vundle                                      |vundle-why-vundle|
3. Quick start                                     |vundle-quickstart|
4. Scripts                                         |vundle-scripts|
   4.1. Configure scripts                          |vundle-scripts-configure|
   4.2. Installing scripts                         |vundle-scripts-install|
   4.3. Updating scripts                           |vundle-scripts-update|
   4.4. Searching scripts                          |vundle-scripts-search|
   4.5. Listing scripts                            |vundle-scripts-list|
   4.6. Cleanup                                    |vundle-scripts-cleanup|
5. Interactive mode                                |vundle-interactive|
6. Key mappings                                    |vundle-keymappings|
7. Options                                         |vundle-options|

===========================================================================

ABOUT                                              *vundle-about*

Vundle is a short cut for Vim bundle and is the Vim plug-in manager.

2. WHY VUNDLE ~
                                                   *vundle-why-vundle*
Vundle allows to:

- keep track and configure your scripts right in `.vimrc`
- install configured scripts (aka bundle) 
- update configured scripts
- search [all available vim scripts] by name
- clean up from unused scripts

Also *Vundle* :

- manages runtime path of your installed scripts
- regenerates helptags automatically

Vundle takes advantage of [vim-scripts.org](http://vim-scripts.org) 
in order to install/search [all available vim scripts]

3. QUICK START ~
                                                    *vundle-quickstart*
1) Setup Vundle: >

    git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle

2) Configure bundles:

   Sample `.vimrc`: >

     set nocompatible               " be iMproved
     filetype off                   " required!

     set rtp+=~/.vim/vundle.git/ 
     call vundle#rc()

     " let Vundle manage Vundle
     Bundle 'gmarik/vundle'

     " My Bundles here:
     "
     " original repos on github
     Bundle 'tpope/vim-fugitive'
     Bundle 'Lokaltog/vim-easymotion'
     Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}
     " vim-scripts repos
     Bundle 'L9'
     Bundle 'FuzzyFinder'
     Bundle 'rails.vim'
     " non github repos
     Bundle 'git://git.wincent.com/command-t.git'
     " git repos on your local machine (ie. when working on your own plugin)
     Bundle 'file:///Users/gmarik/path/to/plugin'
     " ...

     filetype plugin indent on     " required!
     " or 
     " filetype plugin on          " to not use the indentation settings set by plugins

3) Install configured bundles:

   Launch `vim`, run >

    :BundleInstall

Installing requires [Git] and triggers [Git clone](http://gitref.org/creating/#clone) for 
each configured repo to `~/.vim/bundle/`.

4. SCRIPTS ~
                                                    *vundle-scripts*
4.1 CONFIGURE SCRIPTS ~
                                      *vundle-scripts-configure* *Bundle*
Before installing scripts they need to be configured. It's done using `Bundle`
command in `.vimrc`: >

    Bundle 'git_repo_uri'       " 'git_repo_uri' should be a valid uri to git repository 
or >
    Bundle 'script_name'        " 'script-name' should be an official script name (see |vundle-scripts-search| )

Vundle loves Github, that's why short uris can be used with commands: >

    Bundle 'tpope/vim-fugitive'

equals full uri >

    Bundle 'http://github.com/tpope/vim-fugitive.git'

NOTE: Vundle defaults to http:// protocol for the short URIs


4.2 INSTALL SCRIPTS ~
                                      *vundle-scripts-install* *BundleInstall*
run >
    :BundleInstall

installs configured scripts. Newly installed scripts will be automatically
enabled. Except special cases requiring compilation or pre-configuration.

BundleInstall allows to install scripts by name:>

    :BundleInstall unite.vim

installs and activates unite.vim. You can use Tab to auto-complete known script names.
NOTE: installation, as just described, doesn't automatically configure scripts; 
you have to configure them manually.

4.3 UPDATE SCRIPTS ~
                                      *vundle-scripts-update* *BundleInstall!*
run >
    :BundleInstall!             " NOTE: bang(!)

installs or updates configured scripts.
press u after updates complete to see the changelog of all updated bundles.

4.4 SEARCHING ~
                                       *vundle-scripts-search* *BundleSearch*
run >
    :BundleSearch foo

lists bundles matching 'foo' in new a new split window, ie:
>
    Bundle "VimFootnotes"
    Bundle "foo.vim"
>
and >

    :BundleSearch! foo

refreshes script list before performing actual search.

If command is run without argument: >

    :BundleSearch!

it will display all known scripts

Searching requires [`curl`](http://curl.haxx.se/)

4.5 LISTING BUNDLES ~
                                     *vundle-scripts-list* *BundleList*

To quickly pull list of installed bundles use >

    :BundleList


4.6 CLEANING UP ~
                                     *vundle-scripts-cleanup* *BundleClean*
run >

    :BundleClean

confirms removal of unused script-dirs from `.vim/bundle/`.

                                                            *BundleClean!*
>
    :BundleClean!

removes unused dirs with no questions.


                                     *vundle-interactive*
5. INTERACTIVE MODE ~

Vundle provides simple interactive mode to help you explore new scripts easily.
Interactive mode is available as result of any commands that display list of
bundles. For instance, running: >

    :BundleSearch! unite

triggers search for scripts matching 'unite' and yields a split window with
content: >

    "Keymap: i - Install bundle; c - Cleanup; r - Refine list; R - Reload list
    "Search results for: unite
    Bundle 'unite.vim'
    Bundle 'unite-yarm'
    Bundle 'unite-gem'
    Bundle 'unite-locate'
    Bundle 'unite-font'
    Bundle 'unite-colorscheme'

As the first line(starting with `"Keymap:`) shows, certain actions may be applied
to selected bundles .  Move cursor over line `Bundle 'unite.vim'` and press i 
key(install, see |vundle-keymappings| for more details). 
After unite.vim is installed - `:Unite file` command should be
available to prove 'unite.vim' availability.

NOTE: Interactive installation doesn't update your .vimrc configuration.

                                     *vundle-keymappings*
6. KEY MAPPINGS ~

KEY | DESCRIPTION
----|-------------------------- >
 i  |  run :BundleInstall with name taken from line cursor is positioned on
 I  |  same as i, but runs :BundleInstall! to update bundle
 D  |  delete selected bundle( be careful not to remove local modifications)
 c  |  run :BundleClean
 s  |  run :BundleSearch
 R  |  fetch fresh script list from server
.

                                     *vundle-options*
7. OPTIONS ~

>
  let g:vundle_default_git_proto = 'git'

makes Vundle use `git` instead default `https` when building absolute repo URIs


vim:tw=78:ts=8:ft=help:norl:
zhimakaimen:/vimfiles/bundle/vundle/doc/vundle.txt
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=GBK">
<title>E:\Program Files\Vim\vimfiles\bundle\vundle\doc\vundle.txt.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v6">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,number_lines">
<style type="text/css">
<!--
pre { font-family: monospace; color: #dcdccc; background-color: #3f3f3f; }
body { font-family: monospace; color: #dcdccc; background-color: #3f3f3f; }
.lnr { color: #9fafaf; background-color: #262626; }
.Comment { color: #7f9f7f; font-style: italic; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr">49 </span><span class="Comment">    git clone <a href="http://github.com/gmarik/vundle.git">http://github.com/gmarik/vundle.git</a> ~/.vim/vundle.git</span>
</pre>
</body>
</html>
zhimakaimen:/vimfiles/bundle/vundle/doc/vundle.txt.html
" vim -u test/vimrc
set nocompatible

set nowrap

let root = '/tmp/!vundle-test/bundles/'
let src = 'http://github.com/gmarik/vundle.git' 

" let src = '~/.vim/bundle/vundle/.git' 

" Vundle Options
" let g:vundle_default_git_proto = 'git'

if !isdirectory(expand(root, 1).'/vundle')
  exec '!git clone '.src.' '.shellescape(root, 1).'/vundle'
endif

filetype off
syntax on

runtime macros/matchit.vim

exec 'set rtp+='.root.'/vundle'

call vundle#rc(root)

Bundle "gmarik/vundle"

" vim-scripts name
Bundle 'molokai'

" github username with dashes
Bundle 'vim-scripts/ragtag.vim'

" original repo
Bundle 'altercation/vim-colors-solarized'
" with extension
Bundle 'nelstrom/vim-mac-classic-theme.git'
"
"  invalid uri
Bundle 'nonexistinguser/yupppierepo.git'

" full uri
Bundle 'https://github.com/vim-scripts/vim-game-of-life'
" full uri
Bundle 'git@github.com:gmarik/ingretu.git'
" short uri
Bundle 'gh:gmarik/snipmate.vim.git'
Bundle 'github:mattn/gist-vim.git'

" local uri stuff
Bundle '~/Dropbox/.gitrepos/utilz.vim.git'
" Bundle 'file://Dropbox/.gitrepos/utilz.vim.git'

" with options
Bundle 'rstacruz/sparkup.git', {'rtp': 'vim/'}

" Camel case
Bundle 'vim-scripts/RubySinatra'

" syntax issue #203
Bundle 'jimenezrick/vimerl'

filetype plugin indent on      " Automatically detect file types.

set wildignore+=doc              " should not break helptags
set wildignore+=.git             " should not break clone
set wildignore+=.git/*             " should not break clone
set wildignore+=*/.git/*
" TODO: helptags fails with this
" set wildignore+=doc/*             " should not break clone
" set wildignore+=*/doc/*

au VimEnter * BundleInstall

" e test/files/erlang.erl
zhimakaimen:/vimfiles/bundle/vundle/test/vimrc
set nocompatible
syntax on
filetype off
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()
Bundle 'gmarik/vundle'
filetype plugin indent on

zhimakaimen:/vimfiles/bundle/vundle/test/minirc.vim
-module(mmc_logmon_sup).
-behaviour(supervisor).
-export([init/1]).

init(_) ->
    {ok, {
        {one_for_one, 5, 1},
        [
            {listener,
                {aaa, start_link, []},
                permanent, 100, worker,
                [aaa]
            },
            {server,
                {bbb, start_link, []},
                permanent, 100, worker,
                [bbb]
            }
        ]
    }}.
zhimakaimen:/vimfiles/bundle/vundle/test/files/test.erl
" Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim
" Author:       gmarik
" HomePage:     http://github.com/gmarik/vundle
" Readme:       http://github.com/gmarik/vundle/blob/master/README.md
" Version:      0.9

com! -nargs=+         Bundle
\ call vundle#config#bundle(<args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall
\ call vundle#installer#new('!' == '<bang>', <q-args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch
\ call vundle#scripts#all('!'=='<bang>', <q-args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete Bundles
\ call vundle#scripts#all('!'=='<bang>', <q-args>)

com! -nargs=0 -bang BundleList
\ call vundle#installer#list('!'=='<bang>')

com! -nargs=? -bang   BundleClean
\ call vundle#installer#clean('!' == '<bang>')

com! -nargs=0         BundleDocs 
\ call vundle#installer#helptags(g:bundles)

" Aliases
com! BundleUpdate BundleInstall!

if (has('signs'))
sign define Vu_error    text=!  texthl=Error
sign define Vu_active   text=>  texthl=Comment
sign define Vu_todate   text=.  texthl=Comment
sign define Vu_new      text=+  texthl=Comment
sign define Vu_updated  text=*  texthl=Comment
sign define Vu_deleted  text=-  texthl=Comment
sign define Vu_helptags text=*  texthl=Comment
endif


func! vundle#rc(...) abort
  let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)
  let g:updated_bundles = []
  let g:vundle_log = []
  let g:vundle_changelog = ['Updated Bundles:']
  call vundle#config#init()
endf
zhimakaimen:/vimfiles/bundle/vundle/autoload/vundle.vim
func! vundle#scripts#all(bang, ...)
  let b:match = ''
  let info = ['"Keymap: i - Install bundle; c - Cleanup; s - Search; R - Reload list']
  let matches = s:load_scripts(a:bang)
  if !empty(a:1)
    let matches = filter(matches, 'v:val =~? "'.escape(a:1,'"').'"')
    let info += ['"Search results for: '.a:1]
    " TODO: highlight matches
    let b:match = a:1
  endif
  call vundle#scripts#view('search',info, vundle#scripts#bundle_names(reverse(matches)))
  redraw
  echo len(matches).' bundles found'
endf

func! vundle#scripts#reload() abort
  silent exec ':BundleSearch! '.(exists('b:match') ? b:match : '')
  redraw
endf

func! vundle#scripts#complete(a,c,d)
  return join(s:load_scripts(0),"\n")
endf

func! s:view_log()
  if !exists('g:vundle_log_file')
    let g:vundle_log_file = tempname()
  endif

  call writefile(g:vundle_log, g:vundle_log_file)
  execute 'silent pedit ' . g:vundle_log_file

  wincmd P | wincmd H
endf

func! s:create_changelog() abort
  for bundle_data in g:updated_bundles
    let initial_sha = bundle_data[0]
    let updated_sha = bundle_data[1]
    let bundle      = bundle_data[2]

    let cmd = 'cd '.shellescape(bundle.path()).
          \              ' && git log --pretty=format:"%s   %an, %ar" --graph '.
          \               initial_sha.'..'.updated_sha

    let cmd = g:shellesc_cd(cmd)

    let updates = system(cmd)

    call add(g:vundle_changelog, '')
    call add(g:vundle_changelog, 'Updated Bundle: '.bundle.name)

    if bundle.uri =~ "https://github.com"
      call add(g:vundle_changelog, 'Compare at: '.bundle.uri[0:-5].'/compare/'.initial_sha.'...'.updated_sha)
    endif

    for update in split(updates, '\n')
      let update = substitute(update, '\s\+$', '', '')
      call add(g:vundle_changelog, '  '.update)
    endfor
  endfor
endf

func! s:view_changelog()
  call s:create_changelog()

  if !exists('g:vundle_changelog_file')
    let g:vundle_changelog_file = tempname()
  endif

  call writefile(g:vundle_changelog, g:vundle_changelog_file)
  execute 'silent pedit ' . g:vundle_changelog_file

  wincmd P | wincmd H
endf

func! vundle#scripts#bundle_names(names)
  return map(copy(a:names), ' printf("Bundle ' ."'%s'".'", v:val) ')
endf

func! vundle#scripts#view(title, headers, results)
  if exists('g:vundle_view') && bufloaded(g:vundle_view)
    exec g:vundle_view.'bd!'
  endif

  exec 'silent pedit [Vundle] '.a:title

  wincmd P | wincmd H

  let g:vundle_view = bufnr('%')
  "
  " make buffer modifiable 
  " to append without errors
  set modifiable

  call append(0, a:headers + a:results)

  setl buftype=nofile
  setl noswapfile

  setl cursorline
  setl nonu ro noma ignorecase 
  if (exists('&relativenumber')) | setl norelativenumber | endif

  setl ft=vundle
  setl syntax=vim
  syn keyword vimCommand Bundle
  syn keyword vimCommand Helptags

  com! -buffer -bang -nargs=1 DeleteBundle
    \ call vundle#installer#run('vundle#installer#delete', split(<q-args>,',')[0], ['!' == '<bang>', <args>])

  com! -buffer -bang -nargs=? InstallAndRequireBundle   
    \ call vundle#installer#run('vundle#installer#install_and_require', split(<q-args>,',')[0], ['!' == '<bang>', <q-args>])

  com! -buffer -bang -nargs=? InstallBundle
    \ call vundle#installer#run('vundle#installer#install', split(<q-args>,',')[0], ['!' == '<bang>', <q-args>])

  com! -buffer -bang -nargs=0 InstallHelptags 
    \ call vundle#installer#run('vundle#installer#docs', 'helptags', [])

  com! -buffer -nargs=0 VundleLog call s:view_log()

  com! -buffer -nargs=0 VundleChangelog call s:view_changelog()

  nnoremap <buffer> q :silent bd!<CR>
  nnoremap <buffer> D :exec 'Delete'.getline('.')<CR>

  nnoremap <buffer> add  :exec 'Install'.getline('.')<CR>
  nnoremap <buffer> add! :exec 'Install'.substitute(getline('.'), '^Bundle ', 'Bundle! ', '')<CR>

  nnoremap <buffer> i :exec 'InstallAndRequire'.getline('.')<CR>
  nnoremap <buffer> I :exec 'InstallAndRequire'.substitute(getline('.'), '^Bundle ', 'Bundle! ', '')<CR>

  nnoremap <buffer> l :VundleLog<CR>
  nnoremap <buffer> u :VundleChangelog<CR>
  nnoremap <buffer> h :h vundle<CR>
  nnoremap <buffer> ? :norm h<CR>

  nnoremap <buffer> c :BundleClean<CR>
  nnoremap <buffer> C :BundleClean!<CR>

  nnoremap <buffer> s :BundleSearch 
  nnoremap <buffer> R :call vundle#scripts#reload()<CR>

  " goto first line after headers
  exec ':'.(len(a:headers) + 1)
endf

func! s:fetch_scripts(to)
  let scripts_dir = fnamemodify(expand(a:to, 1), ":h")
  if !isdirectory(scripts_dir)
    call mkdir(scripts_dir, "p")
  endif

  let l:vim_scripts_json = 'http://vim-scripts.org/api/scripts.json'
  if executable("curl")
    let cmd = 'curl --fail -s -o '.shellescape(a:to).' '.l:vim_scripts_json
  elseif executable("wget")
    let temp = shellescape(tempname())
    let cmd = 'wget -q -O '.temp.' '.l:vim_scripts_json. ' && mv -f '.temp.' '.shellescape(a:to)
    if (has('win32') || has('win64')) 
      let cmd = substitute(cmd, 'mv -f ', 'move /Y ', '') " change force flag
      let cmd = g:shellesc(cmd)
    end
  else
    echoerr 'Error curl or wget is not available!'
    return 1
  endif

  call system(cmd)

  if (0 != v:shell_error)
    echoerr 'Error fetching scripts!'
    return v:shell_error
  endif
  return 0
endf

func! s:load_scripts(bang)
  let f = expand(g:bundle_dir.'/.vundle/script-names.vim-scripts.org.json', 1)
  if a:bang || !filereadable(f)
    if 0 != s:fetch_scripts(f)
      return []
    end
  endif
  return eval(readfile(f, 'b')[0])
endf
zhimakaimen:/vimfiles/bundle/vundle/autoload/vundle/scripts.vim
func! vundle#installer#new(bang, ...) abort
  let bundles = (a:1 == '') ?
        \ g:bundles :
        \ map(copy(a:000), 'vundle#config#bundle(v:val, {})')

  let names = vundle#scripts#bundle_names(map(copy(bundles), 'v:val.name_spec'))
  call vundle#scripts#view('Installer',['" Installing bundles to '.expand(g:bundle_dir, 1)], names +  ['Helptags'])

  call s:process(a:bang, (a:bang ? 'add!' : 'add'))

  call vundle#config#require(bundles)
endf


func! s:process(bang, cmd)
  let msg = ''

  redraw
  sleep 1m

  let lines = (getline('.','$')[0:-2])

  for line in lines
    redraw

    exec ':norm '.a:cmd

    if 'error' == g:vundle_last_status
      let msg = 'With errors; press l to view log'
    endif

    if 'updated' == g:vundle_last_status && empty(msg)
      let msg = 'Bundles updated; press u to view changelog'
    endif

    " goto next one
    exec ':+1'

    setl nomodified
  endfor

  redraw
  echo 'Done! '.msg
endf

func! vundle#installer#run(func_name, name, ...) abort
  let n = a:name

  echo 'Processing '.n
  call s:sign('active')

  sleep 1m

  let status = call(a:func_name, a:1)

  call s:sign(status)

  redraw

  if 'new' == status
    echo n.' installed'
  elseif 'updated' == status
    echo n.' updated'
  elseif 'todate' == status
    echo n.' already installed'
  elseif 'deleted' == status
    echo n.' deleted'
  elseif 'helptags' == status
    echo n.' regenerated'
  elseif 'error' == status
    echohl Error
    echo 'Error processing '.n
    echohl None
    sleep 1
  else
    throw 'whoops, unknown status:'.status
  endif

  let g:vundle_last_status = status

  return status
endf

func! s:sign(status) 
  if (!has('signs'))
    return
  endif

  exe ":sign place ".line('.')." line=".line('.')." name=Vu_". a:status ." buffer=" . bufnr("%")
endf

func! vundle#installer#install_and_require(bang, name) abort
  let result = vundle#installer#install(a:bang, a:name)
  let b = vundle#config#bundle(a:name, {})
  call vundle#installer#helptags([b])
  call vundle#config#require([b])
  return result
endf

func! vundle#installer#install(bang, name) abort
  if !isdirectory(g:bundle_dir) | call mkdir(g:bundle_dir, 'p') | endif

  let b = vundle#config#init_bundle(a:name, {})

  return s:sync(a:bang, b)
endf

func! vundle#installer#docs() abort
  let error_count = vundle#installer#helptags(g:bundles)
  if error_count > 0
      return 'error'
  endif
  return 'helptags'
endf

func! vundle#installer#helptags(bundles) abort
  let bundle_dirs = map(copy(a:bundles),'v:val.rtpath')
  let help_dirs = filter(bundle_dirs, 's:has_doc(v:val)')

  call s:log('')
  call s:log('Helptags:')

  let statuses = map(copy(help_dirs), 's:helptags(v:val)')
  let errors = filter(statuses, 'v:val == 0')

  call s:log('Helptags: '.len(help_dirs).' bundles processed')

  return len(errors)
endf

func! vundle#installer#list(bang) abort
  let bundles = vundle#scripts#bundle_names(map(copy(g:bundles), 'v:val.name_spec'))
  call vundle#scripts#view('list', ['" My Bundles'], bundles)
  redraw
  echo len(g:bundles).' bundles configured'
endf


func! vundle#installer#clean(bang) abort
  let bundle_dirs = map(copy(g:bundles), 'v:val.path()') 
  let all_dirs = (v:version > 702 || (v:version == 702 && has("patch51")))
  \   ? split(globpath(g:bundle_dir, '*', 1), "\n")
  \   : split(globpath(g:bundle_dir, '*'), "\n")
  let x_dirs = filter(all_dirs, '0 > index(bundle_dirs, v:val)')

  if empty(x_dirs)
    let headers = ['" All clean!']
    let names = []
  else
    let headers = ['" Removing bundles:']
    let names = vundle#scripts#bundle_names(map(copy(x_dirs), 'fnamemodify(v:val, ":t")'))
  end

  call vundle#scripts#view('clean', headers, names)
  redraw

  if (a:bang || empty(names))
    call s:process(a:bang, 'D')
  else
    call inputsave()
    let response = input('Continue? [Y/n]: ')
    call inputrestore()
    if (response =~? 'y' || response == '')
      call s:process(a:bang, 'D')
    endif
  endif
endf


func! vundle#installer#delete(bang, dir_name) abort

  let cmd = (has('win32') || has('win64')) ?
  \           'rmdir /S /Q' :
  \           'rm -rf'

  let bundle = vundle#config#init_bundle(a:dir_name, {})
  let cmd .= ' '.shellescape(bundle.path())

  let out = s:system(cmd)

  call s:log('')
  call s:log('Bundle '.a:dir_name)
  call s:log('$ '.cmd)
  call s:log('> '.out)

  if 0 != v:shell_error
    return 'error'
  else
    return 'deleted'
  endif
endf

func! s:has_doc(rtp) abort
  return isdirectory(a:rtp.'/doc')
  \   && (!filereadable(a:rtp.'/doc/tags') || filewritable(a:rtp.'/doc/tags'))
  \   && (v:version > 702 || (v:version == 702 && has("patch51")))
  \     ? !(empty(glob(a:rtp.'/doc/*.txt', 1)) && empty(glob(a:rtp.'/doc/*.??x', 1)))
  \     : !(empty(glob(a:rtp.'/doc/*.txt')) && empty(glob(a:rtp.'/doc/*.??x')))
endf

func! s:helptags(rtp) abort
  let doc_path = a:rtp.'/doc/'
  call s:log(':helptags '.doc_path)
  try
    execute 'helptags ' . doc_path
  catch
    call s:log("> Error running :helptags ".doc_path)
    return 0
  endtry
  return 1
endf

func! s:sync(bang, bundle) abort
  let git_dir = expand(a:bundle.path().'/.git/', 1)
  if isdirectory(git_dir) || filereadable(expand(a:bundle.path().'/.git', 1))
    if !(a:bang) | return 'todate' | endif
    let cmd = 'cd '.shellescape(a:bundle.path()).' && git pull && git submodule update --init --recursive'

    let cmd = g:shellesc_cd(cmd)

    let get_current_sha = 'cd '.shellescape(a:bundle.path()).' && git rev-parse HEAD'
    let get_current_sha = g:shellesc_cd(get_current_sha)
    let initial_sha = s:system(get_current_sha)[0:15]
  else
    let cmd = 'git clone --recursive '.shellescape(a:bundle.uri).' '.shellescape(a:bundle.path())
    let initial_sha = ''
  endif

  let out = s:system(cmd)
  call s:log('')
  call s:log('Bundle '.a:bundle.name_spec)
  call s:log('$ '.cmd)
  call s:log('> '.out)

  if 0 != v:shell_error
    return 'error'
  end

  if empty(initial_sha)
    return 'new'
  endif

  let updated_sha = s:system(get_current_sha)[0:15]

  if initial_sha == updated_sha
    return 'todate'
  endif

  call add(g:updated_bundles, [initial_sha, updated_sha, a:bundle])
  return 'updated'
endf

func! g:shellesc(cmd) abort
  if (has('win32') || has('win64'))
    if &shellxquote != '('                           " workaround for patch #445
      return '"'.a:cmd.'"'                          " enclose in quotes so && joined cmds work
    endif
  endif
  return a:cmd
endf

func! g:shellesc_cd(cmd) abort
  if (has('win32') || has('win64'))
    let cmd = substitute(a:cmd, '^cd ','cd /d ','')  " add /d switch to change drives
    let cmd = g:shellesc(cmd)
    return cmd
  else
    return a:cmd
  endif
endf

func! s:system(cmd) abort
  return system(a:cmd)
endf

func! s:log(str) abort
  let fmt = '%y%m%d %H:%M:%S'
  call add(g:vundle_log, '['.strftime(fmt).'] '.a:str)
  return a:str
endf
zhimakaimen:/vimfiles/bundle/vundle/autoload/vundle/installer.vim
func! vundle#config#bundle(arg, ...)
  let bundle = vundle#config#init_bundle(a:arg, a:000)
  call s:rtp_rm_a()
  call add(g:bundles, bundle)
  call s:rtp_add_a()
  return bundle
endf

func! vundle#config#init()
  if !exists('g:bundles') | let g:bundles = [] | endif
  call s:rtp_rm_a()
  let g:bundles = []
endf

func! vundle#config#require(bundles) abort
  for b in a:bundles
    call s:rtp_add(b.rtpath)
    call s:rtp_add(g:bundle_dir)
    " TODO: it has to be relative rtpath, not bundle.name
    exec 'runtime! '.b.name.'/plugin/*.vim'
    exec 'runtime! '.b.name.'/after/*.vim'
    call s:rtp_rm(g:bundle_dir)
  endfor
endf

func! vundle#config#init_bundle(name, opts)
  if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
    echo "Spurious leading and/or trailing whitespace found in bundle spec '" . a:name . "'"
  endif
  let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')))
  let b = extend(opts, copy(s:bundle))
  let b.rtpath = s:rtpath(opts)
  return b
endf

func! s:parse_options(opts)
  " TODO: improve this
  if len(a:opts) != 1 | return {} | endif

  if type(a:opts[0]) == type({})
    return a:opts[0]
  else
    return {'rev': a:opts[0]}
  endif
endf

func! s:parse_name(arg)
  let arg = a:arg
  let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'

  if    arg =~? '^\s*\(gh\|github\):\S\+'
  \  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
    let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
    if uri !~? '\.git$'
      let uri .= '.git'
    endif
    let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
  elseif arg =~? '^\s*\(git@\|git://\)\S\+' 
  \   || arg =~? '\(file\|https\?\)://'
  \   || arg =~? '\.git\s*$'
    let uri = arg
    let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
  else
    let name = arg
    let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
  endif
  return {'name': name, 'uri': uri, 'name_spec': arg }
endf

func! s:rtp_rm_a()
  let paths = map(copy(g:bundles), 'v:val.rtpath')
  let prepends = join(paths, ',')
  let appends = join(paths, '/after,').'/after'
  exec 'set rtp-='.fnameescape(prepends)
  exec 'set rtp-='.fnameescape(appends)
endf

func! s:rtp_add_a()
  let paths = map(copy(g:bundles), 'v:val.rtpath')
  let prepends = join(paths, ',')
  let appends = join(paths, '/after,').'/after'
  exec 'set rtp^='.fnameescape(prepends)
  exec 'set rtp+='.fnameescape(appends)
endf

func! s:rtp_rm(dir) abort
  exec 'set rtp-='.fnameescape(expand(a:dir, 1))
  exec 'set rtp-='.fnameescape(expand(a:dir.'/after', 1))
endf

func! s:rtp_add(dir) abort
  exec 'set rtp^='.fnameescape(expand(a:dir, 1))
  exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))
endf

func! s:expand_path(path) abort
  return simplify(expand(a:path, 1))
endf

func! s:rtpath(opts)
  return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
endf

let s:bundle = {}

func! s:bundle.path()
  return s:expand_path(g:bundle_dir.'/'.self.name)
endf

zhimakaimen:/vimfiles/bundle/vundle/autoload/vundle/config.vim
Quickly install with:

    git clone git://github.com/msanders/snipmate.vim.git
	cd snipmate.vim
	cp -R * ~/.vim
zhimakaimen:/vimfiles/bundle/snipmate.vim/README.markdown
{
  "name" : "snipmate",
  "version" : "dev",
  "author" : "Michael Sanders <msanders42@gmail.com>",
  "repository" : {"type": "git", "url": "git://github.com/msanders/snipmate.vim.git"},
  "dependencies" : {},
  "description" : "snipMate.vim aims to be a concise vim script that implements some of TextMate's snippets features in Vim."
}
zhimakaimen:/vimfiles/bundle/snipmate.vim/plugin-info.txt
" These are the mappings for snipMate.vim. Putting it here ensures that it
" will be mapped after other plugins such as supertab.vim.
if !exists('loaded_snips') || exists('s:did_snips_mappings')
	finish
endif
let s:did_snips_mappings = 1

" This is put here in the 'after' directory in order for snipMate to override
" other plugin mappings (e.g., supertab).
"
" You can safely adjust these mappings to your preferences (as explained in
" :help snipMate-remap).
ino <silent> <tab> <c-r>=TriggerSnippet()<cr>
snor <silent> <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>
ino <silent> <s-tab> <c-r>=BackwardsSnippet()<cr>
snor <silent> <s-tab> <esc>i<right><c-r>=BackwardsSnippet()<cr>
ino <silent> <c-r><tab> <c-r>=ShowAvailableSnips()<cr>

" The default mappings for these are annoying & sometimes break snipMate.
" You can change them back if you want, I've put them here for convenience.
snor <bs> b<bs>
snor <right> <esc>a
snor <left> <esc>bi
snor ' b<bs>'
snor ` b<bs>`
snor % b<bs>%
snor U b<bs>U
snor ^ b<bs>^
snor \ b<bs>\
snor <c-x> b<bs><c-x>

" By default load snippets in snippets_dir
if empty(snippets_dir)
	finish
endif

call GetSnippets(snippets_dir, '_') " Get global snippets

au FileType * if &ft != 'help' | call GetSnippets(snippets_dir, &ft) | endif
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/vimfiles/bundle/snipmate.vim/after/plugin/snipMate.vim
'snippets'	snipMate.txt	/*'snippets'*
.snippet	snipMate.txt	/*.snippet*
.snippets	snipMate.txt	/*.snippets*
ExtractSnips()	snipMate.txt	/*ExtractSnips()*
ExtractSnipsFile()	snipMate.txt	/*ExtractSnipsFile()*
Filename()	snipMate.txt	/*Filename()*
ReloadAllSnippets()	snipMate.txt	/*ReloadAllSnippets()*
ReloadSnippets()	snipMate.txt	/*ReloadSnippets()*
ResetAllSnippets()	snipMate.txt	/*ResetAllSnippets()*
ResetSnippets()	snipMate.txt	/*ResetSnippets()*
g:snippets_dir	snipMate.txt	/*g:snippets_dir*
g:snips_author	snipMate.txt	/*g:snips_author*
i_CTRL-R_<Tab>	snipMate.txt	/*i_CTRL-R_<Tab>*
list-snippets	snipMate.txt	/*list-snippets*
multi_snip	snipMate.txt	/*multi_snip*
snipMate	snipMate.txt	/*snipMate*
snipMate-$#	snipMate.txt	/*snipMate-$#*
snipMate-${#:}	snipMate.txt	/*snipMate-${#:}*
snipMate-${#}	snipMate.txt	/*snipMate-${#}*
snipMate-author	snipMate.txt	/*snipMate-author*
snipMate-commands	snipMate.txt	/*snipMate-commands*
snipMate-contact	snipMate.txt	/*snipMate-contact*
snipMate-description	snipMate.txt	/*snipMate-description*
snipMate-disadvantages	snipMate.txt	/*snipMate-disadvantages*
snipMate-expandtab	snipMate.txt	/*snipMate-expandtab*
snipMate-features	snipMate.txt	/*snipMate-features*
snipMate-filename	snipMate.txt	/*snipMate-filename*
snipMate-indenting	snipMate.txt	/*snipMate-indenting*
snipMate-license	snipMate.txt	/*snipMate-license*
snipMate-placeholders	snipMate.txt	/*snipMate-placeholders*
snipMate-remap	snipMate.txt	/*snipMate-remap*
snipMate-settings	snipMate.txt	/*snipMate-settings*
snipMate-usage	snipMate.txt	/*snipMate-usage*
snipMate.txt	snipMate.txt	/*snipMate.txt*
snippet	snipMate.txt	/*snippet*
snippet-syntax	snipMate.txt	/*snippet-syntax*
snippets	snipMate.txt	/*snippets*
zhimakaimen:/vimfiles/bundle/snipmate.vim/doc/tags
*snipMate.txt*  Plugin for using TextMate-style snippets in Vim.

snipMate                                       *snippet* *snippets* *snipMate*
Last Change: December 27, 2009

|snipMate-description|   Description
|snipMate-syntax|        Snippet syntax
|snipMate-usage|         Usage
|snipMate-settings|      Settings
|snipMate-features|      Features
|snipMate-disadvantages| Disadvantages to TextMate
|snipMate-contact|       Contact
|snipMate-license|       License

For Vim version 7.0 or later.
This plugin only works if 'compatible' is not set.
{Vi does not have any of these features.}

==============================================================================
DESCRIPTION                                             *snipMate-description*

snipMate.vim implements some of TextMate's snippets features in Vim. A
snippet is a piece of often-typed text that you can insert into your
document using a trigger word followed by a <tab>.

For instance, in a C file using the default installation of snipMate.vim, if
you type "for<tab>" in insert mode, it will expand a typical for loop in C: >

 for (i = 0; i < count; i++) {

 }


To go to the next item in the loop, simply <tab> over to it; if there is
repeated code, such as the "i" variable in this example, you can simply
start typing once it's highlighted and all the matches specified in the
snippet will be updated. To go in reverse, use <shift-tab>.

==============================================================================
SYNTAX                                                        *snippet-syntax*

Snippets can be defined in two ways. They can be in their own file, named
after their trigger in 'snippets/<filetype>/<trigger>.snippet', or they can be
defined together in a 'snippets/<filetype>.snippets' file. Note that dotted
'filetype' syntax is supported -- e.g., you can use >

	:set ft=html.eruby

to activate snippets for both HTML and eRuby for the current file.

The syntax for snippets in *.snippets files is the following: >

 snippet trigger
 	expanded text
	more expanded text

Note that the first hard tab after the snippet trigger is required, and not
expanded in the actual snippet. The syntax for *.snippet files is the same,
only without the trigger declaration and starting indentation.

Also note that snippets must be defined using hard tabs. They can be expanded
to spaces later if desired (see |snipMate-indenting|).

"#" is used as a line-comment character in *.snippets files; however, they can
only be used outside of a snippet declaration. E.g.: >

 # this is a correct comment
 snippet trigger
 	expanded text
 snippet another_trigger
 	# this isn't a comment!
	expanded text
<
This should hopefully be obvious with the included syntax highlighting.

                                                               *snipMate-${#}*
Tab stops ~

By default, the cursor is placed at the end of a snippet. To specify where the
cursor is to be placed next, use "${#}", where the # is the number of the tab
stop. E.g., to place the cursor first on the id of a <div> tag, and then allow
the user to press <tab> to go to the middle of it:
 >
 snippet div
 	<div id="${1}">
		${2}
	</div>
<
                        *snipMate-placeholders* *snipMate-${#:}* *snipMate-$#*
Placeholders ~

Placeholder text can be supplied using "${#:text}", where # is the number of
the tab stop. This text then can be copied throughout the snippet using "$#",
given # is the same number as used before. So, to make a C for loop: >

 snippet for
 	for (${2:i}; $2 < ${1:count}; $1++) {
		${4}
	}

This will cause "count" to first be selected and change if the user starts
typing. When <tab> is pressed, the "i" in ${2}'s position will be selected;
all $2 variables will default to "i" and automatically be updated if the user
starts typing.
NOTE: "$#" syntax is used only for variables, not for tab stops as in TextMate.

Variables within variables are also possible. For instance: >

 snippet opt
 	<option value="${1:option}">${2:$1}</option>

Will, as usual, cause "option" to first be selected and update all the $1
variables if the user starts typing. Since one of these variables is inside of
${2}, this text will then be used as a placeholder for the next tab stop,
allowing the user to change it if he wishes.

To copy a value throughout a snippet without supplying default text, simply
use the "${#:}" construct without the text; e.g.: >

 snippet foo
 	${1:}bar$1
<                                                          *snipMate-commands*
Interpolated Vim Script ~

Snippets can also contain Vim script commands that are executed (via |eval()|)
when the snippet is inserted. Commands are given inside backticks (`...`); for
TextMates's functionality, use the |system()| function. E.g.: >

 snippet date
 	`system("date +%Y-%m-%d")`

will insert the current date, assuming you are on a Unix system. Note that you
can also (and should) use |strftime()| for this example.

Filename([{expr}] [, {defaultText}])             *snipMate-filename* *Filename()*

Since the current filename is used often in snippets, a default function
has been defined for it in snipMate.vim, appropriately called Filename().

With no arguments, the default filename without an extension is returned;
the first argument specifies what to place before or after the filename,
and the second argument supplies the default text to be used if the file
has not been named. "$1" in the first argument is replaced with the filename;
if you only want the filename to be returned, the first argument can be left
blank. Examples: >

 snippet filename
 	`Filename()`
 snippet filename_with_default
 	`Filename('', 'name')`
 snippet filename_foo
 	`filename('$1_foo')`

The first example returns the filename if it the file has been named, and an
empty string if it hasn't. The second returns the filename if it's been named,
and "name" if it hasn't. The third returns the filename followed by "_foo" if
it has been named, and an empty string if it hasn't.

                                                                   *multi_snip*
To specify that a snippet can have multiple matches in a *.snippets file, use
this syntax: >

 snippet trigger A description of snippet #1
 	expand this text
 snippet trigger A description of snippet #2
 	expand THIS text!

In this example, when "trigger<tab>" is typed, a numbered menu containing all
of the descriptions of the "trigger" will be shown; when the user presses the
corresponding number, that snippet will then be expanded.

To create a snippet with multiple matches using *.snippet files,
simply place all the snippets in a subdirectory with the trigger name:
'snippets/<filetype>/<trigger>/<name>.snippet'.

==============================================================================
USAGE                                                         *snipMate-usage*

                                                 *'snippets'* *g:snippets_dir*
Snippets are by default looked for any 'snippets' directory in your
'runtimepath'. Typically, it is located at '~/.vim/snippets/' on *nix or
'$HOME\vimfiles\snippets\' on Windows. To change that location or add another
one, change the g:snippets_dir variable in your |.vimrc| to your preferred
directory, or use the |ExtractSnips()|function. This will be used by the
|globpath()| function, and so accepts the same syntax as it (e.g.,
comma-separated paths).

ExtractSnipsFile({directory}, {filetype})     *ExtractSnipsFile()* *.snippets*

ExtractSnipsFile() extracts the specified *.snippets file for the given
filetype. A .snippets file contains multiple snippet declarations for the
filetype. It is further explained above, in |snippet-syntax|.

ExtractSnips({directory}, {filetype})             *ExtractSnips()* *.snippet*

ExtractSnips() extracts *.snippet files from the specified directory and
defines them as snippets for the given filetype. The directory tree should
look like this: 'snippets/<filetype>/<trigger>.snippet'. If the snippet has
multiple matches, it should look like this:
'snippets/<filetype>/<trigger>/<name>.snippet' (see |multi_snip|).

ResetAllSnippets()                                       *ResetAllSnippets()*
ResetAllSnippets() removes all snippets from memory. This is useful to put at
the top of a snippet setup file for if you would like to |:source| it multiple
times.

ResetSnippets({filetype})                                   *ResetSnippets()*
ResetSnippets() removes all snippets from memory for the given filetype.

ReloadAllSnippets()                                     *ReloadAllSnippets()*
ReloadAllSnippets() reloads all snippets for all filetypes. This is useful for
testing and debugging.

ReloadSnippets({filetype})                                 *ReloadSnippets()*
ReloadSnippets() reloads all snippets for the given filetype.

                                             *list-snippets* *i_CTRL-R_<Tab>*
If you would like to see what snippets are available, simply type <c-r><tab>
in the current buffer to show a list via |popupmenu-completion|.

==============================================================================
SETTINGS                                  *snipMate-settings* *g:snips_author*

The g:snips_author string (similar to $TM_FULLNAME in TextMate) should be set
to your name; it can then be used in snippets to automatically add it. E.g.: >

 let g:snips_author = 'Hubert Farnsworth'
 snippet name
 	`g:snips_author`
<
                                     *snipMate-expandtab* *snipMate-indenting*
If you would like your snippets to be expanded using spaces instead of tabs,
just enable 'expandtab' and set 'softtabstop' to your preferred amount of
spaces. If 'softtabstop' is not set, 'shiftwidth' is used instead.

                                                              *snipMate-remap*
snipMate does not come with a setting to customize the trigger key, but you
can remap it easily in the two lines it's defined in the 'after' directory
under 'plugin/snipMate.vim'. For instance, to change the trigger key
to CTRL-J, just change this: >

 ino <tab> <c-r>=TriggerSnippet()<cr>
 snor <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>

to this: >
 ino <c-j> <c-r>=TriggerSnippet()<cr>
 snor <c-j> <esc>i<right><c-r>=TriggerSnippet()<cr>

==============================================================================
FEATURES                                                   *snipMate-features*

snipMate.vim has the following features among others:
  - The syntax of snippets is very similar to TextMate's, allowing
    easy conversion.
  - The position of the snippet is kept transparently (i.e. it does not use
    markers/placeholders written to the buffer), which allows you to escape
    out of an incomplete snippet, something particularly useful in Vim.
  - Variables in snippets are updated as-you-type.
  - Snippets can have multiple matches.
  - Snippets can be out of order. For instance, in a do...while loop, the
    condition can be added before the code.
  - [New] File-based snippets are supported.
  - [New] Triggers after non-word delimiters are expanded, e.g. "foo"
    in "bar.foo".
  - [New] <shift-tab> can now be used to jump tab stops in reverse order.

==============================================================================
DISADVANTAGES                                         *snipMate-disadvantages*

snipMate.vim currently has the following disadvantages to TextMate's snippets:
    - There is no $0; the order of tab stops must be explicitly stated.
    - Placeholders within placeholders are not possible. E.g.: >

      '<div${1: id="${2:some_id}}">${3}</div>'
<
      In TextMate this would first highlight ' id="some_id"', and if
      you hit delete it would automatically skip ${2} and go to ${3}
      on the next <tab>, but if you didn't delete it it would highlight
      "some_id" first. You cannot do this in snipMate.vim.
    - Regex cannot be performed on variables, such as "${1/.*/\U&}"
    - Placeholders cannot span multiple lines.
    - Activating snippets in different scopes of the same file is
      not possible.

Perhaps some of these features will be added in a later release.

==============================================================================
CONTACT                                   *snipMate-contact* *snipMate-author*

To contact the author (Michael Sanders), please email:
 msanders42+snipmate <at> gmail <dot> com

I greatly appreciate any suggestions or improvements offered for the script.

==============================================================================
LICENSE                                                     *snipMate-license*

snipMate is released under the MIT license:

Copyright 2009-2010 Michael Sanders. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The software is provided "as is", without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in the
software.

==============================================================================

vim:tw=78:ts=8:ft=help:norl:
zhimakaimen:/vimfiles/bundle/snipmate.vim/doc/snipMate.txt
" File:          snipMate.vim
" Author:        Michael Sanders
" Version:       0.84
" Description:   snipMate.vim implements some of TextMate's snippets features in
"                Vim. A snippet is a piece of often-typed text that you can
"                insert into your document using a trigger word followed by a "<tab>".
"
"                For more help see snipMate.txt; you can do this by using:
"                :helptags ~/.vim/doc
"                :h snipMate.txt

if exists('loaded_snips') || &cp || version < 700
	finish
endif
let loaded_snips = 1
if !exists('snips_author') | let snips_author = 'Me' | endif

au BufRead,BufNewFile *.snippets\= set ft=snippet
au FileType snippet setl noet fdm=indent

let s:snippets = {} | let s:multi_snips = {}

if !exists('snippets_dir')
	let snippets_dir = substitute(globpath(&rtp, 'snippets/'), "\n", ',', 'g')
endif

fun! MakeSnip(scope, trigger, content, ...)
	let multisnip = a:0 && a:1 != ''
	let var = multisnip ? 's:multi_snips' : 's:snippets'
	if !has_key({var}, a:scope) | let {var}[a:scope] = {} | endif
	if !has_key({var}[a:scope], a:trigger)
		let {var}[a:scope][a:trigger] = multisnip ? [[a:1, a:content]] : a:content
	elseif multisnip | let {var}[a:scope][a:trigger] += [[a:1, a:content]]
	else
		echom 'Warning in snipMate.vim: Snippet '.a:trigger.' is already defined.'
				\ .' See :h multi_snip for help on snippets with multiple matches.'
	endif
endf

fun! ExtractSnips(dir, ft)
	for path in split(globpath(a:dir, '*'), "\n")
		if isdirectory(path)
			let pathname = fnamemodify(path, ':t')
			for snipFile in split(globpath(path, '*.snippet'), "\n")
				call s:ProcessFile(snipFile, a:ft, pathname)
			endfor
		elseif fnamemodify(path, ':e') == 'snippet'
			call s:ProcessFile(path, a:ft)
		endif
	endfor
endf

" Processes a single-snippet file; optionally add the name of the parent
" directory for a snippet with multiple matches.
fun s:ProcessFile(file, ft, ...)
	let keyword = fnamemodify(a:file, ':t:r')
	if keyword  == '' | return | endif
	try
		let text = join(readfile(a:file), "\n")
	catch /E484/
		echom "Error in snipMate.vim: couldn't read file: ".a:file
	endtry
	return a:0 ? MakeSnip(a:ft, a:1, text, keyword)
			\  : MakeSnip(a:ft, keyword, text)
endf

fun! ExtractSnipsFile(file, ft)
	if !filereadable(a:file) | return | endif
	let text = readfile(a:file)
	let inSnip = 0
	for line in text + ["\n"]
		if inSnip && (line[0] == "\t" || line == '')
			let content .= strpart(line, 1)."\n"
			continue
		elseif inSnip
			call MakeSnip(a:ft, trigger, content[:-2], name)
			let inSnip = 0
		endif

		if line[:6] == 'snippet'
			let inSnip = 1
			let trigger = strpart(line, 8)
			let name = ''
			let space = stridx(trigger, ' ') + 1
			if space " Process multi snip
				let name = strpart(trigger, space)
				let trigger = strpart(trigger, 0, space - 1)
			endif
			let content = ''
		endif
	endfor
endf

" Reset snippets for filetype.
fun! ResetSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	for dict in [s:snippets, s:multi_snips, g:did_ft]
		if has_key(dict, ft)
			unlet dict[ft]
		endif
	endfor
endf

" Reset snippets for all filetypes.
fun! ResetAllSnippets()
	let s:snippets = {} | let s:multi_snips = {} | let g:did_ft = {}
endf

" Reload snippets for filetype.
fun! ReloadSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	call ResetSnippets(ft)
	call GetSnippets(g:snippets_dir, ft)
endf

" Reload snippets for all filetypes.
fun! ReloadAllSnippets()
	for ft in keys(g:did_ft)
		call ReloadSnippets(ft)
	endfor
endf

let g:did_ft = {}
fun! GetSnippets(dir, filetypes)
	for ft in split(a:filetypes, '\.')
		if has_key(g:did_ft, ft) | continue | endif
		call s:DefineSnips(a:dir, ft, ft)
		if ft == 'objc' || ft == 'cpp' || ft == 'cs'
			call s:DefineSnips(a:dir, 'c', ft)
		elseif ft == 'xhtml'
			call s:DefineSnips(a:dir, 'html', 'xhtml')
		endif
		let g:did_ft[ft] = 1
	endfor
endf

" Define "aliasft" snippets for the filetype "realft".
fun s:DefineSnips(dir, aliasft, realft)
	for path in split(globpath(a:dir, a:aliasft.'/')."\n".
					\ globpath(a:dir, a:aliasft.'-*/'), "\n")
		call ExtractSnips(path, a:realft)
	endfor
	for path in split(globpath(a:dir, a:aliasft.'.snippets')."\n".
					\ globpath(a:dir, a:aliasft.'-*.snippets'), "\n")
		call ExtractSnipsFile(path, a:realft)
	endfor
endf

fun! TriggerSnippet()
	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingForward == "<tab>"
			let SuperTabKey = "\<c-n>"
		elseif g:SuperTabMappingBackward == "<tab>"
			let SuperTabKey = "\<c-p>"
		endif
	endif

	if pumvisible() " Update snippet if completion is used, or deal with supertab
		if exists('SuperTabKey')
			call feedkeys(SuperTabKey) | return ''
		endif
		call feedkeys("\<esc>a", 'n') " Close completion menu
		call feedkeys("\<tab>") | return ''
	endif

	if exists('g:snipPos') | return snipMate#jumpTabStop(0) | endif

	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let [trigger, snippet] = s:GetSnippet(word, scope)
		" If word is a trigger for a snippet, delete the trigger & expand
		" the snippet.
		if snippet != ''
			let col = col('.') - len(trigger)
			sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
			return snipMate#expandSnip(snippet, col)
		endif
	endfor

	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<tab>"
endf

fun! BackwardsSnippet()
	if exists('g:snipPos') | return snipMate#jumpTabStop(1) | endif

	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingBackward == "<s-tab>"
			let SuperTabKey = "\<c-p>"
		elseif g:SuperTabMappingForward == "<s-tab>"
			let SuperTabKey = "\<c-n>"
		endif
	endif
	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<s-tab>"
endf

" Check if word under cursor is snippet trigger; if it isn't, try checking if
" the text after non-word characters is (e.g. check for "foo" in "bar.foo")
fun s:GetSnippet(word, scope)
	let word = a:word | let snippet = ''
	while snippet == ''
		if exists('s:snippets["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:snippets[a:scope][word]
		elseif exists('s:multi_snips["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:ChooseSnippet(a:scope, word)
			if snippet == '' | break | endif
		else
			if match(word, '\W') == -1 | break | endif
			let word = substitute(word, '.\{-}\W', '', '')
		endif
	endw
	if word == '' && a:word != '.' && stridx(a:word, '.') != -1
		let [word, snippet] = s:GetSnippet('.', a:scope)
	endif
	return [word, snippet]
endf

fun s:ChooseSnippet(scope, trigger)
	let snippet = []
	let i = 1
	for snip in s:multi_snips[a:scope][a:trigger]
		let snippet += [i.'. '.snip[0]]
		let i += 1
	endfor
	if i == 2 | return s:multi_snips[a:scope][a:trigger][0][1] | endif
	let num = inputlist(snippet) - 1
	return num == -1 ? '' : s:multi_snips[a:scope][a:trigger][num][1]
endf

fun! ShowAvailableSnips()
	let line  = getline('.')
	let col   = col('.')
	let word  = matchstr(getline('.'), '\S\+\%'.col.'c')
	let words = [word]
	if stridx(word, '.')
		let words += split(word, '\.', 1)
	endif
	let matchlen = 0
	let matches = []
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let triggers = has_key(s:snippets, scope) ? keys(s:snippets[scope]) : []
		if has_key(s:multi_snips, scope)
			let triggers += keys(s:multi_snips[scope])
		endif
		for trigger in triggers
			for word in words
				if word == ''
					let matches += [trigger] " Show all matches if word is empty
				elseif trigger =~ '^'.word
					let matches += [trigger]
					let len = len(word)
					if len > matchlen | let matchlen = len | endif
				endif
			endfor
		endfor
	endfor

	" This is to avoid a bug with Vim when using complete(col - matchlen, matches)
	" (Issue#46 on the Google Code snipMate issue tracker).
	call setline(line('.'), substitute(line, repeat('.', matchlen).'\%'.col.'c', '', ''))
	call complete(col, matches)
	return ''
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/vimfiles/bundle/snipmate.vim/plugin/snipMate.vim
# snippets for making snippets :)
snippet snip
	snippet ${1:trigger}
		${2}
snippet msnip
	snippet ${1:trigger} ${2:description}
		${3}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/snippet.snippets
# #!/bin/zsh
snippet #!
	#!/bin/zsh

snippet if
	if ${1:condition}; then
		${2:# statements}
	fi
snippet ife
	if ${1:condition}; then
		${2:# statements}
	else
		${3:# statements}
	fi
snippet elif
	elif ${1:condition} ; then
		${2:# statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:# statements}
	done
snippet fore
	for ${1:item} in ${2:list}; do
		${3:# statements}
	done
snippet wh
	while ${1:condition}; do
		${2:# statements}
	done
snippet until
	until ${1:condition}; do
		${2:# statements}
	done
snippet repeat
	repeat ${1:integer}; do
		${2:# statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
snippet select
	select ${1:answer} in ${2:choices}; do
		${3:# statements}
	done
snippet (
	( ${1:#statements} )
snippet {
	{ ${1:#statements} }
snippet [
	[[ ${1:test} ]]
snippet always
	{ ${1:try} } always { ${2:always} }
snippet fun
	function ${1:name} (${2:args}) {
		${3:# body}
	}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/zsh.snippets
# #!/bin/bash
snippet #!
	#!/bin/bash
	
snippet if
	if [[ ${1:condition} ]]; then
		${2:#statements}
	fi
snippet elif
	elif [[ ${1:condition} ]]; then
		${2:#statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:#statements}
	done
snippet wh
	while [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet until
	until [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/sh.snippets
# #import <...>
snippet Imp
	#import <${1:Cocoa/Cocoa.h}>${2}
# #import "..."
snippet imp
	#import "${1:`Filename()`.h}"${2}
# @selector(...)
snippet sel
	@selector(${1:method}:)${3}
# @"..." string
snippet s
	@"${1}"${2}
# Object
snippet o
	${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};${5}
# NSLog(...)
snippet log
	NSLog(@"${1:%@}"${2});${3}
# Class
snippet objc
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{
	}
	@end

	@implementation $1
	${3}
	@end
# Class Interface
snippet int
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
snippet @interface
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
# Class Implementation
snippet impl
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
snippet @implementation
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
# Protocol
snippet pro
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
snippet @protocol
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
# init Definition
snippet init
	- (id)init
	{
		if (self = [super init]) {
			${1}
		}
		return self;
	}
# dealloc Definition
snippet dealloc
	- (void) dealloc
	{
		${1:deallocations}
		[super dealloc];
	}
snippet su
	[super ${1:init}]${2}
snippet ibo
	IBOutlet ${1:NSSomeClass} *${2:$1};${3}
# Category
snippet cat
	@interface ${1:NSObject} (${2:MyCategory})
	@end

	@implementation $1 ($2)
	${3}
	@end
# Category Interface
snippet cath
	@interface ${1:`Filename('$1', 'NSObject')`} (${2:MyCategory})
	${3}
	@end
# Method
snippet m
	- (${1:id})${2:method}
	{
		${3}
	}
# Method declaration
snippet md
	- (${1:id})${2:method};${3}
# IBAction declaration
snippet ibad
	- (IBAction)${1:method}:(${2:id})sender;${3}
# IBAction method
snippet iba
	- (IBAction)${1:method}:(${2:id})sender
	{
		${3}
	}
# awakeFromNib method
snippet wake
	- (void)awakeFromNib
	{
		${1}
	}
# Class Method
snippet M
	+ (${1:id})${2:method}
	{
		${3:return nil;}
	}
# Sub-method (Call super)
snippet sm
	- (${1:id})${2:method}
	{
		[super $2];${3}
		return self;
	}
# Accessor Methods For:
# Object
snippet objacc
	- (${1:id})${2:thing}
	{
		return $2;
	}

	- (void)set$2:($1)${3:new$2}
	{
		[$3 retain];
		[$2 release];
		$2 = $3;
	}${4}
# for (object in array)
snippet forin
	for (${1:Class} *${2:some$1} in ${3:array}) {
		${4}
	}
snippet fore
	for (${1:object} in ${2:array}) {
		${3:statements}
	}
snippet forarray
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
snippet fora
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
# Try / Catch Block
snippet	@try
	@try {
		${1:statements}
	}
	@catch (NSException * e) {
		${2:handler}
	}
	@finally {
		${3:statements}
	}
snippet @catch
	@catch (${1:exception}) {
		${2:handler}
	}
snippet @finally
	@finally {
		${1:statements}
	}
# IBOutlet
# @property (Objective-C 2.0)
snippet prop
	@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};${4}
# @synthesize (Objective-C 2.0)
snippet syn
	@synthesize ${1:property};${2}
# [[ alloc] init]
snippet alloc
	[[${1:foo} alloc] init${2}];${3}
snippet a
	[[${1:foo} alloc] init${2}];${3}
# retain
snippet ret
	[${1:foo} retain];${2}
# release
snippet rel
	[${1:foo} release];
# autorelease
snippet arel
	[${1:foo} autorelease];
# autorelease pool
snippet pool
	NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];
	${2:/* code */}
	[$1 drain];
# Throw an exception
snippet except
	NSException *${1:badness};
	$1 = [NSException exceptionWithName:@"${2:$1Name}"
	                             reason:@"${3}"
	                           userInfo:nil];
	[$1 raise];
snippet prag
	#pragma mark ${1:-}
snippet cl
	@class ${1:Foo};${2}
snippet color
	[[NSColor ${1:blackColor}] set];
# NSArray
snippet array
	NSMutableArray *${1:array} = [NSMutable array];${2}
snippet nsa
	NSArray ${1}
snippet nsma
	NSMutableArray ${1}
snippet aa
	NSArray * array;${1}
snippet ma
	NSMutableArray * array;${1}
# NSDictionary
snippet dict
	NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];${2}
snippet nsd
	NSDictionary ${1}
snippet nsmd
	NSMutableDictionary ${1}
# NSString
snippet nss
	NSString ${1}
snippet nsms
	NSMutableString ${1}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/objc.snippets
snippet php
	<?php
	${1}
	?>
snippet ec
	echo "${1:string}"${2};
snippet inc
	include '${1:file}';${2}
snippet inc1
	include_once '${1:file}';${2}
snippet req
	require '${1:file}';${2}
snippet req1
	require_once '${1:file}';${2}
# $GLOBALS['...']
snippet globals
	$GLOBALS['${1:variable}']${2: = }${3:something}${4:;}${5}
snippet $_ COOKIE['...']
	$_COOKIE['${1:variable}']${2}
snippet $_ ENV['...']
	$_ENV['${1:variable}']${2}
snippet $_ FILES['...']
	$_FILES['${1:variable}']${2}
snippet $_ Get['...']
	$_GET['${1:variable}']${2}
snippet $_ POST['...']
	$_POST['${1:variable}']${2}
snippet $_ REQUEST['...']
	$_REQUEST['${1:variable}']${2}
snippet $_ SERVER['...']
	$_SERVER['${1:variable}']${2}
snippet $_ SESSION['...']
	$_SESSION['${1:variable}']${2}
# Start Docblock
snippet /*
	/**
	 * ${1}
	 **/
# Class - post doc
snippet doc_cp
	/**
	 * ${1:undocumented class}
	 *
	 * @package ${2:default}
	 * @author ${3:`g:snips_author`}
	**/${4}
# Class Variable - post doc
snippet doc_vp
	/**
	 * ${1:undocumented class variable}
	 *
	 * @var ${2:string}
	 **/${3}
# Class Variable
snippet doc_v
	/**
	 * ${3:undocumented class variable}
	 *
	 * @var ${4:string}
	 **/
	${1:var} $${2};${5}
# Class
snippet doc_c
	/**
	 * ${3:undocumented class}
	 *
	 * @packaged ${4:default}
	 * @author ${5:`g:snips_author`}
	 **/
	${1:}class ${2:}
	{${6}
	} // END $1class $2
# Constant Definition - post doc
snippet doc_dp
	/**
	 * ${1:undocumented constant}
	 **/${2}
# Constant Definition
snippet doc_d
	/**
	 * ${3:undocumented constant}
	 **/
	define(${1}, ${2});${4}
# Function - post doc
snippet doc_fp
	/**
	 * ${1:undocumented function}
	 *
	 * @return ${2:void}
	 * @author ${3:`g:snips_author`}
	 **/${4}
# Function signature
snippet doc_s
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3});${7}
# Function
snippet doc_f
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3})
	{${7}
	}
# Header
snippet doc_h
	/**
	 * ${1}
	 *
	 * @author ${2:`g:snips_author`}
	 * @version ${3:$Id$}
	 * @copyright ${4:$2}, `strftime('%d %B, %Y')`
	 * @package ${5:default}
	 **/
	
	/**
	 * Define DocBlock
	 *//
# Interface
snippet doc_i
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 **/
	interface ${1:}
	{${5}
	} // END interface $1
# class ...
snippet class
	/**
	 * ${1}
	 **/
	class ${2:ClassName}
	{
		${3}
		function ${4:__construct}(${5:argument})
		{
			${6:// code...}
		}
	}
# define(...)
snippet def
	define('${1}'${2});${3}
# defined(...)
snippet def?
	${1}defined('${2}')${3}
snippet wh
	while (${1:/* condition */}) {
		${2:// code...}
	}
# do ... while
snippet do
	do {
		${2:// code... }
	} while (${1:/* condition */});
snippet if
	if (${1:/* condition */}) {
		${2:// code...}
	}
snippet ife
	if (${1:/* condition */}) {
		${2:// code...}
	} else {
		${3:// code...}
	}
	${4}
snippet else
	else {
		${1:// code...}
	}
snippet elseif
	elseif (${1:/* condition */}) {
		${2:// code...}
	}
# Tertiary conditional
snippet t
	$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};${5}
snippet switch
	switch ($${1:variable}) {
		case '${2:value}':
			${3:// code...}
			break;
		${5}
		default:
			${4:// code...}
			break;
	}
snippet case
	case '${1:value}':
		${2:// code...}
		break;${3}
snippet for
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4: // code...}
	}
snippet foreach
	foreach ($${1:variable} as $${2:key}) {
		${3:// code...}
	}
snippet fun
	${1:public }function ${2:FunctionName}(${3})
	{
		${4:// code...}
	}
# $... = array (...)
snippet array
	$${1:arrayName} = array('${2}' => ${3});${4}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/php.snippets
# #!/usr/bin/perl
snippet #!
	#!/usr/bin/perl

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	}
	else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression} if ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression} unless ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression} while ${2:condition};${3}
# C-style For Loop
snippet cfor
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4:# body...}
	}
# For loop one-line
snippet xfor
	${1:expression} for @${2:array};${3}
# Foreach Loop
snippet for
	foreach my $${1:x} (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet fore
	${1:expression} foreach @${2:array};${3}
# Package
snippet cl
	package ${1:ClassName};

	use base qw(${2:ParentClass});

	sub new {
		my $class = shift;
		$class = ref $class if ref $class;
		my $self = bless {}, $class;
		$self;
	}

	1;${3}
# Read File
snippet slurp
	my $${1:var};
	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/perl.snippets
# \begin{}...\end{}
snippet begin
	\begin{${1:env}}
		${2}
	\end{$1}
# Tabular
snippet tab
	\begin{${1:tabular}}{${2:c}}
	${3}
	\end{$1}
# Align(ed)
snippet ali
	\begin{align${1:ed}}
		${2}
	\end{align$1}
# Gather(ed)
snippet gat
	\begin{gather${1:ed}}
		${2}
	\end{gather$1}
# Equation
snippet eq
	\begin{equation}
		${1}
	\end{equation}
# Unnumbered Equation
snippet \
	\\[
		${1}
	\\]
# Enumerate
snippet enum
	\begin{enumerate}
		\item ${1}
	\end{enumerate}
# Itemize
snippet item
	\begin{itemize}
		\item ${1}
	\end{itemize}
# Description
snippet desc
	\begin{description}
		\item[${1}] ${2}
	\end{description}
# Matrix
snippet mat
	\begin{${1:p/b/v/V/B/small}matrix}
		${2}
	\end{$1matrix}
# Cases
snippet cas
	\begin{cases}
		${1:equation}, &\text{ if }${2:case}\\
		${3}
	\end{cases}
# Split
snippet spl
	\begin{split}
		${1}
	\end{split}
# Part
snippet part
	\part{${1:part name}} % (fold)
	\label{prt:${2:$1}}
	${3}
	% part $2 (end)
# Chapter
snippet cha
	\chapter{${1:chapter name}} % (fold)
	\label{cha:${2:$1}}
	${3}
	% chapter $2 (end)
# Section
snippet sec
	\section{${1:section name}} % (fold)
	\label{sec:${2:$1}}
	${3}
	% section $2 (end)
# Sub Section
snippet sub
	\subsection{${1:subsection name}} % (fold)
	\label{sub:${2:$1}}
	${3}
	% subsection $2 (end)
# Sub Sub Section
snippet subs
	\subsubsection{${1:subsubsection name}} % (fold)
	\label{ssub:${2:$1}}
	${3}
	% subsubsection $2 (end)
# Paragraph
snippet par
	\paragraph{${1:paragraph name}} % (fold)
	\label{par:${2:$1}}
	${3}
	% paragraph $2 (end)
# Sub Paragraph
snippet subp
	\subparagraph{${1:subparagraph name}} % (fold)
	\label{subp:${2:$1}}
	${3}
	% subparagraph $2 (end)
snippet itd
	\item[${1:description}] ${2:item}
snippet figure
	${1:Figure}~\ref{${2:fig:}}${3}
snippet table
	${1:Table}~\ref{${2:tab:}}${3}
snippet listing
	${1:Listing}~\ref{${2:list}}${3}
snippet section
	${1:Section}~\ref{${2:sec:}}${3}
snippet page
	${1:page}~\pageref{${2}}${3}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/tex.snippets
# a farbox header snip
snippet til
	Title: ${1}
	Status: ${2:Public}
	Tags: ${3}
	Date: time${4}

	[TOC]
# a code block snip
# a bug occurs starting with ``
snippet code
	```${1:verilog}
	${2}
	```

# a Tex numbered equation block snip
snippet equ
	$$
	\begin{equation}
		${1:your equation}
	\end{equation}
	$$

# \begin{}...\end{}
snippet begin
	$$
	\begin{${1:env}}
		${2}
	\end{$1}
	$$

# linker snip
snippet lin
	[${1}](${2:http://}${3})

zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/markdown.snippets
# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet req
	require "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet deft
	def test_${1:case_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end		
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end	
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eaid
	each_index do |${1:i}|
	end
snippet eak
	each_key { |${1:key}| ${2} }
snippet eakd
	each_key do |${1:key}|
		${2}
	end
snippet eal
	each_line { |${1:line}| ${2} }
snippet eald
	each_line do |${1:line}|
		${2}
	end		
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${3}
	end			
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet easd-
	each_slice(${1:2}) do |${2:group}|
		${3}
	end		
snippet eav
	each_value { |${1:val}| ${2} }
snippet eavd
	each_value do |${1:val}| 
		${2}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet eawid
	each_with_index do |${1:e},${2:i}|
		${3}
	end
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet reved
	reverse_each do |${1:e}|
		${2}
	end	
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end		
snippet map
	map { |${1:e}| ${2} }
snippet mapd
	map do |${1:e}| 
		${2}
	end		
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet cold
	collect do |${1:e}|
		${2}
	end
snippet det
	detect { |${1:e}| ${2} }
snippet detd
	detect do |${1:e}|
		${2}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet find
	find do |${1:e}|
		${2}
	end		
snippet fina
	find_all { |${1:e}| ${2} }
snippet finad
	find_all do |${1:e}|
		${2}
	end			
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end		
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet pard
	partition do |${1:e}|
		${2}
	end		
snippet rej
	reject { |${1:e}| ${2} }
snippet rejd
	reject do |${1:e}|
		${2}
	end
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end		
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet :
	:${1:key} => ${2:"value"}${3}
snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
snippet patfh
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/ruby.snippets
# module and export all
snippet mod
	-module(${1:`Filename('', 'my')`}).
	
	-compile([export_all]).
	
	start() ->
	    ${2}
	
	stop() ->
	    ok.
# define directive
snippet def
	-define(${1:macro}, ${2:body}).${3}
# export directive
snippet exp
	-export([${1:function}/${2:arity}]).
# include directive
snippet inc
	-include("${1:file}").${2}
# behavior directive
snippet beh
	-behaviour(${1:behaviour}).${2}
# if expression
snippet if
	if
	    ${1:guard} ->
	        ${2:body}
	end
# case expression
snippet case
	case ${1:expression} of
	    ${2:pattern} ->
	        ${3:body};
	end
# record directive
snippet rec
	-record(${1:record}, {
	    ${2:field}=${3:value}}).${4}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/erlang.snippets
# Read File Into Vector
snippet readfile
	std::vector<char> v;
	if (FILE *${2:fp} = fopen(${1:"filename"}, "r")) {
		char buf[1024];
		while (size_t len = fread(buf, 1, sizeof(buf), $2))
			v.insert(v.end(), buf, buf + len);
		fclose($2);
	}${3}
# std::map
snippet map
	std::map<${1:key}, ${2:value}> map${3};
# std::vector
snippet vector
	std::vector<${1:char}> v${2};
# Namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* $1 */
# Class
snippet cl
	class ${1:`Filename('$1_t', 'name')`} {
	public:
		$1 (${2:arguments});
		virtual ~$1 ();

	private:
		${3:/* data */}
	};
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4:/* code */}
	}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/cpp.snippets
snippet #!
	#!/usr/bin/env python

snippet imp
	import ${1:module}
# Module Docstring
snippet docs
	'''
	File: ${1:`Filename('$1.py', 'foo.py')`}
	Author: ${2:`g:snips_author`}
	Description: ${3}
	'''
snippet wh
	while ${1:condition}:
		${2:# code...}
snippet for
	for ${1:needle} in ${2:haystack}:
		${3:# code...}
# New Class
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${6}
# New Function
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${4:pass}
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${3}
# New Method
snippet defs
	def ${1:mname}(self, ${2:arg}):
		${3:pass}
# New Property
snippet property
	def ${1:foo}():
		doc = "${2:The $1 property.}"
		def fget(self):
			${3:return self._$1}
		def fset(self, value):
			${4:self._$1 = value}
# Lambda
snippet ld
	${1:var} = lambda ${2:vars} : ${3:action}
snippet .
	self.
snippet try Try/Except
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
snippet try Try/Except/Else
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
snippet try Try/Except/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	finally:
		${5:pass}
snippet try Try/Except/Else/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
	finally:
		${6:pass}
# if __name__ == '__main__':
snippet ifmain
	if __name__ == '__main__':
		${1:main()}
# __magic__
snippet _
	__${1:init}__${2}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/python.snippets
snippet header
	" File: ${1:`expand('%:t')`}
	" Author: ${2:`g:snips_author`}
	" Description: ${3}
	${4:" Last Modified: `strftime("%B %d, %Y")`}
snippet guard
	if exists('${1:did_`Filename()`}') || &cp${2: || version < 700}
		finish
	endif
	let $1 = 1${3}
snippet f
	fun ${1:function_name}(${2})
		${3:" code}
	endf
snippet for
	for ${1:needle} in ${2:haystack}
		${3:" code}
	endfor
snippet wh
	while ${1:condition}
		${2:" code}
	endw
snippet if
	if ${1:condition}
		${2:" code}
	endif
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	endif
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/vim.snippets
snippet .
	.${1:class_name}
	{
		${2:font-size:}
	}
	
snippet sel
	${1:selector_name}
	{
		${2:font-size:}
	}
	
snippet #
	#${1:id_name}
	{
		${2:font-size:}
	}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/css.snippets
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/.gitignore
snippet if
	If ${1:condition} Then
		${2:; True code}
	EndIf
snippet el
	Else
		${1}
snippet elif
	ElseIf ${1:condition} Then
		${2:; True code}
# If/Else block
snippet ifel
	If ${1:condition} Then
		${2:; True code}
	Else
		${3:; Else code}
	EndIf
# If/ElseIf/Else block
snippet ifelif
	If ${1:condition 1} Then
		${2:; True code}
	ElseIf ${3:condition 2} Then
		${4:; True code}
	Else
		${5:; Else code}
	EndIf
# Switch block
snippet switch
	Switch (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSwitch
# Select block
snippet select
	Select (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSelect
# While loop
snippet while
	While (${1:condition})
		${2:; code...}
	WEnd
# For loop
snippet for
	For ${1:n} = ${3:1} to ${2:count}
		${4:; code...}
	Next
# New Function
snippet func
	Func ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${4:Return}
	EndFunc
# Message box
snippet msg
	MsgBox(${3:MsgType}, ${1:"Title"}, ${2:"Message Text"})
# Debug Message
snippet debug
	MsgBox(0, "Debug", ${1:"Debug Message"})
# Show Variable Debug Message
snippet showvar
	MsgBox(0, "${1:VarName}", $1)
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/autoit.snippets
# #!/usr/bin/env tclsh
snippet #!
	#!/usr/bin/env tclsh
	
# Process
snippet pro
	proc ${1:function_name} {${2:args}} {
		${3:#body ...}
	}
#xif
snippet xif
	${1:expr}? ${2:true} : ${3:false}
# Conditional
snippet if
	if {${1}} {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if {${1}} {
		${2:# body...}
	} else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if {${1}} {
		${2:# body...}
	} elseif {${3}} {
		${4:# elsif...}
	} else {
		${5:# else...}
	}
# If catch then
snippet ifc
	if { [catch {${1:#do something...}} ${2:err}] } {
		${3:# handle failure...}
	}
# Catch
snippet catch
	catch {${1}} ${2:err} ${3:options}
# While Loop
snippet wh
	while {${1}} {
		${2:# body...}
	}
# For Loop
snippet for
	for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {
		${4:# body...}
	}
# Foreach Loop
snippet fore
	foreach ${1:x} {${2:#list}} {
		${3:# body...}
	}
# after ms script...
snippet af
	after ${1:ms} ${2:#do something}
# after cancel id
snippet afc
	after cancel ${1:id or script}
# after idle
snippet afi
	after idle ${1:script}
# after info id
snippet afin
	after info ${1:id}
# Expr
snippet exp
	expr {${1:#expression here}}
# Switch
snippet sw
	switch ${1:var} {
		${3:pattern 1} {
			${4:#do something}
		}
		default {
			${2:#do something}
		}
	}
# Case
snippet ca
	${1:pattern} {
		${2:#do something}
	}${3}
# Namespace eval
snippet ns
	namespace eval ${1:path} {${2:#script...}}
# Namespace current
snippet nsc
	namespace current
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/tcl.snippets
# a verilog header 
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Device: ${2:EP2C35}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//
# the revision details
snippet rev
	
	//`strftime("%c")`: ${1:created}
# module extract
snippet mod
	module ${1:name_of_module} 
	(
		${2:input}
	);
	endmodule
# module with parameters
snippet mp
	module ${1:name_of_module} 
	#(
	//parameter declaration
		parameter
	)
	(
		${2:input}
	);
	endmodule
# initial block
snippet ini
	initial
	begin
		${1:/*statements*/}
	end
# begin-end pair
snippet beg
	begin
		${1:/*statements*/}
	end
# fork-join pair
snippet fo
	fork
		${1:/*statements*/}
	join
# a wire variables declare
snippet wire
	wire [${2:7}:${1:0}] ${3:/*variables*/};
# a reg variables declare 
snippet reg
	reg [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare
snippet input
	input [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet output
	output [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet inout
	inout [${2:7}:${1:0}] ${3:/*variables*/};
# module inst boost
snippet inst a autoinst snip
	${1:name_of_module} m$1 
	(/*autoinst*/);
# inst with parameters
snippet ip
	${1:name_of_module} 
	#(/*autoinstparam*/)
	m$1 
	(/*autoinst*/);

# else if statement
# snippet eif
# 	else if (${1} ${2:=}= ${3})
# 	begin
# 		${4:/*statements*/}
# 	end
# if statement
snippet if
	if (${1:a} ${2:=}= ${3:b})
	begin
		${4:/*statements*/}
	end
# assign statement
snippet ass
	assign
		${1} = ${2};
# always block statement
snippet alw a combinational always block
	always @(${1:/*autosense*/})
	begin
		${2:/*statements*/}
	end
snippet alw a clk triggered always block
	always @(${1:pos}edge ${2:clk})
	begin
		${3:/*statements*/}
	end
snippet alw a clk triggered always block with reset signal
	always @(${1:pos}edge ${2:clk} or ${3:neg}edge ${4:rst_n})
	begin
		if (!$4)
		begin
			${5:/*autoreset*/}
		end
		else
		begin
			${6:/*statements*/}
		end
	end
# time scale statement
snippet ts
	`timescale 1ns/${1:100ps}
# include statement
snippet inc
	`include "${1:define}.v"
# else block
snippet else
	else
	begin
		${1}
	end
# an inc snip
snippet acc
	${1:var} <= $1 + ${2:8}'d1;
# state machine snip
snippet sm
	//state reg
	(* syn_encoding = "safe" *)reg [${1:7}:0] ns_$2, cs_${2:mmm};
	//state parameters
	localparam 
		${5:sIDLE} = 0,
	always @(posedge ${3:clk} or negedge ${4:rst_n})
		if (!$4)
			cs_$2 <= $5;
		else
			cs_$2 <= ns_$2;

	always @(*)
	begin
		ns_$2 = cs_$2;
		case (cs_$2)
			$5:
			default:
				ns_$2 = $5;
		endcase
	end
# parameterized bit oprand
snippet p0
	{(${1:pWIDTH}){1'b0}};
snippet p1
	{{(${1:pWIDTH}-1){1'b0}}, 1'b1};
# Altera Synthesis Attributes
snippet sa full case
	(* full_case *)
snippet sa parallel case
	(* parallel_case *)
snippet sa keep
	(* keep *)
snippet sa preserve
	(* preserve *)
snippet sa noprune
	(* noprune *)
snippet sa encoding
	(* syn_encoding = "safe" *)
# end of verilog snippets

zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/verilog.snippets
# my snippet

The verilog.snippets file is with verilog-mode compatibility.
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/README.markdown
# a c header
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Project: ${2:sup}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//Author: Zhou Chuanrui
	//E-mail: zhouchuanrui@foxmail.com
	//
# main()
snippet main
	int main(int argc, const char *argv[])
	{
		${1}
		return 0;
	}
snippet mainn
	int main(void)
	{
		${1}
		return 0;
	}
# #include <...>
snippet inc
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet def
	#define
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
snippet once
	#ifndef ${1:`toupper(Filename('$1_H', 'UNTITLED_H'))`}

	#define $1

	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if (${1:/* condition */}) 
	{
		${2:/* code */}
	}
snippet el
	else
	{
		${1}
	}
# Ternary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do
	{
		${2:/* code */}
	} while (${1:/* condition */});
# While Loop
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# For Loop
snippet for
	for (${2:i} = 0; $2 < ${1:count}; $2${3:++})
	{
		${4:/* code */}
	}
# Custom For Loop
snippet forr
	for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
	{
		${5:/* code */}
	}
# Function
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Function Declaration
snippet fund
	${1:void} ${2:function_name}(${3});${4}
# Typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};${3}
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	}${3: /* optional variable list */};${4}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }
	{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Typdef enum
snippet tde
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
# printf
# unfortunately version this isn't as nice as TextMates's, given the lack of a
# dynamic `...`
snippet pr
	printf("${1:%s}\n"${2});${3}
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
# This is kind of convenient
snippet .
	[${1}]${2}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/c.snippets
# Prototype
snippet proto
	${1:class_name}.prototype.${2:method_name} =
	function(${3:first_argument}) {
		${4:// body...}
	};
# Function
snippet fun
	function ${1:function_name} (${2:argument}) {
		${3:// body...}
	}
# Anonymous Function
snippet f
	function(${1}) {${2}};
# if
snippet if
	if (${1:true}) {${2}}
# if ... else
snippet ife
	if (${1:true}) {${2}}
	else{${3}}
# tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# switch
snippet switch
	switch(${1:expression}) {
		case '${3:case}':
			${4:// code}
			break;
		${5}
		default:
			${2:// code}
	}
# case
snippet case
	case '${1:case}':
		${2:// code}
		break;
	${3}
# for (...) {...}
snippet for
	for (var ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {
		${4:$1[$2]}
	};
# for (...) {...} (Improved Native For-Loop)
snippet forr
	for (var ${2:i} = ${1:Things}.length - 1; $2 >= 0; $2${3:--}) {
		${4:$1[$2]}
	};
# while (...) {...}
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# do...while
snippet do
	do {
		${2:/* code */}
	} while (${1:/* condition */});
# Object Method
snippet :f
	${1:method_name}: function(${2:attribute}) {
		${4}
	}${3:,}
# setTimeout function
snippet timeout
	setTimeout(function() {${3}}${2}, ${1:10};
# Get Elements
snippet get
	getElementsBy${1:TagName}('${2}')${3}
# Get Element
snippet gett
	getElementBy${1:Id}('${2}')${3}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/javascript.snippets
snippet main
	public static void main (String [] args)
	{
		${1:/* code */}
	}
snippet pu
	public
snippet po
	protected
snippet pr
	private
snippet st
	static
snippet fi
	final
snippet ab
	abstract
snippet re
	return
snippet br
	break;
snippet de
	default:
		${1}
snippet ca
	catch(${1:Exception} ${2:e}) ${3}
snippet th
	throw 
snippet sy
	synchronized
snippet im
	import
snippet imp
	implements
snippet ext
	extends 
snippet j.u
	java.util
snippet j.i
	java.io.
snippet j.b
	java.beans.
snippet j.n
	java.net.
snippet j.m
	java.math.
snippet if
	if (${1}) ${2}
snippet el
	else 
snippet elif
	else if (${1}) ${2}
snippet wh
	while (${1}) ${2}
snippet for
	for (${1}; ${2}; ${3}) ${4}
snippet fore
	for (${1} : ${2}) ${3}
snippet sw
	switch (${1}) ${2}
snippet cs
	case ${1}:
		${2}
	${3}
snippet tc
	public class ${1:`Filename()`} extends ${2:TestCase}
snippet t
	public void test${1:Name}() throws Exception ${2}
snippet cl
	class ${1:`Filename("", "untitled")`} ${2}
snippet in
	interface ${1:`Filename("", "untitled")`} ${2:extends Parent}${3}
snippet m
	${1:void} ${2:method}(${3}) ${4:throws }${5}
snippet v
	${1:String} ${2:var}${3: = null}${4};${5}
snippet co
	static public final ${1:String} ${2:var} = ${3};${4}
snippet cos
	static public final String ${1:var} = "${2}";${3}
snippet as
	assert ${1:test} : "${2:Failure message}";${3}
snippet try
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	}
snippet tryf
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
snippet rst
	ResultSet ${1:rst}${2: = null}${3};${4}
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/java.snippets
snippet def
	<%def name="${1:name}">
		${2:}
	</%def>
snippet call
	<%call expr="${1:name}">
		${2:}
	</%call>
snippet doc
	<%doc>
		${1:}
	</%doc>
snippet text
	<%text>
		${1:}
	</%text>
snippet for
	% for ${1:i} in ${2:iter}:
		${3:}
	% endfor
snippet if if
	% if ${1:condition}:
		${2:}
	% endif
snippet if if/else
	% if ${1:condition}:
		${2:}
	% else:
		${3:}
	% endif
snippet try
	% try:
		${1:}
	% except${2:}:
		${3:pass}
	% endtry
snippet wh
	% while ${1:}:
		${2:}
	% endwhile
snippet $
	${ ${1:} }
snippet <%
	<% ${1:} %>
snippet <!%
	<!% ${1:} %>
snippet inherit
	<%inherit file="${1:filename}" />
snippet include
	<%include file="${1:filename}" />
snippet namespace
	<%namespace file="${1:name}" />
snippet page
	<%page args="${1:}" />
zhimakaimen:/vimfiles/bundle/snipmate.vim/snippets/mako.snippets
" Syntax highlighting for snippet files (used for snipMate.vim)
" Hopefully this should make snippets a bit nicer to write!
syn match snipComment '^#.*'
syn match placeHolder '\${\d\+\(:.\{-}\)\=}' contains=snipCommand
syn match tabStop '\$\d\+'
syn match snipCommand '[^\\]`.\{-}`'
syn match snippet '^snippet.*' transparent contains=multiSnipText,snipKeyword
syn match multiSnipText '\S\+ \zs.*' contained
syn match snipKeyword '^snippet'me=s+8 contained
syn match snipError "^[^#s\t].*$"

hi link snipComment   Comment
hi link multiSnipText String
hi link snipKeyword   Keyword
hi link snipComment   Comment
hi link placeHolder   Special
hi link tabStop       Special
hi link snipCommand   String
hi link snipError     Error
zhimakaimen:/vimfiles/bundle/snipmate.vim/syntax/snippet.vim
fun! Filename(...)
	let filename = expand('%:t:r')
	if filename == '' | return a:0 == 2 ? a:2 : '' | endif
	return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
endf

fun s:RemoveSnippet()
	unl! g:snipPos s:curPos s:snipLen s:endCol s:endLine s:prevLen
	     \ s:lastBuf s:oldWord
	if exists('s:update')
		unl s:startCol s:origWordLen s:update
		if exists('s:oldVars') | unl s:oldVars s:oldEndCol | endif
	endif
	aug! snipMateAutocmds
endf

fun snipMate#expandSnip(snip, col)
	let lnum = line('.') | let col = a:col

	let snippet = s:ProcessSnippet(a:snip)
	" Avoid error if eval evaluates to nothing
	if snippet == '' | return '' | endif

	" Expand snippet onto current position with the tab stops removed
	let snipLines = split(substitute(snippet, '$\d\+\|${\d\+.\{-}}', '', 'g'), "\n", 1)

	let line = getline(lnum)
	let afterCursor = strpart(line, col - 1)
	" Keep text after the cursor
	if afterCursor != "\t" && afterCursor != ' '
		let line = strpart(line, 0, col - 1)
		let snipLines[-1] .= afterCursor
	else
		let afterCursor = ''
		" For some reason the cursor needs to move one right after this
		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
			let col += 1
		endif
	endif

	call setline(lnum, line.snipLines[0])

	" Autoindent snippet according to previous indentation
	let indent = matchend(line, '^.\{-}\ze\(\S\|$\)') + 1
	call append(lnum, map(snipLines[1:], "'".strpart(line, 0, indent - 1)."'.v:val"))

	" Open any folds snippet expands into
	if &fen | sil! exe lnum.','.(lnum + len(snipLines) - 1).'foldopen' | endif

	let [g:snipPos, s:snipLen] = s:BuildTabStops(snippet, lnum, col - indent, indent)

	if s:snipLen
		aug snipMateAutocmds
			au CursorMovedI * call s:UpdateChangedSnip(0)
			au InsertEnter * call s:UpdateChangedSnip(1)
		aug END
		let s:lastBuf = bufnr(0) " Only expand snippet while in current buffer
		let s:curPos = 0
		let s:endCol = g:snipPos[s:curPos][1]
		let s:endLine = g:snipPos[s:curPos][0]

		call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])
		let s:prevLen = [line('$'), col('$')]
		if g:snipPos[s:curPos][2] != -1 | return s:SelectWord() | endif
	else
		unl g:snipPos s:snipLen
		" Place cursor at end of snippet if no tab stop is given
		let newlines = len(snipLines) - 1
		call cursor(lnum + newlines, indent + len(snipLines[-1]) - len(afterCursor)
					\ + (newlines ? 0: col - 1))
	endif
	return ''
endf

" Prepare snippet to be processed by s:BuildTabStops
fun s:ProcessSnippet(snip)
	let snippet = a:snip
	" Evaluate eval (`...`) expressions.
	" Backquotes prefixed with a backslash "\" are ignored.
	" Using a loop here instead of a regex fixes a bug with nested "\=".
	if stridx(snippet, '`') != -1
		while match(snippet, '\(^\|[^\\]\)`.\{-}[^\\]`') != -1
			let snippet = substitute(snippet, '\(^\|[^\\]\)\zs`.\{-}[^\\]`\ze',
		                \ substitute(eval(matchstr(snippet, '\(^\|[^\\]\)`\zs.\{-}[^\\]\ze`')),
		                \ "\n\\%$", '', ''), '')
		endw
		let snippet = substitute(snippet, "\r", "\n", 'g')
		let snippet = substitute(snippet, '\\`', '`', 'g')
	endif

	" Place all text after a colon in a tab stop after the tab stop
	" (e.g. "${#:foo}" becomes "${:foo}foo").
	" This helps tell the position of the tab stops later.
	let snippet = substitute(snippet, '${\d\+:\(.\{-}\)}', '&\1', 'g')

	" Update the a:snip so that all the $# become the text after
	" the colon in their associated ${#}.
	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
	let i = 1
	while stridx(snippet, '${'.i) != -1
		let s = matchstr(snippet, '${'.i.':\zs.\{-}\ze}')
		if s != ''
			let snippet = substitute(snippet, '$'.i, s.'&', 'g')
		endif
		let i += 1
	endw

	if &et " Expand tabs to spaces if 'expandtab' is set.
		return substitute(snippet, '\t', repeat(' ', &sts ? &sts : &sw), 'g')
	endif
	return snippet
endf

" Counts occurences of haystack in needle
fun s:Count(haystack, needle)
	let counter = 0
	let index = stridx(a:haystack, a:needle)
	while index != -1
		let index = stridx(a:haystack, a:needle, index+1)
		let counter += 1
	endw
	return counter
endf

" Builds a list of a list of each tab stop in the snippet containing:
" 1.) The tab stop's line number.
" 2.) The tab stop's column number
"     (by getting the length of the string between the last "\n" and the
"     tab stop).
" 3.) The length of the text after the colon for the current tab stop
"     (e.g. "${1:foo}" would return 3). If there is no text, -1 is returned.
" 4.) If the "${#:}" construct is given, another list containing all
"     the matches of "$#", to be replaced with the placeholder. This list is
"     composed the same way as the parent; the first item is the line number,
"     and the second is the column.
fun s:BuildTabStops(snip, lnum, col, indent)
	let snipPos = []
	let i = 1
	let withoutVars = substitute(a:snip, '$\d\+', '', 'g')
	while stridx(a:snip, '${'.i) != -1
		let beforeTabStop = matchstr(withoutVars, '^.*\ze${'.i.'\D')
		let withoutOthers = substitute(withoutVars, '${\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')

		let j = i - 1
		call add(snipPos, [0, 0, -1])
		let snipPos[j][0] = a:lnum + s:Count(beforeTabStop, "\n")
		let snipPos[j][1] = a:indent + len(matchstr(withoutOthers, '.*\(\n\|^\)\zs.*\ze${'.i.'\D'))
		if snipPos[j][0] == a:lnum | let snipPos[j][1] += a:col | endif

		" Get all $# matches in another list, if ${#:name} is given
		if stridx(withoutVars, '${'.i.':') != -1
			let snipPos[j][2] = len(matchstr(withoutVars, '${'.i.':\zs.\{-}\ze}'))
			let dots = repeat('.', snipPos[j][2])
			call add(snipPos[j], [])
			let withoutOthers = substitute(a:snip, '${\d\+.\{-}}\|$'.i.'\@!\d\+', '', 'g')
			while match(withoutOthers, '$'.i.'\(\D\|$\)') != -1
				let beforeMark = matchstr(withoutOthers, '^.\{-}\ze'.dots.'$'.i.'\(\D\|$\)')
				call add(snipPos[j][3], [0, 0])
				let snipPos[j][3][-1][0] = a:lnum + s:Count(beforeMark, "\n")
				let snipPos[j][3][-1][1] = a:indent + (snipPos[j][3][-1][0] > a:lnum
				                           \ ? len(matchstr(beforeMark, '.*\n\zs.*'))
				                           \ : a:col + len(beforeMark))
				let withoutOthers = substitute(withoutOthers, '$'.i.'\ze\(\D\|$\)', '', '')
			endw
		endif
		let i += 1
	endw
	return [snipPos, i - 1]
endf

fun snipMate#jumpTabStop(backwards)
	let leftPlaceholder = exists('s:origWordLen')
	                      \ && s:origWordLen != g:snipPos[s:curPos][2]
	if leftPlaceholder && exists('s:oldEndCol')
		let startPlaceholder = s:oldEndCol + 1
	endif

	if exists('s:update')
		call s:UpdatePlaceholderTabStops()
	else
		call s:UpdateTabStops()
	endif

	" Don't reselect placeholder if it has been modified
	if leftPlaceholder && g:snipPos[s:curPos][2] != -1
		if exists('startPlaceholder')
			let g:snipPos[s:curPos][1] = startPlaceholder
		else
			let g:snipPos[s:curPos][1] = col('.')
			let g:snipPos[s:curPos][2] = 0
		endif
	endif

	let s:curPos += a:backwards ? -1 : 1
	" Loop over the snippet when going backwards from the beginning
	if s:curPos < 0 | let s:curPos = s:snipLen - 1 | endif

	if s:curPos == s:snipLen
		let sMode = s:endCol == g:snipPos[s:curPos-1][1]+g:snipPos[s:curPos-1][2]
		call s:RemoveSnippet()
		return sMode ? "\<tab>" : TriggerSnippet()
	endif

	call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])

	let s:endLine = g:snipPos[s:curPos][0]
	let s:endCol = g:snipPos[s:curPos][1]
	let s:prevLen = [line('$'), col('$')]

	return g:snipPos[s:curPos][2] == -1 ? '' : s:SelectWord()
endf

fun s:UpdatePlaceholderTabStops()
	let changeLen = s:origWordLen - g:snipPos[s:curPos][2]
	unl s:startCol s:origWordLen s:update
	if !exists('s:oldVars') | return | endif
	" Update tab stops in snippet if text has been added via "$#"
	" (e.g., in "${1:foo}bar$1${2}").
	if changeLen != 0
		let curLine = line('.')

		for pos in g:snipPos
			if pos == g:snipPos[s:curPos] | continue | endif
			let changed = pos[0] == curLine && pos[1] > s:oldEndCol
			let changedVars = 0
			let endPlaceholder = pos[2] - 1 + pos[1]
			" Subtract changeLen from each tab stop that was after any of
			" the current tab stop's placeholders.
			for [lnum, col] in s:oldVars
				if lnum > pos[0] | break | endif
				if pos[0] == lnum
					if pos[1] > col || (pos[2] == -1 && pos[1] == col)
						let changed += 1
					elseif col < endPlaceholder
						let changedVars += 1
					endif
				endif
			endfor
			let pos[1] -= changeLen * changed
			let pos[2] -= changeLen * changedVars " Parse variables within placeholders
                                                  " e.g., "${1:foo} ${2:$1bar}"

			if pos[2] == -1 | continue | endif
			" Do the same to any placeholders in the other tab stops.
			for nPos in pos[3]
				let changed = nPos[0] == curLine && nPos[1] > s:oldEndCol
				for [lnum, col] in s:oldVars
					if lnum > nPos[0] | break | endif
					if nPos[0] == lnum && nPos[1] > col
						let changed += 1
					endif
				endfor
				let nPos[1] -= changeLen * changed
			endfor
		endfor
	endif
	unl s:endCol s:oldVars s:oldEndCol
endf

fun s:UpdateTabStops()
	let changeLine = s:endLine - g:snipPos[s:curPos][0]
	let changeCol = s:endCol - g:snipPos[s:curPos][1]
	if exists('s:origWordLen')
		let changeCol -= s:origWordLen
		unl s:origWordLen
	endif
	let lnum = g:snipPos[s:curPos][0]
	let col = g:snipPos[s:curPos][1]
	" Update the line number of all proceeding tab stops if <cr> has
	" been inserted.
	if changeLine != 0
		let changeLine -= 1
		for pos in g:snipPos
			if pos[0] >= lnum
				if pos[0] == lnum | let pos[1] += changeCol | endif
				let pos[0] += changeLine
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] >= lnum
					if nPos[0] == lnum | let nPos[1] += changeCol | endif
					let nPos[0] += changeLine
				endif
			endfor
		endfor
	elseif changeCol != 0
		" Update the column of all proceeding tab stops if text has
		" been inserted/deleted in the current line.
		for pos in g:snipPos
			if pos[1] >= col && pos[0] == lnum
				let pos[1] += changeCol
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] >= col
					let nPos[1] += changeCol
				endif
			endfor
		endfor
	endif
endf

fun s:SelectWord()
	let s:origWordLen = g:snipPos[s:curPos][2]
	let s:oldWord = strpart(getline('.'), g:snipPos[s:curPos][1] - 1,
				\ s:origWordLen)
	let s:prevLen[1] -= s:origWordLen
	if !empty(g:snipPos[s:curPos][3])
		let s:update = 1
		let s:endCol = -1
		let s:startCol = g:snipPos[s:curPos][1] - 1
	endif
	if !s:origWordLen | return '' | endif
	let l = col('.') != 1 ? 'l' : ''
	if &sel == 'exclusive'
		return "\<esc>".l.'v'.s:origWordLen."l\<c-g>"
	endif
	return s:origWordLen == 1 ? "\<esc>".l.'gh'
							\ : "\<esc>".l.'v'.(s:origWordLen - 1)."l\<c-g>"
endf

" This updates the snippet as you type when text needs to be inserted
" into multiple places (e.g. in "${1:default text}foo$1bar$1",
" "default text" would be highlighted, and if the user types something,
" UpdateChangedSnip() would be called so that the text after "foo" & "bar"
" are updated accordingly)
"
" It also automatically quits the snippet if the cursor is moved out of it
" while in insert mode.
fun s:UpdateChangedSnip(entering)
	if exists('g:snipPos') && bufnr(0) != s:lastBuf
		call s:RemoveSnippet()
	elseif exists('s:update') " If modifying a placeholder
		if !exists('s:oldVars') && s:curPos + 1 < s:snipLen
			" Save the old snippet & word length before it's updated
			" s:startCol must be saved too, in case text is added
			" before the snippet (e.g. in "foo$1${2}bar${1:foo}").
			let s:oldEndCol = s:startCol
			let s:oldVars = deepcopy(g:snipPos[s:curPos][3])
		endif
		let col = col('.') - 1

		if s:endCol != -1
			let changeLen = col('$') - s:prevLen[1]
			let s:endCol += changeLen
		else " When being updated the first time, after leaving select mode
			if a:entering | return | endif
			let s:endCol = col - 1
		endif

		" If the cursor moves outside the snippet, quit it
		if line('.') != g:snipPos[s:curPos][0] || col < s:startCol ||
					\ col - 1 > s:endCol
			unl! s:startCol s:origWordLen s:oldVars s:update
			return s:RemoveSnippet()
		endif

		call s:UpdateVars()
		let s:prevLen[1] = col('$')
	elseif exists('g:snipPos')
		if !a:entering && g:snipPos[s:curPos][2] != -1
			let g:snipPos[s:curPos][2] = -2
		endif

		let col = col('.')
		let lnum = line('.')
		let changeLine = line('$') - s:prevLen[0]

		if lnum == s:endLine
			let s:endCol += col('$') - s:prevLen[1]
			let s:prevLen = [line('$'), col('$')]
		endif
		if changeLine != 0
			let s:endLine += changeLine
			let s:endCol = col
		endif

		" Delete snippet if cursor moves out of it in insert mode
		if (lnum == s:endLine && (col > s:endCol || col < g:snipPos[s:curPos][1]))
			\ || lnum > s:endLine || lnum < g:snipPos[s:curPos][0]
			call s:RemoveSnippet()
		endif
	endif
endf

" This updates the variables in a snippet when a placeholder has been edited.
" (e.g., each "$1" in "${1:foo} $1bar $1bar")
fun s:UpdateVars()
	let newWordLen = s:endCol - s:startCol + 1
	let newWord = strpart(getline('.'), s:startCol, newWordLen)
	if newWord == s:oldWord || empty(g:snipPos[s:curPos][3])
		return
	endif

	let changeLen = g:snipPos[s:curPos][2] - newWordLen
	let curLine = line('.')
	let startCol = col('.')
	let oldStartSnip = s:startCol
	let updateTabStops = changeLen != 0
	let i = 0

	for [lnum, col] in g:snipPos[s:curPos][3]
		if updateTabStops
			let start = s:startCol
			if lnum == curLine && col <= start
				let s:startCol -= changeLen
				let s:endCol -= changeLen
			endif
			for nPos in g:snipPos[s:curPos][3][(i):]
				" This list is in ascending order, so quit if we've gone too far.
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] > col
					let nPos[1] -= changeLen
				endif
			endfor
			if lnum == curLine && col > start
				let col -= changeLen
				let g:snipPos[s:curPos][3][i][1] = col
			endif
			let i += 1
		endif

		" "Very nomagic" is used here to allow special characters.
		call setline(lnum, substitute(getline(lnum), '\%'.col.'c\V'.
						\ escape(s:oldWord, '\'), escape(newWord, '\&'), ''))
	endfor
	if oldStartSnip != s:startCol
		call cursor(0, startCol + s:startCol - oldStartSnip)
	endif

	let s:oldWord = newWord
	let g:snipPos[s:curPos][2] = newWordLen
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/vimfiles/bundle/snipmate.vim/autoload/snipMate.vim
" Helper function for (x)html snippets
if exists('s:did_snip_helper') || &cp || !exists('loaded_snips')
	finish
endif
let s:did_snip_helper = 1

" Automatically closes tag if in xhtml
fun! Close()
	return stridx(&ft, 'xhtml') == -1 ? '' : ' /'
endf
zhimakaimen:/vimfiles/bundle/snipmate.vim/ftplugin/html_snip_helper.vim
'Tlist_Auto_Highlight_Tag'	taglist.txt	/*'Tlist_Auto_Highlight_Tag'*
'Tlist_Auto_Open'	taglist.txt	/*'Tlist_Auto_Open'*
'Tlist_Auto_Update'	taglist.txt	/*'Tlist_Auto_Update'*
'Tlist_Close_On_Select'	taglist.txt	/*'Tlist_Close_On_Select'*
'Tlist_Compact_Format'	taglist.txt	/*'Tlist_Compact_Format'*
'Tlist_Ctags_Cmd'	taglist.txt	/*'Tlist_Ctags_Cmd'*
'Tlist_Display_Prototype'	taglist.txt	/*'Tlist_Display_Prototype'*
'Tlist_Display_Tag_Scope'	taglist.txt	/*'Tlist_Display_Tag_Scope'*
'Tlist_Enable_Fold_Column'	taglist.txt	/*'Tlist_Enable_Fold_Column'*
'Tlist_Exit_OnlyWindow'	taglist.txt	/*'Tlist_Exit_OnlyWindow'*
'Tlist_File_Fold_Auto_Close'	taglist.txt	/*'Tlist_File_Fold_Auto_Close'*
'Tlist_GainFocus_On_ToggleOpen'	taglist.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
'Tlist_Highlight_Tag_On_BufEnter'	taglist.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
'Tlist_Inc_Winwidth'	taglist.txt	/*'Tlist_Inc_Winwidth'*
'Tlist_Max_Submenu_Items'	taglist.txt	/*'Tlist_Max_Submenu_Items'*
'Tlist_Max_Tag_Length'	taglist.txt	/*'Tlist_Max_Tag_Length'*
'Tlist_Process_File_Always'	taglist.txt	/*'Tlist_Process_File_Always'*
'Tlist_Show_Menu'	taglist.txt	/*'Tlist_Show_Menu'*
'Tlist_Show_One_File'	taglist.txt	/*'Tlist_Show_One_File'*
'Tlist_Sort_Type'	taglist.txt	/*'Tlist_Sort_Type'*
'Tlist_Use_Horiz_Window'	taglist.txt	/*'Tlist_Use_Horiz_Window'*
'Tlist_Use_Right_Window'	taglist.txt	/*'Tlist_Use_Right_Window'*
'Tlist_Use_SingleClick'	taglist.txt	/*'Tlist_Use_SingleClick'*
'Tlist_WinHeight'	taglist.txt	/*'Tlist_WinHeight'*
'Tlist_WinWidth'	taglist.txt	/*'Tlist_WinWidth'*
:TlistAddFiles	taglist.txt	/*:TlistAddFiles*
:TlistAddFilesRecursive	taglist.txt	/*:TlistAddFilesRecursive*
:TlistClose	taglist.txt	/*:TlistClose*
:TlistDebug	taglist.txt	/*:TlistDebug*
:TlistHighlightTag	taglist.txt	/*:TlistHighlightTag*
:TlistLock	taglist.txt	/*:TlistLock*
:TlistMessages	taglist.txt	/*:TlistMessages*
:TlistOpen	taglist.txt	/*:TlistOpen*
:TlistSessionLoad	taglist.txt	/*:TlistSessionLoad*
:TlistSessionSave	taglist.txt	/*:TlistSessionSave*
:TlistShowPrototype	taglist.txt	/*:TlistShowPrototype*
:TlistShowTag	taglist.txt	/*:TlistShowTag*
:TlistToggle	taglist.txt	/*:TlistToggle*
:TlistUndebug	taglist.txt	/*:TlistUndebug*
:TlistUnlock	taglist.txt	/*:TlistUnlock*
:TlistUpdate	taglist.txt	/*:TlistUpdate*
Tlist_Get_Tag_Prototype_By_Line()	taglist.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tagname_By_Line()	taglist.txt	/*Tlist_Get_Tagname_By_Line()*
Tlist_Set_App()	taglist.txt	/*Tlist_Set_App()*
Tlist_Update_File_Tags()	taglist.txt	/*Tlist_Update_File_Tags()*
taglist-commands	taglist.txt	/*taglist-commands*
taglist-debug	taglist.txt	/*taglist-debug*
taglist-extend	taglist.txt	/*taglist-extend*
taglist-faq	taglist.txt	/*taglist-faq*
taglist-functions	taglist.txt	/*taglist-functions*
taglist-install	taglist.txt	/*taglist-install*
taglist-internet	taglist.txt	/*taglist-internet*
taglist-intro	taglist.txt	/*taglist-intro*
taglist-keys	taglist.txt	/*taglist-keys*
taglist-license	taglist.txt	/*taglist-license*
taglist-menu	taglist.txt	/*taglist-menu*
taglist-options	taglist.txt	/*taglist-options*
taglist-requirements	taglist.txt	/*taglist-requirements*
taglist-session	taglist.txt	/*taglist-session*
taglist-todo	taglist.txt	/*taglist-todo*
taglist-using	taglist.txt	/*taglist-using*
taglist.txt	taglist.txt	/*taglist.txt*
zhimakaimen:/vimfiles/bundle/taglist.vim/doc/tags
*taglist.txt*	Plugin for browsing source code

Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
For Vim version 6.0 and above
Last change: 2007 May 24

1. Overview 					|taglist-intro|
2. Taglist on the internet			|taglist-internet|
3. Requirements					|taglist-requirements|
4. Installation 				|taglist-install|
5. Usage 					|taglist-using|
6. Options 					|taglist-options|
7. Commands 					|taglist-commands|
8. Global functions 				|taglist-functions|
9. Extending 					|taglist-extend|
10. FAQ 					|taglist-faq|
11. License 					|taglist-license|
12. Todo					|taglist-todo|

==============================================================================
						*taglist-intro*
1. Overview~

The "Tag List" plugin is a source code browser plugin for Vim. This plugin
allows you to efficiently browse through source code files for different
programming languages. The "Tag List" plugin provides the following features:

    * Displays the tags (functions, classes, structures, variables, etc.) 
      defined in a file in a vertically or horizontally split Vim window.
    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
      in the popup menu.
    * Automatically updates the taglist window as you switch between
      files/buffers. As you open new files, the tags defined in the new files
      are added to the existing file list and the tags defined in all the
      files are displayed grouped by the filename.
    * When a tag name is selected from the taglist window, positions the
      cursor at the definition of the tag in the source file.
    * Automatically highlights the current tag name.
    * Groups the tags by their type and displays them in a foldable tree.
    * Can display the prototype and scope of a tag.
    * Can optionally display the tag prototype instead of the tag name in the
      taglist window.
    * The tag list can be sorted either by name or by chronological order.
    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
      SML, Sql, TCL, Verilog, Vim and Yacc.
    * Can be easily extended to support new languages. Support for
      existing languages can be modified easily.
    * Provides functions to display the current tag name in the Vim status
      line or the window title bar.
    * The list of tags and files in the taglist can be saved and
      restored across Vim sessions.
    * Provides commands to get the name and prototype of the current tag.
    * Runs in both console/terminal and GUI versions of Vim.
    * Works with the winmanager plugin. Using the winmanager plugin, you
      can use Vim plugins like the file explorer, buffer explorer and the
      taglist plugin at the same time like an IDE.
    * Can be used in both Unix and MS-Windows systems.

==============================================================================
						*taglist-internet*
2. Taglist on the internet~

The home page of the taglist plugin is at:
>
	http://vim-taglist.sourceforge.net/
<
You can subscribe to the taglist mailing list to post your questions or
suggestions for improvement or to send bug reports. Visit the following page
for subscribing to the mailing list:
>
	http://groups.yahoo.com/group/taglist
<
==============================================================================
						*taglist-requirements*
3. Requirements~

The taglist plugin requires the following:

    * Vim version 6.0 and above
    * Exuberant ctags 5.0 and above

The taglist plugin will work on all the platforms where the exuberant ctags
utility and Vim are supported (this includes MS-Windows and Unix based
systems).

The taglist plugin relies on the exuberant ctags utility to dynamically
generate the tag listing.  The exuberant ctags utility must be installed in
your system to use this plugin.  The exuberant ctags utility is shipped with
most of the Linux distributions.  You can download the exuberant ctags utility
from
>
	http://ctags.sourceforge.net
<
The taglist plugin doesn't use or create a tags file and there is no need to
create a tags file to use this plugin. The taglist plugin will not work with
the GNU ctags or the Unix ctags utility.

This plugin relies on the Vim "filetype" detection mechanism to determine the
type of the current file. You have to turn on the Vim filetype detection by
adding the following line to your .vimrc file:
>
	filetype on
<
The taglist plugin will not work if you run Vim in the restricted mode (using
the -Z command-line argument).

The taglist plugin uses the Vim system() function to invoke the exuberant
ctags utility. If Vim is compiled without the system() function then you
cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
Vim without the system() function for security reasons.

==============================================================================
						*taglist-install*
4. Installation~

1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
   have the following two files (the directory structure should be preserved):

	plugin/taglist.vim - main taglist plugin file
	doc/taglist.txt    - documentation (help) file

   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
   details about installing Vim plugins.
2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
   directory, start Vim and run the ":helptags ." command to process the
   taglist help file. Without this step, you cannot jump to the taglist help
   topics.
3. If the exuberant ctags utility is not present in one of the directories in
   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
   point to the location of the exuberant ctags utility (not to the directory)
   in the .vimrc file.
4. If you are running a terminal/console version of Vim and the terminal
   doesn't support changing the window width then set the
   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
5. Restart Vim.
6. You can now use the ":TlistToggle" command to open/close the taglist
   window. You can use the ":help taglist" command to get more information
   about using the taglist plugin.

To uninstall the taglist plugin, remove the plugin/taglist.vim and
doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.

==============================================================================
						*taglist-using*
5. Usage~

The taglist plugin can be used in several different ways.

1. You can keep the taglist window open during the entire editing session. On
   opening the taglist window, the tags defined in all the files in the Vim
   buffer list will be displayed in the taglist window. As you edit files, the
   tags defined in them will be added to the taglist window. You can select a
   tag from the taglist window and jump to it. The current tag will be
   highlighted in the taglist window. You can close the taglist window when
   you no longer need the window.
2. You can configure the taglist plugin to process the tags defined in all the
   edited files always. In this configuration, even if the taglist window is
   closed and the taglist menu is not displayed, the taglist plugin will
   processes the tags defined in newly edited files. You can then open the
   taglist window only when you need to select a tag and then automatically
   close the taglist window after selecting the tag.
3. You can configure the taglist plugin to display only the tags defined in
   the current file in the taglist window. By default, the taglist plugin
   displays the tags defined in all the files in the Vim buffer list. As you
   switch between files, the taglist window will be refreshed to display only
   the tags defined in the current file.
4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
   taglist plugin to display the tags defined in the current file and select a
   tag to jump to it. You can use the menu without opening the taglist window.
   By default, the Tags menu is disabled.
5. You can configure the taglist plugin to display the name of the current tag
   in the Vim window status line or in the Vim window title bar. For this to
   work without the taglist window or menu, you need to configure the taglist
   plugin to process the tags defined in a file always.
6. You can save the tags defined in multiple files to a taglist session file
   and load it when needed. You can also configure the taglist plugin to not
   update the taglist window when editing new files. You can then manually add
   files to the taglist window.

Opening the taglist window~
You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
commands. The ":TlistOpen" command opens the taglist window and jumps to it.
The ":TlistToggle" command opens or closes (toggle) the taglist window and the
cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
variable is set to 1, then the ":TlistToggle" command opens the taglist window
and moves the cursor to the taglist window.

You can map a key to invoke these commands. For example, the following command
creates a normal mode mapping for the <F8> key to toggle the taglist window.
>
	nnoremap <silent> <F8> :TlistToggle<CR>
<
Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.

To automatically open the taglist window on Vim startup, set the
'Tlist_Auto_Open' variable to 1.

You can also open the taglist window on startup using the following command
line:
>
	$ vim +TlistOpen
<
Closing the taglist window~
You can close the taglist window from the taglist window by pressing 'q' or
using the Vim ":q" command. You can also use any of the Vim window commands to
close the taglist window. Invoking the ":TlistToggle" command when the taglist
window is opened, closes the taglist window. You can also use the
":TlistClose" command to close the taglist window.

To automatically close the taglist window when a tag or file is selected, you
can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.

Jumping to a tag or a file~
You can select a tag in the taglist window either by pressing the <Enter> key
or by double clicking the tag name using the mouse. To jump to a tag on a
single mouse click set the 'Tlist_Use_SingleClick' variable to 1.

If the selected file is already opened in a window, then the cursor is moved
to that window. If the file is not currently opened in a window then the file
is opened in the window used by the taglist plugin to show the previously
selected file. If there are no usable windows, then the file is opened in a
new window.  The file is not opened in special windows like the quickfix
window, preview window and windows containing buffer with the 'buftype' option
set.

To jump to the tag in a new window, press the 'o' key. To open the file in the
previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
to the tag but still keep the cursor in the taglist window (preview).

To open the selected file in a tab, use the 't' key.  If the file is already
present in a tab then the cursor is moved to that tab otherwise the file is
opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
window is automatically opened in the newly created tab.

Instead of jumping to a tag, you can open a file by pressing the <Enter> key
or by double clicking the file name using the mouse.

In the taglist window, you can use the [[ or <Backspace> key to jump to the
beginning of the previous file. You can use the ]] or <Tab> key to jump to the
beginning of the next file. When you reach the first or last file, the search
wraps around and the jumps to the next/previous file.

Highlighting the current tag~
The taglist plugin automatically highlights the name of the current tag in the
taglist window. The Vim |CursorHold| autocmd event is used for this. If the
current tag name is not visible in the taglist window, then the taglist window
contents are scrolled to make that tag name visible. You can also use the
":TlistHighlightTag" command to force the highlighting of the current tag.

The tag name is highlighted if no activity is performed for |'updatetime'|
milliseconds. The default value for this Vim option is 4 seconds. To avoid
unexpected problems, you should not set the |'updatetime'| option to a very
low value.

To disable the automatic highlighting of the current tag name in the taglist
window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.

When entering a Vim buffer/window, the taglist plugin automatically highlights
the current tag in that buffer/window.  If you like to disable the automatic
highlighting of the current tag when entering a buffer, set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero.

Adding files to the taglist~
When the taglist window is opened, all the files in the Vim buffer list are
processed and the supported files are added to the taglist.  When you edit a
file in Vim, the taglist plugin automatically processes this file and adds it
to the taglist. If you close the taglist window, the tag information in the
taglist is retained.

To process files even when the taglist window is not open, set the
'Tlist_Process_File_Always' variable to 1.

You can manually add multiple files to the taglist without opening them using
the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.

For example, to add all the C files in the /my/project/dir directory to the
taglist, you can use the following command:
>
	:TlistAddFiles /my/project/dir/*.c
<
Note that when adding several files with a large number of tags or a large
number of files, it will take several seconds to several minutes for the
taglist plugin to process all the files. You should not interrupt the taglist
plugin by pressing <CTRL-C>.

You can recursively add multiple files from a directory tree using the
":TlistAddFilesRecursive" command:
>
	:TlistAddFilesRecursive /my/project/dir *.c
<
This command takes two arguments. The first argument specifies the directory
from which to recursively add the files. The second optional argument
specifies the wildcard matching pattern for selecting the files to add. The
default pattern is * and all the files are added.

Displaying tags for only one file~
The taglist window displays the tags for all the files in the Vim buffer list
and all the manually added files. To display the tags for only the current
active buffer, set the 'Tlist_Show_One_File' variable to 1.

Removing files from the taglist~
You can remove a file from the taglist window, by pressing the 'd' key when the
cursor is on one of the tags listed for the file in the taglist window. The
removed file will no longer be displayed in the taglist window in the current
Vim session. To again display the tags for the file, open the file in a Vim
window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
to add the file to the taglist.

When a buffer is removed from the Vim buffer list using the ":bdelete" or the
":bwipeout" command, the taglist is updated to remove the stored information
for this buffer.

Updating the tags displayed for a file~
The taglist plugin keeps track of the modification time of a file. When the
modification time changes (the file is modified), the taglist plugin
automatically updates the tags listed for that file. The modification time of
a file is checked when you enter a window containing that file or when you
load that file.

You can also update or refresh the tags displayed for a file by pressing the
"u" key in the taglist window. If an existing file is modified, after the file
is saved, the taglist plugin automatically updates the tags displayed for the
file.

You can also use the ":TlistUpdate" command to update the tags for the current
buffer after you made some changes to it. You should save the modified buffer
before you update the taglist window. Otherwise the listed tags will not
include the new tags created in the buffer. 

If you have deleted the tags displayed for a file in the taglist window using
the 'd' key, you can again display the tags for that file using the
":TlistUpdate" command.

Controlling the taglist updates~
To disable the automatic processing of new files or modified files, you can
set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
zero, the taglist is updated only when you use the ":TlistUpdate" command or
the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
this option to control which files are added to the taglist.

You can use the ":TlistLock" command to lock the taglist contents. After this
command is executed, new files are not automatically added to the taglist.
When the taglist is locked, you can use the ":TlistUpdate" command to add the
current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
command.

Displaying the tag prototype~
To display the prototype of the tag under the cursor in the taglist window,
press the space bar. If you place the cursor on a tag name in the taglist
window, then the tag prototype is displayed at the Vim status line after
|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
option is 4 seconds.

You can get the name and prototype of a tag without opening the taglist window
and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
commands. These commands will work only if the current file is already present
in the taglist. To use these commands without opening the taglist window, set
the 'Tlist_Process_File_Always' variable to 1.

You can use the ":TlistShowTag" command to display the name of the tag at or
before the specified line number in the specified file.  If the file name and
line number are not supplied, then this command will display the name of the
current tag. For example,
>
	:TlistShowTag
	:TlistShowTag myfile.java 100
<
You can use the ":TlistShowPrototype" command to display the prototype of the
tag at or before the specified line number in the specified file.  If the file
name and the line number are not supplied, then this command will display the
prototype of the current tag.  For example,
>
	:TlistShowPrototype
	:TlistShowPrototype myfile.c 50
<
In the taglist window, when the mouse is moved over a tag name, the tag
prototype is displayed in a balloon. This works only in GUI versions where
balloon evaluation is supported.

Taglist window contents~
The taglist window contains the tags defined in various files in the taglist
grouped by the filename and by the tag type (variable, function, class, etc.).
For tags with scope information (like class members, structures inside
structures, etc.), the scope information is displayed in square brackets "[]"
after the tag name.

The contents of the taglist buffer/window are managed by the taglist plugin.
The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
|'modifiable'| option is turned off for the taglist buffer. You should not
manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
manually edit the taglist buffer contents, then the taglist plugin will be out
of sync with the taglist buffer contents and the plugin will no longer work
correctly. To redisplay the taglist buffer contents again, close the taglist
window and reopen it.

Opening and closing the tag and file tree~
In the taglist window, the tag names are displayed as a foldable tree using
the Vim folding support. You can collapse the tree using the '-' key or using
the Vim |zc| fold command. You can open the tree using the '+' key or using
the Vim |zo| fold command. You can open all the folds using the '*' key or
using the Vim |zR| fold command. You can also use the mouse to open/close the
folds. You can close all the folds using the '=' key. You should not manually
create or delete the folds in the taglist window.

To automatically close the fold for the inactive files/buffers and open only
the fold for the current buffer in the taglist window, set the
'Tlist_File_Fold_Auto_Close' variable to 1.

Sorting the tags for a file~
The tags displayed in the taglist window can be sorted either by their name or
by their chronological order. The default sorting method is by the order in
which the tags appear in a file. You can change the default sort method by
setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
sort the tags by their name by pressing the "s" key in the taglist window. You
can again sort the tags by their chronological order using the "s" key. Each
file in the taglist window can be sorted using different order.

Zooming in and out of the taglist window~
You can press the 'x' key in the taglist window to maximize the taglist
window width/height. The window will be maximized to the maximum possible
width/height without closing the other existing windows. You can again press
'x' to restore the taglist window to the default width/height.

						*taglist-session*
Taglist Session~
A taglist session refers to the group of files and their tags stored in the
taglist in a Vim session.

You can save and restore a taglist session (and all the displayed tags) using
the ":TlistSessionSave" and ":TlistSessionLoad" commands.

To save the information about the tags and files in the taglist to a file, use
the ":TlistSessionSave" command and specify the filename:
>
	:TlistSessionSave <file name>
<
To load a saved taglist session, use the ":TlistSessionLoad" command: >

	:TlistSessionLoad <file name>
<
When you load a taglist session file, the tags stored in the file will be
added to the tags already stored in the taglist.

The taglist session feature can be used to save the tags for large files or a
group of frequently used files (like a project). By using the taglist session
file, you can minimize the amount to time it takes to load/refresh the taglist
for multiple files.

You can create more than one taglist session file for multiple groups of
files.

Displaying the tag name in the Vim status line or the window title bar~
You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
plugin to display the current tag name in the Vim status line or the window
title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
function to display the current tag prototype in the Vim status line or the
window title bar.

For example, the following command can be used to display the current tag name
in the status line:
>
	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
<
The following command can be used to display the current tag name in the
window title bar:
>
	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
<
Note that the current tag name can be displayed only after the file is
processed by the taglist plugin. For this, you have to either set the
'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
the taglist menu. For more information about configuring the Vim status line,
refer to the documentation for the Vim |'statusline'| option.

Changing the taglist window highlighting~
The following Vim highlight groups are defined and used to highlight the
various entities in the taglist window:

    TagListTagName  - Used for tag names
    TagListTagScope - Used for tag scope
    TagListTitle    - Used for tag titles
    TagListComment  - Used for comments
    TagListFileName - Used for filenames

By default, these highlight groups are linked to the standard Vim highlight
groups. If you want to change the colors used for these highlight groups,
prefix the highlight group name with 'My' and define it in your .vimrc or
.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
MyTagListComment and MyTagListFileName.  For example, to change the colors
used for tag names, you can use the following command:
>
    :highlight MyTagListTagName guifg=blue ctermfg=blue
<
Controlling the taglist window~
To use a horizontally split taglist window, instead of a vertically split
window, set the 'Tlist_Use_Horiz_Window' variable to 1.

To use a vertically split taglist window on the rightmost side of the Vim
window, set the 'Tlist_Use_Right_Window' variable to 1.

You can specify the width of the vertically split taglist window, by setting
the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
split taglist window, by setting the 'Tlist_WinHeight' variable.

When opening a vertically split taglist window, the Vim window width is
increased to accommodate the new taglist window. When the taglist window is
closed, the Vim window is reduced. To disable this, set the
'Tlist_Inc_Winwidth' variable to zero.

To reduce the number of empty lines in the taglist window, set the
'Tlist_Compact_Format' variable to 1.

To not display the Vim fold column in the taglist window, set the
'Tlist_Enable_Fold_Column' variable to zero.

To display the tag prototypes instead of the tag names in the taglist window,
set the 'Tlist_Display_Prototype' variable to 1.

To not display the scope of the tags next to the tag names, set the
'Tlist_Display_Tag_Scope' variable to zero.

						*taglist-keys*
Taglist window key list~
The following table lists the description of the keys that can be used
in the taglist window.

  Key           Description~

  <CR>          Jump to the location where the tag under cursor is
                defined.
  o             Jump to the location where the tag under cursor is
                defined in a new window.
  P             Jump to the tag in the previous (Ctrl-W_p) window.
  p             Display the tag definition in the file window and
                keep the cursor in the taglist window itself.
  t             Jump to the tag in a new tab. If the file is already
                opened in a tab, move to that tab.
  Ctrl-t	Jump to the tag in a new tab.
  <Space>       Display the prototype of the tag under the cursor.
  		For file names, display the full path to the file,
		file type and the number of tags. For tag types, display the
		tag type and the number of tags.
  u             Update the tags listed in the taglist window
  s             Change the sort order of the tags (by name or by order)
  d             Remove the tags for the file under the cursor
  x             Zoom-in or Zoom-out the taglist window
  +             Open a fold
  -             Close a fold
  *             Open all folds
  =             Close all folds
  [[		Jump to the beginning of the previous file
  <Backspace>	Jump to the beginning of the previous file
  ]]		Jump to the beginning of the next file
  <Tab>		Jump to the beginning of the next file
  q             Close the taglist window
  <F1>          Display help

The above keys will work in both the normal mode and the insert mode.

						*taglist-menu*
Taglist menu~
When using GUI Vim, the taglist plugin can display the tags defined in the
current file in the drop-down menu and the popup menu. By default, this
feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
variable to 1.

You can jump to a tag by selecting the tag name from the menu. You can use the
taglist menu independent of the taglist window i.e. you don't need to open the
taglist window to get the taglist menu.

When you switch between files/buffers, the taglist menu is automatically
updated to display the tags defined in the current file/buffer.

The tags are grouped by their type (variables, functions, classes, methods,
etc.) and displayed as a separate sub-menu for each type. If all the tags
defined in a file are of the same type (e.g. functions), then the sub-menu is
not used.

If the number of items in a tag type submenu exceeds the value specified by
the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
The first and last tag names in the submenu are used to form the submenu name.
The menu items are prefixed by alpha-numeric characters for easy selection by
keyboard.

If the popup menu support is enabled (the |'mousemodel'| option contains
"popup"), then the tags menu is added to the popup menu. You can access
the popup menu by right clicking on the GUI window.

You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
You can sort the tags listed in the menu either by name or by order by
selecting the 'Tags->Sort menu by->Name/Order' menu entry.

You can tear-off the Tags menu and keep it on the side of the Vim window
for quickly locating the tags.

Using the taglist plugin with the winmanager plugin~
You can use the taglist plugin with the winmanager plugin. This will allow you
to use the file explorer, buffer explorer and the taglist plugin at the same
time in different windows. To use the taglist plugin with the winmanager
plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
to use the file explorer plugin and the taglist plugin at the same time, use
the following setting: >

	let winManagerWindowLayout = 'FileExplorer|TagList'
<
Getting help~
If you have installed the taglist help file (this file), then you can use the
Vim ":help taglist-<keyword>" command to get help on the various taglist
topics.

You can press the <F1> key in the taglist window to display the help
information about using the taglist window. If you again press the <F1> key,
the help information is removed from the taglist window.

						*taglist-debug*
Debugging the taglist plugin~
You can use the ":TlistDebug" command to enable logging of the debug messages
from the taglist plugin. To display the logged debug messages, you can use the
":TlistMessages" command. To disable the logging of the debug messages, use
the ":TlistUndebug" command.

You can specify a file name to the ":TlistDebug" command to log the debug
messages to a file. Otherwise, the debug messages are stored in a script-local
variable. In the later case, to minimize memory usage, only the last 3000
characters from the debug messages are stored.

==============================================================================
						*taglist-options*
6. Options~

A number of Vim variables control the behavior of the taglist plugin. These
variables are initialized to a default value. By changing these variables you
can change the behavior of the taglist plugin. You need to change these
settings only if you want to change the behavior of the taglist plugin. You
should use the |:let| command in your .vimrc file to change the setting of any
of these variables. 

The configurable taglist variables are listed below. For a detailed
description of these variables refer to the text below this table.

|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
				taglist.
|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
|'Tlist_Auto_Update'|		Automatically update the taglist to include
				newly edited files.
|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
				selected.
|'Tlist_Compact_Format'|	Remove extra information and blank lines from
       				the taglist window.
|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
				window.
|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
				window.
|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
|'Tlist_GainFocus_On_ToggleOpen'|
				Jump to taglist window on open.
|'Tlist_Highlight_Tag_On_BufEnter'|
				On entering a buffer, automatically highlight
				the current tag.
|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
				the taglist window.
|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
|'Tlist_Process_File_Always'|	Process files even when the taglist window is
				closed.
|'Tlist_Show_Menu'|		Display the tags menu.
|'Tlist_Show_One_File'|		Show tags for the current buffer only.
|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
				taglist window.
|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
|'Tlist_WinHeight'|		Horizontally split taglist window height.
|'Tlist_WinWidth'|		Vertically split taglist window width.

						*'Tlist_Auto_Highlight_Tag'*
Tlist_Auto_Highlight_Tag~
The taglist plugin will automatically highlight the current tag in the taglist
window. If you want to disable this, then you can set the
'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
tag highlighting is disabled, the tags for a new file will still be added to
the taglist window.
>
	let Tlist_Auto_Highlight_Tag = 0
<
With the above variable set to 1, you can use the ":TlistHighlightTag" command
to highlight the current tag.

						*'Tlist_Auto_Open'*
Tlist_Auto_Open~
To automatically open the taglist window, when you start Vim, you can set the
'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
the taglist window will not be opened automatically on Vim startup.
>
	let Tlist_Auto_Open = 1
<
The taglist window is opened only when a supported type of file is opened on
Vim startup. For example, if you open text files, then the taglist window will
not be opened.

						*'Tlist_Auto_Update'*
Tlist_Auto_Update~
When a new file is edited, the tags defined in the file are automatically
processed and added to the taglist. To stop adding new files to the taglist,
set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
to 1.
>
	let Tlist_Auto_Update = 0
<
With the above variable set to 1, you can use the ":TlistUpdate" command to
add the tags defined in the current file to the taglist.

						*'Tlist_Close_On_Select'*
Tlist_Close_On_Select~
If you want to close the taglist window when a file or tag is selected, then
set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
set zero and when you select a tag or file from the taglist window, the window
is not closed.
>
	let Tlist_Close_On_Select = 1
<
						*'Tlist_Compact_Format'*
Tlist_Compact_Format~
By default, empty lines are used to separate different tag types displayed for
a file and the tags displayed for different files in the taglist window. If
you want to display as many tags as possible in the taglist window, you can
set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
>
	let Tlist_Compact_Format = 1
<
						*'Tlist_Ctags_Cmd'*
Tlist_Ctags_Cmd~
The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
ctags utility. If exuberant ctags is present in any one of the directories in
the PATH environment variable, then there is no need to set this variable.

The exuberant ctags tool can be installed under different names.  When the
taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
the PATH environment variable.  If any one of the named executable is found,
then the Tlist_Ctags_Cmd variable is set to that name.

If exuberant ctags is not present in one of the directories specified in the
PATH environment variable, then set this variable to point to the location of
the ctags utility in your system. Note that this variable should point to the
fully qualified exuberant ctags location and NOT to the directory in which
exuberant ctags is installed. If the exuberant ctags tool is not found in
either PATH or in the specified location, then the taglist plugin will not be
loaded. Examples:
>
	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
<
						*'Tlist_Display_Prototype'*
Tlist_Display_Prototype~
By default, only the tag name will be displayed in the taglist window. If you
like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
variable to 1. By default, this variable is set to zero and only tag names
will be displayed.
>
	let Tlist_Display_Prototype = 1
<
						*'Tlist_Display_Tag_Scope'*
Tlist_Display_Tag_Scope~
By default, the scope of a tag (like a C++ class) will be displayed in
square brackets next to the tag name. If you don't want the tag scopes
to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
this variable is set to 1 and the tag scopes will be displayed.
>
	let Tlist_Display_Tag_Scope = 0
<
						*'Tlist_Enable_Fold_Column'*
Tlist_Enable_Fold_Column~
By default, the Vim fold column is enabled and displayed in the taglist
window. If you wish to disable this (for example, when you are working with a
narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
variable to zero.
>
	let Tlist_Enable_Fold_Column = 1
<
						*'Tlist_Exit_OnlyWindow'*
Tlist_Exit_OnlyWindow~
If you want to exit Vim if only the taglist window is currently opened, then
set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
set to zero and the Vim instance will not be closed if only the taglist window
is present.
>
	let Tlist_Exit_OnlyWindow = 1
<
						*'Tlist_File_Fold_Auto_Close'*
Tlist_File_Fold_Auto_Close~
By default, the tags tree displayed in the taglist window for all the files is
opened. You can close/fold the tags tree for the files manually. To
automatically close the tags tree for inactive files, you can set the
'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
the tags tree for the current buffer is automatically opened and for all the
other buffers is closed.
>
	let Tlist_File_Fold_Auto_Close = 1
<
					    *'Tlist_GainFocus_On_ToggleOpen'*
Tlist_GainFocus_On_ToggleOpen~
When the taglist window is opened using the ':TlistToggle' command, this
option controls whether the cursor is moved to the taglist window or remains
in the current window. By default, this option is set to 0 and the cursor
remains in the current window. When this variable is set to 1, the cursor
moves to the taglist window after opening the taglist window.
>
	let Tlist_GainFocus_On_ToggleOpen = 1
<
					    *'Tlist_Highlight_Tag_On_BufEnter'*
Tlist_Highlight_Tag_On_BufEnter~
When you enter a Vim buffer/window, the current tag in that buffer/window is
automatically highlighted in the taglist window. If the current tag name is
not visible in the taglist window, then the taglist window contents are
scrolled to make that tag name visible. If you like to disable the automatic
highlighting of the current tag when entering a buffer, you can set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
this variable is 1.
>
	let Tlist_Highlight_Tag_On_BufEnter = 0
<
						*'Tlist_Inc_Winwidth'*
Tlist_Inc_Winwidth~
By default, when the width of the window is less than 100 and a new taglist
window is opened vertically, then the window width is increased by the value
set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
of this variable is used only if you are using a vertically split taglist
window.

If your terminal doesn't support changing the window width from Vim (older
version of xterm running in a Unix system) or if you see any weird problems in
the screen due to the change in the window width or if you prefer not to
adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
window then you must set this variable to zero, otherwise the system may hang
due to a Vim limitation (explained in :help win32-problems)
>
	let Tlist_Inc_Winwidth = 0
<
						*'Tlist_Max_Submenu_Items'*
Tlist_Max_Submenu_Items~
If a file contains too many tags of a particular type (function, variable,
class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
variable, then the menu for that tag type will be split into multiple
sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
>
	let Tlist_Max_Submenu_Items = 20
<
The name of the submenu is formed using the names of the first and the last
tag entries in that submenu.

						*'Tlist_Max_Tag_Length'*
Tlist_Max_Tag_Length~
Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
used to form the tag type submenu name. The default value for this variable is
10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
less characters:
>
	let Tlist_Max_Tag_Length = 10
<
						*'Tlist_Process_File_Always'*
Tlist_Process_File_Always~
By default, the taglist plugin will generate and process the tags defined in
the newly opened files only when the taglist window is opened or when the
taglist menu is enabled. When the taglist window is closed, the taglist plugin
will stop processing the tags for newly opened files.

You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
of tags for new files even when the taglist window is closed and the taglist
menu is disabled.
>
	let Tlist_Process_File_Always = 1
<
To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
taglist window and the taglist menu, you should set this variable to 1.

						*'Tlist_Show_Menu'*
Tlist_Show_Menu~
When using GUI Vim, you can display the tags defined in the current file in a
menu named "Tags". By default, this feature is turned off. To turn on this
feature, set the 'Tlist_Show_Menu' variable to 1:
>
	let Tlist_Show_Menu = 1
<
						*'Tlist_Show_One_File'*
Tlist_Show_One_File~
By default, the taglist plugin will display the tags defined in all the loaded
buffers in the taglist window. If you prefer to display the tags defined only
in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
this variable is set to 1, as you switch between buffers, the taglist window
will be refreshed to display the tags for the current buffer and the tags for
the previous buffer will be removed.
>
	let Tlist_Show_One_File = 1
<
						*'Tlist_Sort_Type'*
Tlist_Sort_Type~
The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
taglist window. The tags can be sorted either alphabetically by their name or
by the order of their appearance in the file (chronological order). By
default, the tag names will be listed by the order in which they are defined
in the file. You can change the sort type (from name to order or from order to
name) by pressing the "s" key in the taglist window. You can also change the
default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
>
	let Tlist_Sort_Type = "name"
<
						*'Tlist_Use_Horiz_Window'*
Tlist_Use_Horiz_Window~
Be default, the tag names are displayed in a vertically split window. If you
prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
command window, then you should use a horizontally split window instead of a
vertically split window. Also, if you are using an older version of xterm in a
Unix system that doesn't support changing the xterm window width, you should
use a horizontally split window.
>
	let Tlist_Use_Horiz_Window = 1
<
						*'Tlist_Use_Right_Window'*
Tlist_Use_Right_Window~
By default, the vertically split taglist window will appear on the left hand
side. If you prefer to open the window on the right hand side, you can set the
'Tlist_Use_Right_Window' variable to 1:
>
	let Tlist_Use_Right_Window = 1
<
						*'Tlist_Use_SingleClick'*
Tlist_Use_SingleClick~
By default, when you double click on the tag name using the left mouse 
button, the cursor will be positioned at the definition of the tag. You 
can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
you single click on the tag name using the mouse. By default this variable
is set to zero.
>
	let Tlist_Use_SingleClick = 1
<
Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
the taglist window using the mouse, then Vim will crash. This problem is fixed
in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
using the mouse, you can use normal Vim window resizing commands to resize the
taglist window.

						*'Tlist_WinHeight'*
Tlist_WinHeight~
The default height of the horizontally split taglist window is 10. This can be
changed by modifying the 'Tlist_WinHeight' variable:
>
	let Tlist_WinHeight = 20
<
The |'winfixheight'| option is set for the taglist window, to maintain the
height of the taglist window, when new Vim windows are opened and existing
windows are closed.

						*'Tlist_WinWidth'*
Tlist_WinWidth~
The default width of the vertically split taglist window is 30. This can be
changed by modifying the 'Tlist_WinWidth' variable:
>
	let Tlist_WinWidth = 20
<
Note that the value of the |'winwidth'| option setting determines the minimum
width of the current window. If you set the 'Tlist_WinWidth' variable to a
value less than that of the |'winwidth'| option setting, then Vim will use the
value of the |'winwidth'| option.

When new Vim windows are opened and existing windows are closed, the taglist
plugin will try to maintain the width of the taglist window to the size
specified by the 'Tlist_WinWidth' variable.

==============================================================================
						*taglist-commands*
7. Commands~

The taglist plugin provides the following ex-mode commands:

|:TlistAddFiles|	Add multiple files to the taglist.
|:TlistAddFilesRecursive|
			Add files recursively to the taglist.
|:TlistClose|		Close the taglist window.
|:TlistDebug|		Start logging of taglist debug messages.
|:TlistLock|		Stop adding new files to the taglist.
|:TlistMessages|	Display the logged taglist plugin debug messages.
|:TlistOpen|		Open and jump to the taglist window.
|:TlistSessionSave|	Save the information about files and tags in the
			taglist to a session file.
|:TlistSessionLoad|	Load the information about files and tags stored
			in a session file to taglist.
|:TlistShowPrototype|	Display the prototype of the tag at or before the
		    	specified line number.
|:TlistShowTag|		Display the name of the tag defined at or before the
			specified line number.
|:TlistHighlightTag|	Highlight the current tag in the taglist window.
|:TlistToggle|		Open or close (toggle) the taglist window.
|:TlistUndebug|		Stop logging of taglist debug messages.
|:TlistUnlock|		Start adding new files to the taglist.
|:TlistUpdate|		Update the tags for the current buffer.

						*:TlistAddFiles*
:TlistAddFiles {file(s)} [file(s) ...]
		Add one or more specified files to the taglist. You can
		specify multiple filenames using wildcards. To specify a
		file name with space character, you should escape the space
		character with a backslash.
		Examples:
>
		    :TlistAddFiles *.c *.cpp
		    :TlistAddFiles file1.html file2.html
<
		If you specify a large number of files, then it will take some
		time for the taglist plugin to process all of them. The
		specified files will not be edited in a Vim window and will
		not be added to the Vim buffer list.

						*:TlistAddFilesRecursive*
:TlistAddFilesRecursive {directory} [ {pattern} ]
		Add files matching {pattern} recursively from the specified
		{directory} to the taglist. If {pattern} is not specified,
		then '*' is assumed. To specify the current directory, use "."
		for {directory}. To specify a directory name with space
		character, you should escape the space character with a
		backslash.
		Examples:
>
		    :TlistAddFilesRecursive myproject *.java
		    :TlistAddFilesRecursive smallproject
<
		If large number of files are present in the specified
		directory tree, then it will take some time for the taglist
		plugin to process all of them.

						*:TlistClose*
:TlistClose	Close the taglist window. This command can be used from any
		one of the Vim windows.

						*:TlistDebug*
:TlistDebug [filename]
		Start logging of debug messages from the taglist plugin.
		If {filename} is specified, then the debug messages are stored
		in the specified file. Otherwise, the debug messages are
		stored in a script local variable. If the file {filename} is
		already present, then it is overwritten.

						*:TlistLock*
:TlistLock
		Lock the taglist and don't process new files. After this
		command is executed, newly edited files will not be added to
		the taglist.

						*:TlistMessages*
:TlistMessages
		Display the logged debug messages from the taglist plugin
		in a window.  This command works only when logging to a
		script-local variable.

						*:TlistOpen*
:TlistOpen	Open and jump to the taglist window. Creates the taglist
		window, if the window is not opened currently. After executing
		this command, the cursor is moved to the taglist window.  When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags defined in them
		are displayed in the taglist window.

						*:TlistSessionSave*
:TlistSessionSave {filename}
		Saves the information about files and tags in the taglist to
		the specified file. This command can be used to save and
		restore the taglist contents across Vim sessions.

						*:TlistSessionLoad*
:TlistSessionLoad {filename}
		Load the information about files and tags stored in the
		specified session file to the taglist.

						*:TlistShowPrototype*
:TlistShowPrototype [filename] [linenumber]
		Display the prototype of the tag at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the prototype for the tag for any line number in this
		range. 

						*:TlistShowTag*
:TlistShowTag [filename] [linenumber]
		Display the name of the tag defined at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the tag name for any line number in this range. 

						*:TlistHighlightTag*
:TlistHighlightTag
		Highlight the current tag in the taglist window. By default,
		the taglist plugin periodically updates the taglist window to
		highlight the current tag. This command can be used to force
		the taglist plugin to highlight the current tag.

						*:TlistToggle*
:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
		window, if the window is not opened currently. Closes the
		taglist window, if the taglist window is already opened. When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags are displayed in
		the taglist window. After executing this command, the cursor
		is not moved from the current window to the taglist window.

						*:TlistUndebug*
:TlistUndebug
		Stop logging of debug messages from the taglist plugin.

						*:TlistUnlock*
:TlistUnlock
		Unlock the taglist and start processing newly edited files.

						*:TlistUpdate*
:TlistUpdate	Update the tags information for the current buffer. This
		command can be used to re-process the current file/buffer and
		get the tags information. As the taglist plugin uses the file
		saved in the disk (instead of the file displayed in a Vim
		buffer), you should save a modified buffer before you update
		the taglist. Otherwise the listed tags will not include the
		new tags created in the buffer. You can use this command even
		when the taglist window is not opened.

==============================================================================
						*taglist-functions*
8. Global functions~

The taglist plugin provides several global functions that can be used from
other Vim plugins to interact with the taglist plugin. These functions are
described below.

|Tlist_Update_File_Tags()|		Update the tags for the specified file
|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
				    	before the specified line number in the
				    	specified file.
|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
					before the specified line number in
					the specified file.
|Tlist_Set_App()|			Set the name of the application
					controlling the taglist window.

					    *Tlist_Update_File_Tags()*
Tlist_Update_File_Tags({filename}, {filetype})
		Update the tags for the file {filename}. The second argument
		specifies the Vim filetype for the file. If the taglist plugin
		has not processed the file previously, then the exuberant
		ctags tool is invoked to generate the tags for the file.

					    *Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
		Return the prototype of the tag at or before the specified
		line number in the specified file. If the filename and line
		number are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Get_Tagname_By_Line()*
Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
		Return the name of the tag at or before the specified line
		number in the specified file. If the filename and line number
		are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Set_App()*
Tlist_Set_App({appname})
		Set the name of the plugin that controls the taglist plugin
		window and buffer. This can be used to integrate the taglist
		plugin with other Vim plugins.
		
		For example, the winmanager plugin and the Cream package use
		this function and specify the appname as "winmanager" and
		"cream" respectively.
		
		By default, the taglist plugin is a stand-alone plugin and
		controls the taglist window and buffer. If the taglist window
		is controlled by an external plugin, then the appname should
		be set appropriately.

==============================================================================
						*taglist-extend*
9. Extending~

The taglist plugin supports all the languages supported by the exuberant ctags
tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
TCL, Verilog, Vim and Yacc.

You can extend the taglist plugin to add support for new languages and also
modify the support for the above listed languages.

You should NOT make modifications to the taglist plugin script file to add
support for new languages. You will lose these changes when you upgrade to the
next version of the taglist plugin. Instead you should follow the below
described instructions to extend the taglist plugin.

You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
file. The name of these variables depends on the language name and is
described below.

Modifying support for an existing language~
To modify the support for an already supported language, you have to set the
tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
with the Vim filetype name for the language file.  For example, to modify the
support for the perl language files, you have to set the tlist_perl_settings
variable. To modify the support for java files, you have to set the
tlist_java_settings variable.

To determine the filetype name used by Vim for a file, use the following
command in the buffer containing the file:

	:set filetype

The above command will display the Vim filetype for the current buffer.

The format of the value set in the tlist_xxx_settings variable is

    <language_name>;flag1:name1;flag2:name2;flag3:name3

The different fields in the value are separated by the ';' character.

The first field 'language_name' is the name used by exuberant ctags to refer
to this language file. This name can be different from the file type name used
by Vim. For example, for C++, the language name used by ctags is 'c++' but the
filetype name used by Vim is 'cpp'. To get the list of language names
supported by exuberant ctags, use the following command:

	$ ctags --list-maps=all

The remaining fields follow the format "flag:name". The sub-field 'flag' is
the language specific flag used by exuberant ctags to generate the
corresponding tags. For example, for the C language, to list only the
functions, the 'f' flag is used. To get the list of flags supported by
exuberant ctags for the various languages use the following command:

	$ ctags --list-kinds=all

The sub-field 'name' specifies the title text to use for displaying the tags
of a particular type. For example, 'name' can be set to 'functions'. This
field can be set to any text string name.

For example, to list only the classes and functions defined in a C++ language
file, add the following line to your .vimrc file:

	let tlist_cpp_settings = 'c++;c:class;f:function'

In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
exuberant ctags to list C++ classes and functions and 'class' is the title
used for the class tags and 'function' is the title used for the function tags
in the taglist window.

For example, to display only functions defined in a C file and to use "My
Functions" as the title for the function tags, use

	let tlist_c_settings = 'c;f:My Functions'

When you set the tlist_xxx_settings variable, you will override the default
setting used by the taglist plugin for the 'xxx' language. You cannot add to
the default options used by the taglist plugin for a particular file type. To
add to the options used by the taglist plugin for a language, copy the option
values from the taglist plugin file to your .vimrc file and modify it.

Adding support for a new language~
If you want to add support for a new language to the taglist plugin, you need
to first extend the exuberant ctags tool. For more information about extending
exuberant ctags, visit the following page:

    http://ctags.sourceforge.net/EXTENDING.html

To add support for a new language, set the tlist_xxx_settings variable in the
~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
name with the Vim filetype name for the new language.

For example, to extend the taglist plugin to support the latex language, you
can use the following line (assuming, you have already extended exuberant
ctags to support the latex language):

	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'

With the above line, when you edit files of filetype "tex" in Vim, the taglist
plugin will invoke the exuberant ctags tool passing the "latex" filetype and
the flags b, c and l to generate the tags. The text heading 'bibitem',
'command' and 'label' will be used in the taglist window for the tags which
are generated for the flags b, c and l respectively.

==============================================================================
						*taglist-faq*
10. Frequently Asked Questions~

Q. The taglist plugin doesn't work. The taglist window is empty and the tags
   defined in a file are not displayed. 
A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
   features supported by Vim version 6.0 and above. You can use the following
   command to get the Vim version:
>
	$ vim --version
<
   Are you using exuberant ctags version 5.0 and above? The taglist plugin
   relies on the features supported by exuberant ctags and will not work with
   GNU ctags or the Unix ctags utility. You can use the following command to
   determine whether the ctags installed in your system is exuberant ctags:
>
	$ ctags --version
<
   Is exuberant ctags present in one of the directories in your PATH? If not,
   you need to set the Tlist_Ctags_Cmd variable to point to the location of
   exuberant ctags. Use the following Vim command to verify that this is setup
   correctly:
>
	:echo system(Tlist_Ctags_Cmd . ' --version')
<
   The above command should display the version information for exuberant
   ctags.

   Did you turn on the Vim filetype detection? The taglist plugin relies on
   the filetype detected by Vim and passes the filetype to the exuberant ctags
   utility to parse the tags. Check the output of the following Vim command:
>
	:filetype
<
   The output of the above command should contain "filetype detection:ON".
   To turn on the filetype detection, add the following line to the .vimrc or
   _vimrc file:
>
	filetype on
<
   Is your version of Vim compiled with the support for the system() function?
   The following Vim command should display 1:
>
	:echo exists('*system')
<
   In some Linux distributions (particularly Suse Linux), the default Vim
   installation is built without the support for the system() function. The
   taglist plugin uses the system() function to invoke the exuberant ctags
   utility. You need to rebuild Vim after enabling the support for the
   system() function. If you use the default build options, the system()
   function will be supported. 

   Do you have the |'shellslash'| option set? You can try disabling the
   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
   utility with the path to the file, if the incorrect slashes are used, then
   you will see errors.
   
   Check the shell related Vim options values using the following command:
>
	:set shell? shellcmdflag? shellpipe?
	:set shellquote? shellredir? shellxquote?
<
   If these options are set in your .vimrc or _vimrc file, try removing those
   lines.

   Are you using a Unix shell in a MS-Windows environment? For example,
   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
   set to point to this shell? You can try resetting the SHELL environment
   variable.

   If you are using a Unix shell on MS-Windows, you should try to use
   exuberant ctags that is compiled for Unix-like environments so that
   exuberant ctags will understand path names with forward slash characters.

   Is your filetype supported by the exuberant ctags utility? The file types
   supported by the exuberant ctags utility are listed in the ctags help. If a
   file type is not supported, you have to extend exuberant ctags. You can use
   the following command to list the filetypes supported by exuberant ctags:
>
	ctags --list-languages
<
   Run the following command from the shell prompt and check whether the tags
   defined in your file are listed in the output from exuberant ctags:
>
	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
<
   If you see your tags in the output from the above command, then the
   exuberant ctags utility is properly parsing your file.

   Do you have the .ctags or _ctags or the ctags.cnf file in your home
   directory for specifying default options or for extending exuberant ctags?
   If you do have this file, check the options in this file and make sure
   these options are not interfering with the operation of the taglist plugin.

   If you are using MS-Windows, check the value of the TEMP and TMP
   environment variables. If these environment variables are set to a path
   with space characters in the name, then try using the DOS 8.3 short name
   for the path or set them to a path without the space characters in the
   name. For example, if the temporary directory name is "C:\Documents and
   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
   the following:
>
	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
<
   If exuberant ctags is installed in a directory with space characters in the
   name, then try adding the directory to the PATH environment variable or try
   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
   or try copying the exuberant ctags to a path without space characters in
   the name. For example, if exuberant ctags is installed in the directory
   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
   as below:
>
	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
<
   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
   make sure that either you have the cygwin compiled sort utility installed
   and available in your PATH or compile exuberant ctags with internal sort
   support. Otherwise, when exuberant ctags sorts the tags output by invoking
   the sort utility, it may end up invoking the MS-Windows version of
   sort.exe, thereby resulting in failure.

Q. When I try to open the taglist window, I am seeing the following error
   message. How do I fix this problem?

   Taglist: Failed to generate tags for /my/path/to/file
   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...

A. The taglist plugin will work only with the exuberant ctags tool. You
   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
   You will see an error message similar to the one shown above, if you try
   use a non-exuberant ctags program with Vim. To fix this problem, either add
   the exuberant ctags tool location to the PATH environment variable or set
   the 'Tlist_Ctags_Cmd' variable.

Q. A file has more than one tag with the same name. When I select a tag name
   from the taglist window, the cursor is positioned at the incorrect tag
   location. 
A. The taglist plugin uses the search pattern generated by the exuberant ctags
   utility to position the cursor at the location of a tag definition. If a
   file has more than one tag with the same name and same prototype, then the
   search pattern will be the same. In this case, when searching for the tag
   pattern, the cursor may be positioned at the incorrect location. 

Q. I have made some modifications to my file and introduced new
   functions/classes/variables. I have not yet saved my file. The taglist
   plugin is not displaying the new tags when I update the taglist window.
A. The exuberant ctags utility will process only files that are present in the
   disk. To list the tags defined in a file, you have to save the file and
   then update the taglist window. 

Q. I have created a ctags file using the exuberant ctags utility for my source
   tree. How do I configure the taglist plugin to use this tags file? 
A. The taglist plugin doesn't use a tags file stored in disk. For every opened
   file, the taglist plugin invokes the exuberant ctags utility to get the
   list of tags dynamically. The Vim system() function is used to invoke
   exuberant ctags and get the ctags output. This function internally uses a
   temporary file to store the output. This file is deleted after the output
   from the command is read. So you will never see the file that contains the
   output of exuberant ctags.

Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
   I keep pressing a key with the taglist window open, the current buffer
   contents are changed. Why is this?
A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
   If the |'updatetime'| option is set to a low value, then the CursorHold
   autocmd will be triggered frequently. As the taglist plugin changes
   the focus to the taglist window to highlight the current tag, this could
   interfere with the key movement resulting in changing the contents of
   the current buffer. The workaround for this problem is to not set the
   |'updatetime'| option to a low value.

==============================================================================
						*taglist-license*
11. License~
Permission is hereby granted to use and distribute the taglist plugin, with or
without modifications, provided that this copyright notice is copied with it.
Like anything else that's free, taglist.vim is provided *as is* and comes with
no warranty of any kind, either expressed or implied. In no event will the
copyright holder be liable for any damamges resulting from the use of this
software.

==============================================================================
						*taglist-todo*
12. Todo~

1. Group tags according to the scope and display them. For example,
   group all the tags belonging to a C++/Java class 
2. Support for displaying tags in a modified (not-yet-saved) file. 
3. Automatically open the taglist window only for selected filetypes.
   For other filetypes, close the taglist window. 
4. When using the shell from the MKS toolkit, the taglist plugin 
   doesn't work.
5. The taglist plugin doesn't work with files edited remotely using the
   netrw plugin. The exuberant ctags utility cannot process files over
   scp/rcp/ftp, etc.

==============================================================================

vim:tw=78:ts=8:noet:ft=help:
zhimakaimen:/vimfiles/bundle/taglist.vim/doc/taglist.txt
" File: taglist.vim
" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
" Version: 4.5
" Last Modified: September 21, 2007
" Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
"            Permission is hereby granted to use and distribute this code,
"            with or without modifications, provided that this copyright
"            notice is copied with it. Like anything else that's free,
"            taglist.vim is provided *as is* and comes with no warranty of any
"            kind, either expressed or implied. In no event will the copyright
"            holder be liable for any damamges resulting from the use of this
"            software.
"
" The "Tag List" plugin is a source code browser plugin for Vim and provides
" an overview of the structure of the programming language files and allows
" you to efficiently browse through source code files for different
" programming languages.  You can visit the taglist plugin home page for more
" information:
"
"       http://vim-taglist.sourceforge.net
"
" You can subscribe to the taglist mailing list to post your questions
" or suggestions for improvement or to report bugs. Visit the following
" page for subscribing to the mailing list:
"
"       http://groups.yahoo.com/group/taglist/
"
" For more information about using this plugin, after installing the
" taglist plugin, use the ":help taglist" command.
"
" Installation
" ------------
" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
"    unzip the following two files (the directory structure should be
"    preserved):
"
"       plugin/taglist.vim - main taglist plugin file
"       doc/taglist.txt    - documentation (help) file
"
"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
"    Vim help pages for more details about installing Vim plugins.
" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
"    command to process the taglist help file.
" 3. If the exuberant ctags utility is not present in your PATH, then set the
"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
"    utility (not to the directory) in the .vimrc file.
" 4. If you are running a terminal/console version of Vim and the
"    terminal doesn't support changing the window width then set the
"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
" 5. Restart Vim.
" 6. You can now use the ":TlistToggle" command to open/close the taglist
"    window. You can use the ":help taglist" command to get more
"    information about using the taglist plugin.
"
" ****************** Do not modify after this line ************************

" Line continuation used here
let s:cpo_save = &cpo
set cpo&vim

if !exists('loaded_taglist')
    " First time loading the taglist plugin
    "
    " To speed up the loading of Vim, the taglist plugin uses autoload
    " mechanism to load the taglist functions.
    " Only define the configuration variables, user commands and some
    " auto-commands and finish sourcing the file

    " The taglist plugin requires the built-in Vim system() function. If this
    " function is not available, then don't load the plugin.
    if !exists('*system')
        echomsg 'Taglist: Vim system() built-in function is not available. ' .
                    \ 'Plugin is not loaded.'
        let loaded_taglist = 'no'
        let &cpo = s:cpo_save
        finish
    endif

    " Location of the exuberant ctags tool
    if !exists('Tlist_Ctags_Cmd')
        if executable('exuberant-ctags')
            " On Debian Linux, exuberant ctags is installed
            " as exuberant-ctags
            let Tlist_Ctags_Cmd = 'exuberant-ctags'
        elseif executable('exctags')
            " On Free-BSD, exuberant ctags is installed as exctags
            let Tlist_Ctags_Cmd = 'exctags'
        elseif executable('ctags')
            let Tlist_Ctags_Cmd = 'ctags'
        elseif executable('ctags.exe')
            let Tlist_Ctags_Cmd = 'ctags.exe'
        elseif executable('tags')
            let Tlist_Ctags_Cmd = 'tags'
        else
            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
                        \ 'not found in PATH. Plugin is not loaded.'
            " Skip loading the plugin
            let loaded_taglist = 'no'
            let &cpo = s:cpo_save
            finish
        endif
    endif


    " Automatically open the taglist window on Vim startup
    if !exists('Tlist_Auto_Open')
        let Tlist_Auto_Open = 0
    endif

    " When the taglist window is toggle opened, move the cursor to the
    " taglist window
    if !exists('Tlist_GainFocus_On_ToggleOpen')
        let Tlist_GainFocus_On_ToggleOpen = 0
    endif

    " Process files even when the taglist window is not open
    if !exists('Tlist_Process_File_Always')
        let Tlist_Process_File_Always = 0
    endif

    if !exists('Tlist_Show_Menu')
        let Tlist_Show_Menu = 0
    endif

    " Tag listing sort type - 'name' or 'order'
    if !exists('Tlist_Sort_Type')
        let Tlist_Sort_Type = 'order'
    endif

    " Tag listing window split (horizontal/vertical) control
    if !exists('Tlist_Use_Horiz_Window')
        let Tlist_Use_Horiz_Window = 0
    endif

    " Open the vertically split taglist window on the left or on the right
    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
    " zero (i.e.  only for vertically split windows)
    if !exists('Tlist_Use_Right_Window')
        let Tlist_Use_Right_Window = 0
    endif

    " Increase Vim window width to display vertically split taglist window.
    " For MS-Windows version of Vim running in a MS-DOS window, this must be
    " set to 0 otherwise the system may hang due to a Vim limitation.
    if !exists('Tlist_Inc_Winwidth')
        if (has('win16') || has('win95')) && !has('gui_running')
            let Tlist_Inc_Winwidth = 0
        else
            let Tlist_Inc_Winwidth = 1
        endif
    endif

    " Vertically split taglist window width setting
    if !exists('Tlist_WinWidth')
        let Tlist_WinWidth = 30
    endif

    " Horizontally split taglist window height setting
    if !exists('Tlist_WinHeight')
        let Tlist_WinHeight = 10
    endif

    " Display tag prototypes or tag names in the taglist window
    if !exists('Tlist_Display_Prototype')
        let Tlist_Display_Prototype = 0
    endif

    " Display tag scopes in the taglist window
    if !exists('Tlist_Display_Tag_Scope')
        let Tlist_Display_Tag_Scope = 1
    endif

    " Use single left mouse click to jump to a tag. By default this is disabled.
    " Only double click using the mouse will be processed.
    if !exists('Tlist_Use_SingleClick')
        let Tlist_Use_SingleClick = 0
    endif

    " Control whether additional help is displayed as part of the taglist or
    " not.  Also, controls whether empty lines are used to separate the tag
    " tree.
    if !exists('Tlist_Compact_Format')
        let Tlist_Compact_Format = 0
    endif

    " Exit Vim if only the taglist window is currently open. By default, this is
    " set to zero.
    if !exists('Tlist_Exit_OnlyWindow')
        let Tlist_Exit_OnlyWindow = 0
    endif

    " Automatically close the folds for the non-active files in the taglist
    " window
    if !exists('Tlist_File_Fold_Auto_Close')
        let Tlist_File_Fold_Auto_Close = 0
    endif

    " Close the taglist window when a tag is selected
    if !exists('Tlist_Close_On_Select')
        let Tlist_Close_On_Select = 0
    endif

    " Automatically update the taglist window to display tags for newly
    " edited files
    if !exists('Tlist_Auto_Update')
        let Tlist_Auto_Update = 1
    endif

    " Automatically highlight the current tag
    if !exists('Tlist_Auto_Highlight_Tag')
        let Tlist_Auto_Highlight_Tag = 1
    endif
    
    " Automatically highlight the current tag on entering a buffer
    if !exists('Tlist_Highlight_Tag_On_BufEnter')
        let Tlist_Highlight_Tag_On_BufEnter = 1
    endif

    " Enable fold column to display the folding for the tag tree
    if !exists('Tlist_Enable_Fold_Column')
        let Tlist_Enable_Fold_Column = 1
    endif

    " Display the tags for only one file in the taglist window
    if !exists('Tlist_Show_One_File')
        let Tlist_Show_One_File = 0
    endif

    if !exists('Tlist_Max_Submenu_Items')
        let Tlist_Max_Submenu_Items = 20
    endif

    if !exists('Tlist_Max_Tag_Length')
        let Tlist_Max_Tag_Length = 10
    endif

    " Do not change the name of the taglist title variable. The winmanager
    " plugin relies on this name to determine the title for the taglist
    " plugin.
    let TagList_title = "__Tag_List__"

    " Taglist debug messages
    let s:tlist_msg = ''

    " Define the taglist autocommand to automatically open the taglist window
    " on Vim startup
    if g:Tlist_Auto_Open
        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
    endif

    " Refresh the taglist
    if g:Tlist_Process_File_Always
        autocmd BufEnter * call s:Tlist_Refresh()
    endif

    if g:Tlist_Show_Menu
        autocmd GUIEnter * call s:Tlist_Menu_Init()
    endif

    " When the taglist buffer is created when loading a Vim session file,
    " the taglist buffer needs to be initialized. The BufFilePost event
    " is used to handle this case.
    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()

    " Define the user commands to manage the taglist window
    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
    " For backwards compatiblity define the Tlist command
    command! -nargs=0 -bar Tlist TlistToggle
    command! -nargs=+ -complete=file TlistAddFiles
                \  call s:Tlist_Add_Files(<f-args>)
    command! -nargs=+ -complete=dir TlistAddFilesRecursive
                \ call s:Tlist_Add_Files_Recursive(<f-args>)
    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
    " For backwards compatiblity define the TlistSync command
    command! -nargs=0 -bar TlistSync TlistHighlightTag
    command! -nargs=* -complete=buffer TlistShowPrototype
                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
    command! -nargs=* -complete=buffer TlistShowTag
                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
    command! -nargs=* -complete=file TlistSessionLoad
                \ call s:Tlist_Session_Load(<q-args>)
    command! -nargs=* -complete=file TlistSessionSave
                \ call s:Tlist_Session_Save(<q-args>)
    command! -bar TlistLock let Tlist_Auto_Update=0
    command! -bar TlistUnlock let Tlist_Auto_Update=1

    " Commands for enabling/disabling debug and to display debug messages
    command! -nargs=? -complete=file -bar TlistDebug
                \ call s:Tlist_Debug_Enable(<q-args>)
    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()

    " Define autocommands to autoload the taglist plugin when needed.

    " Trick to get the current script ID
    map <SID>xx <SID>xx
    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
                                \ '\1', '')
    unmap <SID>xx

    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined TagList_* source ' .
                \ escape(expand('<sfile>'), ' ')

    let loaded_taglist = 'fast_load_done'

    if g:Tlist_Show_Menu && has('gui_running')
        call s:Tlist_Menu_Init()
    endif

    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

if !exists('s:tlist_sid')
    " Two or more versions of taglist plugin are installed. Don't
    " load this version of the plugin.
    finish
endif

unlet! s:tlist_sid

if loaded_taglist != 'fast_load_done'
    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

" Taglist plugin functionality is available
let loaded_taglist = 'available'

"------------------- end of user configurable options --------------------

" Default language specific settings for supported file types and tag types
"
" Variable name format:
"
"       s:tlist_def_{vim_ftype}_settings
" 
" vim_ftype - Filetype detected by Vim
"
" Value format:
"
"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
"
" ctags_ftype - File type supported by exuberant ctags
" flag        - Flag supported by exuberant ctags to generate a tag type
" name        - Name of the tag type used in the taglist window to display the
"               tags of this type
"

" assembly language
let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'

" aspperl language
let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'

" aspvbs language
let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'

" awk language
let s:tlist_def_awk_settings = 'awk;f:function'

" beta language
let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'

" c language
let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
                           \ 'v:variable;f:function'

" c++ language
let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
                             \ 'c:class;g:enum;s:struct;u:union;f:function'

" c# language
let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
                             \ 'E:event;g:enum;s:struct;i:interface;' .
                             \ 'p:properties;m:method'

" cobol language
let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
                               \ 'P:program;s:section'

" eiffel language
let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'

" erlang language
let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'

" expect (same as tcl) language
let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'

" fortran language
let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'

" HTML language
let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'

" java language
let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
                              \ 'f:field;m:method'

" javascript language
let s:tlist_def_javascript_settings = 'javascript;f:function'

" lisp language
let s:tlist_def_lisp_settings = 'lisp;f:function'

" lua language
let s:tlist_def_lua_settings = 'lua;f:function'

" makefiles
let s:tlist_def_make_settings = 'make;m:macro'

" pascal language
let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'

" perl language
let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'

" php language
let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'

" python language
let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'

" rexx language
let s:tlist_def_rexx_settings = 'rexx;s:subroutine'

" ruby language
let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
                              \ 'm:singleton method'

" scheme language
let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'

" shell language
let s:tlist_def_sh_settings = 'sh;f:function'

" C shell language
let s:tlist_def_csh_settings = 'sh;f:function'

" Z shell language
let s:tlist_def_zsh_settings = 'sh;f:function'

" slang language
let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'

" sml language
let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
                             \ 'r:structure;t:type;v:value;f:function'

" sql language
let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'

" tcl language
let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'

" vera language
let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
                                \ 'f:function;g:enum;m:member;p:program;' .
                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
                                \ 'x:externvar'

"verilog language
let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'

" vim language
let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'

" yacc language
let s:tlist_def_yacc_settings = 'yacc;l:label'

"------------------- end of language specific options --------------------

" Vim window size is changed by the taglist plugin or not
let s:tlist_winsize_chgd = -1
" Taglist window is maximized or not
let s:tlist_win_maximized = 0
" Name of files in the taglist
let s:tlist_file_names=''
" Number of files in the taglist
let s:tlist_file_count = 0
" Number of filetypes supported by taglist
let s:tlist_ftype_count = 0
" Is taglist part of other plugins like winmanager or cream?
let s:tlist_app_name = "none"
" Are we displaying brief help text
let s:tlist_brief_help = 1
" List of files removed on user request
let s:tlist_removed_flist = ""
" Index of current file displayed in the taglist window
let s:tlist_cur_file_idx = -1
" Taglist menu is empty or not
let s:tlist_menu_empty = 1

" An autocommand is used to refresh the taglist window when entering any
" buffer. We don't want to refresh the taglist window if we are entering the
" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
" variable is used to skip the refresh of the taglist window and is set
" and cleared appropriately.
let s:Tlist_Skip_Refresh = 0

" Tlist_Window_Display_Help()
function! s:Tlist_Window_Display_Help()
    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    if s:tlist_brief_help
        " Add the brief help
        call append(0, '" Press <F1> to display help text')
    else
        " Add the extensive help
        call append(0, '" <enter> : Jump to tag definition')
        call append(1, '" o : Jump to tag definition in new window')
        call append(2, '" p : Preview the tag definition')
        call append(3, '" <space> : Display tag prototype')
        call append(4, '" u : Update tag list')
        call append(5, '" s : Select sort field')
        call append(6, '" d : Remove file from taglist')
        call append(7, '" x : Zoom-out/Zoom-in taglist window')
        call append(8, '" + : Open a fold')
        call append(9, '" - : Close a fold')
        call append(10, '" * : Open all folds')
        call append(11, '" = : Close all folds')
        call append(12, '" [[ : Move to the start of previous file')
        call append(13, '" ]] : Move to the start of next file')
        call append(14, '" q : Close the taglist window')
        call append(15, '" <F1> : Remove help text')
    endif
endfunction

" Tlist_Window_Toggle_Help_Text()
" Toggle taglist plugin help text between the full version and the brief
" version
function! s:Tlist_Window_Toggle_Help_Text()
    if g:Tlist_Compact_Format
        " In compact display mode, do not display help
        return
    endif

    " Include the empty line displayed after the help text
    let brief_help_size = 1
    let full_help_size = 16

    setlocal modifiable

    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Remove the currently highlighted tag. Otherwise, the help text
    " might be highlighted by mistake
    match none

    " Toggle between brief and full help text
    if s:tlist_brief_help
        let s:tlist_brief_help = 0

        " Remove the previous help
        exe '1,' . brief_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
    else
        let s:tlist_brief_help = 1

        " Remove the previous help
        exe '1,' . full_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
    endif

    call s:Tlist_Window_Display_Help()

    " Restore the report option
    let &report = old_report

    setlocal nomodifiable
endfunction

" Taglist debug support
let s:tlist_debug = 0

" File for storing the debug messages
let s:tlist_debug_file = ''

" Tlist_Debug_Enable
" Enable logging of taglist debug messages.
function! s:Tlist_Debug_Enable(...)
    let s:tlist_debug = 1

    " Check whether a valid file name is supplied.
    if a:1 != ''
        let s:tlist_debug_file = fnamemodify(a:1, ':p')

        " Empty the log file
        exe 'redir! > ' . s:tlist_debug_file
        redir END

        " Check whether the log file is present/created
        if !filewritable(s:tlist_debug_file)
            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
                        \ . s:tlist_debug_file)
            let s:tlist_debug_file = ''
        endif
    endif
endfunction

" Tlist_Debug_Disable
" Disable logging of taglist debug messages.
function! s:Tlist_Debug_Disable(...)
    let s:tlist_debug = 0
    let s:tlist_debug_file = ''
endfunction

" Tlist_Debug_Show
" Display the taglist debug messages in a new window
function! s:Tlist_Debug_Show()
    if s:tlist_msg == ''
        call s:Tlist_Warning_Msg('Taglist: No debug messages')
        return
    endif

    " Open a new window to display the taglist debug messages
    new taglist_debug.txt
    " Delete all the lines (if the buffer already exists)
    silent! %delete _
    " Add the messages
    silent! put =s:tlist_msg
    " Move the cursor to the first line
    normal! gg
endfunction

" Tlist_Log_Msg
" Log the supplied debug message along with the time
function! s:Tlist_Log_Msg(msg)
    if s:tlist_debug
        if s:tlist_debug_file != ''
            exe 'redir >> ' . s:tlist_debug_file
            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
            redir END
        else
            " Log the message into a variable
            " Retain only the last 3000 characters
            let len = strlen(s:tlist_msg)
            if len > 3000
                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
            endif
            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
                        \ a:msg . "\n"
        endif
    endif
endfunction

" Tlist_Warning_Msg()
" Display a message using WarningMsg highlight group
function! s:Tlist_Warning_Msg(msg)
    echohl WarningMsg
    echomsg a:msg
    echohl None
endfunction

" Last returned file index for file name lookup.
" Used to speed up file lookup
let s:tlist_file_name_idx_cache = -1

" Tlist_Get_File_Index()
" Return the index of the specified filename
function! s:Tlist_Get_File_Index(fname)
    if s:tlist_file_count == 0 || a:fname == ''
        return -1
    endif

    " If the new filename is same as the last accessed filename, then
    " return that index
    if s:tlist_file_name_idx_cache != -1 &&
                \ s:tlist_file_name_idx_cache < s:tlist_file_count
        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
            " Same as the last accessed file
            return s:tlist_file_name_idx_cache
        endif
    endif

    " First, check whether the filename is present
    let s_fname = a:fname . "\n"
    let i = stridx(s:tlist_file_names, s_fname)
    if i == -1
        let s:tlist_file_name_idx_cache = -1
        return -1
    endif

    " Second, compute the file name index
    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
    let s:tlist_file_name_idx_cache = strlen(nl_txt)
    return s:tlist_file_name_idx_cache
endfunction

" Last returned file index for line number lookup.
" Used to speed up file lookup
let s:tlist_file_lnum_idx_cache = -1

" Tlist_Window_Get_File_Index_By_Linenum()
" Return the index of the filename present in the specified line number
" Line number refers to the line number in the taglist window
function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')

    " First try to see whether the new line number is within the range
    " of the last returned file
    if s:tlist_file_lnum_idx_cache != -1 &&
                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
            return s:tlist_file_lnum_idx_cache
        endif
    endif

    let fidx = -1

    if g:Tlist_Show_One_File
        " Displaying only one file in the taglist window. Check whether
        " the line is within the tags displayed for that file
        if s:tlist_cur_file_idx != -1
            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
                let fidx = s:tlist_cur_file_idx
            endif

        endif
    else
        " Do a binary search in the taglist
        let left = 0
        let right = s:tlist_file_count - 1

        while left < right
            let mid = (left + right) / 2

            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
                let s:tlist_file_lnum_idx_cache = mid
                return mid
            endif

            if a:lnum < s:tlist_{mid}_start
                let right = mid - 1
            else
                let left = mid + 1
            endif
        endwhile

        if left >= 0 && left < s:tlist_file_count
                    \ && a:lnum >= s:tlist_{left}_start
                    \ && a:lnum <= s:tlist_{left}_end
            let fidx = left
        endif
    endif

    let s:tlist_file_lnum_idx_cache = fidx

    return fidx
endfunction

" Tlist_Exe_Cmd_No_Acmds
" Execute the specified Ex command after disabling autocommands
function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
    let old_eventignore = &eventignore
    set eventignore=all
    exe a:cmd
    let &eventignore = old_eventignore
endfunction

" Tlist_Skip_File()
" Check whether tag listing is supported for the specified file
function! s:Tlist_Skip_File(filename, ftype)
    " Skip buffers with no names and buffers with filetype not set
    if a:filename == '' || a:ftype == ''
        return 1
    endif

    " Skip files which are not supported by exuberant ctags
    " First check whether default settings for this filetype are available.
    " If it is not available, then check whether user specified settings are
    " available. If both are not available, then don't list the tags for this
    " filetype
    let var = 's:tlist_def_' . a:ftype . '_settings'
    if !exists(var)
        let var = 'g:tlist_' . a:ftype . '_settings'
        if !exists(var)
            return 1
        endif
    endif

    " Skip files which are not readable or files which are not yet stored
    " to the disk
    if !filereadable(a:filename)
        return 1
    endif

    return 0
endfunction

" Tlist_User_Removed_File
" Returns 1 if a file is removed by a user from the taglist
function! s:Tlist_User_Removed_File(filename)
    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
endfunction

" Tlist_Update_Remove_List
" Update the list of user removed files from the taglist
" add == 1, add the file to the removed list
" add == 0, delete the file from the removed list
function! s:Tlist_Update_Remove_List(filename, add)
    if a:add
        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
    else
        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
        let text_before = strpart(s:tlist_removed_flist, 0, idx)
        let rem_text = strpart(s:tlist_removed_flist, idx)
        let next_idx = stridx(rem_text, "\n")
        let text_after = strpart(rem_text, next_idx + 1)

        let s:tlist_removed_flist = text_before . text_after
    endif
endfunction

" Tlist_FileType_Init
" Initialize the ctags arguments and tag variable for the specified
" file type
function! s:Tlist_FileType_Init(ftype)
    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
    " If the user didn't specify any settings, then use the default
    " ctags args. Otherwise, use the settings specified by the user
    let var = 'g:tlist_' . a:ftype . '_settings'
    if exists(var)
        " User specified ctags arguments
        let settings = {var} . ';'
    else
        " Default ctags arguments
        let var = 's:tlist_def_' . a:ftype . '_settings'
        if !exists(var)
            " No default settings for this file type. This filetype is
            " not supported
            return 0
        endif
        let settings = s:tlist_def_{a:ftype}_settings . ';'
    endif

    let msg = 'Taglist: Invalid ctags option setting - ' . settings

    " Format of the option that specifies the filetype and ctags arugments:
    "
    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
    "

    " Extract the file type to pass to ctags. This may be different from the
    " file type detected by Vim
    let pos = stridx(settings, ';')
    if pos == -1
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    let ctags_ftype = strpart(settings, 0, pos)
    if ctags_ftype == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    " Make sure a valid filetype is supplied. If the user didn't specify a
    " valid filetype, then the ctags option settings may be treated as the
    " filetype
    if ctags_ftype =~ ':'
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Remove the file type from settings
    let settings = strpart(settings, pos + 1)
    if settings == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Process all the specified ctags flags. The format is
    " flag1:name1;flag2:name2;flag3:name3
    let ctags_flags = ''
    let cnt = 0
    while settings != ''
        " Extract the flag
        let pos = stridx(settings, ':')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let flag = strpart(settings, 0, pos)
        if flag == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        " Remove the flag from settings
        let settings = strpart(settings, pos + 1)

        " Extract the tag type name
        let pos = stridx(settings, ';')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let name = strpart(settings, 0, pos)
        if name == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let settings = strpart(settings, pos + 1)

        let cnt = cnt + 1

        let s:tlist_{a:ftype}_{cnt}_name = flag
        let s:tlist_{a:ftype}_{cnt}_fullname = name
        let ctags_flags = ctags_flags . flag
    endwhile

    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
    let s:tlist_{a:ftype}_count = cnt
    let s:tlist_{a:ftype}_ctags_flags = ctags_flags

    " Save the filetype name
    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
    let s:tlist_ftype_count = s:tlist_ftype_count + 1

    return 1
endfunction

" Tlist_Detect_Filetype
" Determine the filetype for the specified file using the filetypedetect
" autocmd.
function! s:Tlist_Detect_Filetype(fname)
    " Ignore the filetype autocommands
    let old_eventignore = &eventignore
    set eventignore=FileType

    " Save the 'filetype', as this will be changed temporarily
    let old_filetype = &filetype

    " Run the filetypedetect group of autocommands to determine
    " the filetype
    exe 'doautocmd filetypedetect BufRead ' . a:fname

    " Save the detected filetype
    let ftype = &filetype

    " Restore the previous state
    let &filetype = old_filetype
    let &eventignore = old_eventignore

    return ftype
endfunction

" Tlist_Get_Buffer_Filetype
" Get the filetype for the specified buffer
function! s:Tlist_Get_Buffer_Filetype(bnum)
    let buf_ft = getbufvar(a:bnum, '&filetype')

    if bufloaded(a:bnum)
        " For loaded buffers, the 'filetype' is already determined
        return buf_ft
    endif

    " For unloaded buffers, if the 'filetype' option is set, return it
    if buf_ft != ''
        return buf_ft
    endif

    " Skip non-existent buffers
    if !bufexists(a:bnum)
        return ''
    endif

    " For buffers whose filetype is not yet determined, try to determine
    " the filetype
    let bname = bufname(a:bnum)

    return s:Tlist_Detect_Filetype(bname)
endfunction

" Tlist_Discard_TagInfo
" Discard the stored tag information for a file
function! s:Tlist_Discard_TagInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    let ftype = s:tlist_{a:fidx}_filetype

    " Discard information about the tags defined in the file
    let i = 1
    while i <= s:tlist_{a:fidx}_tag_count
        let fidx_i = 's:tlist_' . a:fidx . '_' . i
        unlet! {fidx_i}_tag
        unlet! {fidx_i}_tag_name
        unlet! {fidx_i}_tag_type
        unlet! {fidx_i}_ttype_idx
        unlet! {fidx_i}_tag_proto
        unlet! {fidx_i}_tag_searchpat
        unlet! {fidx_i}_tag_linenum
        let i = i + 1
    endwhile

    let s:tlist_{a:fidx}_tag_count = 0

    " Discard information about tag type groups
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{a:fidx}_{ttype} != ''
            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
            let {fidx_ttype} = ''
            let {fidx_ttype}_offset = 0
            let cnt = {fidx_ttype}_count
            let {fidx_ttype}_count = 0
            let j = 1
            while j <= cnt
                unlet! {fidx_ttype}_{j}
                let j = j + 1
            endwhile
        endif
        let i = i + 1
    endwhile

    " Discard the stored menu command also
    let s:tlist_{a:fidx}_menu_cmd = ''
endfunction

" Tlist_Window_Update_Line_Offsets
" Update the line offsets for tags for files starting from start_idx
" and displayed in the taglist window by the specified offset
function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
    let i = a:start_idx

    while i < s:tlist_file_count
        if s:tlist_{i}_visible
            " Update the start/end line number only if the file is visible
            if a:increment
                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
            else
                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
            endif
        endif
        let i = i + 1
    endwhile
endfunction

" Tlist_Discard_FileInfo
" Discard the stored information for a file
function! s:Tlist_Discard_FileInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    call s:Tlist_Discard_TagInfo(a:fidx)

    let ftype = s:tlist_{a:fidx}_filetype

    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        unlet! s:tlist_{a:fidx}_{ttype}
        unlet! s:tlist_{a:fidx}_{ttype}_offset
        unlet! s:tlist_{a:fidx}_{ttype}_count
        let i = i + 1
    endwhile

    unlet! s:tlist_{a:fidx}_filename
    unlet! s:tlist_{a:fidx}_sort_type
    unlet! s:tlist_{a:fidx}_filetype
    unlet! s:tlist_{a:fidx}_mtime
    unlet! s:tlist_{a:fidx}_start
    unlet! s:tlist_{a:fidx}_end
    unlet! s:tlist_{a:fidx}_valid
    unlet! s:tlist_{a:fidx}_visible
    unlet! s:tlist_{a:fidx}_tag_count
    unlet! s:tlist_{a:fidx}_menu_cmd
endfunction

" Tlist_Window_Remove_File_From_Display
" Remove the specified file from display
function! s:Tlist_Window_Remove_File_From_Display(fidx)
    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
                \ s:tlist_{a:fidx}_filename . ')')
    " If the file is not visible then no need to remove it
    if !s:tlist_{a:fidx}_visible
        return
    endif

    " Remove the tags displayed for the specified file from the window
    let start = s:tlist_{a:fidx}_start
    " Include the empty line after the last line also
    if g:Tlist_Compact_Format
        let end = s:tlist_{a:fidx}_end
    else
        let end = s:tlist_{a:fidx}_end + 1
    endif

    setlocal modifiable
    exe 'silent! ' . start . ',' . end . 'delete _'
    setlocal nomodifiable

    " Correct the start and end line offsets for all the files following
    " this file, as the tags for this file are removed
    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
endfunction

" Tlist_Remove_File
" Remove the file under the cursor or the specified file index
" user_request - User requested to remove the file from taglist
function! s:Tlist_Remove_File(file_idx, user_request)
    let fidx = a:file_idx

    if fidx == -1
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif
    endif
    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')

    let save_winnr = winnr()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Taglist window is open, remove the file from display

        if save_winnr != winnum
            let old_eventignore = &eventignore
            set eventignore=all
            exe winnum . 'wincmd w'
        endif

        call s:Tlist_Window_Remove_File_From_Display(fidx)

        if save_winnr != winnum
            exe save_winnr . 'wincmd w'
            let &eventignore = old_eventignore
        endif
    endif

    let fname = s:tlist_{fidx}_filename

    if a:user_request
        " As the user requested to remove the file from taglist,
        " add it to the removed list
        call s:Tlist_Update_Remove_List(fname, 1)
    endif

    " Remove the file name from the taglist list of filenames
    let idx = stridx(s:tlist_file_names, fname . "\n")
    let text_before = strpart(s:tlist_file_names, 0, idx)
    let rem_text = strpart(s:tlist_file_names, idx)
    let next_idx = stridx(rem_text, "\n")
    let text_after = strpart(rem_text, next_idx + 1)
    let s:tlist_file_names = text_before . text_after

    call s:Tlist_Discard_FileInfo(fidx)

    " Shift all the file variables by one index
    let i = fidx + 1

    while i < s:tlist_file_count
        let j = i - 1

        let s:tlist_{j}_filename = s:tlist_{i}_filename
        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
        let s:tlist_{j}_start = s:tlist_{i}_start
        let s:tlist_{j}_end = s:tlist_{i}_end
        let s:tlist_{j}_valid = s:tlist_{i}_valid
        let s:tlist_{j}_visible = s:tlist_{i}_visible
        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd

        let k = 1
        while k <= s:tlist_{j}_tag_count
            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
            let k = k + 1
        endwhile

        let ftype = s:tlist_{i}_filetype

        let k = 1
        while k <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{k}_name
            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
            if s:tlist_{j}_{ttype} != ''
                let l = 1
                while l <= s:tlist_{j}_{ttype}_count
                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
                    let l = l + 1
                endwhile
            endif
            let k = k + 1
        endwhile

        " As the file and tag information is copied to the new index,
        " discard the previous information
        call s:Tlist_Discard_FileInfo(i)

        let i = i + 1
    endwhile

    " Reduce the number of files displayed
    let s:tlist_file_count = s:tlist_file_count - 1

    if g:Tlist_Show_One_File
        " If the tags for only one file is displayed and if we just
        " now removed that file, then invalidate the current file idx
        if s:tlist_cur_file_idx == fidx
            let s:tlist_cur_file_idx = -1
        endif
    endif
endfunction

" Tlist_Window_Goto_Window
" Goto the taglist window
function! s:Tlist_Window_Goto_Window()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        if winnr() != winnum
            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
        endif
    endif
endfunction

" Tlist_Window_Create
" Create a new taglist window. If it is already open, jump to it
function! s:Tlist_Window_Create()
    call s:Tlist_Log_Msg('Tlist_Window_Create()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    " If used with winmanager don't open windows. Winmanager will handle
    " the window/buffer management
    if s:tlist_app_name == "winmanager"
        return
    endif

    " Create a new window. If user prefers a horizontal window, then open
    " a horizontally split window. Otherwise open a vertically split
    " window
    if g:Tlist_Use_Horiz_Window
        " Open a horizontally split window
        let win_dir = 'botright'
        " Horizontal window height
        let win_size = g:Tlist_WinHeight
    else
        if s:tlist_winsize_chgd == -1
            " Open a vertically split window. Increase the window size, if
            " needed, to accomodate the new window
            if g:Tlist_Inc_Winwidth &&
                        \ &columns < (80 + g:Tlist_WinWidth)
                " Save the original window position
                let s:tlist_pre_winx = getwinposx()
                let s:tlist_pre_winy = getwinposy()

                " one extra column is needed to include the vertical split
                let &columns= &columns + g:Tlist_WinWidth + 1

                let s:tlist_winsize_chgd = 1
            else
                let s:tlist_winsize_chgd = 0
            endif
        endif

        if g:Tlist_Use_Right_Window
            " Open the window at the rightmost place
            let win_dir = 'botright vertical'
        else
            " Open the window at the leftmost place
            let win_dir = 'topleft vertical'
        endif
        let win_size = g:Tlist_WinWidth
    endif

    " If the tag listing temporary buffer already exists, then reuse it.
    " Otherwise create a new buffer
    let bufnum = bufnr(g:TagList_title)
    if bufnum == -1
        " Create a new buffer
        let wcmd = g:TagList_title
    else
        " Edit the existing buffer
        let wcmd = '+buffer' . bufnum
    endif

    " Create the taglist window
    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd

    " Save the new window position
    let s:tlist_winx = getwinposx()
    let s:tlist_winy = getwinposy()

    " Initialize the taglist window
    call s:Tlist_Window_Init()
endfunction

" Tlist_Window_Zoom
" Zoom (maximize/minimize) the taglist window
function! s:Tlist_Window_Zoom()
    if s:tlist_win_maximized
        " Restore the window back to the previous size
        if g:Tlist_Use_Horiz_Window
            exe 'resize ' . g:Tlist_WinHeight
        else
            exe 'vert resize ' . g:Tlist_WinWidth
        endif
        let s:tlist_win_maximized = 0
    else
        " Set the window size to the maximum possible without closing other
        " windows
        if g:Tlist_Use_Horiz_Window
            resize
        else
            vert resize
        endif
        let s:tlist_win_maximized = 1
    endif
endfunction

" Tlist_Ballon_Expr
" When the mouse cursor is over a tag in the taglist window, display the
" tag prototype (balloon)
function! Tlist_Ballon_Expr()
    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
    if fidx == -1
        return ''
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
    if tidx == 0
        return ''
    endif

    " Get the tag search pattern and display it
    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Window_Check_Width
" Check the width of the taglist window. For horizontally split windows, the
" 'winfixheight' option is used to fix the height of the window. For
" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
" need to handle window width changes from this function.
function! s:Tlist_Window_Check_Width()
    let tlist_winnr = bufwinnr(g:TagList_title)
    if tlist_winnr == -1
        return
    endif

    let width = winwidth(tlist_winnr)
    if width != g:Tlist_WinWidth
        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
                    \ "width from " . width . " to " . g:Tlist_WinWidth)
        let save_winnr = winnr()
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
        endif
        exe 'vert resize ' . g:Tlist_WinWidth
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Window_Exit_Only_Window
" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
" taglist window is present.
function! s:Tlist_Window_Exit_Only_Window()
    " Before quitting Vim, delete the taglist buffer so that
    " the '0 mark is correctly set to the previous buffer.
    if v:version < 700
	if winbufnr(2) == -1
	    bdelete
	    quit
	endif
    else
	if winbufnr(2) == -1
	    if tabpagenr('$') == 1
		" Only one tag page is present
		bdelete
		quit
	    else
		" More than one tab page is present. Close only the current
		" tab page
		close
	    endif
	endif
    endif
endfunction

" Tlist_Window_Init
" Set the default options for the taglist window
function! s:Tlist_Window_Init()
    call s:Tlist_Log_Msg('Tlist_Window_Init()')

    " The 'readonly' option should not be set for the taglist buffer.
    " If Vim is started as "view/gview" or if the ":view" command is
    " used, then the 'readonly' option is set for all the buffers.
    " Unset it for the taglist buffer
    setlocal noreadonly

    " Set the taglist buffer filetype to taglist
    setlocal filetype=taglist

    " Define taglist window element highlighting
    syntax match TagListComment '^" .*'
    syntax match TagListFileName '^[^" ].*$'
    syntax match TagListTitle '^  \S.*$'
    syntax match TagListTagScope  '\s\[.\{-\}\]$'

    " Define the highlighting only if colors are supported
    if has('gui_running') || &t_Co > 2
        " Colors to highlight various taglist window elements
        " If user defined highlighting group exists, then use them.
        " Otherwise, use default highlight groups.
        if hlexists('MyTagListTagName')
            highlight link TagListTagName MyTagListTagName
        else
            highlight default link TagListTagName Search
        endif
        " Colors to highlight comments and titles
        if hlexists('MyTagListComment')
            highlight link TagListComment MyTagListComment
        else
            highlight clear TagListComment
            highlight default link TagListComment Comment
        endif
        if hlexists('MyTagListTitle')
            highlight link TagListTitle MyTagListTitle
        else
            highlight clear TagListTitle
            highlight default link TagListTitle Title
        endif
        if hlexists('MyTagListFileName')
            highlight link TagListFileName MyTagListFileName
        else
            highlight clear TagListFileName
            highlight default TagListFileName guibg=Grey ctermbg=darkgray
                        \ guifg=white ctermfg=white
        endif
        if hlexists('MyTagListTagScope')
            highlight link TagListTagScope MyTagListTagScope
        else
            highlight clear TagListTagScope
            highlight default link TagListTagScope Identifier
        endif
    else
        highlight default TagListTagName term=reverse cterm=reverse
    endif

    " Folding related settings
    setlocal foldenable
    setlocal foldminlines=0
    setlocal foldmethod=manual
    setlocal foldlevel=9999
    if g:Tlist_Enable_Fold_Column
        setlocal foldcolumn=3
    else
        setlocal foldcolumn=0
    endif
    setlocal foldtext=v:folddashes.getline(v:foldstart)

    if s:tlist_app_name != "winmanager"
        " Mark buffer as scratch
        silent! setlocal buftype=nofile
        if s:tlist_app_name == "none"
            silent! setlocal bufhidden=delete
        endif
        silent! setlocal noswapfile
        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
        " buffers. So if the taglist buffer is unlisted, multiple taglist
        " windows will be opened. This bug is fixed in Vim 6.1 and above
        if v:version >= 601
            silent! setlocal nobuflisted
        endif
    endif

    silent! setlocal nowrap

    " If the 'number' option is set in the source window, it will affect the
    " taglist window. So forcefully disable 'number' option for the taglist
    " window
    silent! setlocal nonumber

    " Use fixed height when horizontally split window is used
    if g:Tlist_Use_Horiz_Window
        if v:version >= 602
            set winfixheight
        endif
    endif
    if !g:Tlist_Use_Horiz_Window && v:version >= 700
        set winfixwidth
    endif

    " Setup balloon evaluation to display tag prototype
    if v:version >= 700 && has('balloon_eval')
        setlocal balloonexpr=Tlist_Ballon_Expr()
        set ballooneval
    endif

    " Setup the cpoptions properly for the maps to work
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    " Create buffer local mappings for jumping to the tags and sorting the list
    nnoremap <buffer> <silent> <CR>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> o
                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    nnoremap <buffer> <silent> p
                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    nnoremap <buffer> <silent> P
                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    nnoremap <buffer> <silent> t
                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    nnoremap <buffer> <silent> <C-t>
                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    nnoremap <buffer> <silent> <2-LeftMouse>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> s
                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    nnoremap <buffer> <silent> + :silent! foldopen<CR>
    nnoremap <buffer> <silent> - :silent! foldclose<CR>
    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    nnoremap <buffer> <silent> q :close<CR>

    " Insert mode mappings
    inoremap <buffer> <silent> <CR>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    " Windows needs return
    inoremap <buffer> <silent> <Return>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> o
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    inoremap <buffer> <silent> p
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    inoremap <buffer> <silent> P
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    inoremap <buffer> <silent> t
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    inoremap <buffer> <silent> <C-t>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    inoremap <buffer> <silent> <2-LeftMouse>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> s
                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> <Space>       <C-o>:call
                                    \ <SID>Tlist_Window_Show_Info()<CR>
    inoremap <buffer> <silent> u
                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    inoremap <buffer> <silent> q    <C-o>:close<CR>

    " Map single left mouse click if the user wants this functionality
    if g:Tlist_Use_SingleClick == 1
        " Contributed by Bindu Wavell
        " attempt to perform single click mapping, it would be much
        " nicer if we could nnoremap <buffer> ... however vim does
        " not fire the <buffer> <leftmouse> when you use the mouse
        " to enter a buffer.
        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
                    \ '<bar> endif <CR>'
        if maparg('<leftmouse>', 'n') == ''
            " no mapping for leftmouse
            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
        else
            " we have a mapping
            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
            let mapcmd = mapcmd . substitute(substitute(
                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
                        \ '\c^<leftmouse>', '', '')
            let mapcmd = mapcmd . clickmap
            exe mapcmd
        endif
    endif

    " Define the taglist autocommands
    augroup TagListAutoCmds
        autocmd!
        " Display the tag prototype for the tag under the cursor.
        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
        " Highlight the current tag periodically
        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)

        " Adjust the Vim window width when taglist window is closed
        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
        " Close the fold for this buffer when leaving the buffer
        if g:Tlist_File_Fold_Auto_Close
            autocmd BufEnter * silent
                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
        endif
        " Exit Vim itself if only the taglist window is present (optional)
        if g:Tlist_Exit_OnlyWindow
	    autocmd BufEnter __Tag_List__ nested
			\ call s:Tlist_Window_Exit_Only_Window()
        endif
        if s:tlist_app_name != "winmanager" &&
                    \ !g:Tlist_Process_File_Always &&
                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
            " Auto refresh the taglist window
            autocmd BufEnter * call s:Tlist_Refresh()
        endif

        if !g:Tlist_Use_Horiz_Window
            if v:version < 700
                autocmd WinEnter * call s:Tlist_Window_Check_Width()
            endif
        endif
        if v:version >= 700
            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
        endif
    augroup end

    " Restore the previous cpoptions settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Window_Refresh
" Display the tags for all the files in the taglist window
function! s:Tlist_Window_Refresh()
    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Mark the buffer as modifiable
    setlocal modifiable

    " Delete the contents of the buffer to the black-hole register
    silent! %delete _

    " As we have cleared the taglist window, mark all the files
    " as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    if g:Tlist_Compact_Format == 0
        " Display help in non-compact mode
        call s:Tlist_Window_Display_Help()
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " If the tags for only one file should be displayed in the taglist
    " window, then no need to add the tags here. The bufenter autocommand
    " will add the tags for that file.
    if g:Tlist_Show_One_File
        return
    endif

    " List all the tags for the previously processed files
    " Do this only if taglist is configured to display tags for more than
    " one file. Otherwise, when Tlist_Show_One_File is configured,
    " tags for the wrong file will be displayed.
    let i = 0
    while i < s:tlist_file_count
        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
                    \ s:tlist_{i}_filetype)
        let i = i + 1
    endwhile

    if g:Tlist_Auto_Update
        " Add and list the tags for all buffers in the Vim buffer list
        let i = 1
        let last_bufnum = bufnr('$')
        while i <= last_bufnum
            if buflisted(i)
                let fname = fnamemodify(bufname(i), ':p')
                let ftype = s:Tlist_Get_Buffer_Filetype(i)
                " If the file doesn't support tag listing, skip it
                if !s:Tlist_Skip_File(fname, ftype)
                    call s:Tlist_Window_Refresh_File(fname, ftype)
                endif
            endif
            let i = i + 1
        endwhile
    endif

    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
    if g:Tlist_File_Fold_Auto_Close
        " Close all the folds
        silent! %foldclose
    endif

    " Move the cursor to the top of the taglist window
    normal! gg
endfunction

" Tlist_Post_Close_Cleanup()
" Close the taglist window and adjust the Vim window width
function! s:Tlist_Post_Close_Cleanup()
    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
    " Mark all the files as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    " Remove the taglist autocommands
    silent! autocmd! TagListAutoCmds

    " Clear all the highlights
    match none

    silent! syntax clear TagListTitle
    silent! syntax clear TagListComment
    silent! syntax clear TagListTagScope

    " Remove the left mouse click mapping if it was setup initially
    if g:Tlist_Use_SingleClick
        if hasmapto('<LeftMouse>')
            nunmap <LeftMouse>
        endif
    endif

    if s:tlist_app_name != "winmanager"
    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
                \ s:tlist_winsize_chgd != 1 ||
                \ &columns < (80 + g:Tlist_WinWidth)
        " No need to adjust window width if using horizontally split taglist
        " window or if columns is less than 101 or if the user chose not to
        " adjust the window width
    else
        " If the user didn't manually move the window, then restore the window
        " position to the pre-taglist position
        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
                    \ getwinposx() == s:tlist_winx &&
                    \ getwinposy() == s:tlist_winy
            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
        endif

        " Adjust the Vim window width
        let &columns= &columns - (g:Tlist_WinWidth + 1)
    endif
    endif

    let s:tlist_winsize_chgd = -1

    " Reset taglist state variables
    if s:tlist_app_name == "winmanager"
        let s:tlist_app_name = "none"
    endif
    let s:tlist_window_initialized = 0
endfunction

" Tlist_Window_Refresh_File()
" List the tags defined in the specified file in a Vim window
function! s:Tlist_Window_Refresh_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx != -1
        let file_listed = 1
    else
        let file_listed = 0
    endif

    if !file_listed
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(a:filename)
            return
        endif
    endif

    if file_listed && s:tlist_{fidx}_visible
        " Check whether the file tags are currently valid
        if s:tlist_{fidx}_valid
            " Goto the first line in the file
            exe s:tlist_{fidx}_start

            " If the line is inside a fold, open the fold
            if foldclosed('.') != -1
                exe "silent! " . s:tlist_{fidx}_start . "," .
                            \ s:tlist_{fidx}_end . "foldopen!"
            endif
            return
        endif

        " Discard and remove the tags for this file from display
        call s:Tlist_Discard_TagInfo(fidx)
        call s:Tlist_Window_Remove_File_From_Display(fidx)
    endif

    " Process and generate a list of tags defined in the file
    if !file_listed || !s:tlist_{fidx}_valid
        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
        if ret_fidx == -1
            return
        endif
        let fidx = ret_fidx
    endif

    " Set report option to a huge value to prevent informational messages
    " while adding lines to the taglist window
    let old_report = &report
    set report=99999

    if g:Tlist_Show_One_File
        " Remove the previous file
        if s:tlist_cur_file_idx != -1
            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
            let s:tlist_{s:tlist_cur_file_idx}_start = 0
            let s:tlist_{s:tlist_cur_file_idx}_end = 0
        endif
        let s:tlist_cur_file_idx = fidx
    endif

    " Mark the buffer as modifiable
    setlocal modifiable

    " Add new files to the end of the window. For existing files, add them at
    " the same line where they were previously present. If the file is not
    " visible, then add it at the end
    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
        if g:Tlist_Compact_Format
            let s:tlist_{fidx}_start = line('$')
        else
            let s:tlist_{fidx}_start = line('$') + 1
        endif
    endif

    let s:tlist_{fidx}_visible = 1

    " Goto the line where this file should be placed
    if g:Tlist_Compact_Format
        exe s:tlist_{fidx}_start
    else
        exe s:tlist_{fidx}_start - 1
    endif

    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
    if g:Tlist_Compact_Format == 0
        silent! put =txt
    else
        silent! put! =txt
        " Move to the next line
        exe line('.') + 1
    endif
    let file_start = s:tlist_{fidx}_start

    " Add the tag names grouped by tag type to the buffer with a title
    let i = 1
    let ttype_cnt = s:tlist_{a:ftype}_count
    while i <= ttype_cnt
        let ttype = s:tlist_{a:ftype}_{i}_name
        " Add the tag type only if there are tags for that type
        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
        let ttype_txt = {fidx_ttype}
        if ttype_txt != ''
            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
            if g:Tlist_Compact_Format == 0
                let ttype_start_lnum = line('.') + 1
                silent! put =txt
            else
                let ttype_start_lnum = line('.')
                silent! put! =txt
            endif
            silent! put =ttype_txt

            let {fidx_ttype}_offset = ttype_start_lnum - file_start

            " create a fold for this tag type
            let fold_start = ttype_start_lnum
            let fold_end = fold_start + {fidx_ttype}_count
            exe fold_start . ',' . fold_end  . 'fold'

            " Adjust the cursor position
            if g:Tlist_Compact_Format == 0
                exe ttype_start_lnum + {fidx_ttype}_count
            else
                exe ttype_start_lnum + {fidx_ttype}_count + 1
            endif

            if g:Tlist_Compact_Format == 0
                " Separate the tag types by a empty line
                silent! put =''
            endif
        endif
        let i = i + 1
    endwhile

    if s:tlist_{fidx}_tag_count == 0
        if g:Tlist_Compact_Format == 0
            silent! put =''
        endif
    endif

    let s:tlist_{fidx}_end = line('.') - 1

    " Create a fold for the entire file
    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                \ s:tlist_{fidx}_end . 'foldopen!'

    " Goto the starting line for this file,
    exe s:tlist_{fidx}_start

    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " Update the start and end line numbers for all the files following this
    " file
    let start = s:tlist_{fidx}_start
    " include the empty line after the last line
    if g:Tlist_Compact_Format
        let end = s:tlist_{fidx}_end
    else
        let end = s:tlist_{fidx}_end + 1
    endif
    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)

    " Now that we have updated the taglist window, update the tags
    " menu (if present)
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Init_File
" Initialize the variables for a new file
function! s:Tlist_Init_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
    " Add new files at the end of the list
    let fidx = s:tlist_file_count
    let s:tlist_file_count = s:tlist_file_count + 1
    " Add the new file name to the taglist list of file names
    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"

    " Initialize the file variables
    let s:tlist_{fidx}_filename = a:filename
    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
    let s:tlist_{fidx}_filetype = a:ftype
    let s:tlist_{fidx}_mtime = -1
    let s:tlist_{fidx}_start = 0
    let s:tlist_{fidx}_end = 0
    let s:tlist_{fidx}_valid = 0
    let s:tlist_{fidx}_visible = 0
    let s:tlist_{fidx}_tag_count = 0
    let s:tlist_{fidx}_menu_cmd = ''

    " Initialize the tag type variables
    let i = 1
    while i <= s:tlist_{a:ftype}_count
        let ttype = s:tlist_{a:ftype}_{i}_name
        let s:tlist_{fidx}_{ttype} = ''
        let s:tlist_{fidx}_{ttype}_offset = 0
        let s:tlist_{fidx}_{ttype}_count = 0
        let i = i + 1
    endwhile

    return fidx
endfunction

" Tlist_Get_Tag_Type_By_Tag
" Return the tag type for the specified tag index
function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'

    " Already parsed and have the tag name
    if exists(ttype_var)
        return {ttype_var}
    endif

    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)

    return {ttype_var}
endfunction

" Tlist_Get_Tag_Prototype
function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'

    " Already parsed and have the tag prototype
    if exists(tproto_var)
        return {tproto_var}
    endif

    " Parse and extract the tag prototype
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let tag_proto = strpart(tag_line, start, end - start)
    let {tproto_var} = substitute(tag_proto, '\s*', '', '')

    return {tproto_var}
endfunction

" Tlist_Get_Tag_SearchPat
function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'

    " Already parsed and have the tag search pattern
    if exists(tpat_var)
        return {tpat_var}
    endif

    " Parse and extract the tag search pattern
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
                        \ (tag_line[end] == '$' ? '\$' : '')

    return {tpat_var}
endfunction

" Tlist_Get_Tag_Linenum
" Return the tag line number, given the tag index
function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'

    " Already parsed and have the tag line number
    if exists(tline_var)
        return {tline_var}
    endif

    " Parse and extract the tag line number
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = strridx(tag_line, 'line:') + 5
    let end = strridx(tag_line, "\t")
    if end < start
        let {tline_var} = strpart(tag_line, start) + 0
    else
        let {tline_var} = strpart(tag_line, start, end - start) + 0
    endif

    return {tline_var}
endfunction

" Tlist_Parse_Tagline
" Parse a tag line from the ctags output. Separate the tag output based on the
" tag type and store it in the tag type variable.
" The format of each line in the ctags output is:
"
"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
"
function! s:Tlist_Parse_Tagline(tag_line)
    if a:tag_line == ''
        " Skip empty lines
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)

    " Make sure the tag type is a valid and supported one
    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
        " Line is not in proper tags format or Tag type is not supported
        return
    endif

    " Update the total tag count
    let s:tidx = s:tidx + 1

    " The following variables are used to optimize this code.  Vim is slow in
    " using curly brace names. To reduce the amount of processing needed, the
    " curly brace variables are pre-processed here
    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype

    " Update the count of this tag type
    let ttype_idx = {fidx_ttype}_count + 1
    let {fidx_ttype}_count = ttype_idx

    " Store the ctags output for this tag
    let {fidx_tidx}_tag = a:tag_line

    " Store the tag index and the tag type index (back pointers)
    let {fidx_ttype}_{ttype_idx} = s:tidx
    let {fidx_tidx}_ttype_idx = ttype_idx

    " Extract the tag name
    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))

    " Extract the tag scope/prototype
    if g:Tlist_Display_Prototype
        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
    else
        let ttxt = '    ' . tag_name

        " Add the tag scope, if it is available and is configured. Tag
        " scope is the last field after the 'line:<num>\t' field
        if g:Tlist_Display_Tag_Scope
            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
            if tag_scope != ''
                let ttxt = ttxt . ' [' . tag_scope . ']'
            endif
        endif
    endif

    " Add this tag to the tag type variable
    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

    " Save the tag name
    let {fidx_tidx}_tag_name = tag_name
endfunction

" Tlist_Process_File
" Get the list of tags defined in the specified file and store them
" in Vim variables. Returns the file index where the tags are stored.
function! s:Tlist_Process_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
                \ a:ftype . ')')
    " Check whether this file is supported
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return -1
    endif

    " If the tag types for this filetype are not yet created, then create
    " them now
    let var = 's:tlist_' . a:ftype . '_count'
    if !exists(var)
        if s:Tlist_FileType_Init(a:ftype) == 0
            return -1
        endif
    endif

    " If this file is already processed, then use the cached values
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " First time, this file is loaded
        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
    else
        " File was previously processed. Discard the tag information
        call s:Tlist_Discard_TagInfo(fidx)
    endif

    let s:tlist_{fidx}_valid = 1

    " Exuberant ctags arguments to generate a tag list
    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '

    " Form the ctags argument depending on the sort type
    if s:tlist_{fidx}_sort_type == 'name'
        let ctags_args = ctags_args . '--sort=yes'
    else
        let ctags_args = ctags_args . '--sort=no'
    endif

    " Add the filetype specific arguments
    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args

    " Ctags command to produce output with regexp for locating the tags
    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'

    if &shellxquote == '"'
        " Double-quotes within double-quotes will not work in the
        " command-line.If the 'shellxquote' option is set to double-quotes,
        " then escape the double-quotes in the ctags command-line.
        let ctags_cmd = escape(ctags_cmd, '"')
    endif

    " In Windows 95, if not using cygwin, disable the 'shellslash'
    " option. Otherwise, this will cause problems when running the
    " ctags command.
    if has('win95') && !has('win32unix')
        let old_shellslash = &shellslash
        set noshellslash
    endif

    if has('win32') && !has('win32unix') && !has('win95')
                \ && (&shell =~ 'cmd.exe')
        " Windows does not correctly deal with commands that have more than 1
        " set of double quotes.  It will strip them all resulting in:
        " 'C:\Program' is not recognized as an internal or external command
        " operable program or batch file.  To work around this, place the
        " command inside a batch file and call the batch file.
        " Do this only on Win2K, WinXP and above.
        " Contributed by: David Fishburn.
        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
                    \ '\taglist.cmd'
        exe 'redir! > ' . s:taglist_tempfile
        silent echo ctags_cmd
        redir END

        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
        let ctags_cmd = '"' . s:taglist_tempfile . '"'
    endif

    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)

    " Run ctags and get the tag list
    let cmd_output = system(ctags_cmd)

    " Restore the value of the 'shellslash' option.
    if has('win95') && !has('win32unix')
        let &shellslash = old_shellslash
    endif

    if exists('s:taglist_tempfile')
        " Delete the temporary cmd file created on MS-Windows
        call delete(s:taglist_tempfile)
    endif

    " Handle errors
    if v:shell_error
        let msg = "Taglist: Failed to generate tags for " . a:filename
        call s:Tlist_Warning_Msg(msg)
        if cmd_output != ''
            call s:Tlist_Warning_Msg(cmd_output)
        endif
        return fidx
    endif

    " Store the modification time for the file
    let s:tlist_{fidx}_mtime = getftime(a:filename)

    " No tags for current file
    if cmd_output == ''
        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
        return fidx
    endif

    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)

    if v:version > 601
        " The following script local variables are used by the
        " Tlist_Parse_Tagline() function.
        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let s:fidx = fidx
        let s:tidx = 0

        " Process the ctags output one line at a time.  The substitute()
        " command is used to parse the tag lines instead of using the
        " matchstr()/stridx()/strpart() functions for performance reason
        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = s:tidx

        " The following script local variables are no longer needed
        unlet! s:ctags_flags
        unlet! s:tidx
        unlet! s:fidx
    else
        " Due to a bug in Vim earlier than version 6.1,
        " we cannot use substitute() to parse the ctags output.
        " Instead the slow str*() functions are used
        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let tidx = 0

        while cmd_output != ''
            " Extract one line at a time
            let idx = stridx(cmd_output, "\n")
            let one_line = strpart(cmd_output, 0, idx)
            " Remove the line from the tags output
            let cmd_output = strpart(cmd_output, idx + 1)

            if one_line == ''
                " Line is not in proper tags format
                continue
            endif

            " Extract the tag type
            let ttype = s:Tlist_Extract_Tagtype(one_line)

            " Make sure the tag type is a valid and supported one
            if ttype == '' || stridx(ctags_flags, ttype) == -1
                " Line is not in proper tags format or Tag type is not
                " supported
                continue
            endif

            " Update the total tag count
            let tidx = tidx + 1

            " The following variables are used to optimize this code.  Vim is
            " slow in using curly brace names. To reduce the amount of
            " processing needed, the curly brace variables are pre-processed
            " here
            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype

            " Update the count of this tag type
            let ttype_idx = {fidx_ttype}_count + 1
            let {fidx_ttype}_count = ttype_idx

            " Store the ctags output for this tag
            let {fidx_tidx}_tag = one_line

            " Store the tag index and the tag type index (back pointers)
            let {fidx_ttype}_{ttype_idx} = tidx
            let {fidx_tidx}_ttype_idx = ttype_idx

            " Extract the tag name
            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))

            " Extract the tag scope/prototype
            if g:Tlist_Display_Prototype
                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
            else
                let ttxt = '    ' . tag_name

                " Add the tag scope, if it is available and is configured. Tag
                " scope is the last field after the 'line:<num>\t' field
                if g:Tlist_Display_Tag_Scope
                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
                    if tag_scope != ''
                        let ttxt = ttxt . ' [' . tag_scope . ']'
                    endif
                endif
            endif

            " Add this tag to the tag type variable
            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

            " Save the tag name
            let {fidx_tidx}_tag_name = tag_name
        endwhile

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = tidx
    endif

    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
                \ ' tags in ' . a:filename)

    return fidx
endfunction

" Tlist_Update_File
" Update the tags for a file (if needed)
function! Tlist_Update_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return
    endif

    " Convert the file name to a full path
    let fname = fnamemodify(a:filename, ':p')

    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(fname)

    if fidx != -1 && s:tlist_{fidx}_valid
        " File exists and the tags are valid
        " Check whether the file was modified after the last tags update
        " If it is modified, then update the tags
        if s:tlist_{fidx}_mtime == getftime(fname)
            return
        endif
    else
        " If the tags were removed previously based on a user request,
        " as we are going to update the tags (based on the user request),
        " remove the filename from the deleted list
        call s:Tlist_Update_Remove_List(fname, 0)
    endif

    " If the taglist window is opened, update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        " Taglist window is not present. Just update the taglist
        " and return
        call s:Tlist_Process_File(fname, a:ftype)
    else
        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
            " If tags for only one file are displayed and we are not
            " updating the tags for that file, then no need to
            " refresh the taglist window. Otherwise, the taglist
            " window should be updated.
            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
                call s:Tlist_Process_File(fname, a:ftype)
                return
            endif
        endif

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Save the cursor position
        let save_line = line('.')
        let save_col = col('.')

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(fname, a:ftype)

        " Restore the cursor position
        if v:version >= 601
            call cursor(save_line, save_col)
        else
            exe save_line
            exe 'normal! ' . save_col . '|'
        endif

        if winnr() != save_winnr
            " Go back to the original window
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Window_Close
" Close the taglist window
function! s:Tlist_Window_Close()
    call s:Tlist_Log_Msg('Tlist_Window_Close()')
    " Make sure the taglist window exists
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    if winnr() == winnum
        " Already in the taglist window. Close it and return
        if winbufnr(2) != -1
            " If a window other than the taglist window is open,
            " then only close the taglist window.
            close
        endif
    else
        " Goto the taglist window, close it and then come back to the
        " original window
        let curbufnr = bufnr('%')
        exe winnum . 'wincmd w'
        close
        " Need to jump back to the original window only if we are not
        " already in that window
        let winnum = bufwinnr(curbufnr)
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
    endif
endfunction

" Tlist_Window_Mark_File_Window
" Mark the current window as the file window to use when jumping to a tag.
" Only if the current window is a non-plugin, non-preview and non-taglist
" window
function! s:Tlist_Window_Mark_File_Window()
    if getbufvar('%', '&buftype') == '' && !&previewwindow
        let w:tlist_file_window = "yes"
    endif
endfunction

" Tlist_Window_Open
" Open and refresh the taglist window
function! s:Tlist_Window_Open()
    call s:Tlist_Log_Msg('Tlist_Window_Open()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    if s:tlist_app_name == "winmanager"
        " Taglist plugin is no longer part of the winmanager app
        let s:tlist_app_name = "none"
    endif

    " Get the filename and filetype for the specified buffer
    let curbuf_name = fnamemodify(bufname('%'), ':p')
    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
    let cur_lnum = line('.')

    " Mark the current window as the desired window to open a file when a tag
    " is selected.
    call s:Tlist_Window_Mark_File_Window()

    " Open the taglist window
    call s:Tlist_Window_Create()

    call s:Tlist_Window_Refresh()

    if g:Tlist_Show_One_File
        " Add only the current buffer and file
        "
        " If the file doesn't support tag listing, skip it
        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
        endif
    endif

    if g:Tlist_File_Fold_Auto_Close
        " Open the fold for the current file, as all the folds in
        " the taglist window are closed
        let fidx = s:Tlist_Get_File_Index(curbuf_name)
        if fidx != -1
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen!"
        endif
    endif

    " Highlight the current tag
    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
endfunction

" Tlist_Window_Toggle()
" Open or close a taglist window
function! s:Tlist_Window_Toggle()
    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
    " If taglist window is open then close it.
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        call s:Tlist_Window_Close()
        return
    endif

    call s:Tlist_Window_Open()

    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
    " set
    if !g:Tlist_GainFocus_On_ToggleOpen
        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Process_Filelist
" Process multiple files. Each filename is separated by "\n"
" Returns the number of processed files
function! s:Tlist_Process_Filelist(file_names)
    let flist = a:file_names

    " Enable lazy screen updates
    let old_lazyredraw = &lazyredraw
    set lazyredraw

    " Keep track of the number of processed files
    let fcnt = 0

    " Process one file at a time
    while flist != ''
        let nl_idx = stridx(flist, "\n")
        let one_file = strpart(flist, 0, nl_idx)

        " Remove the filename from the list
        let flist = strpart(flist, nl_idx + 1)

        if one_file == ''
            continue
        endif

        " Skip directories
        if isdirectory(one_file)
            continue
        endif

        let ftype = s:Tlist_Detect_Filetype(one_file)

        echon "\r                                                              "
        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')

        let fcnt = fcnt + 1

        call Tlist_Update_File(one_file, ftype)
    endwhile

    " Clear the displayed informational messages
    echon "\r                                                            "

    " Restore the previous state
    let &lazyredraw = old_lazyredraw

    return fcnt
endfunction

" Tlist_Process_Dir
" Process the files in a directory matching the specified pattern
function! s:Tlist_Process_Dir(dir_name, pat)
    let flist = glob(a:dir_name . '/' . a:pat) . "\n"

    let fcnt = s:Tlist_Process_Filelist(flist)

    let len = strlen(a:dir_name)
    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
        let glob_expr = a:dir_name . '*'
    else
        let glob_expr = a:dir_name . '/*'
    endif
    let all_files = glob(glob_expr) . "\n"

    while all_files != ''
        let nl_idx = stridx(all_files, "\n")
        let one_file = strpart(all_files, 0, nl_idx)

        let all_files = strpart(all_files, nl_idx + 1)
        if one_file == ''
            continue
        endif

        " Skip non-directory names
        if !isdirectory(one_file)
            continue
        endif

        echon "\r                                                              "
        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
    endwhile

    return fcnt
endfunction

" Tlist_Add_Files_Recursive
" Add files recursively from a directory
function! s:Tlist_Add_Files_Recursive(dir, ...)
    let dir_name = fnamemodify(a:dir, ':p')
    if !isdirectory(dir_name)
        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
        return
    endif

    if a:0 == 1
        " User specified file pattern
        let pat = a:1
    else
        " Default file pattern
        let pat = '*'
    endif

    echon "\r                                                              "
    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
    let fcnt = s:Tlist_Process_Dir(dir_name, pat)

    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Add_Files
" Add the specified list of files to the taglist
function! s:Tlist_Add_Files(...)
    let flist = ''
    let i = 1

    " Get all the files matching the file patterns supplied as argument
    while i <= a:0
        let flist = flist . glob(a:{i}) . "\n"
        let i = i + 1
    endwhile

    if flist == ''
        call s:Tlist_Warning_Msg('Error: No matching files are found')
        return
    endif

    let fcnt = s:Tlist_Process_Filelist(flist)
    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Extract_Tagtype
" Extract the tag type from the tag text
function! s:Tlist_Extract_Tagtype(tag_line)
    " The tag type is after the tag prototype field. The prototype field
    " ends with the /;"\t string. We add 4 at the end to skip the characters
    " in this special string..
    let start = strridx(a:tag_line, '/;"' . "\t") + 4
    let end = strridx(a:tag_line, 'line:') - 1
    let ttype = strpart(a:tag_line, start, end - start)

    return ttype
endfunction

" Tlist_Extract_Tag_Scope
" Extract the tag scope from the tag text
function! s:Tlist_Extract_Tag_Scope(tag_line)
    let start = strridx(a:tag_line, 'line:')
    let end = strridx(a:tag_line, "\t")
    if end <= start
        return ''
    endif

    let tag_scope = strpart(a:tag_line, end + 1)
    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)

    return tag_scope
endfunction

" Tlist_Refresh()
" Refresh the taglist
function! s:Tlist_Refresh()
    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
    " If we are entering the buffer from one of the taglist functions, then
    " no need to refresh the taglist window again.
    if s:Tlist_Skip_Refresh
        " We still need to update the taglist menu
        if g:Tlist_Show_Menu
            call s:Tlist_Menu_Update_File(0)
        endif
        return
    endif

    " If part of the winmanager plugin and not configured to process
    " tags always and not configured to display the tags menu, then return
    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
                \ && !g:Tlist_Show_Menu
        return
    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let tlist_win = bufwinnr(g:TagList_title)

    " If the taglist window is not opened and not configured to process
    " tags always and not displaying the tags menu, then return
    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " If the taglist should not be auto updated, then return
        if !g:Tlist_Auto_Update
            return
        endif
    endif

    let cur_lnum = line('.')

    if fidx == -1
        " Update the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
    else
        let mtime = getftime(filename)
        if s:tlist_{fidx}_mtime != mtime
            " Invalidate the tags listed for this file
            let s:tlist_{fidx}_valid = 0

            " Update the taglist and the window
            call Tlist_Update_File(filename, ftype)

            " Store the new file modification time
            let s:tlist_{fidx}_mtime = mtime
        endif
    endif

    " Update the taglist window
    if tlist_win != -1
        " Disable screen updates
        let old_lazyredraw = &lazyredraw
        set nolazyredraw

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
            " Save the cursor position
            let save_line = line('.')
            let save_col = col('.')
        endif

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(filename, ftype)

        " Open the fold for the file
        exe "silent! " . s:tlist_{fidx}_start . "," .
                    \ s:tlist_{fidx}_end . "foldopen!"

        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
                " If displaying tags for only one file in the taglist
                " window and about to display the tags for a new file,
                " then center the current tag line for the new file
                let center_tag_line = 1
            else
                let center_tag_line = 0
            endif

            " Highlight the current tag
            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
        else
            " Restore the cursor position
            if v:version >= 601
                call cursor(save_line, save_col)
            else
                exe save_line
                exe 'normal! ' . save_col . '|'
            endif
        endif

        " Jump back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif

        " Restore screen updates
        let &lazyredraw = old_lazyredraw
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Change_Sort()
" Change the sort order of the tag listing
" caller == 'cmd', command used in the taglist window
" caller == 'menu', taglist menu
" action == 'toggle', toggle sort from name to order and vice versa
" action == 'set', set the sort order to sort_type
function! s:Tlist_Change_Sort(caller, action, sort_type)
    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
    if a:caller == 'cmd'
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif

        " Remove the previous highlighting
        match none
    elseif a:caller == 'menu'
        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
        if fidx == -1
            return
        endif
    endif

    if a:action == 'toggle'
        let sort_type = s:tlist_{fidx}_sort_type

        " Toggle the sort order from 'name' to 'order' and vice versa
        if sort_type == 'name'
            let s:tlist_{fidx}_sort_type = 'order'
        else
            let s:tlist_{fidx}_sort_type = 'name'
        endif
    else
        let s:tlist_{fidx}_sort_type = a:sort_type
    endif

    " Invalidate the tags listed for this file
    let s:tlist_{fidx}_valid = 0

    if a:caller  == 'cmd'
        " Save the current line for later restoration
        let curline = '\V\^' . getline('.') . '\$'

        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                    \   s:tlist_{fidx}_filetype)

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

        " Go back to the cursor line before the tag list is sorted
        call search(curline, 'w')

        call s:Tlist_Menu_Update_File(1)
    else
        call s:Tlist_Menu_Remove_File()

        call s:Tlist_Refresh()
    endif
endfunction

" Tlist_Update_Current_File()
" Update taglist for the current buffer by regenerating the tag list
" Contributed by WEN Guopeng.
function! s:Tlist_Update_Current_File()
    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
    if winnr() == bufwinnr(g:TagList_title)
        " In the taglist window. Update the current file
        call s:Tlist_Window_Update_File()
    else
        " Not in the taglist window. Update the current buffer
        let filename = fnamemodify(bufname('%'), ':p')
        let fidx = s:Tlist_Get_File_Index(filename)
        if fidx != -1
            let s:tlist_{fidx}_valid = 0
        endif
        let ft = s:Tlist_Get_Buffer_Filetype('%')
        call Tlist_Update_File(filename, ft)
    endif
endfunction

" Tlist_Window_Update_File()
" Update the tags displayed in the taglist window
function! s:Tlist_Window_Update_File()
    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    " Remove the previous highlighting
    match none

    " Save the current line for later restoration
    let curline = '\V\^' . getline('.') . '\$'

    let s:tlist_{fidx}_valid = 0

    " Update the taglist window
    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                \ s:tlist_{fidx}_filetype)

    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

    " Go back to the tag line before the list is updated
    call search(curline, 'w')
endfunction

" Tlist_Window_Get_Tag_Type_By_Linenum()
" Return the tag type index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
    let ftype = s:tlist_{a:fidx}_filetype

    " Determine to which tag type the current line number belongs to using the
    " tag type start line number and the number of tags in a tag type
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        let start_lnum =
                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
        if a:lnum >= start_lnum && a:lnum <= end
            break
        endif
        let i = i + 1
    endwhile

    " Current line doesn't belong to any of the displayed tag types
    if i > s:tlist_{ftype}_count
        return ''
    endif

    return ttype
endfunction

" Tlist_Window_Get_Tag_Index()
" Return the tag index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)

    " Current line doesn't belong to any of the displayed tag types
    if ttype == ''
        return 0
    endif

    " Compute the index into the displayed tags for the tag type
    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
    let tidx = a:lnum - ttype_lnum
    if tidx == 0
        return 0
    endif

    " Get the corresponding tag line and return it
    return s:tlist_{a:fidx}_{ttype}_{tidx}
endfunction

" Tlist_Window_Highlight_Line
" Highlight the current line
function! s:Tlist_Window_Highlight_Line()
    " Clear previously selected name
    match none

    " Highlight the current line
    if g:Tlist_Display_Prototype == 0
        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
    else
        let pat = '/\%' . line('.') . 'l.*/'
    endif

    exe 'match TagListTagName ' . pat
endfunction

" Tlist_Window_Open_File
" Open the specified file in either a new window or an existing window
" and place the cursor at the specified tag pattern
function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
                \ a:win_ctrl . ')')
    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
    let s:Tlist_Skip_Refresh = 1

    if s:tlist_app_name == "winmanager"
        " Let the winmanager edit the file
        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
    else

    if a:win_ctrl == 'newtab'
        " Create a new tab
        exe 'tabnew ' . escape(a:filename, ' ')
        " Open the taglist window in the new tab
        call s:Tlist_Window_Open()
    endif

    if a:win_ctrl == 'checktab'
        " Check whether the file is present in any of the tabs.
        " If the file is present in the current tab, then use the
        " current tab.
        if bufwinnr(a:filename) != -1
            let file_present_in_tab = 1
            let i = tabpagenr()
        else
            let i = 1
            let bnum = bufnr(a:filename)
            let file_present_in_tab = 0
            while i <= tabpagenr('$')
                if index(tabpagebuflist(i), bnum) != -1
                    let file_present_in_tab = 1
                    break
                endif
                let i += 1
            endwhile
        endif

        if file_present_in_tab
            " Goto the tab containing the file
            exe 'tabnext ' . i
        else
            " Open a new tab
            exe 'tabnew ' . escape(a:filename, ' ')

            " Open the taglist window
            call s:Tlist_Window_Open()
        endif
    endif

    let winnum = -1
    if a:win_ctrl == 'prevwin'
        " Open the file in the previous window, if it is usable
        let cur_win = winnr()
        wincmd p
        if &buftype == '' && !&previewwindow
            exe "edit " . escape(a:filename, ' ')
            let winnum = winnr()
        else
            " Previous window is not usable
            exe cur_win . 'wincmd w'
        endif
    endif

    " Goto the window containing the file.  If the window is not there, open a
    " new window
    if winnum == -1
        let winnum = bufwinnr(a:filename)
    endif

    if winnum == -1
        " Locate the previously used window for opening a file
        let fwin_num = 0
        let first_usable_win = 0

        let i = 1
        let bnum = winbufnr(i)
        while bnum != -1
            if getwinvar(i, 'tlist_file_window') == 'yes'
                let fwin_num = i
                break
            endif
            if first_usable_win == 0 &&
                        \ getbufvar(bnum, '&buftype') == '' &&
                        \ !getwinvar(i, '&previewwindow')
                " First non-taglist, non-plugin and non-preview window
                let first_usable_win = i
            endif
            let i = i + 1
            let bnum = winbufnr(i)
        endwhile

        " If a previously used window is not found, then use the first
        " non-taglist window
        if fwin_num == 0
            let fwin_num = first_usable_win
        endif

        if fwin_num != 0
            " Jump to the file window
            exe fwin_num . "wincmd w"

            " If the user asked to jump to the tag in a new window, then split
            " the existing window into two.
            if a:win_ctrl == 'newwin'
                split
            endif
            exe "edit " . escape(a:filename, ' ')
        else
            " Open a new window
            if g:Tlist_Use_Horiz_Window
                exe 'leftabove split ' . escape(a:filename, ' ')
            else
                if winbufnr(2) == -1
                    " Only the taglist window is present
                    if g:Tlist_Use_Right_Window
                        exe 'leftabove vertical split ' .
                                    \ escape(a:filename, ' ')
                    else
                        exe 'rightbelow vertical split ' .
                                    \ escape(a:filename, ' ')
                    endif

                    " Go to the taglist window to change the window size to
                    " the user configured value
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                    if g:Tlist_Use_Horiz_Window
                        exe 'resize ' . g:Tlist_WinHeight
                    else
                        exe 'vertical resize ' . g:Tlist_WinWidth
                    endif
                    " Go back to the file window
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                else
                    " A plugin or help window is also present
                    wincmd w
                    exe 'leftabove split ' . escape(a:filename, ' ')
                endif
            endif
        endif
        " Mark the window, so that it can be reused.
        call s:Tlist_Window_Mark_File_Window()
    else
        if v:version >= 700
            " If the file is opened in more than one window, then check
            " whether the last accessed window has the selected file.
            " If it does, then use that window.
            let lastwin_bufnum = winbufnr(winnr('#'))
            if bufnr(a:filename) == lastwin_bufnum
                let winnum = winnr('#')
            endif
        endif
        exe winnum . 'wincmd w'

        " If the user asked to jump to the tag in a new window, then split the
        " existing window into two.
        if a:win_ctrl == 'newwin'
            split
        endif
    endif
    endif

    " Jump to the tag
    if a:tagpat != ''
        " Add the current cursor position to the jump list, so that user can
        " jump back using the ' and ` marks.
        mark '
        silent call search(a:tagpat, 'w')

        " Bring the line to the middle of the window
        normal! z.

        " If the line is inside a fold, open the fold
        if foldclosed('.') != -1
            .foldopen
        endif
    endif

    " If the user selects to preview the tag then jump back to the
    " taglist window
    if a:win_ctrl == 'preview'
        " Go back to the taglist window
        let winnum = bufwinnr(g:TagList_title)
        exe winnum . 'wincmd w'
    else
        " If the user has selected to close the taglist window, when a
        " tag is selected, close the taglist  window
        if g:Tlist_Close_On_Select
            call s:Tlist_Window_Goto_Window()
            close

            " Go back to the window displaying the selected file
            let wnum = bufwinnr(a:filename)
            if wnum != -1 && wnum != winnr()
                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
            endif
        endif
    endif

    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
endfunction

" Tlist_Window_Jump_To_Tag()
" Jump to the location of the current tag
" win_ctrl == useopen - Reuse the existing file window
" win_ctrl == newwin - Open a new window
" win_ctrl == preview - Preview the tag
" win_ctrl == prevwin - Open in previous window
" win_ctrl == newtab - Open in new tab
function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a closed fold, then use the first line of the fold
    " and jump to the file.
    let lnum = foldclosed('.')
    if lnum == -1
        " Jump to the selected tag or file
        let lnum = line('.')
    else
        " Open the closed fold
        .foldopen!
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    " Get the tag output for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx != 0
        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)

        " Highlight the tagline
        call s:Tlist_Window_Highlight_Line()
    else
        " Selected a line which is not a tag name. Just edit the file
        let tagpat = ''
    endif

    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
endfunction

" Tlist_Window_Show_Info()
" Display information about the entry under the cursor
function! s:Tlist_Window_Show_Info()
    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')

    " Clear the previously displayed line
    echo

    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a fold, then don't display the prototype
    if foldclosed('.') != -1
        return
    endif

    let lnum = line('.')

    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    if lnum == s:tlist_{fidx}_start
        " Cursor is on a file name
        let fname = s:tlist_{fidx}_filename
        if strlen(fname) > 50
            let fname = fnamemodify(fname, ':t')
        endif
        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
        return
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx == 0
        " Cursor is on a tag type
        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
        if ttype == ''
            return
        endif

        let ttype_name = ''

        let ftype = s:tlist_{fidx}_filetype
        let i = 1
        while i <= s:tlist_{ftype}_count
            if ttype == s:tlist_{ftype}_{i}_name
                let ttype_name = s:tlist_{ftype}_{i}_fullname
                break
            endif
            let i = i + 1
        endwhile

        echo 'Tag type=' . ttype_name .
                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
        return
    endif

    " Get the tag search pattern and display it
    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Find_Nearest_Tag_Idx
" Find the tag idx nearest to the supplied line number
" Returns -1, if a tag couldn't be found for the specified line number
function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
    let sort_type = s:tlist_{a:fidx}_sort_type

    let left = 1
    let right = s:tlist_{a:fidx}_tag_count

    if sort_type == 'order'
        " Tags sorted by order, use a binary search.
        " The idea behind this function is taken from the ctags.vim script (by
        " Alexey Marinichev) available at the Vim online website.

        " If the current line is the less than the first tag, then no need to
        " search
        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)

        if a:linenum < first_lnum
            return -1
        endif

        while left < right
            let middle = (right + left + 1) / 2
            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)

            if middle_lnum == a:linenum
                let left = middle
                break
            endif

            if middle_lnum > a:linenum
                let right = middle - 1
            else
                let left = middle
            endif
        endwhile
    else
        " Tags sorted by name, use a linear search. (contributed by Dave
        " Eggum).
        " Look for a tag with a line number less than or equal to the supplied
        " line number. If multiple tags are found, then use the tag with the
        " line number closest to the supplied line number. IOW, use the tag
        " with the highest line number.
        let closest_lnum = 0
        let final_left = 0
        while left <= right
            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)

            if lnum < a:linenum && lnum > closest_lnum
                let closest_lnum = lnum
                let final_left = left
            elseif lnum == a:linenum
                let closest_lnum = lnum
                let final_left = left
                break
            else
                let left = left + 1
            endif
        endwhile
        if closest_lnum == 0
            return -1
        endif
        if left >= right
            let left = final_left
        endif
    endif

    return left
endfunction

" Tlist_Window_Highlight_Tag()
" Highlight the current tag
" cntx == 1, Called by the taglist plugin itself
" cntx == 2, Forced by the user through the TlistHighlightTag command
" center = 1, move the tag line to the center of the taglist window
function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
    " Highlight the current tag only if the user configured the
    " taglist plugin to do so or if the user explictly invoked the
    " command to highlight the current tag.
    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
        return
    endif

    if a:filename == ''
        return
    endif

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        return
    endif

    " If the file is currently not displayed in the taglist window, then retrn
    if !s:tlist_{fidx}_visible
        return
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return
    endif

    " Ignore all autocommands
    let old_ei = &eventignore
    set eventignore=all

    " Save the original window number
    let org_winnr = winnr()

    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    " Go to the taglist window
    if !in_taglist_window
        exe winnum . 'wincmd w'
    endif

    " Clear previously selected name
    match none

    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
    if tidx == -1
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        let lnum = line('.')

        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
            " Move the cursor to the beginning of the file
            exe s:tlist_{fidx}_start
        endif

        if foldclosed('.') != -1
            .foldopen
        endif

        call winline()

        if !in_taglist_window
            exe org_winnr . 'wincmd w'
        endif

        " Restore the autocommands
        let &eventignore = old_ei
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)

    " Compute the line number
    " Start of file + Start of tag type + offset
    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
                \ s:tlist_{fidx}_{tidx}_ttype_idx

    " Goto the line containing the tag
    exe lnum

    " Open the fold
    if foldclosed('.') != -1
        .foldopen
    endif

    if a:center
        " Move the tag line to the center of the taglist window
        normal! z.
    else
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        call winline()
    endif

    " Highlight the tag name
    call s:Tlist_Window_Highlight_Line()

    " Go back to the original window
    if !in_taglist_window
        exe org_winnr . 'wincmd w'
    endif

    " Restore the autocommands
    let &eventignore = old_ei
    return
endfunction

" Tlist_Get_Tag_Prototype_By_Line
" Get the prototype for the tag on or before the specified line number in the
" current buffer
function! Tlist_Get_Tag_Prototype_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
                                \ '<line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Expand the file to a fully qualified name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag text using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Get_Tagname_By_Line
" Get the tag name on or before the specified line number in the
" current buffer
function! Tlist_Get_Tagname_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Make sure the current file has a name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag name using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:tlist_{fidx}_{tidx}_tag_name
endfunction

" Tlist_Window_Move_To_File
" Move the cursor to the beginning of the current file or the next file
" or the previous file in the taglist window
" dir == -1, move to start of current or previous function
" dir == 1, move to start of next function
function! s:Tlist_Window_Move_To_File(dir)
    if foldlevel('.') == 0
        " Cursor is on a non-folded line (it is not in any of the files)
        " Move it to a folded line
        if a:dir == -1
            normal! zk
        else
            " While moving down to the start of the next fold,
            " no need to do go to the start of the next file.
            normal! zj
            return
        endif
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    let cur_lnum = line('.')

    if a:dir == -1
        if cur_lnum > s:tlist_{fidx}_start
            " Move to the beginning of the current file
            exe s:tlist_{fidx}_start
            return
        endif

        if fidx != 0
            " Move to the beginning of the previous file
            let fidx = fidx - 1
        else
            " Cursor is at the first file, wrap around to the last file
            let fidx = s:tlist_file_count - 1
        endif

        exe s:tlist_{fidx}_start
        return
    else
        " Move to the beginning of the next file
        let fidx = fidx + 1

        if fidx >= s:tlist_file_count
            " Cursor is at the last file, wrap around to the first file
            let fidx = 0
        endif

        if s:tlist_{fidx}_start != 0
            exe s:tlist_{fidx}_start
        endif
        return
    endif
endfunction

" Tlist_Session_Load
" Load a taglist session (information about all the displayed files
" and the tags) from the specified file
function! s:Tlist_Session_Load(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
        return
    endif

    let sessionfile = a:1

    if !filereadable(sessionfile)
        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
        call s:Tlist_Warning_Msg(msg)
        return
    endif

    " Mark the current window as the file window
    call s:Tlist_Window_Mark_File_Window()

    " Source the session file
    exe 'source ' . sessionfile

    let new_file_count = g:tlist_file_count
    unlet! g:tlist_file_count

    let i = 0
    while i < new_file_count
        let ftype = g:tlist_{i}_filetype
        unlet! g:tlist_{i}_filetype

        if !exists('s:tlist_' . ftype . '_count')
            if s:Tlist_FileType_Init(ftype) == 0
                let i = i + 1
                continue
            endif
        endif

        let fname = g:tlist_{i}_filename
        unlet! g:tlist_{i}_filename

        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            let s:tlist_{fidx}_visible = 0
            let i = i + 1
            continue
        else
            " As we are loading the tags from the session file, if this
            " file was previously deleted by the user, now we need to
            " add it back. So remove the file from the deleted list.
            call s:Tlist_Update_Remove_List(fname, 0)
        endif

        let fidx = s:Tlist_Init_File(fname, ftype)

        let s:tlist_{fidx}_filename = fname

        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
        unlet! g:tlist_{i}_sort_type

        let s:tlist_{fidx}_filetype = ftype
        let s:tlist_{fidx}_mtime = getftime(fname)

        let s:tlist_{fidx}_start = 0
        let s:tlist_{fidx}_end = 0

        let s:tlist_{fidx}_valid = 1

        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
        unlet! g:tlist_{i}_tag_count

        let j = 1
        while j <= s:tlist_{fidx}_tag_count
            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
            unlet! g:tlist_{i}_{j}_tag
            unlet! g:tlist_{i}_{j}_tag_name
            unlet! g:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name

            if exists('g:tlist_' . i . '_' . ttype)
                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
                unlet! g:tlist_{i}_{ttype}
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
                unlet! g:tlist_{i}_{ttype}_count

                let k = 1
                while k <= s:tlist_{fidx}_{ttype}_count
                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
                    unlet! g:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            else
                let s:tlist_{fidx}_{ttype} = ''
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = 0
            endif

            let j = j + 1
        endwhile

        let i = i + 1
    endwhile

    " If the taglist window is open, then update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Refresh the taglist window
        call s:Tlist_Window_Refresh()

        " Go back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Session_Save
" Save a taglist session (information about all the displayed files
" and the tags) into the specified file
function! s:Tlist_Session_Save(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
        return
    endif

    let sessionfile = a:1

    if s:tlist_file_count == 0
        " There is nothing to save
        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
        return
    endif

    if filereadable(sessionfile)
        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
        if ans !=? 'y'
            return
        endif

        echo "\n"
    endif

    let old_verbose = &verbose
    set verbose&vim

    exe 'redir! > ' . sessionfile

    silent! echo '" Taglist session file. This file is auto-generated.'
    silent! echo '" File information'
    silent! echo 'let tlist_file_count = ' . s:tlist_file_count

    let i = 0

    while i < s:tlist_file_count
        " Store information about the file
        silent! echo 'let tlist_' . i . "_filename = '" .
                                            \ s:tlist_{i}_filename . "'"
        silent! echo 'let tlist_' . i . '_sort_type = "' .
                                                \ s:tlist_{i}_sort_type . '"'
        silent! echo 'let tlist_' . i . '_filetype = "' .
                                            \ s:tlist_{i}_filetype . '"'
        silent! echo 'let tlist_' . i . '_tag_count = ' .
                                                        \ s:tlist_{i}_tag_count
        " Store information about all the tags
        let j = 1
        while j <= s:tlist_{i}_tag_count
            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
                        \ s:tlist_{i}_{j}_tag_name . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
                        \ s:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        " Store information about all the tags grouped by their type
        let ftype = s:tlist_{i}_filetype
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{i}_{ttype}_count != 0
                let txt = escape(s:tlist_{i}_{ttype}, '"\')
                let txt = substitute(txt, "\n", "\\\\n", 'g')
                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
                                                \ txt . '"'
                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
                                                     \ s:tlist_{i}_{ttype}_count
                let k = 1
                while k <= s:tlist_{i}_{ttype}_count
                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            endif
            let j = j + 1
        endwhile

        silent! echo

        let i = i + 1
    endwhile

    redir END

    let &verbose = old_verbose
endfunction

" Tlist_Buffer_Removed
" A buffer is removed from the Vim buffer list. Remove the tags defined
" for that file
function! s:Tlist_Buffer_Removed(filename)
    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')

    " Make sure a valid filename is supplied
    if a:filename == ''
        return
    endif

    " Get tag list index of the specified file
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " File not present in the taglist
        return
    endif

    " Remove the file from the list
    call s:Tlist_Remove_File(fidx, 0)
endfunction

" When a buffer is deleted, remove the file from the taglist
autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))

" Tlist_Window_Open_File_Fold
" Open the fold for the specified file and close the fold for all the
" other files
function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
        return
    endif

    " Save the original window number
    let org_winnr = winnr()
    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    if in_taglist_window
        " When entering the taglist window, no need to update the folds
        return
    endif

    " Go to the taglist window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
    endif

    " Close all the folds
    silent! %foldclose

    " Get tag list index of the specified file
    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    if filereadable(fname)
        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            " Open the fold for the file
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen"
        endif
    endif

    " Go back to the original window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
    endif
endfunction

" Tlist_Window_Check_Auto_Open
" Open the taglist window automatically on Vim startup.
" Open the window only when files present in any of the Vim windows support
" tags.
function! s:Tlist_Window_Check_Auto_Open()
    let open_window = 0

    let i = 1
    let buf_num = winbufnr(i)
    while buf_num != -1
        let filename = fnamemodify(bufname(buf_num), ':p')
        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
        if !s:Tlist_Skip_File(filename, ft)
            let open_window = 1
            break
        endif
        let i = i + 1
        let buf_num = winbufnr(i)
    endwhile

    if open_window
        call s:Tlist_Window_Toggle()
    endif
endfunction

" Tlist_Refresh_Folds
" Remove and create the folds for all the files displayed in the taglist
" window. Used after entering a tab. If this is not done, then the folds
" are not properly created for taglist windows displayed in multiple tabs.
function! s:Tlist_Refresh_Folds()
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        return
    endif

    let save_wnum = winnr()
    exe winnum . 'wincmd w'

    " First remove all the existing folds
    normal! zE

    " Create the folds for each in the tag list
    let fidx = 0
    while fidx < s:tlist_file_count
        let ftype = s:tlist_{fidx}_filetype

        " Create the folds for each tag type in a file
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{fidx}_{ttype}_count
                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
                let e = s + s:tlist_{fidx}_{ttype}_count
                exe s . ',' . e . 'fold'
            endif
            let j = j + 1
        endwhile

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                    \ s:tlist_{fidx}_end . 'foldopen!'
        let fidx = fidx + 1
    endwhile

    exe save_wnum . 'wincmd w'
endfunction

function! s:Tlist_Menu_Add_Base_Menu()
    call s:Tlist_Log_Msg('Adding the base menu')

    " Add the menu
    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Name
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Order
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
    anoremenu T&ags.-SEP1-           :

    if &mousemodel =~ 'popup'
        anoremenu <silent> PopUp.T&ags.Refresh\ menu
                    \ :call <SID>Tlist_Menu_Refresh()<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
        anoremenu PopUp.T&ags.-SEP1-           :
    endif
endfunction

let s:menu_char_prefix =
            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

" Tlist_Menu_Get_Tag_Type_Cmd
" Get the menu command for the specified tag type
" fidx - File type index
" ftype - File Type
" add_ttype_name - To add or not to add the tag type name to the menu entries
" ttype_idx - Tag type index
function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
    " Curly brace variable name optimization
    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx

    let ttype = s:tlist_{ftype_ttype_idx}_name
    if a:add_ttype_name
        " If the tag type name contains space characters, escape it. This
        " will be used to create the menu entries.
        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
    endif

    " Curly brace variable name optimization
    let fidx_ttype = a:fidx . '_' . ttype

    " Number of tag entries for this tag type
    let tcnt = s:tlist_{fidx_ttype}_count
    if tcnt == 0 " No entries for this tag type
        return ''
    endif

    let mcmd = ''

    " Create the menu items for the tags.
    " Depending on the number of tags of this type, split the menu into
    " multiple sub-menus, if needed.
    if tcnt > g:Tlist_Max_Submenu_Items
        let j = 1
        while j <= tcnt
            let final_index = j + g:Tlist_Max_Submenu_Items - 1
            if final_index > tcnt
                let final_index = tcnt
            endif

            " Extract the first and last tag name and form the
            " sub-menu name
            let tidx = s:tlist_{fidx_ttype}_{j}
            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            let tidx = s:tlist_{fidx_ttype}_{final_index}
            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            " Truncate the names, if they are greater than the
            " max length
            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)

            " Form the menu command prefix
            let m_prefix = 'anoremenu <silent> T\&ags.'
            if a:add_ttype_name
                let m_prefix = m_prefix . ttype_fullname . '.'
            endif
            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'

            " Character prefix used to number the menu items (hotkey)
            let m_prefix_idx = 0

            while j <= final_index
                let tidx = s:tlist_{fidx_ttype}_{j}

                let tname = s:tlist_{a:fidx}_{tidx}_tag_name

                let mcmd = mcmd . m_prefix . '\&' .
                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
                            \ tidx . ')<CR>|'

                let m_prefix_idx = m_prefix_idx + 1
                let j = j + 1
            endwhile
        endwhile
    else
        " Character prefix used to number the menu items (hotkey)
        let m_prefix_idx = 0

        let m_prefix = 'anoremenu <silent> T\&ags.'
        if a:add_ttype_name
            let m_prefix = m_prefix . ttype_fullname . '.'
        endif
        let j = 1
        while j <= tcnt
            let tidx = s:tlist_{fidx_ttype}_{j}

            let tname = s:tlist_{a:fidx}_{tidx}_tag_name

            let mcmd = mcmd . m_prefix . '\&' .
                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
                        \ . ')<CR>|'

            let m_prefix_idx = m_prefix_idx + 1
            let j = j + 1
        endwhile
    endif

    return mcmd
endfunction

" Update the taglist menu with the tags for the specified file
function! s:Tlist_Menu_File_Refresh(fidx)
    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
    " The 'B' flag is needed in the 'cpoptions' option
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    exe s:tlist_{a:fidx}_menu_cmd

    " Update the popup menu (if enabled)
    if &mousemodel =~ 'popup'
        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
                                        \ ' PopUp.T\\\&ags.', "g")
        exe cmd
    endif

    " The taglist menu is not empty now
    let s:tlist_menu_empty = 0

    " Restore the 'cpoptions' settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Menu_Update_File
" Add the taglist menu
function! s:Tlist_Menu_Update_File(clear_menu)
    if !has('gui_running')
        " Not running in GUI mode
        return
    endif

    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)

    " Remove the tags menu
    if a:clear_menu
        call s:Tlist_Menu_Remove_File()

    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1 || !s:tlist_{fidx}_valid
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " Process the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
        if fidx == -1
            return
        endif
    endif

    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
    if fname != ''
        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
        anoremenu T&ags.-SEP2-           :
    endif

    if !s:tlist_{fidx}_tag_count
        return
    endif

    if s:tlist_{fidx}_menu_cmd != ''
        " Update the menu with the cached command
        call s:Tlist_Menu_File_Refresh(fidx)

        return
    endif

    " We are going to add entries to the tags menu, so the menu won't be
    " empty
    let s:tlist_menu_empty = 0

    let cmd = ''

    " Determine whether the tag type name needs to be added to the menu
    " If more than one tag type is present in the taglisting for a file,
    " then the tag type name needs to be present
    let add_ttype_name = -1
    let i = 1
    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{fidx}_{ttype}_count
            let add_ttype_name = add_ttype_name + 1
        endif
        let i = i + 1
    endwhile

    " Process the tags by the tag type and get the menu command
    let i = 1
    while i <= s:tlist_{ftype}_count
        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
        if mcmd != ''
            let cmd = cmd . mcmd
        endif

        let i = i + 1
    endwhile

    " Cache the menu command for reuse
    let s:tlist_{fidx}_menu_cmd = cmd

    " Update the menu
    call s:Tlist_Menu_File_Refresh(fidx)
endfunction

" Tlist_Menu_Remove_File
" Remove the tags displayed in the tags menu
function! s:Tlist_Menu_Remove_File()
    if !has('gui_running') || s:tlist_menu_empty
        return
    endif

    call s:Tlist_Log_Msg('Removing the tags menu for a file')

    " Cleanup the Tags menu
    silent! unmenu T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu PopUp.T&ags
    endif

    " Add a dummy menu item to retain teared off menu
    noremenu T&ags.Dummy l

    silent! unmenu! T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu! PopUp.T&ags
    endif

    call s:Tlist_Menu_Add_Base_Menu()

    " Remove the dummy menu item
    unmenu T&ags.Dummy

    let s:tlist_menu_empty = 1
endfunction

" Tlist_Menu_Refresh
" Refresh the taglist menu
function! s:Tlist_Menu_Refresh()
    call s:Tlist_Log_Msg('Refreshing the tags menu')
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx != -1
        " Invalidate the cached menu command
        let s:tlist_{fidx}_menu_cmd = ''
    endif

    " Update the taglist, menu and window
    call s:Tlist_Update_Current_File()
endfunction

" Tlist_Menu_Jump_To_Tag
" Jump to the selected tag
function! s:Tlist_Menu_Jump_To_Tag(tidx)
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx == -1
        return
    endif

    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
    if tagpat == ''
        return
    endif

    " Add the current cursor position to the jump list, so that user can
    " jump back using the ' and ` marks.
    mark '

    silent call search(tagpat, 'w')

    " Bring the line to the middle of the window
    normal! z.

    " If the line is inside a fold, open the fold
    if foldclosed('.') != -1
        .foldopen
    endif
endfunction

" Tlist_Menu_Init
" Initialize the taglist menu
function! s:Tlist_Menu_Init()
    call s:Tlist_Menu_Add_Base_Menu()

    " Automatically add the tags defined in the current file to the menu
    augroup TagListMenuCmds
        autocmd!

        if !g:Tlist_Process_File_Always
            autocmd BufEnter * call s:Tlist_Refresh()
        endif
        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
    augroup end

    call s:Tlist_Menu_Update_File(0)
endfunction

" Tlist_Vim_Session_Load
" Initialize the taglist window/buffer, which is created when loading
" a Vim session file.
function! s:Tlist_Vim_Session_Load()
    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')

    " Initialize the taglist window
    call s:Tlist_Window_Init()

    " Refresh the taglist window
    call s:Tlist_Window_Refresh()
endfunction

" Tlist_Set_App
" Set the name of the external plugin/application to which taglist
" belongs.
" Taglist plugin is part of another plugin like cream or winmanager.
function! Tlist_Set_App(name)
    if a:name == ""
        return
    endif

    let s:tlist_app_name = a:name
endfunction

" Winmanager integration

" Initialization required for integration with winmanager
function! TagList_Start()
    " If current buffer is not taglist buffer, then don't proceed
    if bufname('%') != '__Tag_List__'
        return
    endif

    call Tlist_Set_App('winmanager')

    " Get the current filename from the winmanager plugin
    let bufnum = WinManagerGetLastEditedFile()
    if bufnum != -1
        let filename = fnamemodify(bufname(bufnum), ':p')
        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
    endif

    " Initialize the taglist window, if it is not already initialized
    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
        call s:Tlist_Window_Init()
        call s:Tlist_Window_Refresh()
        let s:tlist_window_initialized = 1
    endif

    " Update the taglist window
    if bufnum != -1
        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
            call s:Tlist_Window_Refresh_File(filename, ftype)
        endif
    endif
endfunction

function! TagList_IsValid()
    return 0
endfunction

function! TagList_WrapUp()
    return 0
endfunction

" restore 'cpo'
let &cpo = s:cpo_save
unlet s:cpo_save

zhimakaimen:/vimfiles/bundle/taglist.vim/plugin/taglist.vim
["test.vim","test.zip","test_syntax.vim","ToggleCommentify.vim","DoxyGen-Syntax","keepcase.vim","ifdef-highlighting","vimbuddy.vim","buffoptions.vim","fortune.vim","drawing.vim","ctags.vim","closetag.vim","htmlcmd.vim","ccase.vim","compiler.tar.gz","ls.vim","calendar.vim","dl.vim","jcommenter.vim","info.vim","hunspchk.zip","EnhCommentify.vim","LoadHeaderFile.vim","mailbrowser.vim","vimmailr.zip","format.vim","vimxmms.tar.gz","sourceSafe.zip","python.vim","a.vim","vimrc.tcl","oravim.txt","javabean.vim","jbean.vim","vimvccmd.zip","dbhelper.tgz","matchit.zip","DrawIt","rcs-menu.vim","bufexplorer.zip","sccs-menu.vim","completeWord.py","Mail_Sig.set","Mail_mutt_alias.set","Mail_Re.set","Triggers.vim","Mail_cc.set","lh-brackets","cscope_macros.vim","calendar.vim","colorize.vim","ConvertBase.vim","TagsMenu.zip","perl.vim","oberon.vim","cvsmenu.vim","dtags","delphi.vim","Embperl_Syntax.zip","whatdomain.vim","emacs.vim","po.vim","CD.vim","_vim_wok_visualcpp01.zip","nqc.vim","vfp.vim","project.tar.gz","pt.vim.gz","dctl.vim.gz","foo.vim","word_complete.vim","aux2tags.vim","javaimp.vim","uri-ref","incfiles.vim","functags.vim","wordlist.vim","files2menu.pm","translate.vim","AppendComment.vim","let-modeline.vim","gdbvim.tar.gz","Mkcolorscheme.vim","brief.vim","plkeyb.vim","vimtips.zip","savevers.vim","vcscommand.vim","nsis.vim","borland.vim","tex.vim","express.vim","winmanager","methods.vim","sqlplus.vim","spec.vim","mail.tgz","TagsBase.zip","nlist.vim","DirDiff.vim","regview.vim","BlockHL","desert.vim","colorscheme_template.vim","SelectBuf","bufNwinUtils.vim","lightWeightArray.vim","golden.vim","torte.vim","borland.vim","idutils","MultiPrompt.vim","blue.vim","csharp.vim","cs.vim","Shell.vim","vim.vim","Decho","asu1dark.vim","Astronaut","sum.vim","quickhigh.tgz","selbuff.vim","ctx-1.15.vim","runscript.vim","random_vim_tip.tar.gz","PushPop.vim","usr2latex.pl","spellcheck.vim","PopupBuffer.vim","TableTab.vim","djgpp.vim","vim-spell.tar.gz","ada.vim","ada.vim","which.vim","VirMark.vim","oracle.vim","sql.vim","words_tools.vim","chcmdmod.vim","increment.vim","CmdlineCompl.vim","SearchCompl.vim","perl_io.vim","darkslategray.vim","undoins.vim","cisco-syntax.tar.gz","ShowMarks","EasyHtml.vim","ctags.vim","ant_menu.vim","increment.vim","autoload_cscope.vim","foldutil.vim","minibufexpl.vim","gtkvim.tgz","FavMenu.vim","auctex.vim","ruby-macros.vim","html-macros.vim","vimsh.tar.gz","libList.vim","perforce.vim","idevim.tgz","email.vim","mcant.vim","multvals.vim","TeTrIs.vim","boxdraw","tf.vim","CreateMenuPath.vim","Lineup--A-simple-text-aligner","Justify","A-better-tcl-indent","ViMail","remcmd.vim","prt_mgr.zip","SuperTab","treeexplorer","vtreeexplorer","bk-menu.vim","glib.vim","win-manager-Improved","ruby-menu.vim","renumber.vim","navajo.vim","wcd.vim","RExplorer","fortune.vim","MRU","Engspchk","vcal.vim","genutils","template-file-loader","charset.vim","ComplMenu.vim","bcbuf.vim","quickfonts.vim","DSP-Make","vimconfig","morse.vim","LaTeX-Help","MRU-Menu","ctx","Perldoc.vim","fine_blue.vim","sokoban.vim","linuxmag.vim","c.vim","lh-vim-lib","tagmenu.vim","xmms-play-and-enqueue","cmvc.vim","tex.vim","bccalc.vim","mkview.vim","VIlisp.vim","mu-template","xl_tiv.vim","night.vim","einstimer.vim","closeb","Brown","Expand-Template","search-in-runtime","Brace-Complete-for-CCpp","Smart-Tabs","spell.vim","print_bw.zip","std_c.zip","Naught-n-crosses","SourceSafe-Integration","Michaels-Standard-Settings","Hex-Output","Visual-Mapping-Maker","perforce","xul.vim","cream-capitalization","mu-marks","imaps.vim","JavaRun","Buffer-Menus","cream-ascii","vimRubyX","update_vim","bnf.vim","lid.vim","UserMenu.vim","midnight.vim","tmpl.vim","ihtml.vim","pascii","XSLT-syntax","htmlmap","lastchange.vim","manxome-foes-colorscheme","vimdoc","doc.vim","csc.vim","aspnet.vim","brief.vim","java.vim","Nsis-color","byteme.vim","scite-colors","Cool-colors","navajo-night","multi.vim","taglist.vim","User-Defined-Type-Highlighter","camo.vim","adrian.vim","PrintWithLNum","sybase.vim","Projmgr","netdict","ExecPerl","candy.vim","txt2pdf.vim","unilatex.vim","potts.vim","sessmgr","outlineMode.vim","aqua","serverlist.vim","ruby-matchit","autodate.vim","xian.vim","utl.vim","Align","bluegreen","showbrace","latextags","vimfortune","TabIndent","Vimacs","xmledit","AnsiEsc.vim","ftpluginruby.vim","pyimp.vim","sql_iabbr.vim","gnome-doc.vim","xemacs-colorscheme","fog-colorscheme","CSV-delimited-field-jumper","cream-sort","grep.vim","ipsec_conf.vim","EDIFACT-position-in-a-segment","tomatosoup.vim","xchat-log-syntax","broadcast.vim","vera.vim","f.vim","highlightline.vim","hungarian_to_english","Buffer-Search","srecord.vim","reformat.vim","multivim","JavaImp.vim","PHPcollection","JHTML-syntax-file","Nightshimmer","cfengine-syntax-file","code2html","prt_hdr","cream-progressbar","QuickAscii","bw.vim","lh-cpp","vtags","vtags_def","ASP-maps","tforge.vim","pf.vim","sand","fstab-syntax","MqlMenu.vim","lcscheck.vim","php.vim","textlink.vim","White-Dust","ruby.vim","Highlight-UnMatched-Brackets","localColorSchemes.vim","multipleRanges.vim","getVar.vim","variableSort.vim","vimrc_nopik","dbext.vim","openroad.vim","java_apidoc.vim","ABAP.vim","rcsdiff.vim","snippet.vim","opsplorer","cream-showinvisibles","bash-support.vim","ldraw.vim","DirDo.vim","oceandeep","atomcoder-vim","Expmod","timstamp.vim","Red-Black","ftpluginruby.vim","indentruby.vim","Denim","mof.vim","vim-game-of-life","ia64.vim","d.vim","PreviewTag.vim","ShowLine.vim","ShowBlockName.vim","SyntaxAttr.vim","DarkOcean.vim","ibmedit.vim","python_match.vim","rnc.vim","LbdbQuery.vim","scratch-utility","plp.vim","LaTeX-functions","ocean.vim","spectre.vim","bugfixes-to-vim-indent-for-verilog","gri.vim","scilab.vim","ShowFunc.vim","maxima.vim","ironman.vim","sean.vim","regRedir.vim","colormenu.vim","eruby.vim","getmail.vim","colour_flip.pl","blackdust.vim","CVSAnnotate.vim","beanshell.vim","svn.vim","muf.vim","tex.vim","cvopsefsa.vim","ActionScript","plsql.vim","Zenburn","Kent-Vim-Extensions","plsql.vim","Registryedit-win32","syslog-syntax-file","MySQL-script-runner","elinks.vim","eukleides.vim","jcl.vim","midnight2.vim","smlisp.vim","lustre","lustre-syntax","VimFootnotes","biogoo.vim","Get-Win32-Short-Name","Get-UNC-Path-Win32","pythonhelper","javaGetSet.vim","copycppdectoimp.vim","cppgetset.vim","titlecase.vim","stata.vim","localvimrc","lilac.vim","spacehi.vim","deldiff.vim","Syntax-for-the-BETA-programming-language","JavaDecompiler.vim","exim.vim","java_checkstyle.vim","gmt.vim","xhtml.vim","EasyAccents","draw.vim","HTML.zip","sql.vim","php_abb","xgen.vim","noweb.vim","PCP-header","vim-templates","rrd.vim","TTCoach","nw.vim","rainbow.zip","VB-Line-Number","vimspell","perl_h2xs","emodeline","VEC","fnaqevan","HTML-Photo-Board","cream-vimabbrev","mup.vim","BlockComment.vim","SearchComplete","LaTeX-Suite-aka-Vim-LaTeX","Transparent","python.vim","aj.vim","MultipleSearch","toothpik.vim","cscomment.vim","cuecat.vim","tagexplorer.vim","ddldbl.vim","markjump.vim","SAPDB_Pascal.vim","Posting","cream-keytest","ManPageView","java_getset.vim","debug.vim","SQLUtilities","Cpp-code-template-generator","ri-browser","sql.vim","poser.vim","waimea.vim","sql.vim","SpellChecker","foldlist","OO-code-completion","transvim.vim","Macromedia-Director-Lingo-Syntax","oz.vim","python_box.vim","greputil.vim","mercury.vim","ZoomWin","mailsig","Varrays","casejump.vim","Printer-Dialog","Indent-Finder","mrswin.vim","python_fold","sr.vim","TVO--The-Vim-Outliner","csv-color","CVS-conflict-highlight","PHPDoc-Script-PDocS","mru.vim","tar.vim","VimITunes.vim","Visual-Studio-.NET-compiler-file","cscope-menu","pdbvim","cppcomplete","mh","blockquote.vim","Mixed-sourceassembly-syntax-objdump","elvis-c-highlighting","colorer-color-scheme","ntservices","PHP-dictionary","tiger.vim","tiger.vim","tab-syntax","cream-email-munge","FavEx","apdl.vim","velocity.vim","russian-menu-translation","nuweb.vim","flyaccent.vim","ebnf.vim","IDLATL-Helper","as.vim","Mines","coffee.vim","adp.vim","mruex","HiCurLine","perl-support.vim","BOG","spreadsheet.vim","BufClose.vim","MPD-syntax-highlighting","help.vim","rd.vim","rcsvers.vim","ASPRecolor.vim","HTML--insert","ctrlax.vim","desc.vim","ntprocesses","caramel.vim","GTK","autolisp-help","wintersday.vim","darkdot","TEXT--fill-char","gnu-c","psp.vim","dawn","allfold","fgl.vim","autonumbering-in-vim","cg.vim","matlab.vim","comment.vim","pyljpost.vim","todolist.vim","northsky","fgl.c","JavaBrowser","seashell","BlackSea","PapayaWhip","ChocolateLiquor","guifontpp.vim","TaQua","HelpClose","colorpalette.vim","python-tools","execmap","cmake.vim","cmake.vim","vimwc.sh","vimbadword.sh","oceanblack.vim","php.vim-html-enhanced","cream-numberlines","asmMIPS","valgrind.vim","toc.vim","Qt.vim","ctags.vim","dante.vim","cpp.vim","gisdk","CRefVim","ruler.vim","Asciitable.vim","Adaryn.vim","BreakPts","brookstream","Russian-menu-for-gvimwin32","Conflict2Diff","tagsubmenu","m4pic.vim","nightwish.vim","Color-Sampler-Pack","ShowPairs","MarkShift","SeeTab","putty","resolv.conf-syntax","cf.vim","make-element","Reindent","otf.vim","sparc.vim","getdp","COMMENT.vim","WC.vim","gmsh.vim","SYN2HTML","tcsoft.vim","GetLatestVimScripts","WML-Wireless-Markup-Language-syntax","Color-Scheme-Test","greyblue.vim","colorize","DOS-Commands","fte.vim","chordpro.vim","vectorscript.vim","uniq.vim","stol.vim","ldap_schema.vim","ldif.vim","proc.vim","esperanto","epperl.vim","headers.vim","sip.vim","gpg.vim","gnupg","xml_cbks","VimDebug","scratch.vim","FeralToggleCommentify.vim","hexman.vim","Dotnet-Dictionaries","random.vim","matrix.vim","VisIncr","autumn.vim","listmaps.vim","Maxlen.vim","MakeDoxygenComment","VS-like-Class-Completion","GenerateMatlabFunctionComment","pgn.vim","genindent.vim","fluxbox.vim","ferallastchange.vim","blockhl2.vim","cschemerotate.vim","ftplugin-for-Calendar","Comment-Tools","incbufswitch.vim","feralalign.vim","VimTweak","calibre.vim","cleanphp","actionscript.vim","POD-Folder","VimSpeak","ample.vim","quancept.vim","po.vim","timecolor.vim","timecolor.vim","Visual-Cpp","NEdit","OIL.vim","cg.vim","parrot.vim","xmmsctrl.vim","isi2bib","sketch.vim","gdl.vim","msp.vim","brainfuck-syntax","sfl.vim","browser-like-scrolling-for-readonly-file","nuvola.vim","SideBar.vim","MSIL-Assembly","cygwin.vim","mupad.vim","trash.vim","wiki.vim","tagMenu","local_vimrc.vim","Hanoi-Tower","sudo.vim","co.vim","xmidas.vim","folddigest.vim","quicksession.vim","sql.vim","pam.vim","kickstart.vim","mdl.vim","gor.vim","yaml.vim","sbutils","movewin.vim","SwapHeader","svn.vim","dhcpd.vim","curcmdmode","cmdalias.vim","Intellisense-for-Vim","HelpExtractor","pic.vim","aiseered.vim","winhelp","opengl.vim","ttcn-syntax","ttcn-indent","VDLGBX.DLL","python_encoding.vim","showpairs-mutated","dusk","LogCVSCommit","peaksea","lpc.vim","hlcontext.vim","dont-click","gvim-with-tabs","VHDL-indent","ttcn-dict","mis.vim","table.vim","Source-Control","ocamlhelp.vim","umber-green","vgrep","lebrief.vim","vimcdoc","whereis.vim","highlight_cursor.vim","ntp.vim","php_console.vim","sessions.vim","pyfold","oasis.vim","gdm.vim","fluka.vim","vartabs.vim","delek.vim","qt2vimsyntax","tokens.vim","set_utf8.vim","python.vim","Relaxed-Green","simpleandfriendly.vim","ttcn-ftplugin","promela.vim","xterm16.vim","bmichaelsen","preview.vim","Walk.vim","FindMakefile","MixCase.vim","javaDoc.vim","gramadoir.vim","XQuery-syntax","expand.vim","zrf.vim","truegrid.vim","dks-il2-tex.vim","vimcommander","Smart-Diffsplit","robinhood.vim","darkblue2.vim","billw.vim","mail.vim","white.vim","HHCS_D","enumratingptn","HHCS","ephtml","rgbasm.vim","Mouse-Toggle","BlockWork","avrasm.vim","yum.vim","asmM68k.vim","find_in_files","mp.vim","Intellisense","VimNotes","gq","TT2-syntax","xmaslights.vim","smartmake","httpclog","RTF-1.6-Spec-in-Vim-Help-Format","systemc_syntax.tar.gz","selected-resizer","PureBasic-Syntax-file","macro.vim","python.vim","text.py","yo-speller","increment.vim","nasl.vim","ptl.vim","pyab","mars.vim","howto-ftplugin","SrchRplcHiGrp.vim","latex-mik.vim","Pydiction","Posting","Gothic","File-local-variables","less.vim","FX-HLSL","NSIS-2.0--Syntax","table_format.vim","LocateOpen","Destructive-Paste","inform.vim","VikiDeplate","cscope-quickfix","BlackBeauty","visual_studio.vim","unmswin.vim","Israelli-hebrew-shifted","phoneticvisual-hebrew-keyboard-mapphone","Redundant-phoneticvisual-Hebrew-keyboar","changesqlcase.vim","changeColorScheme.vim","allout.vim","Syntax-context-abbreviations","srec.vim","emacsmode","bufman.vim","automation.vim","GVColors","Posting","RegExpRef","passwd","buttercream.vim","fluxkeys.vim","ods.vim","AutoAlign","FormatBlock","FormatComment.vim","docbkhelper","armasm","EvalSelection.vim","edo_sea","pylint.vim","winpos.vim","gtags.vim","Viewing-Procmail-Log","Toggle","perl_synwrite.vim","ViewOutput","CharTab","nesC","Tower-of-Hanoi","sharp-Plugin-Added","ratfor.vim","fvl.vim","yiheb-il.vim","sql.vim","Editable-User-Interface-EUI-eui_vim","html_umlaute","nvi.vim","unicodeswitch.vim","pydoc.vim","nedit2","adam.vim","po.vim","sieve.vim","AsNeeded","Nibble","fdcc.vim","CSS-2.1-Specification","sqlldr.vim","tex_autoclose.vim","bufmenu2","svncommand.vim","timestamp.vim","html_portuquese","AutoFold.vim","russian-phonetic_utf-8.vim","colorsel.vim","XpMenu","timelog.vim","virata.vim","VimIRC.vim","TogFullscreen.vim","database-client","ftpsync","svg.vim","Karma-Decompiler","autosession.vim","newheader.vim","sccs.vim","screen.vim","edifact.vim","pqmagic.vim","ProjectBrowse","n3.vim","groovy.vim","StyleChecker--perl","2tex.vim","Scons-compiler-plugin","qf.vim","af.vim","aspnet.vim","psql.vim","multiselect","xml2latex","ToggleComment","php-doc","YAPosting","blugrine","latex_pt","replace","DumpStr.vim","RemoteSaveAll.vim","FTP-Completion","nexus.vim","uptime.vim","asmx86","php.vim-for-php5","autoit.vim","pic18fxxx","IncrediBuild.vim","folds.vim","chela_light","rest.vim","indentpython.vim","Siebel-VB-Script-SVB","Tibet","Maxscript","svn-diff.vim","idf.vim","ssa.vim","GtkFileChooser","Simple-templates","onsgmls.vim","mappinggroup.vim","metacosm.vim","ASPJScript","DoxygenToolkit.vim","VHT","pdftotext","rpl","rpl","rpl","aspvbs.vim","FiletypeRegisters","nant-compiler-script","tbf-vimfiles","Window-Sizes","menu_pt_br.vimfix","TransferChinese.vim","gtk-vim-syntax","2htmlj","glsl.vim","SearchInBuffers.vim","Docbook-XSL-compiler-file","Phrases","Olive","Lynx-Offline-Documentation-Browser","srec.vim","srec.vim","lingo.vim","buflist","lingodirector.vim","PLI-Tools","clipbrd","check-mutt-attachments.vim","corewars.vim","redcode.vim","potwiki.vim","updt.vim","revolutions.vim","feralstub.vim","Phoenity-discontinued","aftersyntax.vim","IndentHL","xmlwf.vim","Visual-Mark","errsign","log.vim","msvc2003","scalefont","uc.vim","commenter","OOP.vim","cream-iso639.vim","cream-iso3166-1","HTMLxC.vim","vimgrep.vim","array.vim","vimtabs.vim","CodeReviewer.vim","cube.vim","uc.vim","uc.vim","sf.vim","monday","ST20-compiler-plugin","R.vim","octave.vim","delete.py","groff-keymap","The-Mail-Suite-tms","browser.vim","InteractHL.vim","curBuf.vim","vsutil.vim","DavesVimPack","Menu-Autohide","pygtk_color","Vive.vim","actionscript.vim","greputils","HC12-syntax-highlighting","asp.vim","click.vim","cecutil","mingw.vim","abap.vim","vimsh","dsPIC30f","BufOnly.vim","ConfirmQuit.vim","fasm-compiler","python_calltips","netrw.vim","cscope_win","lindo.vim","VUT","replvim.sh","xmms.vim","HiColors","MS-Word-from-VIM","multiwin.vim","multiAPIsyntax","earth.vim","Black-Angus","tpp.vim","cfengine.vim","sas.vim","InsertTry.vim","VimRegEx.vim","blitzbasic.vim","Archive","cream-statusline-prototype","TabLaTeX","buffer-perlpython.pl","txt2tags-menu","hamster.vim","hamster.vim","clearsilver","hamster.vim","VB.NET-Syntax","VB.NET-Indent","ACScope","ptu","java_src_link.vim","AutumnLeaf","WhatsMissing.vim","bulgarian.vim","edifile.vim","rcs.vim","pydoc.vim","TWiki-Syntax","pmd.vim","BodySnatcher","MapleSyrup","ooosetup.vim","reverse.vim","mod_tcsoft.vim","PHP-correct-Indenting","anttestreport","lingo.vim","lpl.vim","UpdateModDate.vim","vimUnit","lxTrace","vim2ansi","synmark.vim","vim_faq.vim","jhlight.vim","javascript.vim","css.vim","scratch.vim","Japanese-Keymapping","vcbc.vim","scilab.tar.gz","scilab.tar.gz","tree","FileTree","Cisco-ACL-syntax-highlighting-rules","header.vim","inkpot","jhdark","C-fold","ccimpl.vim","bufkill.vim","perl-test-manage.vim","GetFDCText.vim","cygwin_utils.vim","globalreplace.vim","remote-PHP-debugger","xbl.vim","JavaKit","ledger.vim","ledger.vim","txt2tags","unhtml","pagemaker6","tSkeleton","foldcol.vim","jexplorer","html_danish","EditJava","tolerable.vim","Wiked","substitute.vim","sharp-Indent","GoboLinux-ColorScheme","Abc-Menu","DetectIndent","templates.vim","tComment","Rhythmbox-Control-Plugin","sharp-Syntax","oceanlight","OAL-Syntax","PVCS-access","context_complete.vim","fileaccess","avr.vim","tesei.vim","MultipleSearch2.vim","uniface.vim","turbo.vim","rotate.vim","cream-replacemulti","cleanswap","matrix.vim","hcc.vim","wc.vim","AutoUpload","expander.vim","vfp8.vim","vis","omlet.vim","ocaml.annot.pl","nodiff.vim","increment_new.vim","namazu.vim","c.vim","bsh.vim","WhereFrom","oo","Java-Syntax-and-Folding","ProvideX-Syntax","DNA-Tools","vimCU","cvsvimdiff","latexmenu","XML-Indent","AddIfndefGuard","Vim-JDE","cvsdiff.vim","Super-Shell-Indent","cool.vim","Perldoc-from-VIM","The-NERD-Commenter","darkblack.vim","OpenGLSL","monkeyd-configuration-syntax","OCaml-instructions-signature---parser","plist.vim","my-_vimrc-for-Windows-2000XP7-users","DotOutlineTree","Vim-klip-for-Serence-Klipfolio-Windows","explorer-reader.vim","recent.vim","crontab.freebsd.vim","Rainbow-Parenthesis","mom.vim","DoTagStuff","gentypes.py","YankRing.vim","mathml.vim","xhtml.vim","MS-SQL-Server-Syntax","Mark","autoit.vim","Guardian","octave.vim","Markdown-syntax","desert256.vim","Embedded-Vim-Preprocessor","cvsmenu.vim-updated","Omap.vim","swig","cccs.vim","vc_diff","Teradata-syntax","timekeeper","trt.vim","greens","VIMEN","pike.vim","aspvbs.vim","wood.vim","custom","sienna","tmda_filter.vim","cstol.vim","tex_umlaute","Quick-access-file-Menu","IComplete","Emacs-outline-mode","teol.vim","acsb","drcstubs","drc_indent","rubikscube.vim","php_check_syntax.vim","Mathematica-Syntax-File","Mathematica-Indent-File","SpotlightOpen","autoscroll","vsearch.vim","quantum.vim","ToggleOptions.vim","crontab.vim","tagselect","TinyBufferExplorer","TortoiseSVN.vim","nasl.vim","sadic.tgz","tabs.vim","otherfile.vim","otherfile.vim","LogiPat","luarefvim","keywords.vim","Pida","nightshade.vim","form.vim","rsl.vim","Color-Scheme-Explorer","Project-Browser-or-File-explorer-for-vim","Shortcut-functions-for-KeepCase-script-","maximize.dll","recycle.dll-and-recycle.vim","php_funcinfo.vim","T7ko","cguess","php_template","another-dark-scheme","java_fold","DataStage-Universe-Basic","vimplate","vimplate","bwftmenu.vim","asmM6502.vim","udvm.vim","bwHomeEndAdv.vim","bwUtility.vim","snippetsEmu","perlprove.vim","Dynamic-Keyword-Highlighting","CSVTK","ps2vsm","advantage","The-Stars-Color-Scheme","bufferlist.vim","Impact","Windows-PowerShell-Syntax-Plugin","xslt","verilogams.vim","XHTML-1.0-strict-help-file","sudoku","tidy","Pleasant-colorscheme","VST","A-soft-mellow-color-scheme","Professional-colorscheme-for-Vim","pluginfonts.vim","TabBar","Autoproject","last_change","last_change","AutoTag","switchtags.vim","dmd","VIM-Email-Client","cxxcomplete","The-Vim-Gardener","Colortest","Mud","Mud","Modelines-Bundle","syntaxada.vim","Night-Vision-Colorscheme","PDV--phpDocumentor-for-Vim","eraseSubword","larlet.vim","Cthulhian","SmartCase","HP-41-syntax-file","HP-41-file-type-plugin","Last-Modified","cloudy","xslhelper.vim","adobe.vim","Peppers","syntaxconkyrc.vim","bookmarks.vim","Zopedav","CVSconflict","TextMarker","ldap.vim","asmh8300","TailMinusF","QFixToggle","fpc.vim","Chars2HTML","cfengine-log-file-highlighting","syntaxuil.vim","cHeaderFinder","syntaxudev.vim","charon","SessionMgr","UniCycle","interfaces","gdbvim","build.vim","jay-syntax","d.vim","GreedyBackspace.vim","BuildWin","py_jump.vim","motus.vim","fish.vim","Processing-Syntax","range-search.vim","xml.vim","tagSetting.vim","javap.vim","desertedocean.vim","Zen-Color-Scheme","DarkZen-Color-Scheme","gnupg-symmetric.vim","desertedocean.vim","understated","impactG","DesertedOceanBurnt","Local-configuration","OMNeTpp-NED-syntax-file","Workspace-Manager","bwTemplate","vim_colors","brsccs.vim","bibFindIndex","Auto-debug-your-vim","shorewall.vim","carvedwood","avs.vim","jadl.vim","openvpn","softblue","bufmap.vim","corn","dtdmenu","iptables","CarvedWoodCool","darkerdesert","selection_eval.vim","cfname","checksyntax","textutil.vim","haml.zip","Dev-Cpp-Scheme","HiMtchBrkt","Compiler-Plugin-for-msbuild-csc","XML-Folding","compilerpython.vim","winmanager","xsl-fo","XML-Completion","telstar.vim","colors","AllBuffersToOneWindow.vim","MoveLine","Altair-OptiStruct-Syntax","Low-Contrast-Color-Schemes","vera.vim","VHDL-indent-93-syntax","svn_commit","cecscope","baycomb","VCard-syntax","copypath.vim","CycleColor","Grape-Color","moin.vim","glark.vim","syntaxm4.vim","dtd2vim","docbook44","moria","Ant","netrw.vim","far","bayQua","promela","lbnf.vim","watermark","Sift","vim7-install.sh","yellow","maude.vim","Modeliner","Surveyor","muttrc.vim","CmdlineCompl.vim","cvops-aut.vim","kid.vim","marklar.vim","spectro.vim","StickyCursor","fasm.vim","django.vim","ScrollColors","PluginKiller","jr.vim","JavaScript-syntax","pyte","Sudoku-Solver","Efficient-python-folding","derefined","initng","Align.vim","all-colors-pack","rfc2html","delins.vim","slr.vim","Vimball","Search-unFold","jbase.vim","jbase.vim","LargeFile","TabLineSet.vim","XHTML-1.0-Strict-vim7-xml-data-file","autohi","manuscript.vim","screenpaste.vim","VimVS6","SwitchExt","VhdlNav","smcl.vim","changelog","ClassTree","icalendar.vim","OmniCppComplete","maven2.vim","WinWalker.vim","cmaxx","magic.vim","vbnet.vim","javaimports.vim","habiLight","comments.vim","FlexWiki-syntax-highlighting","timing.vim","backburnerEdit_Visual_Block.vim","txt.vim","amarok.vim","vimproject","TagsParser","remind","pluginbackup.vim","colorsmartin_krischik.vim","Highlighter.vim","mousefunc-option-patch","GetChar-event-patch","pythoncomplete","Tabline-wrapping-patch","foxpro.vim","abolish.vim","perl_search_lib","compilergnat.vim","ftpluginada.vim","bluez","jVim","Simple-Color-Scheme","ScreenShot","autoproto.vim","autoloadadacomplete.vim","CD_Plus","xul.vim","Toggle-Window-Size","icansee.vim","KDE-GVIM-vimopen","Neverness-colour-scheme","Rainbow-Parenthsis-Bundle","patchreview.vim","forth.vim","ftdetectada.vim","gtd","rails.vim","abnf","montz.vim","redstring.vim","php.vim","SQLComplete.vim","systemverilog.vim","settlemyer.vim","findstr.vim","crt.vim","css.vim","tcl.vim","cr-bs-del-space-tab.vim","FlagIt","lookupfile","vim-addon-background-cmd","tobase","Erlang-plugin-package","actionscript.vim","verilog_systemverilog.vim","myghty.vim","ShowFunc","skk.vim","unimpaired.vim","octave.vim","crestore.vim","comment.vim","showhide.vim","warsow.vim","blacklight","color_toon","yanktmp.vim","highlight.vim","pop11.vim","Smooth-Scroll","developer","tcl.vim","colornames","gsl.vim","HelpWords","color_peruse","Chrome-syntax-script","Ada-Bundle","IncRoman.vim","Access-SQL-Syntax-file","vj","phps","Satori-Color-Scheme","SWIG-syntax","tdl.vim","afterimage.vim","cshelper","vimtips_with_comments","scvim","phpx","TIMEIT","phpfolding.vim","pastie.vim","x12-syntax","liquid.vim","doriath.vim","findfuncname.vim","XChat-IRC-Log","gnuchangelog","sh.vim","svncommand-tng","matlab_run.vim","candycode.vim","JDL-syntax-file","myfold.vim","SourceCodeObedience","MultiTabs","cpp.vim","AfterColors.vim","zzsplash","SuperTab-continued.","switch_headers.vim","tikiwiki.vim","str2numchar.vim","addexecmod.vim","ASL","scrollfix","asmx86_64","freya","highlight_current_line.vim","proe.vim","git.zip","cobol.zip","quilt","doxygenerator","The-NERD-tree","dw_colors","mint","redocommand","rubycomplete.vim","asm8051.vim","buftabs","tavi.vim","Alternate-workspace","campfire","blink","doorhinge.vim","darktango.vim","blueprint.vim","pdf.vim","Drupal-5.0-function-dictionary","toggle_words.vim","twilight","Tab-Name","tidy-compiler-script","Vexorian-color-scheme","ekvoli","IndexedSearch","Darcs","DNA-sequence-highlighter","plaintex.vim","Tango-colour-scheme","jdox","MakeInBuilddir","mail_indenter","IndentConsistencyCop","IndentConsistencyCopAutoCmds","tailtab.vim","desertEx","SnippetsMgr","StateExp","VPars","surround.vim","C_Epita","vimGTD","vimksh","Remove-Trailing-Spaces","edc-support","vdb.vim","vdb-duplicated","redcode.vim","Marks-Browser","php_getset.vim","FencView.vim","scons.vim","SWIFT-ATE-Syntax","Business-Objects-Syntax","Test.Base-syntax","darker-robin","Tail-Bundle","tcl_snit.vim","tcl_sqlite.vim","tcl.vim","tabula.vim","WLS-Mode","gvimext.dll--support-tabs-under-VIM-7","renamer.vim","cf.vim","vimpager","pyljvim","capslock.vim","ruby_imaps","Templeet","sal-syntax","exUtility","tAssert","perlcritic-compiler-script","rdark","aedit","vbugle","echofunc.vim","applescript.vim","gnuplot.vim","RunVim.applescript","Info.plist","filetype.vim","R-MacOSX","Utility","vst_with_syn","nightflight.vim","amifmt.vim","compilerflex.vim","javascript.vim","toggle_word.vim","GotoFileArg.vim","kib_darktango.vim","tGpg","kib_plastic","surrparen","TTrCodeAssistor","sparql.vim","BinarySearchMove","lbdbq","kate.vim","conlangs","lojban","surrogat","aspnetcs","lua-support","code_complete","tcl_itcl.vim","tcl_togl.vim","recent.vim","SnipSnap","lispcomplete.vim","etk-vim-syntax","woc","DAMOS-tools","Haml","Menu_SQL_Templates.vim","tcl_critcl.vim","Vimgrep-Replace","cvsdiff","Wombat","tcmdbar.vim","scala.vim","mlint.vim","polycl.vim","cscope-wrapper","apachestyle","javacomplete","hexsearch.vim","wikipedia.vim","Bexec","Audacious-Control","tagscan","erm.vim","fcsh-tools","vibrantink","autoloadTemplate.vim","SETL2","svnvimdiff","smarty.vim","polycfg.vim","IndentHL","c16gui","eclipse.vim","compview","brief2","SearchFold","MultiEnc.vim","calmar256-lightdark.vim","Vimplate-Enhanced","guicolorscheme.vim","Infobasic-Set-Syntax-FTDetect-FTPlugi","Random-Tip-Displayer","gotofile","greplace.vim","sqlvim.sh","Windows-PowerShell-Indent-File","Windows-PowerShell-File-Type-Plugin","buffers_search_and_replace","Yankcode","vimbuddy.vim","NAnt-completion","NAnt-syntax","incfilesearch.vim","NetSend.vim","Hints-for-C-Library-Functions","Hints-for-C-Library-Functions","smp","writebackup","writebackupVersionControl","html-improved-indentation","VimSpy","asciidoc.vim","des3.vim","st.vim","RDF-Namespace-complete","bufpos","BlitzBasic-syntax-and-indentation","tEchoPair","IndentAnything","Javascript-Indentation","nicotine.vim","screenplay","jman.vim","OceanBlack256","haproxy","gitdiff.vim","NesC-Syntax-Highlighting","arpalert","AutoClose","carrot.vim","SearchSyntaxError","clarity.vim","Twitter","Xdebugxs-dictionary-of-functions","textmate16.vim","Jinja","native.vim","mako.vim","eZVim","Directory-specific-settings","errormarker.vim","kpl.vim","tlib","tmru","tselectfiles","tselectbuffer","doctest-syntax","simplefold","genshi.vim","django.vim","fruity.vim","summerfruit.vim","projtags.vim","psql.vim","verilog_emacsauto.vim","securemodelines","voodu.vim","vimoutliner-colorscheme-fix","AutoComplPop","ck.vim","svndiff","Increment-and-Decrement-number","felix.vim","python_import.vim","scmCloseParens","nginx.vim","AnyPrinter","DiffGoFile","automated-rafb.net-uploader-plugin","LustyExplorer","vividchalk.vim","CimpTabulate.vim","vmake","Vim-Setup-system","gmcs.vim","ragtag.vim","synic.vim","vcsnursery","FindFile","ael.vim","freefem.vim","skill_comment.vim","REPL","ReloadScript","camelcasemotion","tmboxbrowser","snipper","creole.vim","QuickBuf","SuperPre","in.vim","perlhelp.vim","tbibtools","vdm.vim","mySqlGenQueryMenu.vim","Scheme-Mode","clibs.vim","cvsps-syntax","javalog.vim","ChocolatePapaya","vpp.vim","omniperl","context-complier-plugin","bbs.vim","syntaxalgol68.vim","Rename","DBGp-client","maxscript.vim","svndiff.vim","visSum.vim","html_french","git-commit","rectcut","OOP-javascript-indentation","Syntax-for-XUL","todo.vim","autofmt","drools.vim","fx.vim","stingray","JSON.vim","QuickFixFilterUtil","outline","Dictionary","VimExplorer","gvim-pdfsync","systemverilog.vim","Vimpress","yavdb","doxygen-support.vim","smart_cr","yasnippets","SmartX","CharSort","cimpl","Tabmerge","Simple256","vimscript-coding-aids","tie.vim","lodgeit.vim","Ruby-Snippets","gvim-extensions-for-TALpTAL","indenthaskell.vim","Highlight-and-Mark-Lines","deb.vim","trivial256","Parameter-Helpers","JET_toggle","pyconsole_vim.vim","lettuce.vim","rcscript","rcscript","Easy-alignment-to-column","Sass","vimremote.sh","halfmove","vimff","GtagsClient","FuzzyFinder","runtests.vim","mosalisp.vim","khaki.vim","two2tango","gitvimdiff","kwiki.vim","Shell-History","triangle.vim","NightVision","confluencewiki.vim","railscasts","bruce.vim","undo_tags","iast.vim","sas.vim","blinking_cursor","lookup.vim","python_ifold","gobgen","ColorSchemeMenuMaker","karma.vim","progressbar-widget","greplist.vim","buffer-status-menu.vim","AutoClose","sessionman.vim","dbext4rdb","openssl.vim","DrillCtg","ttoc","cheat.vim","no_quarter","tregisters","ttags","3DGlasses.vim","Gettext-PO-file-compiler","headerguard.vim","Tailf","erlang-indent-file","brew.vim","camlanot.vim","motion.vim","taskpaper.vim","MarkLines","4NT-Bundle","vimblog.vim","makeprgs","swap-parameters","trag","colorful256.vim","F6_Comment-old","F6_Comment","hookcursormoved","narrow_region","QuickComment","tcalc","AutoScrollMode","of.vim","VimPdb","myvim.vim","mips.vim","Flash-Live-Support-Agent-and-Chatroom","nosql.vim","BlockDiff","vimpp","LustyJuggler","enscript-highlight","idlang.vim","asmc54xx","TranslateIt","ttagecho","soso.vim","PropBank-Semantic-Role-Annotations","matchparenpp","winwkspaceexplorer","Warm-grey","haskell.vim","coq-syntax","xemacs-mouse-drag-copy","checksum.vim","executevimscript","newlisp","yate","ttagcomplete","bbcode","yet-another-svn-script","switch-files","rcg_gui","rcg_term","indenthtml.vim","setsyntax","phtml.vim","industrial","Coq-indent","autoresize.vim","mysqlquery","comments.vim","javascript.vim","gen_vimoptrc.vim","TI-Basic-Syntax","code-snippet","refactor","WuYe","Acpp","view_diff","verilog.vim","reloaded.vim","complval.vim","Puppet-Syntax-Highlighting","Smartput","Tab-Menu","narrow","fakeclip","xml_autons","textobj-user","textobj-datetime","EnvEdit.vim","kwbdi.vim","R.vim","oberon2","hiveminder.vim","scratch","csv-reader","BBCode","chords","robocom","autohotkey-ahk","pspad-colors-scheme","Torquescript-syntax-highlighting","Processing","Io-programming-language-syntax","GCov-plugin","gcov.vim","webpreview","speeddating.vim","HeaderCVS","bg.py","basic-colors","Twitter","SDL-library-syntax-for-C","accurev","Wikidoc-syntax-highlighting","symfony.vim","Noweb","XmlPretty","Socialtext-wiki-syntax-highlighting","byter","tintin.vim","tabpage_sort.vim","syntax-highlighting-for-tintinttpp","repeat.vim","Css-Pretty","PBwiki-syntax-highlighting","sgf.vim","xoria256.vim","undobranche_viewer.vim","showmarks","unibasic.vim","nice-vim","GOBject-Builder-gob2","prmths","VimTrac","quiltdiff","ncss.vim","css_color.vim","sessions.vim","snippets.vim","RecentFiles","marvim","greenvision","leo256","altfile","diffchanges.vim","timestamp","VFT--VIM-Form-Toolkit","DataStage-Server-and-Parallel","sharp-Syntax","GNU-R","renamec.vim","ukrainian-enhanced.vim","patran.vim","dakota.vim","Doxygen-via-Doxygen","jammy.vim","osx_like","PERLDOC2","head.vim","repmo.vim","Railscasts-Theme-GUIand256color","cwiki","rdhelp.txt","cqml.vim","Source-Explorer-srcexpl.vim","ColorSchemeEditor","reliable","vimlatex","smoothPageScroll.vim","file-line","git-file.vim","pig.vim","Latex-Text-Formatter","earendel","Luinnar","dtrace-syntax-file","MountainDew.vim","Syntax-for-Fasta","fpdf.vim","number-marks","Unicode-Macro-Table","antlr3.vim","beauty256","rastafari.vim","gauref.vim","northland.vim","SCMDiff","Boost-Build-v2-BBv2-syntax","vimgen","TwitVim","CoremoSearch","runzip","Relativize","Txtfmt-The-Vim-Highlighter","pyrex.vim","Shobogenzo","seoul","Obvious-Mode","VimTAP","Switch","darkspectrum","qfn","groovy.vim","debugger.py","Limp","bensday","Allegro-4.2-syntax-file","CmdlineComplete","tinymode.vim","STL-improved","sort-python-imports","vimwiki","browser.vim","autopreview","pacific.vim","beachcomber.vim","WriteRoom-for-Vim","h80","nc.vim","rtorrent-syntax-file","previewtag","WarzoneResourceFileSyntax","useful-optistruct-functions","StringComplete","darkrobot.vim","256-jungle","vcsbzr.vim","openser.vim","RemoveDups.VIM","less.bat","upf.vim","darkroom","FFeedVim","xml_taginsert","pac.vim","common_vimrc","journal.vim","publish.vim","railstab.vim","musicbox.vim","buffergrep","dark-ruby","bpel.vim","Git-Branch-Info","Named-Buffers","Contrasty","nagios-syntax","occur.vim","xtemplate","EZComment","vera.vim","silent.vim","colorful","apachelogs.vim","vim-rpcpaste","pygdb","AutoInclude","nightflight2.vim","gladecompletion.vim","flydiff","textobj-fold","textobj-jabraces","DevEiate-theme","jptemplate","cmdlinehelp","blackboard.vim","pink","brook.vim","huerotation.vim","cup.vim","vmv","Specky","fgl.vim","ctags.exe","loremipsum","smartchr","skeleton","linglang","Resolve","SwapIt","Glob-Edit","sipngrep","sipngrep-helper","codepad","fortran.vim","perl-mauke.vim","Gembase-dml-plugins","foldsearch","spring.vim","vimdb.vim","Textile-for-VIM","Text-Especially-LaTeX-Formatter","Clever-Tabs","portablemsys","GoogleSearchVIM","Indent-Highlight","softlight.vim","sofu.vim","QuickName","thegoodluck","auto_wc.vim","zoom.vim","zshr.vim","TextFormat","LaTeX-error-filter","batch.vim","catn.vim","nopaste.vim","Tumblr","log.vim","chlordane.vim","pathogen.vim","session.vim","backup.vim","metarw","metarw-git","ku","bundle","simple-pairs","molokai","postmail.vim","dictview.vim","ku-bundle","ku-metarw","Vimchant","bufmru.vim","trinity.vim","Chimp","indentgenie.vim","rootwater.vim","RltvNmbr.vim","stlrefvim","FastGrep","textobj-lastpat","Superior-Haskell-Interaction-Mode-SHIM","Nekthuth","tags-for-std-cpp-STL-streams-...","clue","louver.vim","diff_navigator","simplewhite.vim","vimxmms2","autoincludex.vim","ScopeVerilog","vcsc.py","darkbone.vim","CCTree","vimmp","Duplicated","sqloracle.vim","automatic-for-Verilog","ClosePairs","dokuwiki.vim","if_v8","vim-addon-sql","htmlspecialchars","mlint.vim","win9xblueback.vim","Verilog-constructs-plugin","RemoveIfdef","Note-Maker","winter.vim","buf2html.vim","sqlite_c","endwise.vim","cern_root.vim","conomode.vim","pdc.vim","CSApprox","MPC-syntax","Django-Projects","QuickTemplate","darkeclipse.vim","Fly-Between-Projects","Cutting-and-pasting-txt-file-in-middle","Fly-Between-Projects","hfile","cheat","sqlplsql","Russian-PLansliterated","advice","stackreg","Pit-Configuration","Robotbattle-Scripting-Language","Lissard-syntax","MatlabFilesEdition","Refactor-Color-Scheme","sql_iabbr-2","ku-args","Yow","lastchange","Miranda-syntax-highlighting","Tango2","textobj-diff","jQuery","Merb-and-Datamapper","Format-Helper","quickrun","gadgetxml.vim","PySmell","Wordnet.vim","Gist.vim","Transmit-FTP","arpeggio","nour.vim","code_complete-new-update","LineCommenter","autocorrect.vim","literal_tango.vim","commentToggle","corporation","W3AF-script-syntax-file","Side-C","Php-Doc","fuzzyjump.vim","shymenu","EasyGrep","Php-Doc","TagManager-BETA","pyflakes.vim","VimLocalHistory","Python-Documentation","Download-Vim-Scripts-as-Cron-Task","UpdateDNSSerial","narrow","Pago","PylonsCommand","sqlserver.vim","msdn_help.vim","nightsky","miko","eyapp","google","outputz","mtys-vimrc","unibox","enzyme.vim","AutoTmpl","AutoTmpl","Python-Syntax-Folding","kellys","session_dialog.vim","wombat256.vim","cdargs","submode","sandbox","translit","smartword","paintbox","Csound-compiler-plugin","python_open_module","Gentooish","ini-syntax-definition","cbackup.vim","Persistent-Abbreviations","ActionScript-3-Omnicomplete","grsecurity.vim","maroloccio","pygtk_syntax","Quagmire","Gorilla","textobj-indent","python_check_syntax.vim","proc.vim","fortran_codecomplete.vim","Rack.Builder-syntax","maroloccio2","eclm_wombat.vim","maroloccio3","ViBlip","pty.vim","Fruidle","Pimp","Changed","shellinsidevim.vim","blood","toggle_unit_tests","VimClojure","fly.vim","lightcolors","vanzan_color","tetragrammaton","VimIM","0scan","DBGp-Remote-Debugger-Interface","Spiderhawk","proton","RunView","guepardo.vim","charged-256.vim","ctxabbr","widower.vim","lilydjwg_green","norwaytoday","WOIM.vim","Dpaste.com-Plugin","reorder-tabs","searchfold.vim","wokmarks.vim","Jifty-syntax","Scratch","Thousand-separator","Perl-MooseX.Declare-Syntax","jpythonfold.vim","Thesaurus","IndentCommentPrefix","po.vim","slimv.vim","nxc.vim","muttaliasescomplete.vim","d.vim","cca.vim","Lucius","earthburn","ashen.vim","css-color-preview","snipMate","Mastermind-board-game","StarRange","SearchCols.vim","EditSimilar","Buffer-grep","repy.vim","xsltassistant.vim","php.vim","BusyBee","wps.vim","Vicle","jam.vim","irssilog.vim","CommentAnyWay","jellybeans.vim","myprojects","gitignore","Match-Bracket-for-Objective-C","gams.vim","numbertotext","NumberToEnglish","ansi_blows.vim","bufMenuToo","simple_comments.vim","runVimTests","utf8-math","Vim-Rspec","Blazer","LogMgr","vimdecdef","apidock.vim","ack.vim","Darkdevel","codeburn","std-includes","WinMove","summerfruit256.vim","lint.vim","Session-manager","spec.vim","Fdgrep","blogit.vim","popup_it","quickfixsigns","lilydjwg_dark","upAndDown","PDV-revised","glimpse","vylight","FSwitch","HTML-AutoCloseTag","Zmrok","LBufWin","tmarks","Skittles-Dark","gvimfullscreen_win32","lighttpd-syntax","reorder.vim","todolist.vim","Symfony","wargreycolorscheme","paster.vim","Haskell-Cuteness","svk","nextfile","vimuiex","TaskList.vim","send.vim","PA_translator","textobj-entire","xptemplate","Rubytest.vim","vimstall","sdticket","vimtemplate","graywh","SpamAssassin-syntax","ctk.vim","textobj-function","neocomplcache","up2picasaweb","ku-quickfix","TODO-List","ProtoDef","Cabal.vim","Vimya","exVim","Vim-R-plugin","explorer","compilerjsl.vim","dosbatch-indent","nimrod.vim","csindent.vim","SearchPosition","smartmatcheol.vim","google.vim","ScmFrontEnd-former-name--MinSCM","blogger","jlj.vim","tango-morning.vim","haskell.vim","PLI-Auto-Complete","python_coverage.vim","Erlang_detectVariable","bandit.vim","TagHighlight","Templates-for-Files-and-Function-Groups","darkburn","PBASIC-syntax","darkZ","fitnesse.vim","bblean.vim","cuteErrorMarker","Arduino-syntax-file","squirrel.vim","Simple-R-Omni-Completion","VOoM","Changing-color-script","g15vim","clips.vim","plumbing.vim","ywvim","mako.vim","HtmlHelper","Mark","setget","shell_it","fastlane","TuttiColori-Colorscheme","tango-desert.vim","Hoogle","smarttill","cocoa.vim","altercmd","supercat.vim","nature.vim","GoogleReader.vim","textobj-verticalbar","cursoroverdictionary","Colorzone","colorsupport.vim","FastLadder.vim","herald.vim","zOS-Enterprise-Compiler-PLI","cuteTodoList","iabassist","dual.vim","kalt.vim","kaltex.vim","fbc.vim","operator-user","ats-lang-vim","MediaWiki-folding-and-syntax-highlight","EnhancedJumps","elise.vim","elisex.vim","Dictionary-file-for-Luxology-Modo-Python","argtextobj.vim","PKGBUILD","editsrec","regreplop.vim","ReplaceWithRegister","mrpink","tiddlywiki","PA_ruby_ri","EnumToCase","commentop.vim","SudoEdit.vim","vimrc","Screen-vim---gnu-screentmux","sign-diff","nextCS","Tag-Signature-Balloons","UltiSnips","textobj-syntax","mutt-aliases","mutt-canned","Proj","arc.vim","AutoFenc.vim","cssvar","math","Rename2","translit_converter","Syntax-Highlighting-for-db2diag.log","jsbeautify","tkl.vim","jslint.vim","donbass.vim","sherlock.vim","Notes","Buffer-Reminder-Remake","PreviewDialog","Logcat-syntax-highlighter","Syntastic","bib_autocomp.vim","v2.vim","bclear","vimper","blue.vim","ruby.vim","greek_polytonic.vim","git-cheat","falcon.vim","nuweb-multi-language","d8g_01","d8g_02","d8g_03","d8g_04","vimdiff-vcs","falcon.vim","banned.vim","delimitMate.vim","evening_2","color-chooser.vim","forneus","Mustang2","Quich-Filter","Tortoise","qtmplsel.vim","falcon.vim","falcon.vim","dull","Better-Javascript-Indentation","Join.vim","emv","vimscript","pipe.vim","JumpInCode","Conque-Shell","Crazy-Home-Key","grex","whitebox.vim","logpad.vim","vilight.vim","tir_black","gui2term.py","moss","python-tag-import","Django-helper-utils","operator-replace","DumbBuf","template-init.vim","wwwsearch","cpan.vim","Melt-Vim","InsertList","rargs.vim","cmdline-increment.vim","popup_it","perdirvimrc--Autoload-vimrc-files-per-di","hybridevel","phpErrorMarker","Functionator","CheckAttach.vim","SoftTabStops","Pasto","tango.vim","Windows-PowerShell-indent-enhanced","NERD_tree-Project","JavaScript-syntax-add-E4X-support","php_localvarcheck.vim","chocolate.vim","assistant","md5.vim","Nmap-syntax-highlight","haxe_plugin","fontsize.vim","InsertChar","hlasm.vim","term.vim","MailApp","PyMol-syntax","hornet.vim","Execute-selection-in-Python-and-append","testname","Asneeded-2","smarty-syntax","DBGp-client","sqlplus.vim","unicode.vim","baan.vim","libperl.vim","filter","multisearch.vim","RTM.vim","Cobalt-Colour-scheme","roo.vim","csv.vim","mimicpak","xmms2ctrl","buf_it","template.vim","phpcodesniffer.vim","wikinotes","powershellCall","HiVim","QuickFixHighlight","noused","coldgreen.vim","vorg","FlipLR","simple-comment","ywchaos","haskellFold","pod-helper.vim","Script-Walker","color-codes-SQL-keywords-from-Oracle-11g","FindInNERDTree","Speedware","perlomni.vim","go.vim","go.vim","github-theme","vimmpc","exjumplist","textobj-fatpack","grey2","prettyprint.vim","JumpInCode-new-update","GNU-as-syntax","NSIS-syntax-highlighting","colqer","gemcolors","Go-Syntax","fortran_line_length","Ruby-Single-Test","OmniTags","FindMate","signature_block.vim","record-repeat.vim","php.vim","signal_dec_VHDL","HTML-menu-for-GVIM","spinner.vim","RDoc","XPstatusline","rc.vim","mib_translator","Markdown","growlnotify.vim","JavaAspect","gsession.vim","cgc.vim","manuscript","CodeOverview","bluechia.vim","slurper.vim","create_start_fold_marker.vim","doubleTap","filetype-completion.vim","vikitasks","PyPit","open-terminal-filemanager","Chrysoprase","circos.vim","TxtBrowser","gitolite.vim","ShowFunc.vim","AuthorInfo","Cfengine-3-ftplugin","Cfengine-version-3-syntax","vim-addon-manager","Vim-Condensed-Quick-Reference","hlint","Enhanced-Ex","Flex-Development-Support","restart.vim","selfdot","syntaxGemfile.vim","spidermonkey.vim","pep8","startup_profile","extended-help","tplugin","SpitVspit","Preamble","Mercury-compiler-support","FirstEffectiveLine.vim","vimomni","std.vim","tocterm","apt-complete.vim","SnippetComplete","Dictionary-List-Replacements","Vimrc-Version-Numbering","mark_tools","rfc-syntax","fontzoom.vim","histwin.vim","vim-addon-fcsh","vim-addon-actions","superSnipMate","bzr-commit","hexHighlight.vim","Multi-Replace","strawimodo","vim-addon-mw-utils","actionscript3id.vim","RubySinatra","ccvext.vim","visualstar.vim","AutomaticLaTeXPlugin","AGTD","bvemu.vim","GoogleSuggest-Complete","The-Max-Impact-Experiment","cflow-output-colorful","SaneCL","c-standard-functions-highlight","Wavefronts-obj","hypergit.vim","hex.vim","csp.vim","load_template","emoticon.vim","emoticon.vim","bisect","groovyindent","liftweb.vim","line-number-yank","neutron.vim","SyntaxMotion.vim","Doxia-APT","daemon_saver.vim","ikiwiki-nav","ucf.vim","ISBN-10-to-EAN-13-converter","sha1.vim","hmac.vim","cucumber.zip","mrkn256.vim","fugitive.vim","blowfish.vim","underwater","trogdor","Parameter-Text-Objects","php-doc-upgrade","ZenCoding.vim","jumphl.vim","qmake--syntax.vim","R-syntax-highlighting","BUGS-language","AddCppClass","loadtags","OpenCL-C-syntax-highlighting","pummode","stickykey","rcom","SaveSigns","ywtxt","Rackup","colorselector","TranslateEnToCn","utlx_interwiki.vim","BackgroundColor.vim","django-template-textobjects","html-advanced-text-objects","candyman.vim","tag_in_new_tab","indentpython","vxfold.vim","simplecommenter","CSSMinister","Twee-Integration-for-Vim","httplog","treemenu.vim","delete-surround-html","tumblr.vim","vspec","tcommand","ColorX","alex.vim","happy.vim","Cppcheck-compiler","vim-addon-completion","spin.vim","EasyOpts","Find-files","Bookmarking","tslime.vim","vimake","Command-T","PickAColor.vim","grsecurity","rename.vim","tex-turkce","motpat.vim","orange","Mahewincs","Vim-Title-Formatter","syntaxhaskell.vim","tesla","XTermEsc","vim-indent-object","noweb.vim","vimgdb","cmd.vim","RST-Tables","css3","clevercss.vim","compilerpython.vim","cmakeref","operator-camelize","scalacommenter.vim","vicom","acomment","smartmove.vim","vimform","changesPlugin","Maynard","Otter.vim","ciscoasa.vim","translit3","vimsizer","tex_mini.vim","lastpos.vim","Manuals","VxLib","256-grayvim","mdark.vim","aftersyntaxc.vim","mayansmoke","repeater.vim","ref.vim","recover.vim","Slidedown-Syntax","ShowMultiBase","reimin","self.vim","kiss.vim","Trac-Wikimarkup","NrrwRgn","ego.vim","Delphi-7-2010","CodeFactory","JavaScript-Indent","tagmaster","qiushibaike","dc.vim","tf2.vim","glyph.vim","OutlookVim","GetFile","vimtl","RTL","Sessions","autocomp.vim","TortoiseTyping","syntax-codecsconf","cvsdiff.vim","yaifa.vim","Silence","PNote","mflrename","nevfn","Tumble","vplinst","tony_light","pyref.vim","legiblelight","truebasic.vim","writebackupToAdjacentDir","GUI-Box","LaTeX-Box","mdx.vim","leglight2","RemoveFile.vim","formatvim","easytags.vim","SingleCompile","CFWheels-Dictionary","fu","skk.vim","tcbuild.vim","grails-vim","django_templates.vim","PySuite","shell.vim","vim-addon-sbt","PIV","xpcomplete","gams","Search-in-Addressbook","teraterm","CountJump","darkBlue","underwater-mod","open-browser.vim","rvm.vim","Vim-Script-Updater","beluga-syntax","tac-syntax","datascript.vim","phd","obsidian","ez_scroll","vim-snipplr","vim-haxe","hgrev","zetavim","quickrun.vim","wmgraphviz","reload.vim","Smooth-Center","session.vim","pytestator","sablecc.vim","CSS-one-line--multi-line-folding","vorax","slang_syntax","ikiwiki-syntax","opencl.vim","gitview","ekini-dark-colorscheme","pep8","pyflakes","tabops","endline","pythondo","obviously-insert","toggle_mouse","regbuf.vim","mojo.vim","luainspect.vim","pw","phpcomplete.vim","SyntaxComplete","vimgcwsyntax","JsLint-Helper","Haskell-Highlight-Enhanced","typeredeemer","BusierBee","Shapley-Values","help_movement","diff_movement","fortunes_movement","mail_movement","CSS3-Highlights","vimpluginloader","jsonvim","vimstuff","vimargumentchec","vimcompcrtr","vimoop","yamlvim","DokuVimKi","jade.vim","v4daemon","ovim","Starting-.vimrc","gedim","current-func-info.vim","undofile.vim","vim-addon-ocaml","Haskell-Conceal","trailing-whitespace","rdark-terminal","mantip","htip","python_showpydoc.vim","tangoshady","bundler","cHiTags","Quotes","Smart-Parentheses","operator-reverse","python_showpydoc","rslTools","presets","View-Ports","Replay.vim","qnamebuf","processing-snipmate","ProjectTag","Better-CSS-Syntax-for-Vim","indexer.tar.gz","285colors-with-az-menu","LanguageTool","VIM-Color-Picker","Flex-4","lodestone","Simple-Javascript-Indenter","porter-stem","stem-search","TeX-PDF","PyInteractive","HTML5-Syntax-File","VimgrepBuffer","ToggleLineNumberMode","showcolor.vim","html5.vim","blockinsert","LimitWindowSize","minibufexplorerpp","tdvim_FoldDigest","bufsurf","Open-associated-programs","aspnetide.vim","Timer-routine","Heliotrope","CaptureClipboard","Shades-of-Amber","Zephyr-Color-Scheme","Jasmine-snippets-for-snipMate","swap","RubyProxy","L9","makesd.vim","ora-workbench","sequence","phaver","Say-Time","pyunit","clang","Son-of-Obisidian","Selenitic","diff-fold.vim","Bird-Syntax","Vimtodo","cSyntaxAfter","Code.Blocks-Dark","omnetpp","command-list","open_file_from_clip_board","CommandWithMutableRange","RangeMacro","tchaba","kirikiri.vim","Liquid-Carbon","actionscript.vim","ProjectCTags","Python-2.x-Standard-Library-Reference","Python-3.x-Standard-Library-Reference","ProjectParse","Tabbi","run_python_tests","eregex.vim","OMNeTpp4.x-NED-Syntax-file","Quotes","looks","Lite-Tab-Page","Show-mandictperldocpydocphpdoc-use-K","newsprint.vim","pf_earth.vim","RevealExtends","openurl.vim","southernlights","numbered.vim","grass.vim","toggle_option","idp.vim","sjump.vim","vim_faq","Sorcerer","up.vim","TrimBlank","clang-complete","smartbd","Gundo","altera_sta.vim","altera.vim","vim-addon-async","vim-refact","vydark","gdb4vim","savemap.vim","operator-html-escape","Mizore","maxivim","vim-addon-json-encoding","tohtml_wincp","vim-addon-signs","unite-colorscheme","unite-font","vim-addon-xdebug","VimCoder.jar","FTPDEV","lilypink","js-mask","vim-fileutils","stakeholders","PyScratch","Blueshift","VimCalc","unite-locate","lua_omni","verilog_systemverilog_fix","mheg","void","VIP","Smart-Home-Key","tracwiki","newspaper.vim","rdist-syntax","zenesque.vim","auto","VimOrganizer","stackoverflow.vim","preview","inccomplete","screen_line_jumper","chance-of-storm","unite-gem","devbox-dark-256","lastchange.vim","qthelp","auto_mkdir","jbosslog","wesnothcfg.vim","UnconditionalPaste","unite-yarm","NERD_Tree-and-ack","tabpagecolorscheme","Figlet.vim","Peasy","Indent-Guides","janitor.vim","southwest-fog","Ceasy","txt.vim","Shebang","vimblogger_ft","List-File","softbluev2","eteSkeleton","hdl_plugin","blockle.vim","ColorSelect","notes.vim","FanVim","Vimblr","vcslogdiff","JumpNextLongLine","vimorator","emacsmodeline.vim","textobj-rubyblock","StatusLineHighlight","shadow.vim","csc.vim","JumpToLastOccurrence","perfect.vim","polytonic.utf-8.spl","opencl.vim","iim.vim","line-based_jump_memory.vim","hdl_plugin","localrc.vim","BOOKMARKS--Mark-and-Highlight-Full-Lines","chapa","unite.vim","neverland.vim--All-colorschemes-suck","fokus","phpunit","vim-creole","Search-Google","mophiaSmoke","mophiaDark","Google-translator","auto-kk","update_perl_line_directives","headerGatesAdd.vim","JellyX","HJKL","nclipper.vim","syntax_check_embedded_perl.vim","xterm-color-table.vim","zazen","bocau","supp.vim","w3cvalidator","toner.vim","QCL-syntax-hilighting","kkruby.vim","hdl_plugin","Mind_syntax","Comment-Squawk","neco-ghc","pytest.vim","Enhanced-Javascript-syntax","LispXp","Nazca","obsidian2.vim","vim-addon-sml","pep8","AsyncCommand","lazysnipmate","Biorhythm","IniParser","codepath.vim","twilight256.vim","PreciseJump","cscope_plus.vim","Cobaltish","neco-look","XFST-syntax-file","Royal-Colorschemes","pbcopy.vim","golded.vim","Getafe","ParseJSON","activity-log","File-Case-Enforcer","Microchip-Linker-Script-syntax-file","RST-Tables-works-with-non-english-langu","lexctwolc-Syntax-Highlighter","mxl.vim","fecompressor.vim","Flog","Headlights","Chess-files-.pgn-extension","vim-paint","vundle","funprototypes.vim","SVF-syntax","indentpython.vim","Compile","dragon","Tabular","Tagbar","vimake-vim-programmers-ide","align","windows-sif-syntax","csc.snippets","tidydiff","latte","thermometer","Clean","Neopro","Vim-Blog","bitly.vim","bad-apple","robokai","makebg","asp.net","Atom","vim-remote","IPC-syntax-highlight","PyREPL.vim","phrase.vim","virtualenv.vim","reporoot.vim","rebar","urilib","visualctrlg","textmanip.vim","compilerg95.vim","Risto-Color-Scheme","underlinetag","paper","compilergfortran.vim","compilerifort.vim","Scala-argument-formatter","FindEverything","vim_etx","emacs-like-macro-recorder","To-Upper-case-case-changer","vim-erlang-skeleteons","taglist-plus","PasteBin.vim","compilerpcc.vim","scrnpipe.vim","TeX-9","extradite.vim","VimRepress","text-object-left-and-right","Scala-Java-Edit","vim-stylus","vim-activator","VimOutliner","avr8bit.vim","iconv","accentuate.vim","Solarized","Gravity","SAS-Syntax","gem.vim","vim-scala","Rename","EasyMotion","boost.vim","ciscoacl.vim","Distinguished","mush.vim","cmdline-completion","UltraBlog","GetFilePlus","strange","vim-task","Tab-Manager","XPath-Search","plantuml-syntax","rvmprompt.vim","Save-Current-Font","fatrat.vim","Sesiones.vim","opener.vim","cascading.vim","Google-Translate","molly.vim","jianfan","Dagon","plexer","vim-online","gsearch","Message-Formatter","sudoku_game","emacscommandline","fso","openscad.vim","editqf","visual-increment","gtrans.vim","PairTools","Table-Helper","DayTimeColorer","Amethyst","hier","Javascript-OmniCompletion-with-YUI-and-j","m2sh.vim","colorizer","Tabs-only-for-indentation","modelica","terse","dogmatic.vim","ro-when-swapfound","quit-another-window","gitv","Enter-Indent","jshint.vim","pacmanlog.vim","lastmod.vim","ignore-me","vim-textobj-quoted","simplenote.vim","Comceal","checklist.vim","typofree.vim","Redhawk-Vim-Plugin","vim-soy","Find-XML-Tags","cake.vim","vim-coffee-script","browserprint","jovial.vim","pdub","ucompleteme","ethna-switch","Fanfou.vim","colorv.vim","Advancer-Abbreviation","Auto-Pairs","octave.vim","cmdline-insertdatetime","reorder-columns","calm","nicer-vim-regexps","listtag","Diablo3","vim_django","nautilus-py-vim","IDLE","operator-star","XQuery-indentomnicompleteftplugin","browsereload-mac.vim","splitjoin.vim","vimshell-ssh","ShowMarks7","warez-colorscheme","Quicksilver.vim","wikilink","Buffergator","Buffersaurus","ri-viewer","beautiful-pastebin","chef.vim","indsas","lua.vim","AutoSaveSetting","resizewin","cpp_gnuchlog.vim","tangolight","IDSearch","frawor","git_patch_tags.vim","snipmate-snippets","widl.vim","WinFastFind","ReplaceFile","gUnit-syntax","Handlebars","svnst.vim","The-Old-Ones","Atomic-Save","vim-orgmode","Vimper-IDE","vimgtd","gnupg.vim","Filesearch","VimLite","AutoCpp","simpleRGB","cakephp.vim","googleclosurevim","vim-task-org","brep","vrackets","xorium.vim","transpose-words","Powershell-FTDetect","LycosaExplorer","ldap_schema.vim","Lookup","Intelligent-Tags","lemon.vim","SnipMgr","repeat-motion","skyWeb","Toxic","sgmlendtag","rake.vim","orangeocean256","cdevframework","textgenshi.vim","aldmeris","univresal-blue-scheme","cab.vim","copy-as-rtf","baobaozhu","rfc5424","saturn.vim","tablistlite.vim","functionlist.vim","hints_opengl.vim","wikiatovimhelp","ctags_cache","werks.vim","RegImap","Calm-Breeze","Rst-edit-block-in-tab","Ambient-Color-Scheme","golden-ratio","annotatedmarks","quickhl.vim","FixCSS.vim","enablelvimrc.vim","commentary.vim","prefixer.vim","cssbaseline.vim","html_emogrifier.vim","Premailer.vim","tryit.vim","fthook.vim","sql.vim","zim-syntax","Transcription-Name-Helper","Rcode","obvious-resize","lemon256","swapcol.vim","vim-ipython","EasyPeasy","chinachess.vim","tabpage.vim","tabasco","light2011","numlist.vim","fuzzee.vim","SnippetySnip","melt-syntax","diffwindow_movement","noweboutline.vim","Threesome","quickfixstatus.vim","SimpylFold","indent-motion","mcabberlog.vim","easychair","right_align","galaxy.vim","vim-pandoc","putcmd.vim","vim-rpsl","olga_key","statusline.vim","bad-whitespace","ctrlp.vim","sexy-railscasts","TagmaTips","blue_sky","gccsingle.vim","kiwi.vim","mediawiki","Vimerl","MarkdownFootnotes","linediff.vim","watchdog.vim","syntaxdosini.vim","pylint-mode","NagelfarVim","TclShell","google_prettify.vim","Vimpy","vim-pad","baancomplete","racket.vim","scribble.vim","racket-auto-keywords.vim","Ambient-Theme","White","vim-dokuwiki","slide-show","Speech","vim-google-scribe","fcitx.vim","TagmaTasks","vimroom.vim","MapFinder","mappingmanager","ahkcomplete","Python-mode-klen","tagfinder.vim","rainbow_parentheses.vim","Lyrics","abbott.vim","wiki.vim","todotxt.vim","RST-Tables-CJK","utags","mango.vim","indentfolds","Twilight-for-python","Python-Syntax","vim-json-bundle","VIM-Metaprogramming","statline","SonicTemplate.vim","vim-mnml","Tagma-Buffer-Manager","desert-warm-256","html-source-explorer","codepaper","php-doc","Cpp11-Syntax-Support","node.js","Cleanroom","anwolib","fontforge_script.vim","prop.vim","vim-symbols-strings","vim-diff","openrel.vim","apg.vim","TFS","ipi","RSTO","project.vim","tex_AutoKeymap","log.vim","mirodark","vim-kickstart","MatchTag","Lisper.vim","Dart","vim-ocaml-conceal","csslint.vim","nu42dark-color-scheme","Colour-theme-neon-pk","simple_bookmarks.vim","modeleasy-vim-plugin","aurum","inline_edit.vim","better-snipmate-snippet","LastBuf.vim","SchemeXp","TVO--The-Vim-Outliner-with-asciidoc-supp","yankstack","vim-octopress","ChickenMetaXp","ChickenSetupXp","nscripter.vim","weibo.vim","vim-python-virtualenv","vim-django-support","nose.vim","nodeunit.vim","SpellCheck","lrc.vim","cue.vim","visualrepeat","git-time-lapse","boolpat.vim","Mark-Ring","Festoon","dokuwiki","unite-scriptenames","ide","tocdown","Word-Fuzzy-Completion","rmvim","Xoria256m","shelp","Lawrencium","grads.vim","epegzz.vim","Eddie.vim","behat.zip","phidgets.vim","gtags-multiwindow-browsing","lightdiff","vm.vim","SmartusLine","vimprj","turbux.vim","html-xml-tag-matcher","git-diff","ft_improved","nerdtree-ack","ambicmd.vim","fountain.vim","Powerline","EasyDigraph.vim","autosess","DfrankUtil","ruscmd","textobj-line","Independence","qtpy.vim","switch-buffer-quickly","simple-dark","gf-user","gf-diff","viewdoc","Limbo-syntax","rhinestones","buffet.vim","pwdstatus.vim","gtk-mode","indentjava.vim","coffee-check.vim-B","coffee-check.vim","compot","xsnippet","nsl.vim","vombato-colorscheme","ocamlMultiAnnot","mozpp.vim","mozjs.vim","e2.lua","gmlua.vim","vim-punto-switcher","toggle_comment","CapsulaPigmentorum.vim","CompleteHelper","CamelCaseComplete","vim-addon-haskell","tagport","cd-hook","pfldap.vim","WhiteWash","TagmaLast","Gummybears","taskmanagementvim","flymaker","ditaa","lout.vim","vim-flake8","phpcs.vim","badwolf","jbi.vim","Vim-Support","murphi.vim","argumentative.vim","editorconfig-vim","thinkpad.vim","Coverity-compiler-plugin","vim-wmfs","Trailer-Trash","ipyqtmacvim.vim","writebackupAutomator","CodeCommenter","sandbox_hg","pdv-standalone","Yii-API-manual-for-Vim","fountainwiki.vim","hop-language-syntax-highlight","Skittles-Berry","django.vim","pyunit.vim","EasyColour","tmpclip.vim","Improved-paragraph-motion","tortex","Add-to-Word-Search","fwk-notes","calendar.vim","mystatusinfo.vim","workflowish","tabman.vim","flashdevelop.vim","hammer.vim","Colorizer--Brabandt","less-syntax","DynamicSigns","ShowTrailingWhitespace","DeleteTrailingWhitespace","JumpToTrailingWhitespace","source.vim","mediawiki.vim","regexroute.vim","css3-syntax-plus","diff-toggle","showmarks2","Finder-for-vim","vim-human-dates","vim-addon-commenting","cudajinja.vim","vim-pomodoro","phpqa","TaskMotions","ConflictMotions","Sauce","gitvimrc.vim","instant-markdown.vim","vroom","portmon","spacebox.vim","paredit.vim","Ayumi","Clam","vim_movement","vbs_movement","dosbatch_movement","TextTransform","HyperList","python-imports.vim","youdao.dict","XDebug-DBGp-client-for-PHP","Vim-Gromacs","vimux","Vimpy--Stoner","readnovel","Vitality","close-duplicate-tabs","StripWhiteSpaces","vim-jsbeautify","clean_imports","WebAPI.vim","flipwords.vim","restore_view.vim","SpaceBetween","autolink","vim-addon-rdebug","DBGp-X-client","Splice","vim-htmldjango_omnicomplete","vim-addon-ruby-debug-ide","a-new-txt2tags-syntax","vim-cpp-auto-include","rstatusline","muxmate","vim4rally","SAS-Indent","modx","ucpp-vim-syntax","bestfriend.vim","vim-dasm","evervim","Fortune-vimtips","VDBI.vim","Ideone.vim","neocomplcache-snippets_complete","RbREPL.vim","AmbiCompletion","london.vim","jsruntime.vim","maven-plugin","vim-mou","Transpose","PHPUnit-QF","TimeTap","jsoncodecs.vim","jsflakes.vim","jsflakes","DBGPavim","nosyntaxwords","mathematic.vim","vtimer.vim","_jsbeautify","license-loader","cmdpathup","matchindent.vim","automatic-for-Verilog--guo","lingodirector.vim--Pawlik","Ubloh-Color-Scheme","html_FileCompletion","PyChimp","sonoma.vim","highlights-for-radiologist","Xdebug","burnttoast256","vmark.vim--Visual-Bookmarking","gprof.vim","jshint.vim--Stelmach","sourcebeautify.vim","HgCi","EscapeBchars","cscope.vim","php-cs-fixer","cst","OnSyntaxChange","python_fold_compact","EditPlus"]zhimakaimen:/vimfiles/bundle/.vundle/script-names.vim-scripts.org.json
*~
*.swp
tags
zhimakaimen:/vimfiles/bundle/nerdcommenter/.gitignore
" ============================================================================
" File:        NERD_commenter.vim
" Description: vim global plugin that provides easy code commenting
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Version:     2.3.0
" Last Change: Wed Dec 14 08:00 AM 2011 EST
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================

" Section: script init stuff {{{1
if exists("loaded_nerd_comments")
    finish
endif
if v:version < 700
    echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_comments = 1

" Function: s:InitVariable() function {{{2
" This function is used to initialise a given variable to a given value. The
" variable is only initialised if it does not exist prior
"
" Args:
"   -var: the name of the var to be initialised
"   -value: the value to initialise var to
"
" Returns:
"   1 if the var is set, 0 otherwise
function s:InitVariable(var, value)
    if !exists(a:var)
        execute 'let ' . a:var . ' = ' . "'" . a:value . "'"
        return 1
    endif
    return 0
endfunction

" Section: space string init{{{2
" When putting spaces after the left delim and before the right we use
" s:spaceStr for the space char. This way we can make it add anything after
" the left and before the right by modifying this variable
let s:spaceStr = ' '
let s:lenSpaceStr = strlen(s:spaceStr)

" Section: variable initialization {{{2
call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)
call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)
call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)
call s:InitVariable("g:NERDCompactSexyComs", 0)
call s:InitVariable("g:NERDCreateDefaultMappings", 1)
call s:InitVariable("g:NERDDefaultNesting", 1)
call s:InitVariable("g:NERDMenuMode", 3)
call s:InitVariable("g:NERDLPlace", "[>")
call s:InitVariable("g:NERDUsePlaceHolders", 1)
call s:InitVariable("g:NERDRemoveAltComs", 1)
call s:InitVariable("g:NERDRemoveExtraSpaces", 0)
call s:InitVariable("g:NERDRPlace", "<]")
call s:InitVariable("g:NERDSpaceDelims", 0)

let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"

let s:delimiterMap = {
    \ 'aap': { 'left': '#' },
    \ 'abc': { 'left': '%' },
    \ 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ada': { 'left': '--', 'leftAlt': '--  ' },
    \ 'ahdl': { 'left': '--' },
    \ 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'amiga': { 'left': ';' },
    \ 'aml': { 'left': '/*' },
    \ 'ampl': { 'left': '#' },
    \ 'apache': { 'left': '#' },
    \ 'apachestyle': { 'left': '#' },
    \ 'asciidoc': { 'left': '//' },
    \ 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'armasm': { 'left': ';' },
    \ 'asm68k': { 'left': ';' },
    \ 'asm': { 'left': ';', 'leftAlt': '#' },
    \ 'asn': { 'left': '--' },
    \ 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'asterisk': { 'left': ';' },
    \ 'asy': { 'left': '//' },
    \ 'atlas': { 'left': 'C', 'right': '$' },
    \ 'autohotkey': { 'left': ';' },
    \ 'autoit': { 'left': ';' },
    \ 'ave': { 'left': "'" },
    \ 'awk': { 'left': '#' },
    \ 'basic': { 'left': "'", 'leftAlt': 'REM ' },
    \ 'bbx': { 'left': '%' },
    \ 'bc': { 'left': '#' },
    \ 'bib': { 'left': '%' },
    \ 'bindzone': { 'left': ';' },
    \ 'bst': { 'left': '%' },
    \ 'btm': { 'left': '::' },
    \ 'cabal': { 'left': '--' },
    \ 'caos': { 'left': '*' },
    \ 'calibre': { 'left': '//' },
    \ 'catalog': { 'left': '--', 'right': '--' },
    \ 'c': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'cf': { 'left': '<!---', 'right': '--->' },
    \ 'cfg': { 'left': '#' },
    \ 'cg': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ch': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cl': { 'left': '#' },
    \ 'clean': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clipper': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clojure': { 'left': ';' },
    \ 'cmake': { 'left': '#' },
    \ 'coffee': { 'left': '#' },
    \ 'conkyrc': { 'left': '#' },
    \ 'context': { 'left': '%', 'leftAlt': '--' },
    \ 'cpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cuda': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'crontab': { 'left': '#' },
    \ 'cs': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'csp': { 'left': '--' },
    \ 'cterm': { 'left': '*' },
    \ 'cucumber': { 'left': '#' },
    \ 'cvs': { 'left': 'CVS:' },
    \ 'd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dcl': { 'left': '$!' },
    \ 'dakota': { 'left': '#' },
    \ 'debcontrol': { 'left': '#' },
    \ 'debsources': { 'left': '#' },
    \ 'def': { 'left': ';' },
    \ 'desktop': { 'left': '#' },
    \ 'dhcpd': { 'left': '#' },
    \ 'diff': { 'left': '#' },
    \ 'django': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'docbk': { 'left': '<!--', 'right': '-->' },
    \ 'dns': { 'left': ';' },
    \ 'dosbatch': { 'left': 'REM ', 'leftAlt': '::' },
    \ 'dosini': { 'left': ';' },
    \ 'dot': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dracula': { 'left': ';' },
    \ 'dsl': { 'left': ';' },
    \ 'dtml': { 'left': '<dtml-comment>', 'right': '</dtml-comment>' },
    \ 'dylan': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ebuild': { 'left': '#' },
    \ 'ecd': { 'left': '#' },
    \ 'eclass': { 'left': '#' },
    \ 'eiffel': { 'left': '--' },
    \ 'elf': { 'left': "'" },
    \ 'elmfilt': { 'left': '#' },
    \ 'erlang': { 'left': '%', 'leftAlt': '%%' },
    \ 'eruby': { 'left': '<%#', 'right': '%>', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'expect': { 'left': '#' },
    \ 'exports': { 'left': '#' },
    \ 'fancy': { 'left': '#' },
    \ 'factor': { 'left': '! ', 'leftAlt': '!# ' },
    \ 'fgl': { 'left': '#' },
    \ 'focexec': { 'left': '-*' },
    \ 'form': { 'left': '*' },
    \ 'foxpro': { 'left': '*' },
    \ 'fsharp': { 'left': '(*', 'right': '*)', 'leftAlt': '//' },
    \ 'fstab': { 'left': '#' },
    \ 'fvwm': { 'left': '#' },
    \ 'fx': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gams': { 'left': '*' },
    \ 'gdb': { 'left': '#' },
    \ 'gdmo': { 'left': '--' },
    \ 'geek': { 'left': 'GEEK_COMMENT:' },
    \ 'genshi': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'gentoo-conf-d': { 'left': '#' },
    \ 'gentoo-env-d': { 'left': '#' },
    \ 'gentoo-init-d': { 'left': '#' },
    \ 'gentoo-make-conf': { 'left': '#' },
    \ 'gentoo-package-keywords': { 'left': '#' },
    \ 'gentoo-package-mask': { 'left': '#' },
    \ 'gentoo-package-use': { 'left': '#' },
    \ 'gitcommit': { 'left': '#' },
    \ 'gitconfig': { 'left': ';' },
    \ 'gitrebase': { 'left': '#' },
    \ 'gnuplot': { 'left': '#' },
    \ 'go': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'groovy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gsp': { 'left': '<%--', 'right': '--%>', 'leftAlt': '<!--','rightAlt': '-->'},
    \ 'gtkrc': { 'left': '#' },
    \ 'haskell': { 'left': '{-','right': '-}', 'leftAlt': '--' },
    \ 'hb': { 'left': '#' },
    \ 'h': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'haml': { 'left': '-#', 'leftAlt': '/' },
    \ 'haxe': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hercules': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hog': { 'left': '#' },
    \ 'hostsaccess': { 'left': '#' },
    \ 'htmlcheetah': { 'left': '##' },
    \ 'htmldjango': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'htmlos': { 'left': '#', 'right': '/#' },
    \ 'hxml': { 'left': '#' },
    \ 'ia64': { 'left': '#' },
    \ 'icon': { 'left': '#' },
    \ 'idlang': { 'left': ';' },
    \ 'idl': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'inform': { 'left': '!' },
    \ 'inittab': { 'left': '#' },
    \ 'ishd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'iss': { 'left': ';' },
    \ 'ist': { 'left': '%' },
    \ 'jade': { 'left': '//-', 'leftAlt': '//' },
    \ 'java': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javacc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript.jquery': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'jess': { 'left': ';' },
    \ 'jgraph': { 'left': '(*', 'right': '*)' },
    \ 'jproperties': { 'left': '#' },
    \ 'jsp': { 'left': '<%--', 'right': '--%>' },
    \ 'kix': { 'left': ';' },
    \ 'kscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'lace': { 'left': '--' },
    \ 'ldif': { 'left': '#' },
    \ 'less': { 'left': '/*','right': '*/' },
    \ 'lhaskell': { 'left': '>{-','right': '-}', 'leftAlt': '>-- ' },
    \ 'lilo': { 'left': '#' },
    \ 'lilypond': { 'left': '%' },
    \ 'liquid': { 'left': '{% comment %}', 'right': '{% endcomment %}' },
    \ 'lisp': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'llvm': { 'left': ';' },
    \ 'lotos': { 'left': '(*', 'right': '*)' },
    \ 'lout': { 'left': '#' },
    \ 'lprolog': { 'left': '%' },
    \ 'lscript': { 'left': "'" },
    \ 'lss': { 'left': '#' },
    \ 'lua': { 'left': '--', 'leftAlt': '--[[', 'rightAlt': ']]' },
    \ 'lynx': { 'left': '#' },
    \ 'lytex': { 'left': '%' },
    \ 'mail': { 'left': '> ' },
    \ 'mako': { 'left': '##' },
    \ 'man': { 'left': '."' },
    \ 'map': { 'left': '%' },
    \ 'maple': { 'left': '#' },
    \ 'markdown': { 'left': '<!--', 'right': '-->' },
    \ 'masm': { 'left': ';' },
    \ 'mason': { 'left': '<% #', 'right': '%>' },
    \ 'master': { 'left': '$' },
    \ 'matlab': { 'left': '%' },
    \ 'mel': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'mib': { 'left': '--' },
    \ 'mirah': {'left': '#'},
    \ 'mkd': { 'left': '>' },
    \ 'mma': { 'left': '(*', 'right': '*)' },
    \ 'model': { 'left': '$', 'right': '$' },
    \ 'moduala.': { 'left': '(*', 'right': '*)' },
    \ 'modula2': { 'left': '(*', 'right': '*)' },
    \ 'modula3': { 'left': '(*', 'right': '*)' },
    \ 'monk': { 'left': ';' },
    \ 'mush': { 'left': '#' },
    \ 'mustache': { 'left': '{{!', 'right': '}}' },
    \ 'named': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'nasm': { 'left': ';' },
    \ 'nastran': { 'left': '$' },
    \ 'natural': { 'left': '/*' },
    \ 'ncf': { 'left': ';' },
    \ 'newlisp': { 'left': ';' },
    \ 'nginx': { 'left': '#' },
    \ 'nimrod': { 'left': '#' },
    \ 'nroff': { 'left': '\"' },
    \ 'nsis': { 'left': '#' },
    \ 'ntp': { 'left': '#' },
    \ 'objc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objcpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objj': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ocaml': { 'left': '(*', 'right': '*)' },
    \ 'occam': { 'left': '--' },
    \ 'octave': { 'left': '%', 'leftAlt': '#' },
    \ 'omlet': { 'left': '(*', 'right': '*)' },
    \ 'omnimark': { 'left': ';' },
    \ 'ooc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'openroad': { 'left': '//' },
    \ 'opl': { 'left': "REM" },
    \ 'ora': { 'left': '#' },
    \ 'ox': { 'left': '//' },
    \ 'pascal': { 'left': '{','right': '}', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'patran': { 'left': '$', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pcap': { 'left': '#' },
    \ 'pccts': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pdf': { 'left': '%' },
    \ 'perl': { 'left': '#' },
    \ 'pfmain': { 'left': '//' },
    \ 'php': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pic': { 'left': ';' },
    \ 'pike': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pilrc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pine': { 'left': '#' },
    \ 'plm': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'plsql': { 'left': '-- ', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'po': { 'left': '#' },
    \ 'postscr': { 'left': '%' },
    \ 'pov': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'povini': { 'left': ';' },
    \ 'ppd': { 'left': '%' },
    \ 'ppwiz': { 'left': ';;' },
    \ 'processing': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'prolog': { 'left': '%', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ps1': { 'left': '#' },
    \ 'psf': { 'left': '#' },
    \ 'ptcap': { 'left': '#' },
    \ 'puppet': { 'left': '#' },
    \ 'python': { 'left': '#' },
    \ 'radiance': { 'left': '#' },
    \ 'ratpoison': { 'left': '#' },
    \ 'r': { 'left': '#' },
    \ 'rc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'rebol': { 'left': ';' },
    \ 'registry': { 'left': ';' },
    \ 'remind': { 'left': '#' },
    \ 'resolv': { 'left': '#' },
    \ 'rgb': { 'left': '!' },
    \ 'rib': { 'left': '#' },
    \ 'robots': { 'left': '#' },
    \ 'rspec': { 'left': '#' },
    \ 'ruby': { 'left': '#' },
    \ 'sa': { 'left': '--' },
    \ 'samba': { 'left': ';', 'leftAlt': '#' },
    \ 'sass': { 'left': '//', 'leftAlt': '/*' },
    \ 'sather': { 'left': '--' },
    \ 'scala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'scons': { 'left': '#' },
    \ 'scheme': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'scilab': { 'left': '//' },
    \ 'scsh': { 'left': ';' },
    \ 'scss': { 'left': '/*', 'right': '*/', 'leftAlt': '//' },
    \ 'sed': { 'left': '#' },
    \ 'sgmldecl': { 'left': '--', 'right': '--' },
    \ 'sgmllnx': { 'left': '<!--', 'right': '-->' },
    \ 'sh': { 'left': '#' },
    \ 'sicad': { 'left': '*' },
    \ 'simula': { 'left': '%', 'leftAlt': '--' },
    \ 'sinda': { 'left': '$' },
    \ 'skill': { 'left': ';' },
    \ 'slang': { 'left': '%' },
    \ 'slice': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'slim': { 'left': '/', 'leftAlt': '/!' },
    \ 'slrnrc': { 'left': '%' },
    \ 'sm': { 'left': '#' },
    \ 'smarty': { 'left': '{*', 'right': '*}' },
    \ 'smil': { 'left': '<!', 'right': '>' },
    \ 'smith': { 'left': ';' },
    \ 'sml': { 'left': '(*', 'right': '*)' },
    \ 'snnsnet': { 'left': '#' },
    \ 'snnspat': { 'left': '#' },
    \ 'snnsres': { 'left': '#' },
    \ 'snobol4': { 'left': '*' },
    \ 'spec': { 'left': '#' },
    \ 'specman': { 'left': '//' },
    \ 'spectre': { 'left': '//', 'leftAlt': '*' },
    \ 'spice': { 'left': '$' },
    \ 'sql': { 'left': '-- ' },
    \ 'sqlforms': { 'left': '-- ' },
    \ 'sqlj': { 'left': '-- ' },
    \ 'sqr': { 'left': '!' },
    \ 'squid': { 'left': '#' },
    \ 'st': { 'left': '"' },
    \ 'stp': { 'left': '--' },
    \ 'supercollider': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tads': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tags': { 'left': ';' },
    \ 'tak': { 'left': '$' },
    \ 'tasm': { 'left': ';' },
    \ 'tcl': { 'left': '#' },
    \ 'texinfo': { 'left': "@c " },
    \ 'texmf': { 'left': '%' },
    \ 'tf': { 'left': ';' },
    \ 'tidy': { 'left': '#' },
    \ 'tli': { 'left': '#' },
    \ 'tmux': { 'left': '#' },
    \ 'trasys': { 'left': "$" },
    \ 'tsalt': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tsscl': { 'left': '#' },
    \ 'tssgm': { 'left': "comment = '", 'right': "'" },
    \ 'txt2tags': { 'left': '%' },
    \ 'twig': { 'left': '{#', 'right': '#}' },
    \ 'uc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'uil': { 'left': '!' },
    \ 'vala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vb': { 'left': "'" },
    \ 'velocity': { 'left': "##", 'right': "", 'leftAlt': '#*', 'rightAlt': '*#' },
    \ 'vera': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'verilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'verilog_systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vgrindefs': { 'left': '#' },
    \ 'vhdl': { 'left': '--' },
    \ 'vimperator': { 'left': '"' },
    \ 'virata': { 'left': '%' },
    \ 'vrml': { 'left': '#' },
    \ 'vsejcl': { 'left': '/*' },
    \ 'webmacro': { 'left': '##' },
    \ 'wget': { 'left': '#' },
    \ 'Wikipedia': { 'left': '<!--', 'right': '-->' },
    \ 'winbatch': { 'left': ';' },
    \ 'wml': { 'left': '#' },
    \ 'wvdial': { 'left': ';' },
    \ 'xdefaults': { 'left': '!' },
    \ 'xkb': { 'left': '//' },
    \ 'xmath': { 'left': '#' },
    \ 'xpm2': { 'left': '!' },
    \ 'xquery': { 'left': '(:', 'right': ':)' },
    \ 'z8a': { 'left': ';' }
    \ }

if exists("g:NERDCustomDelimiters")
    call extend(s:delimiterMap, g:NERDCustomDelimiters)
endif

" Section: Comment mapping functions, autocommands and commands {{{1
" ============================================================================
" Section: Comment enabler autocommands {{{2
" ============================================================================

augroup NERDCommenter

    "if the user enters a buffer or reads a buffer then we gotta set up
    "the comment delimiters for that new filetype
    autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)

    "if the filetype of a buffer changes, force the script to reset the
    "delims for the buffer
    autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)
augroup END


" Function: s:SetUpForNewFiletype(filetype) function {{{2
" This function is responsible for setting up buffer scoped variables for the
" given filetype.
"
" Args:
"   -filetype: the filetype to set delimiters for
"   -forceReset: 1 if the delimiters should be reset if they have already be
"    set for this buffer.
"
function s:SetUpForNewFiletype(filetype, forceReset)
    let ft = a:filetype

    "for compound filetypes, if we dont know how to handle the full filetype
    "then break it down and use the first part that we know how to handle
    if ft =~ '\.' && !has_key(s:delimiterMap, ft)
        let filetypes = split(a:filetype, '\.')
        for i in filetypes
            if has_key(s:delimiterMap, i)
                let ft = i
                break
            endif
        endfor
    endif

    let b:NERDSexyComMarker = ''

    if has_key(s:delimiterMap, ft)
        let b:NERDCommenterDelims = s:delimiterMap[ft]
        for i in ['left', 'leftAlt', 'right', 'rightAlt']
            if !has_key(b:NERDCommenterDelims, i)
                let b:NERDCommenterDelims[i] = ''
            endif
        endfor
    else
        let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    endif

endfunction

function s:CreateDelimMapFromCms()
    return {
        \ 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''),
        \ 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'),
        \ 'leftAlt': '',
        \ 'rightAlt': '' }
endfunction

" Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2
" This function is used to swap the delimiters that are being used to the
" alternative delimiters for that filetype. For example, if a c++ file is
" being edited and // comments are being used, after this function is called
" /**/ comments will be used.
"
" Args:
"   -printMsgs: if this is 1 then a message is echoed to the user telling them
"    if this function changed the delimiters or not
function s:SwitchToAlternativeDelimiters(printMsgs)
    "if both of the alternative delimiters are empty then there is no
    "alternative comment style so bail out
    if b:NERDCommenterDelims['leftAlt'] == '' && b:NERDCommenterDelims['rightAlt'] == ''
        if a:printMsgs
            call s:NerdEcho("Cannot use alternative delimiters, none are specified", 0)
        endif
        return 0
    endif

    "save the current delimiters
    let tempLeft = s:Left()
    let tempRight = s:Right()

    "swap current delimiters for alternative
    let b:NERDCommenterDelims['left'] = b:NERDCommenterDelims['leftAlt']
    let b:NERDCommenterDelims['right'] = b:NERDCommenterDelims['rightAlt']

    "set the previously current delimiters to be the new alternative ones
    let b:NERDCommenterDelims['leftAlt'] = tempLeft
    let b:NERDCommenterDelims['rightAlt'] = tempRight

    "tell the user what comment delimiters they are now using
    if a:printMsgs
        call s:NerdEcho("Now using " . s:Left() . " " . s:Right() . " to delimit comments", 1)
    endif

    return 1
endfunction

" Section: Comment delimiter add/removal functions {{{1
" ============================================================================
" Function: s:AppendCommentToLine(){{{2
" This function appends comment delimiters at the EOL and places the cursor in
" position to start typing the comment
function s:AppendCommentToLine()
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    " get the len of the right delim
    let lenRight = strlen(right)

    let isLineEmpty = strlen(getline(".")) == 0
    let insOrApp = (isLineEmpty==1 ? 'i' : 'A')

    "stick the delimiters down at the end of the line. We have to format the
    "comment with spaces as appropriate
    execute ":normal! " . insOrApp . (isLineEmpty ? '' : ' ') . left . right . " "

    " if there is a right delimiter then we gotta move the cursor left
    " by the len of the right delimiter so we insert between the delimiters
    if lenRight > 0
        let leftMoveAmount = lenRight
        execute ":normal! " . leftMoveAmount . "h"
    endif
    startinsert
endfunction

" Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2
" This function is used to comment out a region of code. This region is
" specified as a bounding box by arguments to the function.
"
" Args:
"   -top: the line number for the top line of code in the region
"   -bottom: the line number for the bottom line of code in the region
"   -lSide: the column number for the left most column in the region
"   -rSide: the column number for the right most column in the region
"   -forceNested: a flag indicating whether comments should be nested
function s:CommentBlock(top, bottom, lSide, rSide, forceNested )
    " we need to create local copies of these arguments so we can modify them
    let top = a:top
    let bottom = a:bottom
    let lSide = a:lSide
    let rSide = a:rSide

    "if the top or bottom line starts with tabs we have to adjust the left and
    "right boundaries so that they are set as though the tabs were spaces
    let topline = getline(top)
    let bottomline = getline(bottom)
    if s:HasLeadingTabs(topline, bottomline)

        "find out how many tabs are in the top line and adjust the left
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(topline)
        if lSide < numTabs
            let lSide = &ts * lSide
        else
            let lSide = (lSide - numTabs) + (&ts * numTabs)
        endif

        "find out how many tabs are in the bottom line and adjust the right
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(bottomline)
        let rSide = (rSide - numTabs) + (&ts * numTabs)
    endif

    "we must check that bottom IS actually below top, if it is not then we
    "swap top and bottom. Similarly for left and right.
    if bottom < top
        let temp = top
        let top = bottom
        let bottom = top
    endif
    if rSide < lSide
        let temp = lSide
        let lSide = rSide
        let rSide = temp
    endif

    "if the current delimiters arent multipart then we will switch to the
    "alternative delims (if THEY are) as the comment will be better and more
    "accurate with multipart delims
    let switchedDelims = 0
    if !s:Multipart() && g:NERDAllowAnyVisualDelims && s:AltMultipart()
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "start the commenting from the top and keep commenting till we reach the
    "bottom
    let currentLine=top
    while currentLine <= bottom

        "check if we are allowed to comment this line
        if s:CanCommentLine(a:forceNested, currentLine)

            "convert the leading tabs into spaces
            let theLine = getline(currentLine)
            let lineHasLeadTabs = s:HasLeadingTabs(theLine)
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif

            "dont comment lines that begin after the right boundary of the
            "block unless the user has specified to do so
            if theLine !~ '^ \{' . rSide . '\}' || !g:NERDBlockComIgnoreEmpty

                "attempt to place the cursor in on the left of the boundary box,
                "then check if we were successful, if not then we cant comment this
                "line
                call setline(currentLine, theLine)
                if s:CanPlaceCursor(currentLine, lSide)

                    let leftSpaced = s:Left({'space': 1})
                    let rightSpaced = s:Right({'space': 1})

                    "stick the left delimiter down
                    let theLine = strpart(theLine, 0, lSide-1) . leftSpaced . strpart(theLine, lSide-1)

                    if s:Multipart()
                        "stick the right delimiter down
                        let theLine = strpart(theLine, 0, rSide+strlen(leftSpaced)) . rightSpaced . strpart(theLine, rSide+strlen(leftSpaced))

                        let firstLeftDelim = s:FindDelimiterIndex(s:Left(), theLine)
                        let lastRightDelim = s:LastIndexOfDelim(s:Right(), theLine)

                        if firstLeftDelim != -1 && lastRightDelim != -1
                            let searchStr = strpart(theLine, 0, lastRightDelim)
                            let searchStr = strpart(searchStr, firstLeftDelim+strlen(s:Left()))

                            "replace the outter most delims in searchStr with
                            "place-holders
                            let theLineWithPlaceHolders = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, searchStr)

                            "add the right delimiter onto the line
                            let theLine = strpart(theLine, 0, firstLeftDelim+strlen(s:Left())) . theLineWithPlaceHolders . strpart(theLine, lastRightDelim)
                        endif
                    endif
                endif
            endif

            "restore tabs if needed
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingSpacesToTabs(theLine)
            endif

            call setline(currentLine, theLine)
        endif

        let currentLine = currentLine + 1
    endwhile

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif
endfunction

" Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2
" This function comments a range of lines.
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -align: should be "left" or "both" or "none"
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLines(forceNested, align, firstLine, lastLine)
    " we need to get the left and right indexes of the leftmost char in the
    " block of of lines and the right most char so that we can do alignment of
    " the delimiters if the user has specified
    let leftAlignIndx = s:LeftMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)
    let rightAlignIndx = s:RightMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)

    " gotta add the length of the left delimiter onto the rightAlignIndx cos
    " we'll be adding a left delim to the line
    let rightAlignIndx = rightAlignIndx + strlen(s:Left({'space': 1}))

    " now we actually comment the lines. Do it line by line
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanCommentLine(a:forceNested, currentLine)
            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if a:forceNested && g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            " find out if the line is commented using normal delims and/or
            " alternate ones
            let isCommented = s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)

            " check if we can comment this line
            if !isCommented || g:NERDUsePlaceHolders || s:Multipart()
                if a:align == "left" || a:align == "both"
                    let theLine = s:AddLeftDelimAligned(s:Left({'space': 1}), theLine, leftAlignIndx)
                else
                    let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
                endif
                if a:align == "both"
                    let theLine = s:AddRightDelimAligned(s:Right({'space': 1}), theLine, rightAlignIndx)
                else
                    let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
                endif
            endif
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2
" This function comments a range of lines in a minimal style. I
"
" Args:
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesMinimal(firstLine, lastLine)
    "check that minimal comments can be done on this filetype
    if !s:HasMultipartDelims()
        throw 'NERDCommenter.Delimiters exception: Minimal comments can only be used for filetypes that have multipart delimiters'
    endif

    "if we need to use place holders for the comment, make sure they are
    "enabled for this filetype
    if !g:NERDUsePlaceHolders && s:DoesBlockHaveMultipartDelim(a:firstLine, a:lastLine)
        throw 'NERDCommenter.Settings exception: Place holders are required but disabled.'
    endif

    "get the left and right delims to smack on
    let left = s:GetSexyComLeft(g:NERDSpaceDelims,0)
    let right = s:GetSexyComRight(g:NERDSpaceDelims,0)

    "make sure all multipart delims on the lines are replaced with
    "placeholders to prevent illegal syntax
    let currentLine = a:firstLine
    while(currentLine <= a:lastLine)
        let theLine = getline(currentLine)
        let theLine = s:ReplaceDelims(left, right, g:NERDLPlace, g:NERDRPlace, theLine)
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    "add the delim to the top line
    let theLine = getline(a:firstLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddLeftDelim(left, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:firstLine, theLine)

    "add the delim to the bottom line
    let theLine = getline(a:lastLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddRightDelim(right, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:lastLine, theLine)
endfunction

" Function: s:CommentLinesSexy(topline, bottomline) function {{{2
" This function is used to comment lines in the 'Sexy' style. eg in c:
" /*
"  * This is a sexy comment
"  */
" Args:
"   -topline: the line num of the top line in the sexy comment
"   -bottomline: the line num of the bottom line in the sexy comment
function s:CommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0, 0)
    let right = s:GetSexyComRight(0, 0)

    "check if we can do a sexy comment with the available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot perform sexy comments with available delimiters.'
    endif

    "make sure the lines arent already commented sexually
    if !s:CanSexyCommentLines(a:topline, a:bottomline)
        throw 'NERDCommenter.Nesting exception: cannot nest sexy comments'
    endif


    let sexyComMarker = s:GetSexyComMarker(0,0)
    let sexyComMarkerSpaced = s:GetSexyComMarker(1,0)


    " we jam the comment as far to the right as possible
    let leftAlignIndx = s:LeftMostIndx(1, 1, a:topline, a:bottomline)

    "check if we should use the compact style i.e that the left/right
    "delimiters should appear on the first and last lines of the code and not
    "on separate lines above/below the first/last lines of code
    if g:NERDCompactSexyComs
        let spaceString = (g:NERDSpaceDelims ? s:spaceStr : '')

        "comment the top line
        let theLine = getline(a:topline)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif
        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        let theLine = s:AddLeftDelimAligned(left . spaceString, theLine, leftAlignIndx)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        "comment the bottom line
        if a:bottomline != a:topline
            let theLine = getline(a:bottomline)
            let lineHasTabs = s:HasLeadingTabs(theLine)
            if lineHasTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif
            let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        endif
        let theLine = s:AddRightDelim(spaceString . right, theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline, theLine)
    else

        " add the left delimiter one line above the lines that are to be commented
        call cursor(a:topline, 1)
        execute 'normal! O'
        let theLine = repeat(' ', leftAlignIndx) . left

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        " add the right delimiter after bottom line (we have to add 1 cos we moved
        " the lines down when we added the left delim
        call cursor(a:bottomline+1, 1)
        execute 'normal! o'
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . right

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline+2, theLine)

    endif

    " go thru each line adding the sexyComMarker marker to the start of each
    " line in the appropriate place to align them with the comment delims
    let currentLine = a:topline+1
    while currentLine <= a:bottomline + !g:NERDCompactSexyComs
        " get the line and convert the tabs to spaces
        let theLine = getline(currentLine)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif

        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)

        " add the sexyComMarker
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . sexyComMarkerSpaced . strpart(theLine, leftAlignIndx)

        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif


        " set the line and move onto the next one
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2
" Applies "toggle" commenting to the given range of lines
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesToggle(forceNested, firstLine, lastLine)
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanToggleCommentLine(a:forceNested, currentLine)

            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
            let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2
" This function comments chunks of text selected in visual mode.
" It will comment exactly the text that they have selected.
" Args:
"   -topLine: the line num of the top line in the sexy comment
"   -topCol: top left col for this comment
"   -bottomline: the line num of the bottom line in the sexy comment
"   -bottomCol: the bottom right col for this comment
"   -forceNested: whether the caller wants comments to be nested if the
"    line(s) are already commented
function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)

    "switch delims (if we can) if the current set isnt multipart
    let switchedDelims = 0
    if !s:Multipart() && s:AltMultipart() && !g:NERDAllowAnyVisualDelims
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "if there is only one line in the comment then just do it
    if a:topLine == a:bottomLine
        call s:CommentBlock(a:topLine, a:bottomLine, a:topCol, a:bottomCol, a:forceNested)

    "there are multiple lines in the comment
    else
        "comment the top line
        call s:CommentBlock(a:topLine, a:topLine, a:topCol, strlen(getline(a:topLine)), a:forceNested)

        "comment out all the lines in the middle of the comment
        let topOfRange = a:topLine+1
        let bottomOfRange = a:bottomLine-1
        if topOfRange <= bottomOfRange
            call s:CommentLines(a:forceNested, "none", topOfRange, bottomOfRange)
        endif

        "comment the bottom line
        let bottom = getline(a:bottomLine)
        let numLeadingSpacesTabs = strlen(substitute(bottom, '^\([ \t]*\).*$', '\1', ''))
        call s:CommentBlock(a:bottomLine, a:bottomLine, numLeadingSpacesTabs+1, a:bottomCol, a:forceNested)

    endif

    "stick the cursor back on the char it was on before the comment
    call cursor(a:topLine, a:topCol + strlen(s:Left()) + g:NERDSpaceDelims)

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

endfunction

" Function: s:InvertComment(firstLine, lastLine) function {{{2
" Inverts the comments on the lines between and including the given line
" numbers i.e all commented lines are uncommented and vice versa
" Args:
"   -firstLine: the top of the range of lines to be inverted
"   -lastLine: the bottom of the range of lines to be inverted
function s:InvertComment(firstLine, lastLine)

    " go thru all lines in the given range
    let currentLine = a:firstLine
    while currentLine <= a:lastLine
        let theLine = getline(currentLine)

        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)

        " if the line is commented normally, uncomment it
        if s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(currentLine, currentLine)
            let currentLine = currentLine + 1

        " check if the line is commented sexually
        elseif !empty(sexyComBounds)
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()
            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let currentLine = sexyComBounds[1] - (numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved) + 1

        " the line isnt commented
        else
            call s:CommentLinesToggle(1, currentLine, currentLine)
            let currentLine = currentLine + 1
        endif

    endwhile
endfunction

" Function: NERDComment(mode, type) function {{{2
" This function is a Wrapper for the main commenting functions
"
" Args:
"   -mode: a character indicating the mode in which the comment is requested:
"   'n' for Normal mode, 'x' for Visual mode
"   -type: the type of commenting requested. Can be 'Sexy', 'Invert',
"    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',
"    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'
function! NERDComment(mode, type) range
    let isVisual = a:mode =~ '[vsx]'
    " we want case sensitivity when commenting
    let oldIgnoreCase = &ignorecase
    set noignorecase

    if !exists("g:did_load_ftplugin") || g:did_load_ftplugin != 1
        call s:NerdEcho("filetype plugins should be enabled. See :help NERDComInstallation and :help :filetype-plugin-on", 0)
    endif

    if isVisual
        let firstLine = line("'<")
        let lastLine = line("'>")
        let firstCol = col("'<")
        let lastCol = col("'>") - (&selection == 'exclusive' ? 1 : 0)
    else
        let firstLine = a:firstline
        let lastLine = a:lastline
    endif

    let countWasGiven = (!isVisual && firstLine != lastLine)

    let forceNested = (a:type ==? 'Nested' || g:NERDDefaultNesting)

    if a:type ==? 'Comment' || a:type ==? 'Nested'
        if isVisual && visualmode() == "\<C-V>"
            call s:CommentBlock(firstLine, lastLine, firstCol, lastCol, forceNested)
        elseif isVisual && visualmode() == "v" && (g:NERDCommentWholeLinesInVMode==0 || (g:NERDCommentWholeLinesInVMode==2 && s:HasMultipartDelims()))
            call s:CommentRegion(firstLine, firstCol, lastLine, lastCol, forceNested)
        else
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        endif

    elseif a:type ==? 'AlignLeft' || a:type ==? 'AlignBoth'
        let align = "none"
        if a:type ==? "AlignLeft"
            let align = "left"
        elseif a:type ==? "AlignBoth"
            let align = "both"
        endif
        call s:CommentLines(forceNested, align, firstLine, lastLine)

    elseif a:type ==? 'Invert'
        call s:InvertComment(firstLine, lastLine)

    elseif a:type ==? 'Sexy'
        try
            call s:CommentLinesSexy(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        catch /NERDCommenter.Nesting/
            call s:NerdEcho("Sexy comment aborted. Nested sexy cannot be nested", 0)
        endtry

    elseif a:type ==? 'Toggle'
        let theLine = getline(firstLine)

        if s:IsInSexyComment(firstLine) || s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(firstLine, lastLine)
        else
            call s:CommentLinesToggle(forceNested, firstLine, lastLine)
        endif

    elseif a:type ==? 'Minimal'
        try
            call s:CommentLinesMinimal(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:NerdEcho("Minimal comments can only be used for filetypes that have multipart delimiters.", 0)
        catch /NERDCommenter.Settings/
            call s:NerdEcho("Place holders are required but disabled.", 0)
        endtry

    elseif a:type ==? 'ToEOL'
        call s:SaveScreenState()
        call s:CommentBlock(firstLine, firstLine, col("."), col("$")-1, 1)
        call s:RestoreScreenState()

    elseif a:type ==? 'Append'
        call s:AppendCommentToLine()

    elseif a:type ==? 'Insert'
        call s:PlaceDelimitersAndInsBetween()

    elseif a:type ==? 'Uncomment'
        call s:UncommentLines(firstLine, lastLine)

    elseif a:type ==? 'Yank'
        if isVisual
            normal! gvy
        elseif countWasGiven
            execute firstLine .','. lastLine .'yank'
        else
            normal! yy
        endif
        execute firstLine .','. lastLine .'call NERDComment("'. a:mode .'", "Comment")'
    endif

    let &ignorecase = oldIgnoreCase

    if isVisual
        let nlines = lastLine - firstLine
        silent! call repeat#set("V" . nlines . "jo" . "\<Plug>NERDCommenter". a:type)
    else
        silent! call repeat#set("\<Plug>NERDCommenter". a:type)
    endif
endfunction

" Function: s:PlaceDelimitersAndInsBetween() function {{{2
" This is function is called to place comment delimiters down and place the
" cursor between them
function s:PlaceDelimitersAndInsBetween()
    " get the left and right delimiters without any escape chars in them
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    let theLine = getline(".")
    let lineHasLeadTabs = s:HasLeadingTabs(theLine) || (theLine =~ '^ *$' && !&expandtab)

    "convert tabs to spaces and adjust the cursors column to take this into
    "account
    let untabbedCol = s:UntabbedCol(theLine, col("."))
    call setline(line("."), s:ConvertLeadingTabsToSpaces(theLine))
    call cursor(line("."), untabbedCol)

    " get the len of the right delim
    let lenRight = strlen(right)

    let isDelimOnEOL = col(".") >= strlen(getline("."))

    " if the cursor is in the first col then we gotta insert rather than
    " append the comment delimiters here
    let insOrApp = (col(".")==1 ? 'i' : 'a')

    " place the delimiters down. We do it differently depending on whether
    " there is a left AND right delimiter
    if lenRight > 0
        execute ":normal! " . insOrApp . left . right
        execute ":normal! " . lenRight . "h"
    else
        execute ":normal! " . insOrApp . left
    endif
    silent! normal! l

    "if needed convert spaces back to tabs and adjust the cursors col
    "accordingly
    if lineHasLeadTabs
        let tabbedCol = s:TabbedCol(getline("."), col("."))
        call setline(line("."), s:ConvertLeadingSpacesToTabs(getline(".")))
        call cursor(line("."), tabbedCol)
    endif

    if isDelimOnEOL && lenRight == 0
        startinsert!
    else
        startinsert
    endif
endfunction

" Function: s:RemoveDelimiters(left, right, line) {{{2
" this function is called to remove the first left comment delimiter and the
" last right delimiter of the given line.
"
" The args left and right must be strings. If there is no right delimiter (as
" is the case for e.g vim file comments) them the arg right should be ""
"
" Args:
"   -left: the left comment delimiter
"   -right: the right comment delimiter
"   -line: the line to remove the delimiters from
function s:RemoveDelimiters(left, right, line)

    let l:left = a:left
    let l:right = a:right
    let lenLeft = strlen(left)
    let lenRight = strlen(right)

    let delimsSpaced = (g:NERDSpaceDelims || g:NERDRemoveExtraSpaces)

    let line = a:line

    "look for the left delimiter, if we find it, remove it.
    let leftIndx = s:FindDelimiterIndex(a:left, line)
    if leftIndx != -1
        let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+lenLeft)

        "if the user has specified that there is a space after the left delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, leftIndx, s:lenSpaceStr) == s:spaceStr
            let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+s:lenSpaceStr)
        endif
    endif

    "look for the right delimiter, if we find it, remove it
    let rightIndx = s:FindDelimiterIndex(a:right, line)
    if rightIndx != -1
        let line = strpart(line, 0, rightIndx) . strpart(line, rightIndx+lenRight)

        "if the user has specified that there is a space before the right delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, rightIndx-s:lenSpaceStr, s:lenSpaceStr) == s:spaceStr && s:Multipart()
            let line = strpart(line, 0, rightIndx-s:lenSpaceStr) . strpart(line, rightIndx)
        endif
    endif

    return line
endfunction

" Function: s:UncommentLines(topLine, bottomLine) {{{2
" This function uncomments the given lines
"
" Args:
" topLine: the top line of the visual selection to uncomment
" bottomLine: the bottom line of the visual selection to uncomment
function s:UncommentLines(topLine, bottomLine)
    "make local copies of a:firstline and a:lastline and, if need be, swap
    "them around if the top line is below the bottom
    let l:firstline = a:topLine
    let l:lastline = a:bottomLine
    if firstline > lastline
        let firstline = lastline
        let lastline = a:topLine
    endif

    "go thru each line uncommenting each line removing sexy comments
    let currentLine = firstline
    while currentLine <= lastline

        "check the current line to see if it is part of a sexy comment
        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)
        if !empty(sexyComBounds)

            "we need to store the num lines in the buf before the comment is
            "removed so we know how many lines were removed when the sexy com
            "was removed
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()

            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let numLinesRemoved = numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved
            let currentLine = sexyComBounds[1] - numLinesRemoved + 1
            let lastline = lastline - numLinesRemoved

        "no sexy com was detected so uncomment the line as normal
        else
            call s:UncommentLinesNormal(currentLine, currentLine)
            let currentLine = currentLine + 1
        endif
    endwhile

endfunction

" Function: s:UncommentLinesSexy(topline, bottomline) {{{2
" This function removes all the comment characters associated with the sexy
" comment spanning the given lines
" Args:
"   -topline/bottomline: the top/bottom lines of the sexy comment
function s:UncommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0,1)
    let right = s:GetSexyComRight(0,1)


    "check if it is even possible for sexy comments to exist with the
    "available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot uncomment sexy comments with available delimiters.'
    endif

    let leftUnEsc = s:GetSexyComLeft(0,0)
    let rightUnEsc = s:GetSexyComRight(0,0)

    let sexyComMarker = s:GetSexyComMarker(0, 1)
    let sexyComMarkerUnEsc = s:GetSexyComMarker(0, 0)

    "the markerOffset is how far right we need to move the sexyComMarker to
    "line it up with the end of the left delim
    let markerOffset = strlen(leftUnEsc)-strlen(sexyComMarkerUnEsc)

    " go thru the intermediate lines of the sexy comment and remove the
    " sexy comment markers (eg the '*'s on the start of line in a c sexy
    " comment)
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        " remove the sexy comment marker from the line. We also remove the
        " space after it if there is one and if appropriate options are set
        let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
        if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)

        let theLine = s:ConvertLeadingWhiteSpace(theLine)

        " move onto the next line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    " gotta make a copy of a:bottomline cos we modify the position of the
    " last line  it if we remove the topline
    let bottomline = a:bottomline

    " get the first line so we can remove the left delim from it
    let theLine = getline(a:topline)

    " if the first line contains only the left delim then just delete it
    if theLine =~ '^[ \t]*' . left . '[ \t]*$' && !g:NERDCompactSexyComs
        call cursor(a:topline, 1)
        normal! dd
        let bottomline = bottomline - 1

    " topline contains more than just the left delim
    else

        " remove the delim. If there is a space after it
        " then remove this too if appropriate
        let delimIndx = stridx(theLine, leftUnEsc)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc))
        endif
        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(a:topline, theLine)
    endif

    " get the last line so we can remove the right delim
    let theLine = getline(bottomline)

    " if the bottomline contains only the right delim then just delete it
    if theLine =~ '^[ \t]*' . right . '[ \t]*$'
        call cursor(bottomline, 1)
        normal! dd

    " the last line contains more than the right delim
    else
        " remove the right delim. If there is a space after it and
        " if the appropriate options are set then remove this too.
        let delimIndx = s:LastIndexOfDelim(rightUnEsc, theLine)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc))
        endif

        " if the last line also starts with a sexy comment marker then we
        " remove this as well
        if theLine =~ '^[ \t]*' . sexyComMarker

            " remove the sexyComMarker. If there is a space after it then
            " remove that too
            let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
            if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
            else
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
            endif
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(bottomline, theLine)
    endif
endfunction

" Function: s:UncommentLineNormal(line) {{{2
" uncomments the given line and returns the result
" Args:
"   -line: the line to uncomment
function s:UncommentLineNormal(line)
    let line = a:line

    "get the positions of all delim types on the line
    let indxLeft = s:FindDelimiterIndex(s:Left(), line)
    let indxLeftAlt = s:FindDelimiterIndex(s:Left({'alt': 1}), line)
    let indxRight = s:FindDelimiterIndex(s:Right(), line)
    let indxRightAlt = s:FindDelimiterIndex(s:Right({'alt': 1}), line)

    "get the comment status on the line so we know how it is commented
    let lineCommentStatus =  s:IsCommentedOuttermost(s:Left(), s:Right(), s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is commented with s:Left() and s:Right() so remove these delims
    if lineCommentStatus == 1
        let line = s:RemoveDelimiters(s:Left(), s:Right(), line)

    "it is commented with s:Left({'alt': 1}) and s:Right({'alt': 1}) so remove these delims
    elseif lineCommentStatus == 2 && g:NERDRemoveAltComs
        let line = s:RemoveDelimiters(s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is not properly commented with any delims so we check if it has
    "any random left or right delims on it and remove the outtermost ones
    else
        "remove the outter most left comment delim
        if indxLeft != -1 && (indxLeft < indxLeftAlt || indxLeftAlt == -1)
            let line = s:RemoveDelimiters(s:Left(), '', line)
        elseif indxLeftAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters(s:Left({'alt': 1}), '', line)
        endif

        "remove the outter most right comment delim
        if indxRight != -1 && (indxRight < indxRightAlt || indxRightAlt == -1)
            let line = s:RemoveDelimiters('', s:Right(), line)
        elseif indxRightAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters('', s:Right({'alt': 1}), line)
        endif
    endif


    let indxLeftPlace = s:FindDelimiterIndex(g:NERDLPlace, line)
    let indxRightPlace = s:FindDelimiterIndex(g:NERDRPlace, line)

    let right = s:Right()
    let left = s:Left()
    if !s:Multipart()
        let right = s:Right({'alt': 1})
        let left = s:Left({'alt': 1})
    endif


    "if there are place-holders on the line then we check to see if they are
    "the outtermost delimiters on the line. If so then we replace them with
    "real delimiters
    if indxLeftPlace != -1
        if (indxLeftPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif
    elseif indxRightPlace != -1
        if (indxRightPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif

    endif

    let line = s:ConvertLeadingWhiteSpace(line)

    return line
endfunction

" Function: s:UncommentLinesNormal(topline, bottomline) {{{2
" This function is called to uncomment lines that arent a sexy comment
" Args:
"   -topline/bottomline: the top/bottom line numbers of the comment
function s:UncommentLinesNormal(topline, bottomline)
    let currentLine = a:topline
    while currentLine <= a:bottomline
        let line = getline(currentLine)
        call setline(currentLine, s:UncommentLineNormal(line))
        let currentLine = currentLine + 1
    endwhile
endfunction


" Section: Other helper functions {{{1
" ============================================================================

" Function: s:AddLeftDelim(delim, theLine) {{{2
" Args:
function s:AddLeftDelim(delim, theLine)
    return substitute(a:theLine, '^\([ \t]*\)', '\1' . a:delim, '')
endfunction

" Function: s:AddLeftDelimAligned(delim, theLine) {{{2
" Args:
function s:AddLeftDelimAligned(delim, theLine, alignIndx)

    "if the line is not long enough then bung some extra spaces on the front
    "so we can align the delim properly
    let theLine = a:theLine
    if strlen(theLine) < a:alignIndx
        let theLine = repeat(' ', a:alignIndx - strlen(theLine))
    endif

    return strpart(theLine, 0, a:alignIndx) . a:delim . strpart(theLine, a:alignIndx)
endfunction

" Function: s:AddRightDelim(delim, theLine) {{{2
" Args:
function s:AddRightDelim(delim, theLine)
    if a:delim == ''
        return a:theLine
    else
        return substitute(a:theLine, '$', a:delim, '')
    endif
endfunction

" Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2
" Args:
function s:AddRightDelimAligned(delim, theLine, alignIndx)
    if a:delim == ""
        return a:theLine
    else

        " when we align the right delim we are just adding spaces
        " so we get a string containing the needed spaces (it
        " could be empty)
        let extraSpaces = ''
        let extraSpaces = repeat(' ', a:alignIndx-strlen(a:theLine))

        " add the right delim
        return substitute(a:theLine, '$', extraSpaces . a:delim, '')
    endif
endfunction

" Function: s:AltMultipart() {{{2
" returns 1 if the alternative delims are multipart
function s:AltMultipart()
    return b:NERDCommenterDelims['rightAlt'] != ''
endfunction

" Function: s:CanCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -forceNested: a flag indicating whether the caller wants comments to be nested
"    if the current line is already commented
"   -lineNum: the line num of the line to check for commentability
function s:CanCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    let isCommented = s:IsCommentedNormOrSexy(a:lineNum)

    "if the line isnt commented return true
    if !isCommented
        return 1
    endif

    "if the line is commented but nesting is allowed then return true
    if a:forceNested && (!s:Multipart() || g:NERDUsePlaceHolders)
        return 1
    endif

    return 0
endfunction

" Function: s:CanPlaceCursor(line, col) {{{2
" returns 1 if the cursor can be placed exactly in the given position
function s:CanPlaceCursor(line, col)
    let c = col(".")
    let l = line(".")
    call cursor(a:line, a:col)
    let success = (line(".") == a:line && col(".") == a:col)
    call cursor(l,c)
    return success
endfunction

" Function: s:CanSexyCommentLines(topline, bottomline) {{{2
" Return: 1 if the given lines can be commented sexually, 0 otherwise
function s:CanSexyCommentLines(topline, bottomline)
    " see if the selected regions have any sexy comments
    let currentLine = a:topline
    while(currentLine <= a:bottomline)
        if s:IsInSexyComment(currentLine)
            return 0
        endif
        let currentLine = currentLine + 1
    endwhile
    return 1
endfunction
" Function: s:CanToggleCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be toggle commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -lineNum: the line num of the line to check for commentability
function s:CanToggleCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)
    if (s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)) && !a:forceNested
        return 0
    endif

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    return 1
endfunction

" Function: s:ConvertLeadingSpacesToTabs(line) {{{2
" This function takes a line and converts all leading tabs on that line into
" spaces
"
" Args:
"   -line: the line whose leading tabs will be converted
function s:ConvertLeadingSpacesToTabs(line)
    let toReturn  = a:line
    while toReturn =~ '^\t*' . s:TabSpace() . '\(.*\)$'
        let toReturn = substitute(toReturn, '^\(\t*\)' . s:TabSpace() . '\(.*\)$'  ,  '\1\t\2' , "")
    endwhile

    return toReturn
endfunction


" Function: s:ConvertLeadingTabsToSpaces(line) {{{2
" This function takes a line and converts all leading spaces on that line into
" tabs
"
" Args:
"   -line: the line whose leading spaces will be converted
function s:ConvertLeadingTabsToSpaces(line)
    let toReturn  = a:line
    while toReturn =~ '^\( *\)\t'
        let toReturn = substitute(toReturn, '^\( *\)\t',  '\1' . s:TabSpace() , "")
    endwhile

    return toReturn
endfunction

" Function: s:ConvertLeadingWhiteSpace(line) {{{2
" Converts the leading white space to tabs/spaces depending on &ts
"
" Args:
"   -line: the line to convert
function s:ConvertLeadingWhiteSpace(line)
    let toReturn = a:line
    while toReturn =~ '^ *\t'
        let toReturn = substitute(toReturn, '^ *\zs\t\ze', s:TabSpace(), "g")
    endwhile

    if !&expandtab
        let toReturn = s:ConvertLeadingSpacesToTabs(toReturn)
    endif

    return toReturn
endfunction


" Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2
" This function counts the number of substrings contained in another string.
" These substrings are only counted if they are not escaped with escChar
" Args:
"   -str: the string to look for searchstr in
"   -searchstr: the substring to search for in str
"   -escChar: the escape character which, when preceding an instance of
"    searchstr, will cause it not to be counted
function s:CountNonESCedOccurances(str, searchstr, escChar)
    "get the index of the first occurrence of searchstr
    let indx = stridx(a:str, a:searchstr)

    "if there is an instance of searchstr in str process it
    if indx != -1
        "get the remainder of str after this instance of searchstr is removed
        let lensearchstr = strlen(a:searchstr)
        let strLeft = strpart(a:str, indx+lensearchstr)

        "if this instance of searchstr is not escaped, add one to the count
        "and recurse. If it is escaped, just recurse
        if !s:IsEscaped(a:str, indx, a:escChar)
            return 1 + s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        else
            return s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        endif
    endif
endfunction
" Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2
" Returns 1 if the given block of lines has a delimiter (a:delim) in it
" Args:
"   -delim: the comment delimiter to check the block for
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveDelim(delim, top, bottom)
    let currentLine = a:top
    while currentLine < a:bottom
        let theline = getline(currentLine)
        if s:FindDelimiterIndex(a:delim, theline) != -1
            return 1
        endif
        let currentLine = currentLine + 1
    endwhile
    return 0
endfunction

" Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2
" Returns 1 if the given block has a >= 1 multipart delimiter in it
" Args:
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveMultipartDelim(top, bottom)
    if s:HasMultipartDelims()
        if s:Multipart()
            return s:DoesBlockHaveDelim(s:Left(), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right(), a:top, a:bottom)
        else
            return s:DoesBlockHaveDelim(s:Left({'alt': 1}), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right({'alt': 1}), a:top, a:bottom)
        endif
    endif
    return 0
endfunction


" Function: s:Esc(str) {{{2
" Escapes all the tricky chars in the given string
function s:Esc(str)
    let charsToEsc = '*/\."&$+'
    return escape(a:str, charsToEsc)
endfunction

" Function: s:FindDelimiterIndex(delimiter, line) {{{2
" This function is used to get the string index of the input comment delimiter
" on the input line. If no valid comment delimiter is found in the line then
" -1 is returned
" Args:
"   -delimiter: the delimiter we are looking to find the index of
"   -line: the line we are looking for delimiter on
function s:FindDelimiterIndex(delimiter, line)

    "make sure the delimiter isnt empty otherwise we go into an infinite loop.
    if a:delimiter == ""
        return -1
    endif


    let l:delimiter = a:delimiter
    let lenDel = strlen(l:delimiter)

    "get the index of the first occurrence of the delimiter
    let delIndx = stridx(a:line, l:delimiter)

    "keep looping thru the line till we either find a real comment delimiter
    "or run off the EOL
    while delIndx != -1

        "if we are not off the EOL get the str before the possible delimiter
        "in question and check if it really is a delimiter. If it is, return
        "its position
        if delIndx != -1
            if s:IsDelimValid(l:delimiter, delIndx, a:line)
                return delIndx
            endif
        endif

        "we have not yet found a real comment delimiter so move past the
        "current one we are lookin at
        let restOfLine = strpart(a:line, delIndx + lenDel)
        let distToNextDelim = stridx(restOfLine , l:delimiter)

        "if distToNextDelim is -1 then there is no more potential delimiters
        "on the line so set delIndx to -1. Otherwise, move along the line by
        "distToNextDelim
        if distToNextDelim == -1
            let delIndx = -1
        else
            let delIndx = delIndx + lenDel + distToNextDelim
        endif
    endwhile

    "there is no comment delimiter on this line
    return -1
endfunction

" Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2
" This function takes in a line number and tests whether this line number is
" the top/bottom/middle line of a sexy comment. If it is then the top/bottom
" lines of the sexy comment are returned
" Args:
"   -lineNum: the line number that is to be tested whether it is the
"    top/bottom/middle line of a sexy com
" Returns:
"   A string that has the top/bottom lines of the sexy comment encoded in it.
"   The format is 'topline,bottomline'. If a:lineNum turns out not to be the
"   top/bottom/middle of a sexy comment then -1 is returned
function s:FindBoundingLinesOfSexyCom(lineNum)

    "find which delimiters to look for as the start/end delims of the comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left({'esc': 1})
        let right = s:Right({'esc': 1})
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1, 'esc': 1})
        let right = s:Right({'alt': 1, 'esc': 1})
    else
        return []
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "initialise the top/bottom line numbers of the sexy comment to -1
    let top = -1
    let bottom = -1

    let currentLine = a:lineNum
    while top == -1 || bottom == -1
        let theLine = getline(currentLine)

        "check if the current line is the top of the sexy comment
        if currentLine <= a:lineNum && theLine =~ '^[ \t]*' . left && theLine !~ '.*' . right && currentLine < s:NumLinesInBuf()
            let top = currentLine
            let currentLine = a:lineNum

        "check if the current line is the bottom of the sexy comment
        elseif theLine =~ '^[ \t]*' . right && theLine !~ '.*' . left && currentLine > 1
            let bottom = currentLine

        "the right delimiter is on the same line as the last sexyComMarker
        elseif theLine =~ '^[ \t]*' . sexyComMarker . '.*' . right
            let bottom = currentLine

        "we have not found the top or bottom line so we assume currentLine is an
        "intermediate line and look to prove otherwise
        else

            "if the line doesnt start with a sexyComMarker then it is not a sexy
            "comment
            if theLine !~ '^[ \t]*' . sexyComMarker
                return []
            endif

        endif

        "if top is -1 then we havent found the top yet so keep looking up
        if top == -1
            let currentLine = currentLine - 1
        "if we have found the top line then go down looking for the bottom
        else
            let currentLine = currentLine + 1
        endif

    endwhile

    return [top, bottom]
endfunction


" Function: s:GetSexyComMarker() {{{2
" Returns the sexy comment marker for the current filetype.
"
" C style sexy comments are assumed if possible. If not then the sexy comment
" marker is the last char of the delimiter pair that has both left and right
" delims and has the longest left delim
"
" Args:
"   -space: specifies whether the marker is to have a space string after it
"    (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the marker are to be ESCed
function s:GetSexyComMarker(space, esc)
    let sexyComMarker = b:NERDSexyComMarker

    "if there is no hardcoded marker then we find one
    if sexyComMarker == ''

        "if the filetype has c style comments then use standard c sexy
        "comments
        if s:HasCStyleComments()
            let sexyComMarker = '*'
        else
            "find a comment marker by getting the longest available left delim
            "(that has a corresponding right delim) and taking the last char
            let lenLeft = strlen(s:Left())
            let lenLeftAlt = strlen(s:Left({'alt': 1}))
            let left = ''
            let right = ''
            if s:Multipart() && lenLeft >= lenLeftAlt
                let left = s:Left()
            elseif s:AltMultipart()
                let left = s:Left({'alt': 1})
            else
                return -1
            endif

            "get the last char of left
            let sexyComMarker = strpart(left, strlen(left)-1)
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let sexyComMarker = sexyComMarker . s:spaceStr
    endif

    if a:esc
        let sexyComMarker = s:Esc(sexyComMarker)
    endif

    return sexyComMarker
endfunction

" Function: s:GetSexyComLeft(space, esc) {{{2
" Returns the left delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible
" Args:
"   -space: specifies if the delim has a space string on the end
"   (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComLeft(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let left = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let left = '/*'
    else
        "grab the longest left delim that has a right
        if s:Multipart() && lenLeft >= lenLeftAlt
            let left = s:Left()
        elseif s:AltMultipart()
            let left = s:Left({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let left = left . s:spaceStr
    endif

    if a:esc
        let left = s:Esc(left)
    endif

    return left
endfunction

" Function: s:GetSexyComRight(space, esc) {{{2
" Returns the right delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible.
" Args:
"   -space: specifies if the delim has a space string on the start
"   (the space string will only be added if NERDSpaceDelims
"   is specified for the current filetype)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComRight(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let right = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let right = '*/'
    else
        "grab the right delim that pairs with the longest left delim
        if s:Multipart() && lenLeft >= lenLeftAlt
            let right = s:Right()
        elseif s:AltMultipart()
            let right = s:Right({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let right = s:spaceStr . right
    endif

    if a:esc
        let right = s:Esc(right)
    endif

    return right
endfunction

" Function: s:HasMultipartDelims() {{{2
" Returns 1 iff the current filetype has at least one set of multipart delims
function s:HasMultipartDelims()
    return s:Multipart() || s:AltMultipart()
endfunction

" Function: s:HasLeadingTabs(...) {{{2
" Returns 1 if any of the given strings have leading tabs
function s:HasLeadingTabs(...)
    for s in a:000
        if s =~ '^\t.*'
            return 1
        end
    endfor
    return 0
endfunction
" Function: s:HasCStyleComments() {{{2
" Returns 1 iff the current filetype has c style comment delimiters
function s:HasCStyleComments()
    return (s:Left() == '/*' && s:Right() == '*/') || (s:Left({'alt': 1}) == '/*' && s:Right({'alt': 1}) == '*/')
endfunction

" Function: s:IsCommentedNormOrSexy(lineNum) {{{2
"This function is used to determine whether the given line is commented with
"either set of delimiters or if it is part of a sexy comment
"
" Args:
"   -lineNum: the line number of the line to check
function s:IsCommentedNormOrSexy(lineNum)
    let theLine = getline(a:lineNum)

    "if the line is commented normally return 1
    if s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)
        return 1
    endif

    "if the line is part of a sexy comment return 1
    if s:IsInSexyComment(a:lineNum)
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommented(left, right, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters
"
" Args:
"   -line: the line that to check if commented
"   -left/right: the left and right delimiters to check for
function s:IsCommented(left, right, line)
    "if the line isnt commented return true
    if s:FindDelimiterIndex(a:left, a:line) != -1 && (s:FindDelimiterIndex(a:right, a:line) != -1 || !s:Multipart())
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommentedFromStartOfLine(left, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters at the start of the line i.e the left delimiter is the
"first thing on the line (apart from spaces\tabs)
"
" Args:
"   -line: the line that to check if commented
"   -left: the left delimiter to check for
function s:IsCommentedFromStartOfLine(left, line)
    let theLine = s:ConvertLeadingTabsToSpaces(a:line)
    let numSpaces = strlen(substitute(theLine, '^\( *\).*$', '\1', ''))
    let delimIndx = s:FindDelimiterIndex(a:left, theLine)
    return delimIndx == numSpaces
endfunction

" Function: s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line) {{{2
" Finds the type of the outtermost delims on the line
"
" Args:
"   -line: the line that to check if the outtermost comments on it are
"    left/right
"   -left/right: the left and right delimiters to check for
"   -leftAlt/rightAlt: the left and right alternative delimiters to check for
"
" Returns:
"   0 if the line is not commented with either set of delims
"   1 if the line is commented with the left/right delim set
"   2 if the line is commented with the leftAlt/rightAlt delim set
function s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line)
    "get the first positions of the left delims and the last positions of the
    "right delims
    let indxLeft = s:FindDelimiterIndex(a:left, a:line)
    let indxLeftAlt = s:FindDelimiterIndex(a:leftAlt, a:line)
    let indxRight = s:LastIndexOfDelim(a:right, a:line)
    let indxRightAlt = s:LastIndexOfDelim(a:rightAlt, a:line)

    "check if the line has a left delim before a leftAlt delim
    if (indxLeft <= indxLeftAlt || indxLeftAlt == -1) && indxLeft != -1
        "check if the line has a right delim after any rightAlt delim
        if (indxRight > indxRightAlt && indxRight > indxLeft) || !s:Multipart()
            return 1
        endif

        "check if the line has a leftAlt delim before a left delim
    elseif (indxLeftAlt <= indxLeft || indxLeft == -1) && indxLeftAlt != -1
        "check if the line has a rightAlt delim after any right delim
        if (indxRightAlt > indxRight && indxRightAlt > indxLeftAlt) || !s:AltMultipart()
            return 2
        endif
    else
        return 0
    endif

    return 0

endfunction


" Function: s:IsDelimValid(delimiter, delIndx, line) {{{2
" This function is responsible for determining whether a given instance of a
" comment delimiter is a real delimiter or not. For example, in java the
" // string is a comment delimiter but in the line:
"               System.out.println("//");
" it does not count as a comment delimiter. This function is responsible for
" distinguishing between such cases. It does so by applying a set of
" heuristics that are not fool proof but should work most of the time.
"
" Args:
"   -delimiter: the delimiter we are validating
"   -delIndx: the position of delimiter in line
"   -line: the line that delimiter occurs in
"
" Returns:
" 0 if the given delimiter is not a real delimiter (as far as we can tell) ,
" 1 otherwise
function s:IsDelimValid(delimiter, delIndx, line)
    "get the delimiter without the escchars
    let l:delimiter = a:delimiter

    "get the strings before and after the delimiter
    let preComStr = strpart(a:line, 0, a:delIndx)
    let postComStr = strpart(a:line, a:delIndx+strlen(delimiter))

    "to check if the delimiter is real, make sure it isnt preceded by
    "an odd number of quotes and followed by the same (which would indicate
    "that it is part of a string and therefore is not a comment)
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, '"', "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "'", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "'", "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "`", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "`", "\\"))
        return 0
    endif


    "if the comment delimiter is escaped, assume it isnt a real delimiter
    if s:IsEscaped(a:line, a:delIndx, "\\")
        return 0
    endif

    "vim comments are so fuckin stupid!! Why the hell do they have comment
    "delimiters that are used elsewhere in the syntax?!?! We need to check
    "some conditions especially for vim
    if &filetype == "vim"
        if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\"))
            return 0
        endif

        "if the delimiter is on the very first char of the line or is the
        "first non-tab/space char on the line then it is a valid comment delimiter
        if a:delIndx == 0 || a:line =~ "^[ \t]\\{" . a:delIndx . "\\}\".*$"
            return 1
        endif

        let numLeftParen =s:CountNonESCedOccurances(preComStr, "(", "\\")
        let numRightParen =s:CountNonESCedOccurances(preComStr, ")", "\\")

        "if the quote is inside brackets then assume it isnt a comment
        if numLeftParen > numRightParen
            return 0
        endif

        "if the line has an even num of unescaped "'s then we can assume that
        "any given " is not a comment delimiter
        if s:IsNumEven(s:CountNonESCedOccurances(a:line, "\"", "\\"))
            return 0
        endif
    endif

    return 1

endfunction

" Function: s:IsNumEven(num) {{{2
" A small function the returns 1 if the input number is even and 0 otherwise
" Args:
"   -num: the number to check
function s:IsNumEven(num)
    return (a:num % 2) == 0
endfunction

" Function: s:IsEscaped(str, indx, escChar) {{{2
" This function takes a string, an index into that string and an esc char and
" returns 1 if the char at the index is escaped (i.e if it is preceded by an
" odd number of esc chars)
" Args:
"   -str: the string to check
"   -indx: the index into str that we want to check
"   -escChar: the escape char the char at indx may be ESCed with
function s:IsEscaped(str, indx, escChar)
    "initialise numEscChars to 0 and look at the char before indx
    let numEscChars = 0
    let curIndx = a:indx-1

    "keep going back thru str until we either reach the start of the str or
    "run out of esc chars
    while curIndx >= 0 && strpart(a:str, curIndx, 1) == a:escChar

        "we have found another esc char so add one to the count and move left
        "one char
        let numEscChars  = numEscChars + 1
        let curIndx = curIndx - 1

    endwhile

    "if there is an odd num of esc chars directly before the char at indx then
    "the char at indx is escaped
    return !s:IsNumEven(numEscChars)
endfunction

" Function: s:IsInSexyComment(line) {{{2
" returns 1 if the given line number is part of a sexy comment
function s:IsInSexyComment(line)
    return !empty(s:FindBoundingLinesOfSexyCom(a:line))
endfunction

" Function: s:IsSexyComment(topline, bottomline) {{{2
" This function takes in 2 line numbers and returns 1 if the lines between and
" including the given line numbers are a sexy comment. It returns 0 otherwise.
" Args:
"   -topline: the line that the possible sexy comment starts on
"   -bottomline: the line that the possible sexy comment stops on
function s:IsSexyComment(topline, bottomline)

    "get the delim set that would be used for a sexy comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    else
        return 0
    endif

    "swap the top and bottom line numbers around if need be
    let topline = a:topline
    let bottomline = a:bottomline
    if bottomline < topline
        topline = bottomline
        bottomline = a:topline
    endif

    "if there is < 2 lines in the comment it cannot be sexy
    if (bottomline - topline) <= 0
        return 0
    endif

    "if the top line doesnt begin with a left delim then the comment isnt sexy
    if getline(a:topline) !~ '^[ \t]*' . left
        return 0
    endif

    "if there is a right delim on the top line then this isnt a sexy comment
    if s:FindDelimiterIndex(right, getline(a:topline)) != -1
        return 0
    endif

    "if there is a left delim on the bottom line then this isnt a sexy comment
    if s:FindDelimiterIndex(left, getline(a:bottomline)) != -1
        return 0
    endif

    "if the bottom line doesnt begin with a right delim then the comment isnt
    "sexy
    if getline(a:bottomline) !~ '^.*' . right . '$'
        return 0
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "check each of the intermediate lines to make sure they start with a
    "sexyComMarker
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        if theLine !~ '^[ \t]*' . sexyComMarker
            return 0
        endif

        "if there is a right delim in an intermediate line then the block isnt
        "a sexy comment
        if s:FindDelimiterIndex(right, theLine) != -1
            return 0
        endif

        let currentLine = currentLine + 1
    endwhile

    "we have not found anything to suggest that this isnt a sexy comment so
    return 1

endfunction

" Function: s:LastIndexOfDelim(delim, str) {{{2
" This function takes a string and a delimiter and returns the last index of
" that delimiter in string
" Args:
"   -delim: the delimiter to look for
"   -str: the string to look for delim in
function s:LastIndexOfDelim(delim, str)
    let delim = a:delim
    let lenDelim = strlen(delim)

    "set index to the first occurrence of delim. If there is no occurrence then
    "bail
    let indx = s:FindDelimiterIndex(delim, a:str)
    if indx == -1
        return -1
    endif

    "keep moving to the next instance of delim in str till there is none left
    while 1

        "search for the next delim after the previous one
        let searchStr = strpart(a:str, indx+lenDelim)
        let indx2 = s:FindDelimiterIndex(delim, searchStr)

        "if we find a delim update indx to record the position of it, if we
        "dont find another delim then indx is the last one so break out of
        "this loop
        if indx2 != -1
            let indx = indx + indx2 + lenDelim
        else
            break
        endif
    endwhile

    return indx

endfunction

" Function: s:Left(...) {{{2
" returns left delimiter data
function s:Left(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['leftAlt'] : b:NERDCommenterDelims['left'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = delim . s:spaceStr
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the left most
" char (that is not a space or a tab) on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)

    " declare the left most index as an extreme value
    let leftMostIndx = 1000

    " go thru the block line by line updating leftMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and if it is allowed to be commented, or is not
        " commented, check it
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'
            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))
                " convert spaces to tabs and get the number of leading spaces for
                " this line and update leftMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let leadSpaceOfLine = strlen( substitute(theLine, '\(^[ \t]*\).*$','\1','') )
                if leadSpaceOfLine < leftMostIndx
                    let leftMostIndx = leadSpaceOfLine
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    if leftMostIndx == 1000
        return 0
    else
        return leftMostIndx
    endif
endfunction

" Function: s:Multipart() {{{2
" returns 1 if the current delims are multipart
function s:Multipart()
    return s:Right() != ''
endfunction

" Function: s:NerdEcho(msg, typeOfMsg) {{{2
" Args:
"   -msg: the message to echo
"   -typeOfMsg: 0 = warning message
"               1 = normal message
function s:NerdEcho(msg, typeOfMsg)
    if a:typeOfMsg == 0
        echohl WarningMsg
        echom 'NERDCommenter:' . a:msg
        echohl None
    elseif a:typeOfMsg == 1
        echom 'NERDCommenter:' . a:msg
    endif
endfunction

" Function: s:NumberOfLeadingTabs(s) {{{2
" returns the number of leading tabs in the given string
function s:NumberOfLeadingTabs(s)
    return strlen(substitute(a:s, '^\(\t*\).*$', '\1', ""))
endfunction

" Function: s:NumLinesInBuf() {{{2
" Returns the number of lines in the current buffer
function s:NumLinesInBuf()
    return line('$')
endfunction

" Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2
" This function takes in a string, 2 delimiters in that string and 2 strings
" to replace these delimiters with.
"
" Args:
"   -toReplace1: the first delimiter to replace
"   -toReplace2: the second delimiter to replace
"   -replacor1: the string to replace toReplace1 with
"   -replacor2: the string to replace toReplace2 with
"   -str: the string that the delimiters to be replaced are in
function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)
    let line = s:ReplaceLeftMostDelim(a:toReplace1, a:replacor1, a:str)
    let line = s:ReplaceRightMostDelim(a:toReplace2, a:replacor2, line)
    return line
endfunction

" Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the left most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
function s:ReplaceLeftMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    "get the left most occurrence of toReplace
    let indxToReplace = s:FindDelimiterIndex(toReplace, a:str)

    "if there IS an occurrence of toReplace in str then replace it and return
    "the resulting string
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
        return line
    endif

    return a:str
endfunction

" Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the right most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
"
function s:ReplaceRightMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    let lenToReplace = strlen(toReplace)

    "get the index of the last delim in str
    let indxToReplace = s:LastIndexOfDelim(toReplace, a:str)

    "if there IS a delimiter in str, replace it and return the result
    let line = a:str
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
    endif
    return line
endfunction

"FUNCTION: s:RestoreScreenState() {{{2
"
"Sets the screen state back to what it was when s:SaveScreenState was last
"called.
"
function s:RestoreScreenState()
    if !exists("t:NERDComOldTopLine") || !exists("t:NERDComOldPos")
        throw 'NERDCommenter exception: cannot restore screen'
    endif

    call cursor(t:NERDComOldTopLine, 0)
    normal! zt
    call setpos(".", t:NERDComOldPos)
endfunction

" Function: s:Right(...) {{{2
" returns right delimiter data
function s:Right(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['rightAlt'] : b:NERDCommenterDelims['right'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = s:spaceStr . delim
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the right most
" char on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)
    let rightMostIndx = -1

    " go thru the block line by line updating rightMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and see if it is commentable, otherwise it doesnt
        " count
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'

            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))

                " update rightMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let lineLen = strlen(theLine)
                if lineLen > rightMostIndx
                    let rightMostIndx = lineLen
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    return rightMostIndx
endfunction

"FUNCTION: s:SaveScreenState() {{{2
"Saves the current cursor position in the current buffer and the window
"scroll position
function s:SaveScreenState()
    let t:NERDComOldPos = getpos(".")
    let t:NERDComOldTopLine = line("w0")
endfunction

" Function: s:SwapOutterMultiPartDelimsForPlaceHolders(line) {{{2
" This function takes a line and swaps the outter most multi-part delims for
" place holders
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterMultiPartDelimsForPlaceHolders(line)
    " find out if the line is commented using normal delims and/or
    " alternate ones
    let isCommented = s:IsCommented(s:Left(), s:Right(), a:line)
    let isCommentedAlt = s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), a:line)

    let line2 = a:line

    "if the line is commented and there is a right delimiter, replace
    "the delims with place-holders
    if isCommented && s:Multipart()
        let line2 = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, a:line)

    "similarly if the line is commented with the alternative
    "delimiters
    elseif isCommentedAlt && s:AltMultipart()
        let line2 = s:ReplaceDelims(s:Left({'alt': 1}), s:Right({'alt': 1}), g:NERDLPlace, g:NERDRPlace, a:line)
    endif

    return line2
endfunction

" Function: s:SwapOutterPlaceHoldersForMultiPartDelims(line) {{{2
" This function takes a line and swaps the outtermost place holders for
" multi-part delims
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterPlaceHoldersForMultiPartDelims(line)
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    endif

    let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, a:line)
    return line
endfunction
" Function: s:TabbedCol(line, col) {{{2
" Gets the col number for given line and existing col number. The new col
" number is the col number when all leading spaces are converted to tabs
" Args:
"   -line:the line to get the rel col for
"   -col: the abs col
function s:TabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineSpacesToTabs = substitute(lineTruncated, s:TabSpace(), '\t', 'g')
    return strlen(lineSpacesToTabs)
endfunction
"FUNCTION: s:TabSpace() {{{2
"returns a string of spaces equal in length to &tabstop
function s:TabSpace()
    let tabSpace = ""
    let spacesPerTab = &tabstop
    while spacesPerTab > 0
        let tabSpace = tabSpace . " "
        let spacesPerTab = spacesPerTab - 1
    endwhile
    return tabSpace
endfunction

" Function: s:UnEsc(str, escChar) {{{2
" This function removes all the escape chars from a string
" Args:
"   -str: the string to remove esc chars from
"   -escChar: the escape char to be removed
function s:UnEsc(str, escChar)
    return substitute(a:str, a:escChar, "", "g")
endfunction

" Function: s:UntabbedCol(line, col) {{{2
" Takes a line and a col and returns the absolute column of col taking into
" account that a tab is worth 3 or 4 (or whatever) spaces.
" Args:
"   -line:the line to get the abs col for
"   -col: the col that doesnt take into account tabs
function s:UntabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineTabsToSpaces = substitute(lineTruncated, '\t', s:TabSpace(), 'g')
    return strlen(lineTabsToSpaces)
endfunction
" Section: Comment mapping and menu item setup {{{1
" ===========================================================================

" Create menu items for the specified modes.  If a:combo is not empty, then
" also define mappings and show a:combo in the menu items.
function! s:CreateMaps(modes, target, desc, combo)
    " Build up a map command like
    " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'
    let plug = '<plug>NERDCommenter' . a:target
    let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'
    let plug_end = '", "' . a:target . '")<cr>'
    " Build up a menu command like
    " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'
    let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'],
                \ g:NERDMenuMode, '')
    let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
    if strlen(a:combo)
        let leader = exists('g:mapleader') ? g:mapleader : '\'
        let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
    endif
    let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
    " Execute the commands built above for each requested mode.
    for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')
        if strlen(a:combo)
            execute mode . plug_start . mode . plug_end
            if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                execute mode . 'map <leader>' . a:combo . ' ' . plug
            endif
        endif
        " Check if the user wants the menu to be displayed.
        if g:NERDMenuMode != 0
            execute mode . menu_command
        endif
    endfor
endfunction
call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')
call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
call s:CreateMaps('n',  'Append',     'Append', 'cA')
call s:CreateMaps('',   ':',          '-Sep-', '')
call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
call s:CreateMaps('',   ':',          '-Sep2-', '')
call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
call s:CreateMaps('',   ':',          '-Sep3-', '')
call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')

inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>

" switch to/from alternative delimiters (does not use wrapper function)
nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>
" vim: set foldmethod=marker :
zhimakaimen:/vimfiles/bundle/nerdcommenter/plugin/NERD_commenter.vim
*~
*.swp
tags
zhimakaimen:/vimfiles/bundle/nerdtree/.gitignore
" ============================================================================
" File:        NERD_tree.vim
" Description: vim global plugin that provides a nice tree explorer
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 28 December, 2011
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
"
" SECTION: Script init stuff {{{1
"============================================================
if exists("loaded_nerd_tree")
    finish
endif
if v:version < 700
    echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_tree = 1

"for line continuation - i.e dont want C in &cpo
let s:old_cpo = &cpo
set cpo&vim

"Function: s:initVariable() function {{{2
"This function is used to initialise a given variable to a given value. The
"variable is only initialised if it does not exist prior
"
"Args:
"var: the name of the var to be initialised
"value: the value to initialise var to
"
"Returns:
"1 if the var is set, 0 otherwise
function! s:initVariable(var, value)
    if !exists(a:var)
        exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
        return 1
    endif
    return 0
endfunction

"SECTION: Init variable calls and other random constants {{{2
call s:initVariable("g:NERDChristmasTree", 1)
call s:initVariable("g:NERDTreeAutoCenter", 1)
call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
call s:initVariable("g:NERDTreeChDirMode", 0)
call s:initVariable("g:NERDTreeMinimalUI", 0)
if !exists("g:NERDTreeIgnore")
    let g:NERDTreeIgnore = ['\~$']
endif
call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
call s:initVariable("g:NERDTreeHighlightCursorline", 1)
call s:initVariable("g:NERDTreeHijackNetrw", 1)
call s:initVariable("g:NERDTreeMouseMode", 1)
call s:initVariable("g:NERDTreeNotificationThreshold", 100)
call s:initVariable("g:NERDTreeQuitOnOpen", 0)
call s:initVariable("g:NERDTreeShowBookmarks", 0)
call s:initVariable("g:NERDTreeShowFiles", 1)
call s:initVariable("g:NERDTreeShowHidden", 0)
call s:initVariable("g:NERDTreeShowLineNumbers", 0)
call s:initVariable("g:NERDTreeSortDirs", 1)
call s:initVariable("g:NERDTreeDirArrows", !nerdtree#runningWindows())
call s:initVariable("g:NERDTreeCasadeOpenSingleChildDir", 1)

if !exists("g:NERDTreeSortOrder")
    let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
else
    "if there isnt a * in the sort sequence then add one
    if count(g:NERDTreeSortOrder, '*') < 1
        call add(g:NERDTreeSortOrder, '*')
    endif
endif

if !exists('g:NERDTreeStatusline')

    "the exists() crap here is a hack to stop vim spazzing out when
    "loading a session that was created with an open nerd tree. It spazzes
    "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)
    let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"

endif
call s:initVariable("g:NERDTreeWinPos", "left")
call s:initVariable("g:NERDTreeWinSize", 31)

"init the shell commands that will be used to copy nodes, and remove dir trees
"
"Note: the space after the command is important
if nerdtree#runningWindows()
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
else
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
    call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
endif


"SECTION: Init variable calls for key mappings {{{2
call s:initVariable("g:NERDTreeMapActivateNode", "o")
call s:initVariable("g:NERDTreeMapChangeRoot", "C")
call s:initVariable("g:NERDTreeMapChdir", "cd")
call s:initVariable("g:NERDTreeMapCloseChildren", "X")
call s:initVariable("g:NERDTreeMapCloseDir", "x")
call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
call s:initVariable("g:NERDTreeMapMenu", "m")
call s:initVariable("g:NERDTreeMapHelp", "?")
call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
call s:initVariable("g:NERDTreeMapJumpParent", "p")
call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
call s:initVariable("g:NERDTreeMapJumpRoot", "P")
call s:initVariable("g:NERDTreeMapOpenExpl", "e")
call s:initVariable("g:NERDTreeMapOpenInTab", "t")
call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
call s:initVariable("g:NERDTreeMapOpenSplit", "i")
call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
call s:initVariable("g:NERDTreeMapQuit", "q")
call s:initVariable("g:NERDTreeMapRefresh", "r")
call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
call s:initVariable("g:NERDTreeMapToggleFiles", "F")
call s:initVariable("g:NERDTreeMapToggleFilters", "f")
call s:initVariable("g:NERDTreeMapToggleHidden", "I")
call s:initVariable("g:NERDTreeMapToggleZoom", "A")
call s:initVariable("g:NERDTreeMapUpdir", "u")
call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
call s:initVariable("g:NERDTreeMapCWD", "CD")

"SECTION: Load class files{{{2
call nerdtree#loadClassFiles()

" SECTION: Commands {{{1
"============================================================
"init the command that users start the nerd tree with
command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.TogglePrimary('<args>')
command! -n=0 -bar NERDTreeClose :call nerdtree#closeTreeIfOpen()
command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
command! -n=0 -bar NERDTreeFind call nerdtree#findAndRevealPath()
command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
" SECTION: Auto commands {{{1
"============================================================
augroup NERDTree
    "Save the cursor position whenever we close the nerd tree
    exec "autocmd BufWinLeave ". g:NERDTreeCreator.BufNamePrefix() ."* call nerdtree#saveScreenState()"

    "disallow insert mode in the NERDTree
    exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
augroup END

if g:NERDTreeHijackNetrw
    augroup NERDTreeHijackNetrw
        autocmd VimEnter * silent! autocmd! FileExplorer
        au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
    augroup END
endif

" SECTION: Public API {{{1
"============================================================
function! NERDTreeAddMenuItem(options)
    call g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddMenuSeparator(...)
    let opts = a:0 ? a:1 : {}
    call g:NERDTreeMenuItem.CreateSeparator(opts)
endfunction

function! NERDTreeAddSubmenu(options)
    return g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddKeyMap(options)
    call g:NERDTreeKeyMap.Create(a:options)
endfunction

function! NERDTreeRender()
    call nerdtree#renderView()
endfunction

function! NERDTreeFocus()
    if nerdtree#isTreeOpen()
        call nerdtree#putCursorInTreeWin()
    else
        call g:NERDTreeCreator.TogglePrimary("")
    endif
endfunction

function! NERDTreeCWD()
    call NERDTreeFocus()
    call nerdtree#chRootCwd()
endfunction
" SECTION: Post Source Actions {{{1
call nerdtree#postSourceActions()

"reset &cpo back to users setting
let &cpo = s:old_cpo

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/plugin/NERD_tree.vim
let s:tree_up_dir_line = '.. (up a dir)'
"NERDTreeFlags are syntax items that should be invisible, but give clues as to
"how things should be highlighted
syn match NERDTreeFlag #\~#
syn match NERDTreeFlag #\[RO\]#

"highlighting for the .. (up dir) line at the top of the tree
execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"

"highlighting for the ~/+ symbols for the directory nodes
syn match NERDTreeClosable #\~\<#
syn match NERDTreeClosable #\~\.#
syn match NERDTreeOpenable #+\<#
syn match NERDTreeOpenable #+\.#he=e-1

"highlighting for the tree structural parts
syn match NERDTreePart #|#
syn match NERDTreePart #`#
syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart

"quickhelp syntax elements
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#hs=s+2,he=e-1
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#hs=s+2,he=e-1
syn match NERDTreeHelpTitle #" .*\~#hs=s+2,he=e-1 contains=NERDTreeFlag
syn match NERDTreeToggleOn #".*(on)#hs=e-2,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeToggleOff #".*(off)#hs=e-3,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeFlag,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand

"highlighting for readonly files
syn match NERDTreeRO #.*\[RO\]#hs=s+2 contains=NERDTreeFlag,NERDTreeBookmark,NERDTreePart,NERDTreePartFile

"highlighting for sym links
syn match NERDTreeLink #[^-| `].* -> # contains=NERDTreeBookmark,NERDTreeOpenable,NERDTreeClosable,NERDTreeDirSlash

"highlighing for directory nodes and file nodes
syn match NERDTreeDirSlash #/#
syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeDirSlash,NERDTreeOpenable,NERDTreeClosable
syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark
syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeCWD #^[</].*$#

"highlighting for bookmarks
syn match NERDTreeBookmark # {.*}#hs=s+1

"highlighting for the bookmarks table
syn match NERDTreeBookmarksLeader #^>#
syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader

if exists("g:NERDChristmasTree") && g:NERDChristmasTree
    hi def link NERDTreePart Special
    hi def link NERDTreePartFile Type
    hi def link NERDTreeFile Normal
    hi def link NERDTreeExecFile Title
    hi def link NERDTreeDirSlash Identifier
    hi def link NERDTreeClosable Type
else
    hi def link NERDTreePart Normal
    hi def link NERDTreePartFile Normal
    hi def link NERDTreeFile Normal
    hi def link NERDTreeClosable Title
endif

hi def link NERDTreeBookmarksHeader statement
hi def link NERDTreeBookmarksLeader ignore
hi def link NERDTreeBookmarkName Identifier
hi def link NERDTreeBookmark normal

hi def link NERDTreeHelp String
hi def link NERDTreeHelpKey Identifier
hi def link NERDTreeHelpCommand Identifier
hi def link NERDTreeHelpTitle Macro
hi def link NERDTreeToggleOn Question
hi def link NERDTreeToggleOff WarningMsg

hi def link NERDTreeDir Directory
hi def link NERDTreeUp Directory
hi def link NERDTreeCWD Statement
hi def link NERDTreeLink Macro
hi def link NERDTreeOpenable Title
hi def link NERDTreeFlag ignore
hi def link NERDTreeRO WarningMsg
hi def link NERDTreeBookmark Statement

hi def link NERDTreeCurrentNode Search
zhimakaimen:/vimfiles/bundle/nerdtree/syntax/nerdtree.vim
"CLASS: Creator
"Creates primary/secondary/mirror nerdtree windows. Sets up all the window and
"buffer options and key mappings etc.
"============================================================
let s:Creator = {}
let g:NERDTreeCreator = s:Creator

"FUNCTION: s:Creator._bindMappings() {{{1
function! s:Creator._bindMappings()
    "make <cr> do the same as the default 'o' mapping
    exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"

    call g:NERDTreeKeyMap.BindAll()

    command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
    command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: s:Creator._broadcastInitEvent() {{{1
function! s:Creator._broadcastInitEvent()
    silent doautocmd User NERDTreeInit
endfunction

" FUNCTION: s:Creator.BufNamePrefix() {{{2
function! s:Creator.BufNamePrefix()
    return 'NERD_tree_'
endfunction

"FUNCTION: s:Creator.CreatePrimary(a:name) {{{1
function! s:Creator.CreatePrimary(name)
    let creator = s:Creator.New()
    call creator.createPrimary(a:name)
endfunction

"FUNCTION: s:Creator.createPrimary(a:name) {{{1
"name: the name of a bookmark or a directory
function! s:Creator.createPrimary(name)
    let path = self._pathForString(a:name)

    "if instructed to, then change the vim CWD to the dir the NERDTree is
    "inited in
    if g:NERDTreeChDirMode != 0
        call path.changeToDir()
    endif

    if nerdtree#treeExistsForTab()
        if nerdtree#isTreeOpen()
            call nerdtree#closeTree()
        endif
        unlet t:NERDTreeBufName
    endif

    let newRoot = g:NERDTreeDirNode.New(path)
    call newRoot.open()

    call self._createTreeWin()
    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    let b:NERDTreeRoot = newRoot
    let b:NERDTreeType = "primary"

    call nerdtree#renderView()
    call b:NERDTreeRoot.putCursorHere(0, 0)

    call self._broadcastInitEvent()
endfunction

"FUNCTION: s:Creator.CreateSecondary(dir) {{{1
function! s:Creator.CreateSecondary(dir)
    let creator = s:Creator.New()
    call creator.createSecondary(a:dir)
endfunction

"FUNCTION: s:Creator.createSecondary(dir) {{{1
function! s:Creator.createSecondary(dir)
    try
        let path = g:NERDTreePath.New(a:dir)
    catch /^NERDTree.InvalidArgumentsError/
        call nerdtree#echo("Invalid directory name:" . a:name)
        return
    endtry

    "we want the directory buffer to disappear when we do the :edit below
    setlocal bufhidden=wipe

    let previousBuf = expand("#")

    "we need a unique name for each secondary tree buffer to ensure they are
    "all independent
    exec "silent edit " . self._nextBufferName()

    let b:NERDTreePreviousBuf = bufnr(previousBuf)

    let b:NERDTreeRoot = g:NERDTreeDirNode.New(path)
    call b:NERDTreeRoot.open()

    call self._setCommonBufOptions()
    let b:NERDTreeType = "secondary"

    call nerdtree#renderView()

    call self._broadcastInitEvent()
endfunction

" FUNCTION: s:Creator.CreateMirror() {{{1
function! s:Creator.CreateMirror()
    let creator = s:Creator.New()
    call creator.createMirror()
endfunction

" FUNCTION: s:Creator.createMirror() {{{1
function! s:Creator.createMirror()
    "get the names off all the nerd tree buffers
    let treeBufNames = []
    for i in range(1, tabpagenr("$"))
        let nextName = nerdtree#tabpagevar(i, 'NERDTreeBufName')
        if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
            call add(treeBufNames, nextName)
        endif
    endfor
    let treeBufNames = nerdtree#unique(treeBufNames)

    "map the option names (that the user will be prompted with) to the nerd
    "tree buffer names
    let options = {}
    let i = 0
    while i < len(treeBufNames)
        let bufName = treeBufNames[i]
        let treeRoot = getbufvar(bufName, "NERDTreeRoot")
        let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
        let i = i + 1
    endwhile

    "work out which tree to mirror, if there is more than 1 then ask the user
    let bufferName = ''
    if len(keys(options)) > 1
        let choices = ["Choose a tree to mirror"]
        let choices = extend(choices, sort(keys(options)))
        let choice = inputlist(choices)
        if choice < 1 || choice > len(options) || choice ==# ''
            return
        endif

        let bufferName = options[sort(keys(options))[choice-1]]
    elseif len(keys(options)) ==# 1
        let bufferName = values(options)[0]
    else
        call nerdtree#echo("No trees to mirror")
        return
    endif

    if nerdtree#treeExistsForTab() && nerdtree#isTreeOpen()
        call nerdtree#closeTree()
    endif

    let t:NERDTreeBufName = bufferName
    call self._createTreeWin()
    exec 'buffer ' .  bufferName
    if !&hidden
        call nerdtree#renderView()
    endif
endfunction

"FUNCTION: s:Creator._createTreeWin() {{{1
"Inits the NERD tree window. ie. opens it, sizes it, sets all the local
"options etc
function! s:Creator._createTreeWin()
    "create the nerd tree window
    let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    let splitSize = g:NERDTreeWinSize

    if !exists('t:NERDTreeBufName')
        let t:NERDTreeBufName = self._nextBufferName()
        silent! exec splitLocation . 'vertical ' . splitSize . ' new'
        silent! exec "edit " . t:NERDTreeBufName
    else
        silent! exec splitLocation . 'vertical ' . splitSize . ' split'
        silent! exec "buffer " . t:NERDTreeBufName
    endif

    setlocal winfixwidth
    call self._setCommonBufOptions()
endfunction

"FUNCTION: s:Creator.New() {{{1
function! s:Creator.New()
    let newCreator = copy(self)
    return newCreator
endfunction

" FUNCTION: s:Creator._nextBufferName() {{{2
" returns the buffer name for the next nerd tree
function! s:Creator._nextBufferName()
    let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    return name
endfunction

" FUNCTION: s:Creator._nextBufferNumber() {{{2
" the number to add to the nerd tree buffer name to make the buf name unique
function! s:Creator._nextBufferNumber()
    if !exists("s:Creator._NextBufNum")
        let s:Creator._NextBufNum = 1
    else
        let s:Creator._NextBufNum += 1
    endif

    return s:Creator._NextBufNum
endfunction

"FUNCTION: s:Creator._pathForString(str) {{{1
"find a bookmark or adirectory for the given string
function! s:Creator._pathForString(str)
    let path = {}
    if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
        let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    else
        let dir = a:str ==# '' ? getcwd() : a:str

        "hack to get an absolute path if a relative path is given
        if dir =~# '^\.'
            let dir = getcwd() . g:NERDTreePath.Slash() . dir
        endif
        let dir = g:NERDTreePath.Resolve(dir)

        try
            let path = g:NERDTreePath.New(dir)
        catch /^NERDTree.InvalidArgumentsError/
            call nerdtree#echo("No bookmark or directory found for: " . a:str)
            return
        endtry
    endif
    if !path.isDirectory
        let path = path.getParent()
    endif

    return path
endfunction

"FUNCTION: s:Creator._setCommonBufOptions() {{{1
function! s:Creator._setCommonBufOptions()
    "throwaway buffer options
    setlocal noswapfile
    setlocal buftype=nofile
    setlocal bufhidden=hide
    setlocal nowrap
    setlocal foldcolumn=0
    setlocal foldmethod=manual
    setlocal nofoldenable
    setlocal nobuflisted
    setlocal nospell
    if g:NERDTreeShowLineNumbers
        setlocal nu
    else
        setlocal nonu
        if v:version >= 703
            setlocal nornu
        endif
    endif

    iabc <buffer>

    if g:NERDTreeHighlightCursorline
        setlocal cursorline
    endif

    call self._setupStatusline()

    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    setfiletype nerdtree
    call self._bindMappings()
endfunction

"FUNCTION: s:Creator._setupStatusline() {{{1
function! s:Creator._setupStatusline()
    if g:NERDTreeStatusline != -1
        let &l:statusline = g:NERDTreeStatusline
    endif
endfunction

"FUNCTION: s:Creator.TogglePrimary(dir) {{{1
function! s:Creator.TogglePrimary(dir)
    let creator = s:Creator.New()
    call creator.togglePrimary(a:dir)
endfunction

"FUNCTION: s:Creator.togglePrimary(dir) {{{1
"Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
"closed it is restored or initialized (if it doesnt exist)
"
"Args:
"dir: the full path for the root node (is only used if the NERD tree is being
"initialized.
function! s:Creator.togglePrimary(dir)
    if nerdtree#treeExistsForTab()
        if !nerdtree#isTreeOpen()
            call self._createTreeWin()
            if !&hidden
                call nerdtree#renderView()
            endif
            call nerdtree#restoreScreenState()
        else
            call nerdtree#closeTree()
        endif
    else
        call self.createPrimary(a:dir)
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/creator.vim
"CLASS: KeyMap
"============================================================
let s:KeyMap = {}
let g:NERDTreeKeyMap = s:KeyMap

"FUNCTION: KeyMap.All() {{{1
function! s:KeyMap.All()
    if !exists("s:keyMaps")
        let s:keyMaps = []
    endif
    return s:keyMaps
endfunction

"FUNCTION: KeyMap.FindFor(key, scope) {{{1
function! s:KeyMap.FindFor(key, scope)
    for i in s:KeyMap.All()
         if i.key ==# a:key && i.scope ==# a:scope
            return i
        endif
    endfor
    return {}
endfunction

"FUNCTION: KeyMap.BindAll() {{{1
function! s:KeyMap.BindAll()
    for i in s:KeyMap.All()
        call i.bind()
    endfor
endfunction

"FUNCTION: KeyMap.bind() {{{1
function! s:KeyMap.bind()
    " If the key sequence we're trying to map contains any '<>' notation, we
    " must replace each of the '<' characters with '<lt>' to ensure the string
    " is not translated into its corresponding keycode during the later part
    " of the map command below
    " :he <>
    let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
    if self.key =~# specialNotationRegex
        let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
    else
        let keymapInvokeString = self.key
    endif

    let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "

    exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'
endfunction

"FUNCTION: KeyMap.Remove(key, scope) {{{1
function! s:KeyMap.Remove(key, scope)
    let maps = s:KeyMap.All()
    for i in range(len(maps))
         if maps[i].key ==# a:key && maps[i].scope ==# a:scope
            return remove(maps, i)
        endif
    endfor
endfunction

"FUNCTION: KeyMap.invoke() {{{1
"Call the KeyMaps callback function
function! s:KeyMap.invoke(...)
    let Callback = function(self.callback)
    if a:0
        call Callback(a:1)
    else
        call Callback()
    endif
endfunction

"FUNCTION: KeyMap.Invoke() {{{1
"Find a keymapping for a:key and the current scope invoke it.
"
"Scope is determined as follows:
"   * if the cursor is on a dir node then "DirNode"
"   * if the cursor is on a file node then "FileNode"
"   * if the cursor is on a bookmark then "Bookmark"
"
"If a keymap has the scope of "all" then it will be called if no other keymap
"is found for a:key and the scope.
function! s:KeyMap.Invoke(key)
    let node = g:NERDTreeFileNode.GetSelected()
    if !empty(node)

        "try file node
        if !node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "FileNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try dir node
        if node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "DirNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try generic node
        let km = s:KeyMap.FindFor(a:key, "Node")
        if !empty(km)
            return km.invoke(node)
        endif

    endif

    "try bookmark
    let bm = g:NERDTreeBookmark.GetSelected()
    if !empty(bm)
        let km = s:KeyMap.FindFor(a:key, "Bookmark")
        if !empty(km)
            return km.invoke(bm)
        endif
    endif

    "try all
    let km = s:KeyMap.FindFor(a:key, "all")
    if !empty(km)
        return km.invoke()
    endif
endfunction

"FUNCTION: KeyMap.Create(options) {{{1
function! s:KeyMap.Create(options)
    let newKeyMap = copy(self)
    let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
    let newKeyMap.key = opts['key']
    let newKeyMap.quickhelpText = opts['quickhelpText']
    let newKeyMap.callback = opts['callback']
    let newKeyMap.scope = opts['scope']

    call s:KeyMap.Add(newKeyMap)
endfunction

"FUNCTION: KeyMap.Add(keymap) {{{1
function! s:KeyMap.Add(keymap)
    call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
    call add(s:KeyMap.All(), a:keymap)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/key_map.vim
"CLASS: MenuController
"============================================================
let s:MenuController = {}
let g:NERDTreeMenuController = s:MenuController

"FUNCTION: MenuController.New(menuItems) {{{1
"create a new menu controller that operates on the given menu items
function! s:MenuController.New(menuItems)
    let newMenuController =  copy(self)
    if a:menuItems[0].isSeparator()
        let newMenuController.menuItems = a:menuItems[1:-1]
    else
        let newMenuController.menuItems = a:menuItems
    endif
    return newMenuController
endfunction

"FUNCTION: MenuController.showMenu() {{{1
"start the main loop of the menu and get the user to choose/execute a menu
"item
function! s:MenuController.showMenu()
    call self._saveOptions()

    try
        let self.selection = 0

        let done = 0
        while !done
            redraw!
            call self._echoPrompt()
            let key = nr2char(getchar())
            let done = self._handleKeypress(key)
        endwhile
    finally
        call self._restoreOptions()
    endtry

    if self.selection != -1
        let m = self._current()
        call m.execute()
    endif
endfunction

"FUNCTION: MenuController._echoPrompt() {{{1
function! s:MenuController._echoPrompt()
    echo "NERDTree Menu. Use j/k/enter and the shortcuts indicated"
    echo "=========================================================="

    for i in range(0, len(self.menuItems)-1)
        if self.selection == i
            echo "> " . self.menuItems[i].text
        else
            echo "  " . self.menuItems[i].text
        endif
    endfor
endfunction

"FUNCTION: MenuController._current(key) {{{1
"get the MenuItem that is currently selected
function! s:MenuController._current()
    return self.menuItems[self.selection]
endfunction

"FUNCTION: MenuController._handleKeypress(key) {{{1
"change the selection (if appropriate) and return 1 if the user has made
"their choice, 0 otherwise
function! s:MenuController._handleKeypress(key)
    if a:key == 'j'
        call self._cursorDown()
    elseif a:key == 'k'
        call self._cursorUp()
    elseif a:key == nr2char(27) "escape
        let self.selection = -1
        return 1
    elseif a:key == "\r" || a:key == "\n" "enter and ctrl-j
        return 1
    else
        let index = self._nextIndexFor(a:key)
        if index != -1
            let self.selection = index
            if len(self._allIndexesFor(a:key)) == 1
                return 1
            endif
        endif
    endif

    return 0
endfunction

"FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
"get indexes to all menu items with the given shortcut
function! s:MenuController._allIndexesFor(shortcut)
    let toReturn = []

    for i in range(0, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            call add(toReturn, i)
        endif
    endfor

    return toReturn
endfunction

"FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
"get the index to the next menu item with the given shortcut, starts from the
"current cursor location and wraps around to the top again if need be
function! s:MenuController._nextIndexFor(shortcut)
    for i in range(self.selection+1, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    for i in range(0, self.selection)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    return -1
endfunction

"FUNCTION: MenuController._setCmdheight() {{{1
"sets &cmdheight to whatever is needed to display the menu
function! s:MenuController._setCmdheight()
    let &cmdheight = len(self.menuItems) + 3
endfunction

"FUNCTION: MenuController._saveOptions() {{{1
"set any vim options that are required to make the menu work (saving their old
"values)
function! s:MenuController._saveOptions()
    let self._oldLazyredraw = &lazyredraw
    let self._oldCmdheight = &cmdheight
    set nolazyredraw
    call self._setCmdheight()
endfunction

"FUNCTION: MenuController._restoreOptions() {{{1
"restore the options we saved in _saveOptions()
function! s:MenuController._restoreOptions()
    let &cmdheight = self._oldCmdheight
    let &lazyredraw = self._oldLazyredraw
endfunction

"FUNCTION: MenuController._cursorDown() {{{1
"move the cursor to the next menu item, skipping separators
function! s:MenuController._cursorDown()
    let done = 0
    while !done
        if self.selection < len(self.menuItems)-1
            let self.selection += 1
        else
            let self.selection = 0
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

"FUNCTION: MenuController._cursorUp() {{{1
"move the cursor to the previous menu item, skipping separators
function! s:MenuController._cursorUp()
    let done = 0
    while !done
        if self.selection > 0
            let self.selection -= 1
        else
            let self.selection = len(self.menuItems)-1
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/menu_controller.vim
"CLASS: Bookmark
"============================================================
let s:Bookmark = {}
let g:NERDTreeBookmark = s:Bookmark

" FUNCTION: Bookmark.activate() {{{1
function! s:Bookmark.activate(...)
    call self.open(a:0 ? a:1 : {})
endfunction

" FUNCTION: Bookmark.AddBookmark(name, path) {{{1
" Class method to add a new bookmark to the list, if a previous bookmark exists
" with the same name, just update the path for that bookmark
function! s:Bookmark.AddBookmark(name, path)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            let i.path = a:path
            return
        endif
    endfor
    call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
    call s:Bookmark.Sort()
endfunction

" FUNCTION: Bookmark.Bookmarks()   {{{1
" Class method to get all bookmarks. Lazily initializes the bookmarks global
" variable
function! s:Bookmark.Bookmarks()
    if !exists("g:NERDTreeBookmarks")
        let g:NERDTreeBookmarks = []
    endif
    return g:NERDTreeBookmarks
endfunction

" FUNCTION: Bookmark.BookmarkExistsFor(name)   {{{1
" class method that returns 1 if a bookmark with the given name is found, 0
" otherwise
function! s:Bookmark.BookmarkExistsFor(name)
    try
        call s:Bookmark.BookmarkFor(a:name)
        return 1
    catch /^NERDTree.BookmarkNotFoundError/
        return 0
    endtry
endfunction

" FUNCTION: Bookmark.BookmarkFor(name)   {{{1
" Class method to get the bookmark that has the given name. {} is return if no
" bookmark is found
function! s:Bookmark.BookmarkFor(name)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            return i
        endif
    endfor
    throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'
endfunction

" FUNCTION: Bookmark.BookmarkNames()   {{{1
" Class method to return an array of all bookmark names
function! s:Bookmark.BookmarkNames()
    let names = []
    for i in s:Bookmark.Bookmarks()
        call add(names, i.name)
    endfor
    return names
endfunction

" FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
" Class method to read all bookmarks from the bookmarks file initialize
" bookmark objects for each one.
"
" Args:
" silent - dont echo an error msg if invalid bookmarks are found
function! s:Bookmark.CacheBookmarks(silent)
    if filereadable(g:NERDTreeBookmarksFile)
        let g:NERDTreeBookmarks = []
        let g:NERDTreeInvalidBookmarks = []
        let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
        let invalidBookmarksFound = 0
        for i in bookmarkStrings

            "ignore blank lines
            if i != ''

                let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')

                try
                    let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                    call add(g:NERDTreeBookmarks, bookmark)
                catch /^NERDTree.InvalidArgumentsError/
                    call add(g:NERDTreeInvalidBookmarks, i)
                    let invalidBookmarksFound += 1
                endtry
            endif
        endfor
        if invalidBookmarksFound
            call s:Bookmark.Write()
            if !a:silent
                call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
            endif
        endif
        call s:Bookmark.Sort()
    endif
endfunction

" FUNCTION: Bookmark.compareTo(otherbookmark) {{{1
" Compare these two bookmarks for sorting purposes
function! s:Bookmark.compareTo(otherbookmark)
    return a:otherbookmark.name < self.name
endfunction
" FUNCTION: Bookmark.ClearAll() {{{1
" Class method to delete all bookmarks.
function! s:Bookmark.ClearAll()
    for i in s:Bookmark.Bookmarks()
        call i.delete()
    endfor
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.delete() {{{1
" Delete this bookmark. If the node for this bookmark is under the current
" root, then recache bookmarks for its Path object
function! s:Bookmark.delete()
    let node = {}
    try
        let node = self.getNode(1)
    catch /^NERDTree.BookmarkedNodeNotFoundError/
    endtry
    call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
    if !empty(node)
        call node.path.cacheDisplayString()
    endif
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{1
" Gets the treenode for this bookmark
"
" Args:
" searchFromAbsoluteRoot: specifies whether we should search from the current
" tree root, or the highest cached node
function! s:Bookmark.getNode(searchFromAbsoluteRoot)
    let searchRoot = a:searchFromAbsoluteRoot ? g:NERDTreeDirNode.AbsoluteTreeRoot() : b:NERDTreeRoot
    let targetNode = searchRoot.findNode(self.path)
    if empty(targetNode)
        throw "NERDTree.BookmarkedNodeNotFoundError: no node was found for bookmark: " . self.name
    endif
    return targetNode
endfunction

" FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{1
" Class method that finds the bookmark with the given name and returns the
" treenode for it.
function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    return bookmark.getNode(a:searchFromAbsoluteRoot)
endfunction

" FUNCTION: Bookmark.GetSelected() {{{1
" returns the Bookmark the cursor is over, or {}
function! s:Bookmark.GetSelected()
    let line = getline(".")
    let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    if name != line
        try
            return s:Bookmark.BookmarkFor(name)
        catch /^NERDTree.BookmarkNotFoundError/
            return {}
        endtry
    endif
    return {}
endfunction

" FUNCTION: Bookmark.InvalidBookmarks()   {{{1
" Class method to get all invalid bookmark strings read from the bookmarks
" file
function! s:Bookmark.InvalidBookmarks()
    if !exists("g:NERDTreeInvalidBookmarks")
        let g:NERDTreeInvalidBookmarks = []
    endif
    return g:NERDTreeInvalidBookmarks
endfunction

" FUNCTION: Bookmark.mustExist() {{{1
function! s:Bookmark.mustExist()
    if !self.path.exists()
        call s:Bookmark.CacheBookmarks(1)
        throw "NERDTree.BookmarkPointsToInvalidLocationError: the bookmark \"".
            \ self.name ."\" points to a non existing location: \"". self.path.str()
    endif
endfunction

" FUNCTION: Bookmark.New(name, path) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.New(name, path)
    if a:name =~# ' '
        throw "NERDTree.IllegalBookmarkNameError: illegal name:" . a:name
    endif

    let newBookmark = copy(self)
    let newBookmark.name = a:name
    let newBookmark.path = a:path
    return newBookmark
endfunction

" FUNCTION: Bookmark.open([options]) {{{1
"Args:
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' (vertical split), 'h'
"           (horizontal split), 't' (new tab) or 'p' (previous window).
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
"
function! s:Bookmark.open(...)
    let opts = a:0 ? a:1 : {}

    if self.path.isDirectory && !has_key(opts, 'where')
        call self.toRoot()
    else
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    endif
endfunction

" FUNCTION: Bookmark.openInNewTab(options) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.openInNewTab(options)
    call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
    call self.open(a:options)
endfunction

" FUNCTION: Bookmark.setPath(path)   {{{1
" makes this bookmark point to the given path
function! s:Bookmark.setPath(path)
    let self.path = a:path
endfunction

" FUNCTION: Bookmark.Sort()   {{{1
" Class method that sorts all bookmarks
function! s:Bookmark.Sort()
    let CompareFunc = function("nerdtree#compareBookmarks")
    call sort(s:Bookmark.Bookmarks(), CompareFunc)
endfunction

" FUNCTION: Bookmark.str()   {{{1
" Get the string that should be rendered in the view for this bookmark
function! s:Bookmark.str()
    let pathStrMaxLen = winwidth(nerdtree#getTreeWinNum()) - 4 - len(self.name)
    if &nu
        let pathStrMaxLen = pathStrMaxLen - &numberwidth
    endif

    let pathStr = self.path.str({'format': 'UI'})
    if len(pathStr) > pathStrMaxLen
        let pathStr = '<' . strpart(pathStr, len(pathStr) - pathStrMaxLen)
    endif
    return '>' . self.name . ' ' . pathStr
endfunction

" FUNCTION: Bookmark.toRoot() {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.toRoot()
    if self.validate()
        try
            let targetNode = self.getNode(1)
        catch /^NERDTree.BookmarkedNodeNotFoundError/
            let targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path)
        endtry
        call targetNode.makeRoot()
        call nerdtree#renderView()
        call targetNode.putCursorHere(0, 0)
    endif
endfunction

" FUNCTION: Bookmark.ToRoot(name) {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.ToRoot(name)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    call bookmark.toRoot()
endfunction

" FUNCTION: Bookmark.validate() {{{1
function! s:Bookmark.validate()
    if self.path.exists()
        return 1
    else
        call s:Bookmark.CacheBookmarks(1)
        call nerdtree#renderView()
        call nerdtree#echo(self.name . "now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.")
        return 0
    endif
endfunction

" FUNCTION: Bookmark.Write()   {{{1
" Class method to write all bookmarks to the bookmarks file
function! s:Bookmark.Write()
    let bookmarkStrings = []
    for i in s:Bookmark.Bookmarks()
        call add(bookmarkStrings, i.name . ' ' . i.path.str())
    endfor

    "add a blank line before the invalid ones
    call add(bookmarkStrings, "")

    for j in s:Bookmark.InvalidBookmarks()
        call add(bookmarkStrings, j)
    endfor
    call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/bookmark.vim
"we need to use this number many times for sorting... so we calculate it only
"once here
let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')

"CLASS: Path
"============================================================
let s:Path = {}
let g:NERDTreePath = s:Path

"FUNCTION: Path.AbsolutePathFor(str) {{{1
function! s:Path.AbsolutePathFor(str)
    let prependCWD = 0
    if nerdtree#runningWindows()
        let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
    else
        let prependCWD = a:str !~# '^/'
    endif

    let toReturn = a:str
    if prependCWD
        let toReturn = getcwd() . s:Path.Slash() . a:str
    endif

    return toReturn
endfunction

"FUNCTION: Path.bookmarkNames() {{{1
function! s:Path.bookmarkNames()
    if !exists("self._bookmarkNames")
        call self.cacheDisplayString()
    endif
    return self._bookmarkNames
endfunction

"FUNCTION: Path.cacheDisplayString() {{{1
function! s:Path.cacheDisplayString()
    let self.cachedDisplayString = self.getLastPathComponent(1)

    if self.isExecutable
        let self.cachedDisplayString = self.cachedDisplayString . '*'
    endif

    let self._bookmarkNames = []
    for i in g:NERDTreeBookmark.Bookmarks()
        if i.path.equals(self)
            call add(self._bookmarkNames, i.name)
        endif
    endfor
    if !empty(self._bookmarkNames)
        let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
    endif

    if self.isSymLink
        let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
    endif

    if self.isReadOnly
        let self.cachedDisplayString .=  ' [RO]'
    endif
endfunction

"FUNCTION: Path.changeToDir() {{{1
function! s:Path.changeToDir()
    let dir = self.str({'format': 'Cd'})
    if self.isDirectory ==# 0
        let dir = self.getParent().str({'format': 'Cd'})
    endif

    try
        execute "cd " . dir
        call nerdtree#echo("CWD is now: " . getcwd())
    catch
        throw "NERDTree.PathChangeError: cannot change CWD to " . dir
    endtry
endfunction

"FUNCTION: Path.compareTo() {{{1
"
"Compares this Path to the given path and returns 0 if they are equal, -1 if
"this Path is "less than" the given path, or 1 if it is "greater".
"
"Args:
"path: the path object to compare this to
"
"Return:
"1, -1 or 0
function! s:Path.compareTo(path)
    let thisPath = self.getLastPathComponent(1)
    let thatPath = a:path.getLastPathComponent(1)

    "if the paths are the same then clearly we return 0
    if thisPath ==# thatPath
        return 0
    endif

    let thisSS = self.getSortOrderIndex()
    let thatSS = a:path.getSortOrderIndex()

    "compare the sort sequences, if they are different then the return
    "value is easy
    if thisSS < thatSS
        return -1
    elseif thisSS > thatSS
        return 1
    else
        "if the sort sequences are the same then compare the paths
        "alphabetically
        let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
        if pathCompare
            return -1
        else
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.Create(fullpath) {{{1
"
"Factory method.
"
"Creates a path object with the given path. The path is also created on the
"filesystem. If the path already exists, a NERDTree.Path.Exists exception is
"thrown. If any other errors occur, a NERDTree.Path exception is thrown.
"
"Args:
"fullpath: the full filesystem path to the file/dir to create
function! s:Path.Create(fullpath)
    "bail if the a:fullpath already exists
    if isdirectory(a:fullpath) || filereadable(a:fullpath)
        throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
    endif

    try

        "if it ends with a slash, assume its a dir create it
        if a:fullpath =~# '\(\\\|\/\)$'
            "whack the trailing slash off the end if it exists
            let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')

            call mkdir(fullpath, 'p')

        "assume its a file and create
        else
            call writefile([], a:fullpath)
        endif
    catch
        throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
    endtry

    return s:Path.New(a:fullpath)
endfunction

"FUNCTION: Path.copy(dest) {{{1
"
"Copies the file/dir represented by this Path to the given location
"
"Args:
"dest: the location to copy this dir/file to
function! s:Path.copy(dest)
    if !s:Path.CopyingSupported()
        throw "NERDTree.CopyingNotSupportedError: Copying is not supported on this OS"
    endif

    let dest = s:Path.WinToUnixPath(a:dest)

    let cmd = g:NERDTreeCopyCmd . " " . escape(self.str(), nerdtree#escChars()) . " " . escape(dest, nerdtree#escChars())
    let success = system(cmd)
    if success != 0
        throw "NERDTree.CopyError: Could not copy ''". self.str() ."'' to: '" . a:dest . "'"
    endif
endfunction

"FUNCTION: Path.CopyingSupported() {{{1
"
"returns 1 if copying is supported for this OS
function! s:Path.CopyingSupported()
    return exists('g:NERDTreeCopyCmd')
endfunction

"FUNCTION: Path.copyingWillOverwrite(dest) {{{1
"
"returns 1 if copy this path to the given location will cause files to
"overwritten
"
"Args:
"dest: the location this path will be copied to
function! s:Path.copyingWillOverwrite(dest)
    if filereadable(a:dest)
        return 1
    endif

    if isdirectory(a:dest)
        let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
        if filereadable(path)
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.delete() {{{1
"
"Deletes the file represented by this path.
"Deletion of directories is not supported
"
"Throws NERDTree.Path.Deletion exceptions
function! s:Path.delete()
    if self.isDirectory

        let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
        let success = system(cmd)

        if v:shell_error != 0
            throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
        endif
    else
        let success = delete(self.str())
        if success != 0
            throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
        endif
    endif

    "delete all bookmarks for this path
    for i in self.bookmarkNames()
        let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
        call bookmark.delete()
    endfor
endfunction

"FUNCTION: Path.displayString() {{{1
"
"Returns a string that specifies how the path should be represented as a
"string
function! s:Path.displayString()
    if self.cachedDisplayString ==# ""
        call self.cacheDisplayString()
    endif

    return self.cachedDisplayString
endfunction

"FUNCTION: Path.edit() {{{1
function! s:Path.edit()
    exec "edit " . self.str({'format': 'Edit'})
endfunction

"FUNCTION: Path.extractDriveLetter(fullpath) {{{1
"
"If running windows, cache the drive letter for this path
function! s:Path.extractDriveLetter(fullpath)
    if nerdtree#runningWindows()
        if a:fullpath =~ '^\(\\\\\|\/\/\)'
            "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
            let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
            let self.drive = substitute(self.drive, '/', '\', "g")
        else
            let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
        endif
    else
        let self.drive = ''
    endif

endfunction

"FUNCTION: Path.exists() {{{1
"return 1 if this path points to a location that is readable or is a directory
function! s:Path.exists()
    let p = self.str()
    return filereadable(p) || isdirectory(p)
endfunction

"FUNCTION: Path.getDir() {{{1
"
"Returns this path if it is a directory, else this paths parent.
"
"Return:
"a Path object
function! s:Path.getDir()
    if self.isDirectory
        return self
    else
        return self.getParent()
    endif
endfunction

"FUNCTION: Path.getParent() {{{1
"
"Returns a new path object for this paths parent
"
"Return:
"a new Path object
function! s:Path.getParent()
    if nerdtree#runningWindows()
        let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    else
        let path = '/'. join(self.pathSegments[0:-2], '/')
    endif

    return s:Path.New(path)
endfunction

"FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
"
"Gets the last part of this path.
"
"Args:
"dirSlash: if 1 then a trailing slash will be added to the returned value for
"directory nodes.
function! s:Path.getLastPathComponent(dirSlash)
    if empty(self.pathSegments)
        return ''
    endif
    let toReturn = self.pathSegments[-1]
    if a:dirSlash && self.isDirectory
        let toReturn = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path.getSortOrderIndex() {{{1
"returns the index of the pattern in g:NERDTreeSortOrder that this path matches
function! s:Path.getSortOrderIndex()
    let i = 0
    while i < len(g:NERDTreeSortOrder)
        if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
            return i
        endif
        let i = i + 1
    endwhile
    return s:NERDTreeSortStarIndex
endfunction

"FUNCTION: Path.isUnixHiddenFile() {{{1
"check for unix hidden files
function! s:Path.isUnixHiddenFile()
    return self.getLastPathComponent(0) =~# '^\.'
endfunction

"FUNCTION: Path.isUnixHiddenPath() {{{1
"check for unix path with hidden components
function! s:Path.isUnixHiddenPath()
    if self.getLastPathComponent(0) =~# '^\.'
        return 1
    else
        for segment in self.pathSegments
            if segment =~# '^\.'
                return 1
            endif
        endfor
        return 0
    endif
endfunction

"FUNCTION: Path.ignore() {{{1
"returns true if this path should be ignored
function! s:Path.ignore()
    "filter out the user specified paths to ignore
    if b:NERDTreeIgnoreEnabled
        for i in g:NERDTreeIgnore
            if self._ignorePatternMatches(i)
                return 1
            endif
        endfor
    endif

    "dont show hidden files unless instructed to
    if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
        return 1
    endif

    if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
        return 1
    endif

    if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
        return 1
    endif

    return 0
endfunction

"FUNCTION: Path._ignorePatternMatches(pattern) {{{1
"returns true if this path matches the given ignore pattern
function! s:Path._ignorePatternMatches(pattern)
    let pat = a:pattern
    if strpart(pat,len(pat)-7) == '[[dir]]'
        if !self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-7)
    elseif strpart(pat,len(pat)-8) == '[[file]]'
        if self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-8)
    endif

    return self.getLastPathComponent(0) =~# pat
endfunction

"FUNCTION: Path.isUnder(path) {{{1
"return 1 if this path is somewhere under the given path in the filesystem.
"
"a:path should be a dir
function! s:Path.isUnder(path)
    if a:path.isDirectory == 0
        return 0
    endif

    let this = self.str()
    let that = a:path.str()
    return stridx(this, that . s:Path.Slash()) == 0
endfunction

"FUNCTION: Path.JoinPathStrings(...) {{{1
function! s:Path.JoinPathStrings(...)
    let components = []
    for i in a:000
        let components = extend(components, split(i, '/'))
    endfor
    return '/' . join(components, '/')
endfunction

"FUNCTION: Path.equals() {{{1
"
"Determines whether 2 path objects are "equal".
"They are equal if the paths they represent are the same
"
"Args:
"path: the other path obj to compare this with
function! s:Path.equals(path)
    return self.str() ==# a:path.str()
endfunction

"FUNCTION: Path.New() {{{1
"The Constructor for the Path object
function! s:Path.New(path)
    let newPath = copy(self)

    call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))

    let newPath.cachedDisplayString = ""

    return newPath
endfunction

"FUNCTION: Path.Slash() {{{1
"return the slash to use for the current OS
function! s:Path.Slash()
    return nerdtree#runningWindows() ? '\' : '/'
endfunction

"FUNCTION: Path.Resolve() {{{1
"Invoke the vim resolve() function and return the result
"This is necessary because in some versions of vim resolve() removes trailing
"slashes while in other versions it doesn't.  This always removes the trailing
"slash
function! s:Path.Resolve(path)
    let tmp = resolve(a:path)
    return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
endfunction

"FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
"
"
"Throws NERDTree.Path.InvalidArguments exception.
function! s:Path.readInfoFromDisk(fullpath)
    call self.extractDriveLetter(a:fullpath)

    let fullpath = s:Path.WinToUnixPath(a:fullpath)

    if getftype(fullpath) ==# "fifo"
        throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
    endif

    let self.pathSegments = split(fullpath, '/')

    let self.isReadOnly = 0
    if isdirectory(a:fullpath)
        let self.isDirectory = 1
    elseif filereadable(a:fullpath)
        let self.isDirectory = 0
        let self.isReadOnly = filewritable(a:fullpath) ==# 0
    else
        throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
    endif

    let self.isExecutable = 0
    if !self.isDirectory
        let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    endif

    "grab the last part of the path (minus the trailing slash)
    let lastPathComponent = self.getLastPathComponent(0)

    "get the path to the new node with the parent dir fully resolved
    let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent

    "if  the last part of the path is a symlink then flag it as such
    let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    if self.isSymLink
        let self.symLinkDest = s:Path.Resolve(fullpath)

        "if the link is a dir then slap a / on the end of its dest
        if isdirectory(self.symLinkDest)

            "we always wanna treat MS windows shortcuts as files for
            "simplicity
            if hardPath !~# '\.lnk$'

                let self.symLinkDest = self.symLinkDest . '/'
            endif
        endif
    endif
endfunction

"FUNCTION: Path.refresh() {{{1
function! s:Path.refresh()
    call self.readInfoFromDisk(self.str())
    call self.cacheDisplayString()
endfunction

"FUNCTION: Path.rename() {{{1
"
"Renames this node on the filesystem
function! s:Path.rename(newPath)
    if a:newPath ==# ''
        throw "NERDTree.InvalidArgumentsError: Invalid newPath for renaming = ". a:newPath
    endif

    let success =  rename(self.str(), a:newPath)
    if success != 0
        throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
    endif
    call self.readInfoFromDisk(a:newPath)

    for i in self.bookmarkNames()
        let b = g:NERDTreeBookmark.BookmarkFor(i)
        call b.setPath(copy(self))
    endfor
    call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: Path.str() {{{1
"
"Returns a string representation of this Path
"
"Takes an optional dictionary param to specify how the output should be
"formatted.
"
"The dict may have the following keys:
"  'format'
"  'escape'
"  'truncateTo'
"
"The 'format' key may have a value of:
"  'Cd' - a string to be used with the :cd command
"  'Edit' - a string to be used with :e :sp :new :tabedit etc
"  'UI' - a string used in the NERD tree UI
"
"The 'escape' key, if specified will cause the output to be escaped with
"shellescape()
"
"The 'truncateTo' key causes the resulting string to be truncated to the value
"'truncateTo' maps to. A '<' char will be prepended.
function! s:Path.str(...)
    let options = a:0 ? a:1 : {}
    let toReturn = ""

    if has_key(options, 'format')
        let format = options['format']
        if has_key(self, '_strFor' . format)
            exec 'let toReturn = self._strFor' . format . '()'
        else
            raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
        endif
    else
        let toReturn = self._str()
    endif

    if nerdtree#has_opt(options, 'escape')
        let toReturn = shellescape(toReturn)
    endif

    if has_key(options, 'truncateTo')
        let limit = options['truncateTo']
        if len(toReturn) > limit
            let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
        endif
    endif

    return toReturn
endfunction

"FUNCTION: Path._strForUI() {{{1
function! s:Path._strForUI()
    let toReturn = '/' . join(self.pathSegments, '/')
    if self.isDirectory && toReturn != '/'
        let toReturn  = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path._strForCd() {{{1
"
" returns a string that can be used with :cd
function! s:Path._strForCd()
    return escape(self.str(), nerdtree#escChars())
endfunction

"FUNCTION: Path._strForEdit() {{{1
"
"Return: the string for this path that is suitable to be used with the :edit
"command
function! s:Path._strForEdit()
    let p = escape(self.str({'format': 'UI'}), nerdtree#escChars())
    let cwd = getcwd() . s:Path.Slash()

    "return a relative path if we can
    let isRelative = 0
    if nerdtree#runningWindows()
        let isRelative = stridx(tolower(p), tolower(cwd)) == 0
    else
        let isRelative = stridx(p, cwd) == 0
    endif

    if isRelative
        let p = strpart(p, strlen(cwd))

        "handle the edge case where the file begins with a + (vim interprets
        "the +foo in `:e +foo` as an option to :edit)
        if p[0] == "+"
            let p = '\' . p
        endif
    endif

    if p ==# ''
        let p = '.'
    endif

    return p
endfunction

"FUNCTION: Path._strForGlob() {{{1
function! s:Path._strForGlob()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    let toReturn = lead . join(self.pathSegments, s:Path.Slash())

    if !nerdtree#runningWindows()
        let toReturn = escape(toReturn, nerdtree#escChars())
    endif
    return toReturn
endfunction

"FUNCTION: Path._str() {{{1
"
"Gets the string path for this path object that is appropriate for the OS.
"EG, in windows c:\foo\bar
"    in *nix  /foo/bar
function! s:Path._str()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    return lead . join(self.pathSegments, s:Path.Slash())
endfunction

"FUNCTION: Path.strTrunk() {{{1
"Gets the path without the last segment on the end.
function! s:Path.strTrunk()
    return self.drive . '/' . join(self.pathSegments[0:-2], '/')
endfunction

" FUNCTION: Path.tabnr() {{{1
" return the number of the first tab that is displaying this file
"
" return 0 if no tab was found
function! s:Path.tabnr()
    let str = self.str()
    for t in range(tabpagenr('$'))
        for b in tabpagebuflist(t+1)
            if str == expand('#' . b . ':p')
                return t+1
            endif
        endfor
    endfor
    return 0
endfunction

"FUNCTION: Path.WinToUnixPath(pathstr){{{1
"Takes in a windows path and returns the unix equiv
"
"A class level method
"
"Args:
"pathstr: the windows path to convert
function! s:Path.WinToUnixPath(pathstr)
    if !nerdtree#runningWindows()
        return a:pathstr
    endif

    let toReturn = a:pathstr

    "remove the x:\ of the front
    let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")

    "remove the \\ network share from the front
    let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")

    "convert all \ chars to /
    let toReturn = substitute(toReturn, '\', '/', "g")

    return toReturn
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/path.vim
"CLASS: TreeDirNode
"A subclass of NERDTreeFileNode.
"
"The 'composite' part of the file/dir composite.
"============================================================
let s:TreeDirNode = copy(g:NERDTreeFileNode)
let g:NERDTreeDirNode = s:TreeDirNode

"FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
"class method that returns the highest cached ancestor of the current root
function! s:TreeDirNode.AbsoluteTreeRoot()
    let currentNode = b:NERDTreeRoot
    while currentNode.parent != {}
        let currentNode = currentNode.parent
    endwhile
    return currentNode
endfunction

"FUNCTION: TreeDirNode.activate([options]) {{{1
unlet s:TreeDirNode.activate
function! s:TreeDirNode.activate(...)
    let opts = a:0 ? a:1 : {}
    call self.toggleOpen(opts)
    call nerdtree#renderView()
    call self.putCursorHere(0, 0)
endfunction

"FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
"Adds the given treenode to the list of children for this node
"
"Args:
"-treenode: the node to add
"-inOrder: 1 if the new node should be inserted in sorted order
function! s:TreeDirNode.addChild(treenode, inOrder)
    call add(self.children, a:treenode)
    let a:treenode.parent = self

    if a:inOrder
        call self.sortChildren()
    endif
endfunction

"FUNCTION: TreeDirNode.close() {{{1
"Closes this directory
function! s:TreeDirNode.close()
    let self.isOpen = 0
endfunction

"FUNCTION: TreeDirNode.closeChildren() {{{1
"Closes all the child dir nodes of this node
function! s:TreeDirNode.closeChildren()
    for i in self.children
        if i.path.isDirectory
            call i.close()
            call i.closeChildren()
        endif
    endfor
endfunction

"FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
"Instantiates a new child node for this node with the given path. The new
"nodes parent is set to this node.
"
"Args:
"path: a Path object that this node will represent/contain
"inOrder: 1 if the new node should be inserted in sorted order
"
"Returns:
"the newly created node
function! s:TreeDirNode.createChild(path, inOrder)
    let newTreeNode = g:NERDTreeFileNode.New(a:path)
    call self.addChild(newTreeNode, a:inOrder)
    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.findNode(path) {{{1
"Will find one of the children (recursively) that has the given path
"
"Args:
"path: a path object
unlet s:TreeDirNode.findNode
function! s:TreeDirNode.findNode(path)
    if a:path.equals(self.path)
        return self
    endif
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    if self.path.isDirectory
        for i in self.children
            let retVal = i.findNode(a:path)
            if retVal != {}
                return retVal
            endif
        endfor
    endif
    return {}
endfunction

"FUNCTION: TreeDirNode.getChildCount() {{{1
"Returns the number of children this node has
function! s:TreeDirNode.getChildCount()
    return len(self.children)
endfunction

"FUNCTION: TreeDirNode.getChild(path) {{{1
"Returns child node of this node that has the given path or {} if no such node
"exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChild(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    let index = self.getChildIndex(a:path)
    if index ==# -1
        return {}
    else
        return self.children[index]
    endif

endfunction

"FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
"returns the child at the given index
"Args:
"indx: the index to get the child from
"visible: 1 if only the visible children array should be used, 0 if all the
"children should be searched.
function! s:TreeDirNode.getChildByIndex(indx, visible)
    let array_to_search = a:visible? self.getVisibleChildren() : self.children
    if a:indx > len(array_to_search)
        throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
    endif
    return array_to_search[a:indx]
endfunction

"FUNCTION: TreeDirNode.getChildIndex(path) {{{1
"Returns the index of the child node of this node that has the given path or
"-1 if no such node exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChildIndex(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return -1
    endif

    "do a binary search for the child
    let a = 0
    let z = self.getChildCount()
    while a < z
        let mid = (a+z)/2
        let diff = a:path.compareTo(self.children[mid].path)

        if diff ==# -1
            let z = mid
        elseif diff ==# 1
            let a = mid+1
        else
            return mid
        endif
    endwhile
    return -1
endfunction

"FUNCTION: TreeDirNode.GetSelected() {{{1
"Returns the current node if it is a dir node, or else returns the current
"nodes parent
unlet s:TreeDirNode.GetSelected
function! s:TreeDirNode.GetSelected()
    let currentDir = g:NERDTreeFileNode.GetSelected()
    if currentDir != {} && !currentDir.isRoot()
        if currentDir.path.isDirectory ==# 0
            let currentDir = currentDir.parent
        endif
    endif
    return currentDir
endfunction

"FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
"Returns the number of visible children this node has
function! s:TreeDirNode.getVisibleChildCount()
    return len(self.getVisibleChildren())
endfunction

"FUNCTION: TreeDirNode.getVisibleChildren() {{{1
"Returns a list of children to display for this node, in the correct order
"
"Return:
"an array of treenodes
function! s:TreeDirNode.getVisibleChildren()
    let toReturn = []
    for i in self.children
        if i.path.ignore() ==# 0
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
"returns 1 if this node has any childre, 0 otherwise..
function! s:TreeDirNode.hasVisibleChildren()
    return self.getVisibleChildCount() != 0
endfunction

"FUNCTION: TreeDirNode._initChildren() {{{1
"Removes all childen from this node and re-reads them
"
"Args:
"silent: 1 if the function should not echo any "please wait" messages for
"large directories
"
"Return: the number of child nodes read
function! s:TreeDirNode._initChildren(silent)
    "remove all the current child nodes
    let self.children = []

    "get an array of all the files in the nodes dir
    let dir = self.path
    let globDir = dir.str({'format': 'Glob'})

    if version >= 703
        let filesStr = globpath(globDir, '*', 1) . "\n" . globpath(globDir, '.*', 1)
    else
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
    endif

    let files = split(filesStr, "\n")

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ...")
    endif

    let invalidFilesFound = 0
    for i in files

        "filter out the .. and . directories
        "Note: we must match .. AND ../ cos sometimes the globpath returns
        "../ for path with strange chars (eg $)
        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

            "put the next file in a new node and attach it
            try
                let path = g:NERDTreePath.New(i)
                call self.createChild(path, 0)
            catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                let invalidFilesFound += 1
            endtry
        endif
    endfor

    call self.sortChildren()

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
    endif

    if invalidFilesFound
        call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
    endif
    return self.getChildCount()
endfunction

"FUNCTION: TreeDirNode.New(path) {{{1
"Returns a new TreeNode object with the given path and parent
"
"Args:
"path: a path object representing the full filesystem path to the file/dir that the node represents
unlet s:TreeDirNode.New
function! s:TreeDirNode.New(path)
    if a:path.isDirectory != 1
        throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
    endif

    let newTreeNode = copy(self)
    let newTreeNode.path = a:path

    let newTreeNode.isOpen = 0
    let newTreeNode.children = []

    let newTreeNode.parent = {}

    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.open([opts]) {{{1
"Open the dir in the current tree or in a new tree elsewhere.
"
"If opening in the current tree, return the number of cached nodes.
unlet s:TreeDirNode.open
function! s:TreeDirNode.open(...)
    let opts = a:0 ? a:1 : {}

    if has_key(opts, 'where') && !empty(opts['where'])
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    else
        let self.isOpen = 1
        if self.children ==# []
            return self._initChildren(0)
        else
            return 0
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.openAlong([opts]) {{{1
"recursive open the dir if it has only one directory child.
"
"return the level of opened directories.
function! s:TreeDirNode.openAlong(...)
    let opts = a:0 ? a:1 : {}
    let level = 0

    let node = self
    while node.path.isDirectory
        call node.open(opts)
        let level += 1
        if node.getVisibleChildCount() == 1
            let node = node.getChildByIndex(0, 1)
        else
            break
        endif
    endwhile
    return level
endfunction

" FUNCTION: TreeDirNode.openExplorer() {{{1
" opens an explorer window for this node in the previous window (could be a
" nerd tree or a netrw)
function! s:TreeDirNode.openExplorer()
    call self.open({'where': 'p'})
endfunction

"FUNCTION: TreeDirNode.openInNewTab(options) {{{1
unlet s:TreeDirNode.openInNewTab
function! s:TreeDirNode.openInNewTab(options)
    call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
    call self.open({'where': 't'})
endfunction

"FUNCTION: TreeDirNode._openInNewTab() {{{1
function! s:TreeDirNode._openInNewTab()
    tabnew
    call g:NERDTreeCreator.CreatePrimary(self.path.str())
endfunction

"FUNCTION: TreeDirNode.openRecursively() {{{1
"Opens this treenode and all of its children whose paths arent 'ignored'
"because of the file filters.
"
"This method is actually a wrapper for the OpenRecursively2 method which does
"the work.
function! s:TreeDirNode.openRecursively()
    call self._openRecursively2(1)
endfunction

"FUNCTION: TreeDirNode._openRecursively2() {{{1
"Opens this all children of this treenode recursively if either:
"   *they arent filtered by file filters
"   *a:forceOpen is 1
"
"Args:
"forceOpen: 1 if this node should be opened regardless of file filters
function! s:TreeDirNode._openRecursively2(forceOpen)
    if self.path.ignore() ==# 0 || a:forceOpen
        let self.isOpen = 1
        if self.children ==# []
            call self._initChildren(1)
        endif

        for i in self.children
            if i.path.isDirectory ==# 1
                call i._openRecursively2(0)
            endif
        endfor
    endif
endfunction

"FUNCTION: TreeDirNode.refresh() {{{1
unlet s:TreeDirNode.refresh
function! s:TreeDirNode.refresh()
    call self.path.refresh()

    "if this node was ever opened, refresh its children
    if self.isOpen || !empty(self.children)
        "go thru all the files/dirs under this node
        let newChildNodes = []
        let invalidFilesFound = 0
        let dir = self.path
        let globDir = dir.str({'format': 'Glob'})
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
        let files = split(filesStr, "\n")
        for i in files
            "filter out the .. and . directories
            "Note: we must match .. AND ../ cos sometimes the globpath returns
            "../ for path with strange chars (eg $)
            if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

                try
                    "create a new path and see if it exists in this nodes children
                    let path = g:NERDTreePath.New(i)
                    let newNode = self.getChild(path)
                    if newNode != {}
                        call newNode.refresh()
                        call add(newChildNodes, newNode)

                    "the node doesnt exist so create it
                    else
                        let newNode = g:NERDTreeFileNode.New(path)
                        let newNode.parent = self
                        call add(newChildNodes, newNode)
                    endif


                catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                    let invalidFilesFound = 1
                endtry
            endif
        endfor

        "swap this nodes children out for the children we just read/refreshed
        let self.children = newChildNodes
        call self.sortChildren()

        if invalidFilesFound
            call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.reveal(path) {{{1
"reveal the given path, i.e. cache and open all treenodes needed to display it
"in the UI
function! s:TreeDirNode.reveal(path)
    if !a:path.isUnder(self.path)
        throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
    endif

    call self.open()

    if self.path.equals(a:path.getParent())
        let n = self.findNode(a:path)
        call nerdtree#renderView()
        call n.putCursorHere(1,0)
        return
    endif

    let p = a:path
    while !p.getParent().equals(self.path)
        let p = p.getParent()
    endwhile

    let n = self.findNode(p)
    call n.reveal(a:path)
endfunction

"FUNCTION: TreeDirNode.removeChild(treenode) {{{1
"
"Removes the given treenode from this nodes set of children
"
"Args:
"treenode: the node to remove
"
"Throws a NERDTree.ChildNotFoundError if the given treenode is not found
function! s:TreeDirNode.removeChild(treenode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:treenode)
            call remove(self.children, i)
            return
        endif
    endfor

    throw "NERDTree.ChildNotFoundError: child node was not found"
endfunction

"FUNCTION: TreeDirNode.sortChildren() {{{1
"
"Sorts the children of this node according to alphabetical order and the
"directory priority.
"
function! s:TreeDirNode.sortChildren()
    let CompareFunc = function("nerdtree#compareNodes")
    call sort(self.children, CompareFunc)
endfunction

"FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
"Opens this directory if it is closed and vice versa
function! s:TreeDirNode.toggleOpen(...)
    let opts = a:0 ? a:1 : {}
    if self.isOpen ==# 1
        call self.close()
    else
        if g:NERDTreeCasadeOpenSingleChildDir == 0
            call self.open(opts)
        else
            call self.openAlong(opts)
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
"Replaces the child of this with the given node (where the child node's full
"path matches a:newNode's fullpath). The search for the matching node is
"non-recursive
"
"Arg:
"newNode: the node to graft into the tree
function! s:TreeDirNode.transplantChild(newNode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:newNode)
            let self.children[i] = a:newNode
            let a:newNode.parent = self
            break
        endif
    endfor
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
"CLASS: Opener
"============================================================
let s:Opener = {}
let g:NERDTreeOpener = s:Opener

"FUNCTION: Opener._checkToCloseTree(newtab) {{{1
"Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
"if the tree should be closed now.
"
"Args:
"a:newtab - boolean. If set, only close the tree now if we are opening the
"target in a new tab. This is needed because we have to close tree before we
"leave the tab
function! s:Opener._checkToCloseTree(newtab)
    if self._keepopen
        return
    endif

    if (a:newtab && self._where == 't') || !a:newtab
        call nerdtree#closeTreeIfQuitOnOpen()
    endif
endfunction

"FUNCTION: Opener._gotoTargetWin() {{{1
function! s:Opener._gotoTargetWin()
    if b:NERDTreeType ==# "secondary"
        if self._where == 'v'
            vsplit
        elseif self._where == 'h'
            split
        elseif self._where == 't'
            tabnew
        endif
    else
        call self._checkToCloseTree(1)

        if self._where == 'v'
            call self._newVSplit()
        elseif self._where == 'h'
            call self._newSplit()
        elseif self._where == 't'
            tabnew
        elseif self._where == 'p'
            call self._previousWindow()
        endif

        call self._checkToCloseTree(0)
    endif
endfunction

"FUNCTION: Opener.New(path, opts) {{{1
"Args:
"
"a:path: The path object that is to be opened.
"
"a:opts:
"
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' or 'h' or 't' (for open in
"           new tab)
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
function! s:Opener.New(path, opts)
    let newObj = copy(self)

    let newObj._path = a:path
    let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
    let newObj._reuse = nerdtree#has_opt(a:opts, 'reuse')
    let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    let newObj._treetype = b:NERDTreeType
    call newObj._saveCursorPos()

    return newObj
endfunction

"FUNCTION: Opener._newSplit() {{{1
function! s:Opener._newSplit()
    " Save the user's settings for splitbelow and splitright
    let savesplitbelow=&splitbelow
    let savesplitright=&splitright

    " 'there' will be set to a command to move from the split window
    " back to the explorer window
    "
    " 'back' will be set to a command to move from the explorer window
    " back to the newly split window
    "
    " 'right' and 'below' will be set to the settings needed for
    " splitbelow and splitright IF the explorer is the only window.
    "
    let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
    let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
    let right= g:NERDTreeWinPos ==# "left"
    let below=0

    " Attempt to go to adjacent window
    call nerdtree#exec(back)

    let onlyOneWin = (winnr("$") ==# 1)

    " If no adjacent window, set splitright and splitbelow appropriately
    if onlyOneWin
        let &splitright=right
        let &splitbelow=below
    else
        " found adjacent window - invert split direction
        let &splitright=!right
        let &splitbelow=!below
    endif

    let splitMode = onlyOneWin ? "vertical" : ""

    " Open the new window
    try
        exec(splitMode." sp ")
    catch /^Vim\%((\a\+)\)\=:E37/
        call nerdtree#putCursorInTreeWin()
        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
    catch /^Vim\%((\a\+)\)\=:/
        "do nothing
    endtry

    "resize the tree window if no other window was open before
    if onlyOneWin
        let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
        call nerdtree#exec(there)
        exec("silent ". splitMode ." resize ". size)
        call nerdtree#exec('wincmd p')
    endif

    " Restore splitmode settings
    let &splitbelow=savesplitbelow
    let &splitright=savesplitright
endfunction

"FUNCTION: Opener._newVSplit() {{{1
function! s:Opener._newVSplit()
    let winwidth = winwidth(".")
    if winnr("$")==#1
        let winwidth = g:NERDTreeWinSize
    endif

    call nerdtree#exec("wincmd p")
    vnew

    "resize the nerd tree back to the original size
    call nerdtree#putCursorInTreeWin()
    exec("silent vertical resize ". winwidth)
    call nerdtree#exec('wincmd p')
endfunction

"FUNCTION: Opener.open(target) {{{1
function! s:Opener.open(target)
    if self._path.isDirectory
        call self._openDirectory(a:target)
    else
        call self._openFile()
    endif
endfunction

"FUNCTION: Opener._openFile() {{{1
function! s:Opener._openFile()
    if self._reuse && self._reuseWindow()
        return
    endif

    call self._gotoTargetWin()

    if self._treetype ==# "secondary"
        call self._path.edit()
    else
        call self._path.edit()


        if self._stay
            call self._restoreCursorPos()
        endif
    endif
endfunction

"FUNCTION: Opener._openDirectory(node) {{{1
function! s:Opener._openDirectory(node)
    if self._treetype ==# "secondary"
        call self._gotoTargetWin()
        call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
    else
        call self._gotoTargetWin()
        if empty(self._where)
            call a:node.makeRoot()
            call nerdtree#renderView()
            call a:node.putCursorHere(0, 0)
        elseif self._where == 't'
            call g:NERDTreeCreator.CreatePrimary(a:node.path.str())
        else
            call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
        endif
    endif

    if self._stay
        call self._restoreCursorPos()
    endif
endfunction

"FUNCTION: Opener._previousWindow() {{{1
function! s:Opener._previousWindow()
    if !nerdtree#isWindowUsable(winnr("#")) && nerdtree#firstUsableWindow() ==# -1
        call self._newSplit()
    else
        try
            if !nerdtree#isWindowUsable(winnr("#"))
                call nerdtree#exec(nerdtree#firstUsableWindow() . "wincmd w")
            else
                call nerdtree#exec('wincmd p')
            endif
        catch /^Vim\%((\a\+)\)\=:E37/
            call nerdtree#putCursorInTreeWin()
            throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
        catch /^Vim\%((\a\+)\)\=:/
            echo v:exception
        endtry
    endif
endfunction

"FUNCTION: Opener._restoreCursorPos(){{{1
function! s:Opener._restoreCursorPos()
    call nerdtree#exec('normal ' . self._tabnr . 'gt')
    call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w')
endfunction

"FUNCTION: Opener._reuseWindow(){{{1
"put the cursor in the first window we find for this file
"
"return 1 if we were successful
function! s:Opener._reuseWindow()
    "check the current tab for the window
    let winnr = bufwinnr('^' . self._path.str() . '$')
    if winnr != -1
        call nerdtree#exec(winnr . "wincmd w")
        call self._checkToCloseTree(0)
        return 1
    else
        "check other tabs
        let tabnr = self._path.tabnr()
        if tabnr
            call self._checkToCloseTree(1)
            call nerdtree#exec('normal! ' . tabnr . 'gt')
            let winnr = bufwinnr('^' . self._path.str() . '$')
            call nerdtree#exec(winnr . "wincmd w")
            return 1
        endif
    endif
    return 0
endfunction

"FUNCTION: Opener._saveCursorPos(){{{1
function! s:Opener._saveCursorPos()
    let self._bufnr = bufnr("")
    let self._tabnr = tabpagenr()
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/opener.vim
"CLASS: MenuItem
"============================================================
let s:MenuItem = {}
let g:NERDTreeMenuItem = s:MenuItem

"FUNCTION: MenuItem.All() {{{1
"get all top level menu items
function! s:MenuItem.All()
    if !exists("s:menuItems")
        let s:menuItems = []
    endif
    return s:menuItems
endfunction

"FUNCTION: MenuItem.AllEnabled() {{{1
"get all top level menu items that are currently enabled
function! s:MenuItem.AllEnabled()
    let toReturn = []
    for i in s:MenuItem.All()
        if i.enabled()
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: MenuItem.Create(options) {{{1
"make a new menu item and add it to the global list
function! s:MenuItem.Create(options)
    let newMenuItem = copy(self)

    let newMenuItem.text = a:options['text']
    let newMenuItem.shortcut = a:options['shortcut']
    let newMenuItem.children = []

    let newMenuItem.isActiveCallback = -1
    if has_key(a:options, 'isActiveCallback')
        let newMenuItem.isActiveCallback = a:options['isActiveCallback']
    endif

    let newMenuItem.callback = -1
    if has_key(a:options, 'callback')
        let newMenuItem.callback = a:options['callback']
    endif

    if has_key(a:options, 'parent')
        call add(a:options['parent'].children, newMenuItem)
    else
        call add(s:MenuItem.All(), newMenuItem)
    endif

    return newMenuItem
endfunction

"FUNCTION: MenuItem.CreateSeparator(options) {{{1
"make a new separator menu item and add it to the global list
function! s:MenuItem.CreateSeparator(options)
    let standard_options = { 'text': '--------------------',
                \ 'shortcut': -1,
                \ 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.CreateSubmenu(options) {{{1
"make a new submenu and add it to global list
function! s:MenuItem.CreateSubmenu(options)
    let standard_options = { 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.enabled() {{{1
"return 1 if this menu item should be displayed
"
"delegates off to the isActiveCallback, and defaults to 1 if no callback was
"specified
function! s:MenuItem.enabled()
    if self.isActiveCallback != -1
        return {self.isActiveCallback}()
    endif
    return 1
endfunction

"FUNCTION: MenuItem.execute() {{{1
"perform the action behind this menu item, if this menuitem has children then
"display a new menu for them, otherwise deletegate off to the menuitem's
"callback
function! s:MenuItem.execute()
    if len(self.children)
        let mc = s:MenuController.New(self.children)
        call mc.showMenu()
    else
        if self.callback != -1
            call {self.callback}()
        endif
    endif
endfunction

"FUNCTION: MenuItem.isSeparator() {{{1
"return 1 if this menuitem is a separator
function! s:MenuItem.isSeparator()
    return self.callback == -1 && self.children == []
endfunction

"FUNCTION: MenuItem.isSubmenu() {{{1
"return 1 if this menuitem is a submenu
function! s:MenuItem.isSubmenu()
    return self.callback == -1 && !empty(self.children)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/lib/nerdtree/menu_item.vim
" ============================================================================
" File:        fs_menu.vim
" Description: plugin for the NERD Tree that provides a file system menu
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 17 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_fs_menu")
    finish
endif
let g:loaded_nerdtree_fs_menu = 1

"Automatically delete the buffer after deleting or renaming a file
if !exists("g:NERDTreeAutoDeleteBuffer")
    let g:NERDTreeAutoDeleteBuffer = 0
endif

call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})

if has("gui_mac") || has("gui_macvim") 
    call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
    call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
endif

if g:NERDTreePath.CopyingSupported()
    call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
endif

"FUNCTION: s:echo(msg){{{1
function! s:echo(msg)
    redraw
    echomsg "NERDTree: " . a:msg
endfunction

"FUNCTION: s:echoWarning(msg){{{1
function! s:echoWarning(msg)
    echohl warningmsg
    call s:echo(a:msg)
    echohl normal
endfunction

"FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is deleted
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToDelBuffer(bufnum, msg)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that all windows which display the just deleted filename
        " now display an empty buffer (so a layout is preserved).
        " Is not it better to close single tabs with this file only ?
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':enew! ' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction

"FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is replaced with a new one
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToRenameBuffer(bufnum, msg, newFileName)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that a new buffer is loaded
        exec "badd " . a:newFileName
        " 2. ensure that all windows which display the just deleted filename
        " display a buffer for a new filename. 
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':e! " . a:newFileName . "' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction
"FUNCTION: NERDTreeAddNode(){{{1
function! NERDTreeAddNode()
    let curDirNode = g:NERDTreeDirNode.GetSelected()

    let newNodeName = input("Add a childnode\n".
                          \ "==========================================================\n".
                          \ "Enter the dir/file name to be created. Dirs end with a '/'\n" .
                          \ "", curDirNode.path.str() . g:NERDTreePath.Slash(), "file")

    if newNodeName ==# ''
        call s:echo("Node Creation Aborted.")
        return
    endif

    try
        let newPath = g:NERDTreePath.Create(newNodeName)
        let parentNode = b:NERDTreeRoot.findNode(newPath.getParent())

        let newTreeNode = g:NERDTreeFileNode.New(newPath)
        if parentNode.isOpen || !empty(parentNode.children)
            call parentNode.addChild(newTreeNode, 1)
            call NERDTreeRender()
            call newTreeNode.putCursorHere(1, 0)
        endif
    catch /^NERDTree/
        call s:echoWarning("Node Not Created.")
    endtry
endfunction

"FUNCTION: NERDTreeMoveNode(){{{1
function! NERDTreeMoveNode()
    let curNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Rename the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path for the node:                          \n" .
                          \ "", curNode.path.str(), "file")

    if newNodePath ==# ''
        call s:echo("Node Renaming Aborted.")
        return
    endif

    try
        let bufnum = bufnr(curNode.path.str())

        call curNode.rename(newNodePath)
        call NERDTreeRender()

        "if the node is open in a buffer, ask the user if they want to
        "close that buffer
        if bufnum != -1
            let prompt = "\nNode renamed.\n\nThe old file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Replace this buffer with a new file? (yN)"
            call s:promptToRenameBuffer(bufnum,  prompt, newNodePath)
        endif

        call curNode.putCursorHere(1, 0)

        redraw
    catch /^NERDTree/
        call s:echoWarning("Node Not Renamed.")
    endtry
endfunction

" FUNCTION: NERDTreeDeleteNode() {{{1
function! NERDTreeDeleteNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let confirmed = 0

    if currentNode.path.isDirectory
        let choice =input("Delete the current node\n" .
                         \ "==========================================================\n" .
                         \ "STOP! To delete this entire directory, type 'yes'\n" .
                         \ "" . currentNode.path.str() . ": ")
        let confirmed = choice ==# 'yes'
    else
        echo "Delete the current node\n" .
           \ "==========================================================\n".
           \ "Are you sure you wish to delete the node:\n" .
           \ "" . currentNode.path.str() . " (yN):"
        let choice = nr2char(getchar())
        let confirmed = choice ==# 'y'
    endif


    if confirmed
        try
            call currentNode.delete()
            call NERDTreeRender()

            "if the node is open in a buffer, ask the user if they want to
            "close that buffer
            let bufnum = bufnr(currentNode.path.str())
            if buflisted(bufnum)
                let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Delete this buffer? (yN)"
                call s:promptToDelBuffer(bufnum, prompt)
            endif

            redraw
        catch /^NERDTree/
            call s:echoWarning("Could not remove node")
        endtry
    else
        call s:echo("delete aborted")
    endif

endfunction

" FUNCTION: NERDTreeCopyNode() {{{1
function! NERDTreeCopyNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Copy the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path to copy the node to:                   \n" .
                          \ "", currentNode.path.str(), "file")

    if newNodePath != ""
        "strip trailing slash
        let newNodePath = substitute(newNodePath, '\/$', '', '')

        let confirmed = 1
        if currentNode.path.copyingWillOverwrite(newNodePath)
            call s:echo("Warning: copying may overwrite files! Continue? (yN)")
            let choice = nr2char(getchar())
            let confirmed = choice ==# 'y'
        endif

        if confirmed
            try
                let newNode = currentNode.copy(newNodePath)
                if !empty(newNode)
                    call NERDTreeRender()
                    call newNode.putCursorHere(0, 0)
                endif
            catch /^NERDTree/
                call s:echoWarning("Could not copy node")
            endtry
        endif
    else
        call s:echo("Copy aborted.")
    endif
    redraw
endfunction

function! NERDTreeQuickLook()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        call system("qlmanage -p 2>/dev/null '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeRevealInFinder()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open -R '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeExecuteFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open '" . treenode.path.str() . "'")
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/vimfiles/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
" ============================================================================
" File:        exec_menuitem.vim
" Description: plugin for NERD Tree that provides an execute file menu item
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 22 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_exec_menuitem")
    finish
endif
let g:loaded_nerdtree_exec_menuitem = 1

call NERDTreeAddMenuItem({
            \ 'text': '(!)Execute file',
            \ 'shortcut': '!',
            \ 'callback': 'NERDTreeExecFile',
            \ 'isActiveCallback': 'NERDTreeExecFileActive' })

function! NERDTreeExecFileActive()
    let node = g:NERDTreeFileNode.GetSelected()
    return !node.path.isDirectory && node.path.isExecutable
endfunction

function! NERDTreeExecFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    echo "==========================================================\n"
    echo "Complete the command to execute (add arguments etc):\n"
    let cmd = treenode.path.str({'escape': 1})
    let cmd = input(':!', cmd . ' ')

    if cmd != ''
        exec ':!' . cmd
    else
        echo "Aborted"
    endif
endfunction
zhimakaimen:/vimfiles/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
let s:tree_up_dir_line = '.. (up a dir)'
"NERDTreeFlags are syntax items that should be invisible, but give clues as to
"how things should be highlighted
syn match NERDTreeFlag #\~#
syn match NERDTreeFlag #\[RO\]#

"highlighting for the .. (up dir) line at the top of the tree
execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"

"highlighting for the ~/+ symbols for the directory nodes
syn match NERDTreeClosable #\~\<#
syn match NERDTreeClosable #\~\.#
syn match NERDTreeOpenable #+\<#
syn match NERDTreeOpenable #+\.#he=e-1

"highlighting for the tree structural parts
syn match NERDTreePart #|#
syn match NERDTreePart #`#
syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart

"quickhelp syntax elements
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#hs=s+2,he=e-1
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#hs=s+2,he=e-1
syn match NERDTreeHelpTitle #" .*\~#hs=s+2,he=e-1 contains=NERDTreeFlag
syn match NERDTreeToggleOn #".*(on)#hs=e-2,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeToggleOff #".*(off)#hs=e-3,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeFlag,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand

"highlighting for readonly files
syn match NERDTreeRO #.*\[RO\]#hs=s+2 contains=NERDTreeFlag,NERDTreeBookmark,NERDTreePart,NERDTreePartFile

"highlighting for sym links
syn match NERDTreeLink #[^-| `].* -> # contains=NERDTreeBookmark,NERDTreeOpenable,NERDTreeClosable,NERDTreeDirSlash

"highlighing for directory nodes and file nodes
syn match NERDTreeDirSlash #/#
syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeDirSlash,NERDTreeOpenable,NERDTreeClosable
syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark
syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeCWD #^[</].*$#

"highlighting for bookmarks
syn match NERDTreeBookmark # {.*}#hs=s+1

"highlighting for the bookmarks table
syn match NERDTreeBookmarksLeader #^>#
syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader

if exists("g:NERDChristmasTree") && g:NERDChristmasTree
    hi def link NERDTreePart Special
    hi def link NERDTreePartFile Type
    hi def link NERDTreeFile Normal
    hi def link NERDTreeExecFile Title
    hi def link NERDTreeDirSlash Identifier
    hi def link NERDTreeClosable Type
else
    hi def link NERDTreePart Normal
    hi def link NERDTreePartFile Normal
    hi def link NERDTreeFile Normal
    hi def link NERDTreeClosable Title
endif

hi def link NERDTreeBookmarksHeader statement
hi def link NERDTreeBookmarksLeader ignore
hi def link NERDTreeBookmarkName Identifier
hi def link NERDTreeBookmark normal

hi def link NERDTreeHelp String
hi def link NERDTreeHelpKey Identifier
hi def link NERDTreeHelpCommand Identifier
hi def link NERDTreeHelpTitle Macro
hi def link NERDTreeToggleOn Question
hi def link NERDTreeToggleOff WarningMsg

hi def link NERDTreeDir Directory
hi def link NERDTreeUp Directory
hi def link NERDTreeCWD Statement
hi def link NERDTreeLink Macro
hi def link NERDTreeOpenable Title
hi def link NERDTreeFlag ignore
hi def link NERDTreeRO WarningMsg
hi def link NERDTreeBookmark Statement

hi def link NERDTreeCurrentNode Search
zhimakaimen:/syntax/nerdtree.vim
" Syntax highlighting for snippet files (used for snipMate.vim)
" Hopefully this should make snippets a bit nicer to write!
syn match snipComment '^#.*'
syn match placeHolder '\${\d\+\(:.\{-}\)\=}' contains=snipCommand
syn match tabStop '\$\d\+'
syn match snipCommand '[^\\]`.\{-}`'
syn match snippet '^snippet.*' transparent contains=multiSnipText,snipKeyword
syn match multiSnipText '\S\+ \zs.*' contained
syn match snipKeyword '^snippet'me=s+8 contained
syn match snipError "^[^#s\t].*$"

hi link snipComment   Comment
hi link multiSnipText String
hi link snipKeyword   Keyword
hi link snipComment   Comment
hi link placeHolder   Special
hi link tabStop       Special
hi link snipCommand   String
hi link snipError     Error
zhimakaimen:/syntax/snippet.vim
" Vim syntax file
" Language:	SystemVerilog
" Maintainer:	WeiChung Wu <exelion04 at gmail dot com>
" Last Change:	2011 Aug 04
"
" Credits:
"   Originally created by
"       Dave Eggum (opine at bluebottle dOt com)

" NOTE: extra white space at the end of the line will be highlighted if you
" add this line to your colorscheme:

" highlight SpaceError    guibg=#204050

" (change the value for guibg to any color you like)

" For version 5.x: Clear all syntax items
" For version 6.x: Quit when a syntax file was already loaded
if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

" A bunch of useful SV keywords
syn keyword	svStatement	always always_comb always_ff always_latch assert
syn keyword	svStatement	break return continue fork join disable force release
syn keyword	svStatement	join_any join_none frokjoin binsof intersect

syn keyword	svLabel		bind constraint covergroup coverpoint
syn keyword	svLabel		class CLOCK clocking default function interface modport
syn keyword	svLabel		package program property randseq sequence specify
syn keyword	svLabel		task
syn keyword	svLabel		begin initial module forever import
syn keyword	svLabel		end endclass endfunction endtask endprogram endmodule
syn keyword	svLabel		endinterface endpackage endproperty endclocking endgroup

syn keyword	svConditional	if iff else case casex casez endcase randcase
syn keyword	svConditional	unique priority randsequence endsequence
syn keyword 	svRepeat	repeat while for do foreach
syn keyword 	svModifier	after all any around assoc_size async
syn keyword 	svModifier	before big_endian bit_normal bit_reverse export
syn keyword 	svModifier	extends extern little_endian local hdl_node hdl_task
syn keyword 	svModifier	negedge none packed protected posedge public rules
syn keyword 	svModifier	shadow soft solve static super this typedef unpacked var
syn keyword 	svModifier	vca virtual virtuals wildcard with
syn keyword 	svModifier	ref const pure automatic

syn keyword 	svType		reg string enum event bit
syn keyword 	svType		rand randc integer parameter
syn keyword 	svType		logic int mailbox input output inout unsigned time wire

"syn keyword     svDeprecated	call_func call_task close_conn get_bind get_bind_id
"syn keyword     svDeprecated	get_conn_err mailbox_receive mailbox_send make_client
"syn keyword     svDeprecated	make_server simwave_plot up_connections

" predefined tasks and functions
"syn keyword 	svTask		alloc assoc_index cast_assign cm_coverage
"syn keyword 	svTask		cm_get_coverage cm_get_limit delay error error_mode
"syn keyword 	svTask		exit fclose feof ferror fflush flag fopen fprintf
"syn keyword 	svTask		freadb freadh freadstr get_cycle get_env get_memsize
"syn keyword 	svTask		get_plus_arg getstate get_systime get_time get_time_unit
"syn keyword 	svTask		initstate lock_file mailbox_get mailbox_put os_command
"syn keyword 	svTask		printf prodget prodset psprintf query query_str query_x
"syn keyword 	svTask		rand48 random region_enter region_exit rewind
"syn keyword 	svTask		semaphore_get semaphore_put setstate signal_connect
"syn keyword 	svTask		sprintf srandom sscanf stop suspend_thread sync
"syn keyword 	svTask		trace trigger unit_delay unlock_file urand48
"syn keyword 	svTask		urandom urandom_range
"syn keyword 	svTask		vsv_call_func vsv_call_task vsv_get_conn_err
"syn keyword 	svTask		vsv_make_client vsv_make_server vsv_up_connections
"syn keyword 	svTask		vsv_wait_for_done vsv_wait_for_input wait_child wait_var
"  " ChungWu modify
"syn keyword 	svTask		wait cast display displayb displayh write
syn match       svTask          "\$[a-zA-Z0-9_]\+\>"

syn cluster	svOperGroup	contains=svOperator,svOperParen,svNumber,svString,svOperOk,svType
" syn match	svOperator	"++\|--\|&\|\~&\||\|\~|\|^\|\~^\|\~\|><"
" syn match	svOperator	"*\|/\|%\|+\|-\|<<\|>>\|<\|<=\|>\|>=\|!in"
" syn match	svOperator	"=?=\|!?=\|==\|!=\|===\|!==\|&\~\|^\~\||\~"
" syn match	svOperator	"&&\|||\|=\|+=\|-=\|*=\|/=\|%=\|<<=\|>>=\|&="
" syn match	svOperator	"|=\|^=\|\~&=\|\~|=\|\~^="

syn match	svOperator	"[&|\~><!*@+/=,.\^\-]"
syn keyword	svOperator	or inside dist not

" sv class methods
syn keyword	svMethods	atobin atohex atoi atooct backref bittostr capacity
syn keyword	svMethods	compare Configure constraint_mode DisableTrigger
syn keyword	svMethods	DoAction empty EnableCount EnableTrigger Event find
syn keyword	svMethods	find_index find_first find_first_index find_last find_last_index
syn keyword	svMethods	GetAssert get_at_least get_auto_bin getc GetCount get_coverage_goal get_cov_weight
syn keyword	svMethods	get_cross_bin_max GetFirstAssert GetName GetNextAssert
syn keyword	svMethods	get_status get_status_msg hide hash icompare insert
syn keyword	svMethods	inst_get_at_least inst_get_auto_bin_max inst_get_collect
syn keyword	svMethods	inst_get_coverage_goal inst_get_cov_weight inst_getcross_bin_max
syn keyword	svMethods	inst_query inst_set_at_least inst_set_auto_bin_max
syn keyword	svMethods	inst_set_bin_activiation inst_set_collect inst_set_coverage_goal
syn keyword	svMethods	inst_set_cov_weight inst_set_cross_bin_max itoa last_index
syn keyword	svMethods	len load match max max_index min min_index new object_compare
syn keyword	svMethods	object_compare object_copy object_print pack pick_index
syn keyword	svMethods	pop_back pop_front post_boundary postmatch post_pack post_pack
syn keyword	svMethods	post_randomize post_randomize post_unpack post_unpack
syn keyword	svMethods	pre_boundary prematch pre_pack pre_pack pre_randomize
syn keyword	svMethods	pre-randomize pre_unpack product push_back push_front putc query
syn keyword	svMethods	query_str rand_mode randomize reserve reverse rsort search
syn keyword	svMethods	set_at_least set_auto_bin_max set_bin_activiation
syn keyword	svMethods	set_coverage_goal set_cov_weight set_cross_bin_max
syn keyword	svMethods	size sort substr sum thismatch tolower toupper unique_index
syn keyword	svMethods	Wait
syn keyword	svMethods	num delete exists first last next prev

" interface keywords
"syn keyword	svInterface	ASYNC CLOCK gnr gr0 gr1 grx grz NHOLD nr NR0 NR1
"syn keyword	svInterface	NRZ NRZ NSAMPLE PHOLD PR0 PR1 PRX PRZ r0 r1 rx snr
"syn keyword	svInterface	sr0 sr1 srx srz depth inout input output
"syn match      svInterface	"\$\w\+"


syn keyword	svTodo		contained TODO FIXME XXX FINISH

" svCommentGroup allows adding matches for special things in comments
syn cluster	svCommentGroup	contains=svTodo

" String and Character constants
" Highlight special characters (those which have a backslash) differently
syn match	svSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
syn match	svFormat	display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdhiuoxXDOUfeEgGcCsSpnmt]\|\[\^\=.[^]]*\]\)" contained
syn match	svFormat	display "%%" contained
syn region	svString	start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=svSpecial,svFormat,@Spell
syn region	svConcat	contained transparent oneline start='{' end='}'

" svCppString: same as svString, but ends at end of line
syn region	svCppString	start=+"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=svSpecial,svFormat,@Spell

syn match	svCharacter		"'[^\\]'"
syn match	svCharacter		"L'[^']*'" contains=svSpecial
syn match	svSpecialError		"'\\[^'\"?\\abefnrtv]'"
syn match	svSpecialCharacter	"'\\['\"?\\abefnrtv]'"
syn match	svSpecialCharacter	display	"'\\\o\{1,3}'"
syn match	svSpecialCharacter	display	"'\\x\x\{1,2}'"
syn match	svSpecialCharacter	display	"L'\\x\x\+'"

" highlight trailing white space
syn match	svSpaceError		display	excludenl "\s\+$"
syn match	svSpaceError		display	" \+\t"me=e-1

"catch errors caused by wrong parenthesis and brackets
syn cluster	svParenGroup		contains=svParenError,svIncluded,svSpecial,svCommentSkip,svCommentString,svComment2String,@svCommentGroup,svCommentStartError,svUserCont,svUserLabel,svBitField,svCommentSkip,svOctalZero,svCppOut,svCppOut2,svCppSkip,svFormat,svNumber,svFloat,svOctal,svOctalError,svNumbersCom

syn region	svParen		transparent start='(' end=')' contains=ALLBUT,@svParenGroup,svCppParen,svErrInBracket,svCppBracket,svCppString,@Spell
" svCppParen: same as svParen but ends at end-of-line; used in svDefine
syn region	svCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@svParenGroup,svErrInBracket,svParen,svBracket,svString,@Spell
syn match	svParenError	display "[\])]"
" syn match	svErrInParen	display contained "[\]{}]"
syn match	svErrInParen	display contained "[\]]"
syn region	svBracket	transparent start='\[' end=']' contains=ALLBUT,@svParenGroup,svErrInParen,svCppParen,svCppBracket,svCppString,@Spell

" svCppBracket: same as svParen but ends at end-of-line; used in svDefine
syn region	svCppBracket	transparent start='\[' skip='\\$' excludenl end=']' end='$' contained contains=ALLBUT,@svParenGroup,svErrInParen,svParen,svBracket,svString,@Spell
syn match	svErrInBracket	display contained "[);{}]"

"integer number, or floating point number without a dot and with "f".
syn case ignore
syn match	svNumbers	display transparent "\<\d\|\.\d" contains=svNumber,svFloat,svOctalError,svOctal
" Same, but without octal error (for comments)
syn match	svNumbersCom	display contained transparent "\<\d\|\.\d" contains=svNumber,svFloat,svOctal
" syn match	svNumber	display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
" "hex number
" syn match	svNumber	display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
" syn match   svNumber "\(\<[0-9]\+\|\)'[bdoh][0-9a-fxzA-FXZ_]\+\>"
syn match	svNumber 	"\<\(\<[0-9]\+\)\?\('[bdoh]\)\?[0-9a-fxz_]\+\>"
" syn match   svNumber "\<[+-]\=[0-9]\+\>"
" Flag the first zero of an octal number as something special
syn match	svOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=svOctalZero
syn match	svOctalZero	display contained "\<0"
syn match	svFloat		display contained "\d\+f"
"floating point number, with dot, optional exponent
syn match	svFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
"floating point number, starting with a dot, optional exponent
syn match	svFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
"floating point number, without dot, with exponent
syn match	svFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
"hexadecimal floating point number, optional leading digits, with dot, with exponent
syn match	svFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
"hexadecimal floating point number, with leading digits, optional dot, with exponent
syn match	svFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"

" flag an octal number with wrong digits
syn match	svOctalError	display contained "0\o*[89]\d*"
syn case match

let sv_comment_strings = 1

if exists("sv_comment_strings")
  " A comment can contain svString, svCharacter and svNumber.
  " But a "*/" inside a svString in a svComment DOES end the comment!  So we
  " need to use a special type of svString: svCommentString, which also ends on
  " "*/", and sees a "*" at the start of the line as comment again.
  " Unfortunately this doesn't work very well for // type of comments :-(
  syntax match	svCommentSkip		contained "^\s*\*\($\|\s\+\)"
  syntax region svCommentString		contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=svSpecial,svCommentSkip
  syntax region svComment2String	contained start=+\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=svSpecial
  syntax region	svCommentL		start="//" skip="\\$" end="$" keepend contains=@svCommentGroup,svComment2String,svCharacter,svNumbersCom,svSpaceError,@Spell
  if exists("sv_no_comment_fold")
    syntax region svComment	matchgroup=svCommentStart start="/\*" end="\*/" contains=@svCommentGroup,svCommentStartError,svCommentString,svCharacter,svNumbersCom,svSpaceError,@Spell
  else
    syntax region svComment	matchgroup=svCommentStart start="/\*" end="\*/" contains=@svCommentGroup,svCommentStartError,svCommentString,svCharacter,svNumbersCom,svSpaceError,@Spell fold
  endif
else
  syn region	svCommentL	start="//" skip="\\$" end="$" keepend contains=@svCommentGroup,svSpaceError,@Spell
  if exists("sv_no_comment_fold")
    syn region	svComment	matchgroup=svCommentStart start="/\*" end="\*/" contains=@svCommentGroup,svCommentStartError,svSpaceError,@Spell
  else
    syn region	svComment	matchgroup=svCommentStart start="/\*" end="\*/" contains=@svCommentGroup,svCommentStartError,svSpaceError,@Spell fold
  endif
endif
" keep a // comment separately, it terminates a preproc. conditional
syntax match	svCommentError		display "\*/"
syntax match	svCommentStartError 	display "/\*"me=e-1 contained

" syntax region	svBlock		start="{" end="}" transparent fold
syntax region	svBlock		start="begin" end="end" transparent fold

" sv pre-defined constants
syn keyword svConstant	ALL ANY BAD_STATE BAD_TRANS CALL CHECK CHGEDGE
syn keyword svConstant	CLEAR COPY_NO_WAIT COPY_WAIT CROSS CROSS_TRANS
syn keyword svConstant	DEBUG DELETE EC_ARRAYX EC_CODE_END EC_CONFLICT
syn keyword svConstant	EC_EVNTIMOUT EC_EXPECT EC_FULLEXPECT EC_MBXTMOUT
syn keyword svConstant	EC_NEXPECT EC_RETURN EC_RGNTMOUT EC_SCONFLICT
syn keyword svConstant	EC_SEMTMOUT EC_SEXPECT EC_SFULLEXPECT EC_SNEXTPECT
syn keyword svConstant	EC_USERSET EQ EVENT FAIL FIRST FORK GE GOAL GT
syn keyword svConstant	HAND_SHAKE HI HIGH HNUM LE LIC_EXIT LIC_PRERR
syn keyword svConstant	LIC_PRWARN LIC_WAIT LO LOAD LOW LT MAILBOX MAX_COM
syn keyword svConstant	NE NEGEDGE NEXT NO_OVERLAP NO_OVERLAP_STATE
syn keyword svConstant	NO_OVERLAP_TRANS NO_VARS NO_WAIT NUM NUM_BIN
syn keyword svConstant	NUM_DET null OFF OK OK_LAST ON ONE_BLAST ONE_SHOT ORDER
syn keyword svConstant	PAST_IT PERCENT POSEDGE PROGRAM RAWIN REGION REPORT
syn keyword svConstant	SAMPLE SAVE SEMAPHORE SET SILENT STATE stderr
syn keyword svConstant	stdin stdout STR STR_ERR_OUT_OF_RANGE
syn keyword svConstant	STR_ERR_REGEXP_SYNTAX SUM TRANS VERBOSE void WAIT
syn keyword svConstant	__LINE__ __FILE__ __DATE__ __TIME__
syn keyword svConstant	__VERSION__

syn match   svUserConstant "\<[A-Z][A-Z0-9_]\+\>"
syn match   svUvmMacro  "`uvm_\w\+"

syn match svClass 	"\zs\w\+\ze::"
syn match svClass 	"\zs\w\+\ze\s\+\w\+\s*[=;,)\[]" contains=svConstant,svUserConstant
syn match svClass 	"\zs\w\+\ze\s\+\w\+\s*$" contains=svConstant,svUserConstant
syn match svClass 	"\zs\w\+\ze\s*#(" contains=svConstant,svUserConstant
syn match svUserMethod 	"\zs\w\+\ze\s*(" contains=svConstant,svUserConstant
syn match svObject 	"\zs\w\+\ze\.\w"
syn match svObject 	"\zs\w\+\ze\.\$\w"

" Accept ` for # (Verilog)
syn region	svPreCondit	start="^\s*\(`\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" end="//"me=s-1 contains=svComment,svCppString,svCharacter,svCppParen,svParenError,svNumbers,svCommentError,svSpaceError
syn match	svPreCondit	display "^\s*\(`\|#\)\s*\(else\|endif\)\>"
if !exists("sv_no_if0")
  syn region	svCppOut	start="^\s*\(`\|#\)\s*if\s\+0\+\>" end=".\@=\|$" contains=svCppOut2
  syn region	svCppOut2	contained start="0" end="^\s*\(`\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=svSpaceError,svCppSkip
  syn region	svCppSkip	contained start="^\s*\(`\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(`\|#\)\s*endif\>" contains=svSpaceError,svCppSkip
endif
syn region	svIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
syn match	svIncluded	display contained "<[^>]*>"
syn match	svInclude	display "^\s*\(`\|#\)\s*include\>\s*["<]" contains=svIncluded
"syn match svLineSkip	"\\$"
syn cluster	svPreProcGroup	contains=svPreCondit,svIncluded,svInclude,svDefine,svErrInParen,svErrInBracket,svUserLabel,svSpecial,svOctalZero,svCppOut,svCppOut2,svCppSkip,svFormat,svNumber,svFloat,svOctal,svOctalError,svNumbersCom,svString,svCommentSkip,svCommentString,svComment2String,@svCommentGroup,svCommentStartError,svParen,svBracket,svMulti
syn region	svDefine	start="^\s*\(`\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" end="//"me=s-1 contains=ALLBUT,@svPreProcGroup,@Spell
syn region	svPreProc	start="^\s*\(`\|#\)\s*\(pragma\>\|line\>\|warning\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@svPreProcGroup,@Spell

" Highlight User Labels
syn cluster	svMultiGroup	contains=svIncluded,svSpecial,svCommentSkip,svCommentString,svComment2String,@svCommentGroup,svCommentStartError,svUserCont,svUserLabel,svBitField,svOctalZero,svCppOut,svCppOut2,svCppSkip,svFormat,svNumber,svFloat,svOctal,svOctalError,svNumbersCom,svCppParen,svCppBracket,svCppString
syn region	svMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@svMultiGroup,@Spell
" syn region	svMulti		transparent start='?' skip='::' end=':' contains=ALL
" The above causes svCppOut2 to catch on:
"    i = (isTrue) ? 0 : 1;
" which ends up commenting the rest of the file

" Avoid matching foo::bar() by requiring that the next char is not ':'
syn cluster	svLabelGroup	contains=svUserLabel
syn match	svUserCont	display "^\s*\I\i*\s*:$" contains=@svLabelGroup
syn match	svUserCont	display ";\s*\I\i*\s*:$" contains=@svLabelGroup
syn match	svUserCont	display "^\s*\I\i*\s*:[^:]"me=e-1 contains=@svLabelGroup
syn match	svUserCont	display ";\s*\I\i*\s*:[^:]"me=e-1 contains=@svLabelGroup

syn match	svUserLabel	display "\I\i*" contained

" Avoid recognizing most bitfields as labels
syn match	svBitField	display "^\s*\I\i*\s*:\s*[1-9]"me=e-1
syn match	svBitField	display ";\s*\I\i*\s*:\s*[1-9]"me=e-1

if exists("sv_minlines")
  let b:sv_minlines = sv_minlines
else
  if !exists("sv_no_if0")
    let b:sv_minlines = 50	" #if 0 constructs can be long
  else
    let b:sv_minlines = 15	" mostly for () constructs
  endif
endif
exec "syn sync ccomment svComment minlines=" . b:sv_minlines

" Define the default highlighting.
" For version 5.7 and earlier: only when not done already
" For version 5.8 and later: only when an item doesn't have highlighting yet
if version >= 508 || !exists("did_systemverilog_syn_inits")
  if version < 508
    let did_systemverilog_syn_inits = 1
    command -nargs=+ HiLink hi link <args>
  else
    command -nargs=+ HiLink hi def link <args>
  endif

  HiLink svClass		Identifier
  HiLink svObject		Identifier
  HiLink svUserMethod		Function
  HiLink svUvmMacro		Function
  HiLink svTask                 Keyword
  HiLink svModifier		Tag
  HiLink svDeprecated		svError
  HiLink svMethods		Statement
  " HiLink svInterface		Label
  " HiLink svInterface		Function

  HiLink svFormat		svSpecial
  HiLink svCppString		svString
  HiLink svCommentL		svComment
  HiLink svCommentStart		svComment
  HiLink svLabel		Label
  HiLink svUserLabel		Label
  HiLink svConditional		Conditional
  HiLink svRepeat		Repeat
  HiLink svCharacter		Character
  HiLink svSpecialCharacter	svSpecial
  HiLink svNumber		Number
  HiLink svOctal		Number
  HiLink svOctalZero		PreProc	 " link this to Error if you want
  HiLink svFloat		Float
  HiLink svOctalError		svError
  HiLink svParenError		svError
  HiLink svErrInParen		svError
  HiLink svErrInBracket		svError
  HiLink svCommentError		svError
  HiLink svCommentStartError	svError
  HiLink svSpaceError		SpaceError
  HiLink svSpecialError		svError
  HiLink svOperator		Operator
  HiLink svStructure		Structure
  HiLink svInclude		Include
  HiLink svPreProc		PreProc
  HiLink svDefine		Macro
  HiLink svIncluded		svString
  HiLink svError		Error
  HiLink svStatement		Statement
  HiLink svPreCondit		PreCondit
  HiLink svType			Type
  " HiLink svConstant		Constant
  HiLink svConstant		Keyword
  HiLink svUserConstant		Constant
  HiLink svCommentString	svString
  HiLink svComment2String	svString
  HiLink svCommentSkip		svComment
  HiLink svString		String
  HiLink svComment		Comment
  HiLink svSpecial		SpecialChar
  HiLink svTodo			Todo
  HiLink svCppSkip		svCppOut
  HiLink svCppOut2		svCppOut
  HiLink svCppOut		Comment

  delcommand HiLink
endif

let b:current_syntax = "systemverilog"

" vim: ts=8
zhimakaimen:/syntax/systemverilog.vim
" Vim color file
" author: Mr.Zhou <zhouchuanrui@foxmail.com>
" cool help screens
" :he group-name
" :he highlight-groups
" :he cterm-colors
" Remove all existing highlighting and set the defaults.
hi clear
" Load the syntax highlighting defaults, if it's enabled.
if exists("syntax_on")
  syntax reset
endif
let g:colors_name="myscheme"
" global setting
" the color good for your eyes
hi Normal guibg=#ccefcf

" highlight groups
hi LineNr guibg=black guifg=white 
"hi LineNr guibg=#00BFFF guifg=white 
hi Title	guifg=red
hi TabLineSel guibg=black guifg=white
hi StatusLine guibg=cyan
"hi TabLine guibg = #ccefcf
hi Visual guibg=yellow

" syntax highlighting groups
"hi Comment	guifg=#cdad00
"hi Comment	guifg= DarkYellow
hi Comment	guifg= #7f9f6f 
hi Constant	guifg= #00bfff
hi Statement guifg = #b8af43
hi Special guifg = #7f9f6f
hi PreProc guifg = #b9663e

"vim: sw=4

"" all colors are set by originally
"" $VIMRUNTIME/syntax/syncolor.vim

"-----use :hi to list all the currently used item-settings
"-----use :so $VIMRUNTIME\syntax\hitest.vim to generate a buffer which
"			lists all the item settings"
"-----use :verbose hi <group-name> , it returns the directory 
"			to see where the group item is set "

"Suggested color names (these are available on most systems):
"Red		LightRed	DarkRed
"Green	LightGreen	DarkGreen	SeaGreen
"Blue	LightBlue	DarkBlue	SlateBlue
"Cyan	LightCyan	DarkCyan
"Magenta	LightMagenta	DarkMagenta
"Yellow	LightYellow	Brown		DarkYellow
"Gray	LightGray	DarkGray
"Black	White
"Orange	Purple		Violet

"-----hilight group explains
"-----use :hi to list all the currently used item-settings
"--Item--|--Explain--
" Normal - global words
" LineNr - line number
"ColorColumn	used for the columns set with 'colorcolumn'
"Conceal		placeholder characters substituted for concealed
"				text (see 'conceallevel')
"Cursor			the character under the cursor
"CursorIM		like Cursor, but used when in IME mode |CursorIM|
"CursorColumn	the screen column that the cursor is in when 'cursorcolumn' is
"				set
"CursorLine		the screen line that the cursor is in when 'cursorline' is
"				set
"Directory		directory names (and other special names in listings)
"DiffAdd		diff mode: Added line |diff.txt|
"DiffChange		diff mode: Changed line |diff.txt|
"DiffDelete		diff mode: Deleted line |diff.txt|
"DiffText		diff mode: Changed text within a changed line |diff.txt|
"ErrorMsg		error messages on the command line
"VertSplit		the column separating vertically split windows
"Folded			line used for closed folds
"FoldColumn		'foldcolumn'
"SignColumn		column where |signs| are displayed
"IncSearch		'incsearch' highlighting; also used for the text replaced with
"				":s///c"
"LineNr			Line number for ":number" and ":#" commands, and when 'number'
"				or 'relativenumber' option is set.
"CursorLineNr	Like LineNr when 'cursorline' or 'relativenumber' is set for
"				the cursor line.
"MatchParen		The character under the cursor or just before it, if it
"				is a paired bracket, and its match. |pi_paren.txt|
"ModeMsg		'showmode' message (e.g., "-- INSERT --")
"MoreMsg		|more-prompt|
"NonText		'~' and '@' at the end of the window, characters from
"				'showbreak' and other characters that do not really exist in
"				the text (e.g., ">" displayed when a double-wide character
"				doesn't fit at the end of the line).
"Normal			normal text
"Pmenu			Popup menu: normal item.
"PmenuSel		Popup menu: selected item.
"PmenuSbar		Popup menu: scrollbar.
"PmenuThumb		Popup menu: Thumb of the scrollbar.
"Question		|hit-enter| prompt and yes/no questions
"Search			Last search pattern highlighting (see 'hlsearch').
"				Also used for highlighting the current line in the quickfix
"				window and similar items that need to stand out.
"SpecialKey		Meta and special keys listed with ":map", also for text used
"				to show unprintable characters in the text, 'listchars'.
"				Generally: text that is displayed differently from what it
"				really is.
"SpellBad		Word that is not recognized by the spellchecker. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellCap		Word that should start with a capital. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellLocal		Word that is recognized by the spellchecker as one that is
"				used in another region. |spell|
"				This will be combined with the highlighting used otherwise.
"SpellRare		Word that is recognized by the spellchecker as one that is
"				hardly ever used. |spell|
"				This will be combined with the highlighting used otherwise.
"StatusLine		status line of current window
"StatusLineNC	status lines of not-current windows
"				Note: if this is equal to "StatusLine" Vim will use "^^^" in
"				the status line of the current window.
"TabLine		tab pages line, not active tab page label
"TabLineFill	tab pages line, where there are no labels
"TabLineSel		tab pages line, active tab page label
"Title			titles for output from ":set all", ":autocmd" etc.
"Visual			Visual mode selection
"VisualNOS		Visual mode selection when vim is "Not Owning the Selection".
"				Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
"WarningMsg		warning messages
"WildMenu		current match in 'wildmenu' completion
"

"------highlight syntax items"
"*Comment	any comment

"*Constant	any constant
 "String		a string constant: "this is a string"
 "Character	a character constant: 'c', '\n'
 "Number		a number constant: 234, 0xff
 "Boolean	a boolean constant: TRUE, false
 "Float		a floating point constant: 2.3e10

"*Identifier	any variable name
 "Function	function name (also: methods for classes)

"*Statement	any statement
 "Conditional	if, then, else, endif, switch, etc.
 "Repeat		for, do, while, etc.
 "Label		case, default, etc.
 "Operator	"sizeof", "+", "*", etc.
 "Keyword	any other keyword
 "Exception	try, catch, throw

"*PreProc	generic Preprocessor
 "Include	preprocessor #include
 "Define		preprocessor #define
 "Macro		same as Define
 "PreCondit	preprocessor #if, #else, #endif, etc.

"*Type		int, long, char, etc.
 "StorageClass	static, register, volatile, etc.
 "Structure	struct, union, enum, etc.
 "Typedef	A typedef

"*Special	any special symbol
 "SpecialChar	special character in a constant
 "Tag		you can use CTRL-] on this
 "Delimiter	character that needs attention
 "SpecialComment	special things inside a comment
 "Debug		debugging statements

"*Underlined	text that stands out, HTML links

"*Ignore		left blank, hidden  |hl-Ignore|

"*Error		any erroneous construct

"*Todo		anything that needs extra attention; mostly the
		"keywords TODO FIXME and XXX

zhimakaimen:/colors/myscheme.vim
"CLASS: Creator
"Creates primary/secondary/mirror nerdtree windows. Sets up all the window and
"buffer options and key mappings etc.
"============================================================
let s:Creator = {}
let g:NERDTreeCreator = s:Creator

"FUNCTION: s:Creator._bindMappings() {{{1
function! s:Creator._bindMappings()
    "make <cr> do the same as the default 'o' mapping
    exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"

    call g:NERDTreeKeyMap.BindAll()

    command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
    command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: s:Creator._broadcastInitEvent() {{{1
function! s:Creator._broadcastInitEvent()
    silent doautocmd User NERDTreeInit
endfunction

" FUNCTION: s:Creator.BufNamePrefix() {{{2
function! s:Creator.BufNamePrefix()
    return 'NERD_tree_'
endfunction

"FUNCTION: s:Creator.CreatePrimary(a:name) {{{1
function! s:Creator.CreatePrimary(name)
    let creator = s:Creator.New()
    call creator.createPrimary(a:name)
endfunction

"FUNCTION: s:Creator.createPrimary(a:name) {{{1
"name: the name of a bookmark or a directory
function! s:Creator.createPrimary(name)
    let path = self._pathForString(a:name)

    "if instructed to, then change the vim CWD to the dir the NERDTree is
    "inited in
    if g:NERDTreeChDirMode != 0
        call path.changeToDir()
    endif

    if nerdtree#treeExistsForTab()
        if nerdtree#isTreeOpen()
            call nerdtree#closeTree()
        endif
        unlet t:NERDTreeBufName
    endif

    let newRoot = g:NERDTreeDirNode.New(path)
    call newRoot.open()

    call self._createTreeWin()
    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    let b:NERDTreeRoot = newRoot
    let b:NERDTreeType = "primary"

    call nerdtree#renderView()
    call b:NERDTreeRoot.putCursorHere(0, 0)

    call self._broadcastInitEvent()
endfunction

"FUNCTION: s:Creator.CreateSecondary(dir) {{{1
function! s:Creator.CreateSecondary(dir)
    let creator = s:Creator.New()
    call creator.createSecondary(a:dir)
endfunction

"FUNCTION: s:Creator.createSecondary(dir) {{{1
function! s:Creator.createSecondary(dir)
    try
        let path = g:NERDTreePath.New(a:dir)
    catch /^NERDTree.InvalidArgumentsError/
        call nerdtree#echo("Invalid directory name:" . a:name)
        return
    endtry

    "we want the directory buffer to disappear when we do the :edit below
    setlocal bufhidden=wipe

    let previousBuf = expand("#")

    "we need a unique name for each secondary tree buffer to ensure they are
    "all independent
    exec "silent edit " . self._nextBufferName()

    let b:NERDTreePreviousBuf = bufnr(previousBuf)

    let b:NERDTreeRoot = g:NERDTreeDirNode.New(path)
    call b:NERDTreeRoot.open()

    call self._setCommonBufOptions()
    let b:NERDTreeType = "secondary"

    call nerdtree#renderView()

    call self._broadcastInitEvent()
endfunction

" FUNCTION: s:Creator.CreateMirror() {{{1
function! s:Creator.CreateMirror()
    let creator = s:Creator.New()
    call creator.createMirror()
endfunction

" FUNCTION: s:Creator.createMirror() {{{1
function! s:Creator.createMirror()
    "get the names off all the nerd tree buffers
    let treeBufNames = []
    for i in range(1, tabpagenr("$"))
        let nextName = nerdtree#tabpagevar(i, 'NERDTreeBufName')
        if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
            call add(treeBufNames, nextName)
        endif
    endfor
    let treeBufNames = nerdtree#unique(treeBufNames)

    "map the option names (that the user will be prompted with) to the nerd
    "tree buffer names
    let options = {}
    let i = 0
    while i < len(treeBufNames)
        let bufName = treeBufNames[i]
        let treeRoot = getbufvar(bufName, "NERDTreeRoot")
        let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
        let i = i + 1
    endwhile

    "work out which tree to mirror, if there is more than 1 then ask the user
    let bufferName = ''
    if len(keys(options)) > 1
        let choices = ["Choose a tree to mirror"]
        let choices = extend(choices, sort(keys(options)))
        let choice = inputlist(choices)
        if choice < 1 || choice > len(options) || choice ==# ''
            return
        endif

        let bufferName = options[sort(keys(options))[choice-1]]
    elseif len(keys(options)) ==# 1
        let bufferName = values(options)[0]
    else
        call nerdtree#echo("No trees to mirror")
        return
    endif

    if nerdtree#treeExistsForTab() && nerdtree#isTreeOpen()
        call nerdtree#closeTree()
    endif

    let t:NERDTreeBufName = bufferName
    call self._createTreeWin()
    exec 'buffer ' .  bufferName
    if !&hidden
        call nerdtree#renderView()
    endif
endfunction

"FUNCTION: s:Creator._createTreeWin() {{{1
"Inits the NERD tree window. ie. opens it, sizes it, sets all the local
"options etc
function! s:Creator._createTreeWin()
    "create the nerd tree window
    let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    let splitSize = g:NERDTreeWinSize

    if !exists('t:NERDTreeBufName')
        let t:NERDTreeBufName = self._nextBufferName()
        silent! exec splitLocation . 'vertical ' . splitSize . ' new'
        silent! exec "edit " . t:NERDTreeBufName
    else
        silent! exec splitLocation . 'vertical ' . splitSize . ' split'
        silent! exec "buffer " . t:NERDTreeBufName
    endif

    setlocal winfixwidth
    call self._setCommonBufOptions()
endfunction

"FUNCTION: s:Creator.New() {{{1
function! s:Creator.New()
    let newCreator = copy(self)
    return newCreator
endfunction

" FUNCTION: s:Creator._nextBufferName() {{{2
" returns the buffer name for the next nerd tree
function! s:Creator._nextBufferName()
    let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    return name
endfunction

" FUNCTION: s:Creator._nextBufferNumber() {{{2
" the number to add to the nerd tree buffer name to make the buf name unique
function! s:Creator._nextBufferNumber()
    if !exists("s:Creator._NextBufNum")
        let s:Creator._NextBufNum = 1
    else
        let s:Creator._NextBufNum += 1
    endif

    return s:Creator._NextBufNum
endfunction

"FUNCTION: s:Creator._pathForString(str) {{{1
"find a bookmark or adirectory for the given string
function! s:Creator._pathForString(str)
    let path = {}
    if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
        let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    else
        let dir = a:str ==# '' ? getcwd() : a:str

        "hack to get an absolute path if a relative path is given
        if dir =~# '^\.'
            let dir = getcwd() . g:NERDTreePath.Slash() . dir
        endif
        let dir = g:NERDTreePath.Resolve(dir)

        try
            let path = g:NERDTreePath.New(dir)
        catch /^NERDTree.InvalidArgumentsError/
            call nerdtree#echo("No bookmark or directory found for: " . a:str)
            return
        endtry
    endif
    if !path.isDirectory
        let path = path.getParent()
    endif

    return path
endfunction

"FUNCTION: s:Creator._setCommonBufOptions() {{{1
function! s:Creator._setCommonBufOptions()
    "throwaway buffer options
    setlocal noswapfile
    setlocal buftype=nofile
    setlocal bufhidden=hide
    setlocal nowrap
    setlocal foldcolumn=0
    setlocal foldmethod=manual
    setlocal nofoldenable
    setlocal nobuflisted
    setlocal nospell
    if g:NERDTreeShowLineNumbers
        setlocal nu
    else
        setlocal nonu
        if v:version >= 703
            setlocal nornu
        endif
    endif

    iabc <buffer>

    if g:NERDTreeHighlightCursorline
        setlocal cursorline
    endif

    call self._setupStatusline()

    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    setfiletype nerdtree
    call self._bindMappings()
endfunction

"FUNCTION: s:Creator._setupStatusline() {{{1
function! s:Creator._setupStatusline()
    if g:NERDTreeStatusline != -1
        let &l:statusline = g:NERDTreeStatusline
    endif
endfunction

"FUNCTION: s:Creator.TogglePrimary(dir) {{{1
function! s:Creator.TogglePrimary(dir)
    let creator = s:Creator.New()
    call creator.togglePrimary(a:dir)
endfunction

"FUNCTION: s:Creator.togglePrimary(dir) {{{1
"Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
"closed it is restored or initialized (if it doesnt exist)
"
"Args:
"dir: the full path for the root node (is only used if the NERD tree is being
"initialized.
function! s:Creator.togglePrimary(dir)
    if nerdtree#treeExistsForTab()
        if !nerdtree#isTreeOpen()
            call self._createTreeWin()
            if !&hidden
                call nerdtree#renderView()
            endif
            call nerdtree#restoreScreenState()
        else
            call nerdtree#closeTree()
        endif
    else
        call self.createPrimary(a:dir)
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/creator.vim
"CLASS: KeyMap
"============================================================
let s:KeyMap = {}
let g:NERDTreeKeyMap = s:KeyMap

"FUNCTION: KeyMap.All() {{{1
function! s:KeyMap.All()
    if !exists("s:keyMaps")
        let s:keyMaps = []
    endif
    return s:keyMaps
endfunction

"FUNCTION: KeyMap.FindFor(key, scope) {{{1
function! s:KeyMap.FindFor(key, scope)
    for i in s:KeyMap.All()
         if i.key ==# a:key && i.scope ==# a:scope
            return i
        endif
    endfor
    return {}
endfunction

"FUNCTION: KeyMap.BindAll() {{{1
function! s:KeyMap.BindAll()
    for i in s:KeyMap.All()
        call i.bind()
    endfor
endfunction

"FUNCTION: KeyMap.bind() {{{1
function! s:KeyMap.bind()
    " If the key sequence we're trying to map contains any '<>' notation, we
    " must replace each of the '<' characters with '<lt>' to ensure the string
    " is not translated into its corresponding keycode during the later part
    " of the map command below
    " :he <>
    let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
    if self.key =~# specialNotationRegex
        let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
    else
        let keymapInvokeString = self.key
    endif

    let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "

    exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'
endfunction

"FUNCTION: KeyMap.Remove(key, scope) {{{1
function! s:KeyMap.Remove(key, scope)
    let maps = s:KeyMap.All()
    for i in range(len(maps))
         if maps[i].key ==# a:key && maps[i].scope ==# a:scope
            return remove(maps, i)
        endif
    endfor
endfunction

"FUNCTION: KeyMap.invoke() {{{1
"Call the KeyMaps callback function
function! s:KeyMap.invoke(...)
    let Callback = function(self.callback)
    if a:0
        call Callback(a:1)
    else
        call Callback()
    endif
endfunction

"FUNCTION: KeyMap.Invoke() {{{1
"Find a keymapping for a:key and the current scope invoke it.
"
"Scope is determined as follows:
"   * if the cursor is on a dir node then "DirNode"
"   * if the cursor is on a file node then "FileNode"
"   * if the cursor is on a bookmark then "Bookmark"
"
"If a keymap has the scope of "all" then it will be called if no other keymap
"is found for a:key and the scope.
function! s:KeyMap.Invoke(key)
    let node = g:NERDTreeFileNode.GetSelected()
    if !empty(node)

        "try file node
        if !node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "FileNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try dir node
        if node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "DirNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try generic node
        let km = s:KeyMap.FindFor(a:key, "Node")
        if !empty(km)
            return km.invoke(node)
        endif

    endif

    "try bookmark
    let bm = g:NERDTreeBookmark.GetSelected()
    if !empty(bm)
        let km = s:KeyMap.FindFor(a:key, "Bookmark")
        if !empty(km)
            return km.invoke(bm)
        endif
    endif

    "try all
    let km = s:KeyMap.FindFor(a:key, "all")
    if !empty(km)
        return km.invoke()
    endif
endfunction

"FUNCTION: KeyMap.Create(options) {{{1
function! s:KeyMap.Create(options)
    let newKeyMap = copy(self)
    let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
    let newKeyMap.key = opts['key']
    let newKeyMap.quickhelpText = opts['quickhelpText']
    let newKeyMap.callback = opts['callback']
    let newKeyMap.scope = opts['scope']

    call s:KeyMap.Add(newKeyMap)
endfunction

"FUNCTION: KeyMap.Add(keymap) {{{1
function! s:KeyMap.Add(keymap)
    call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
    call add(s:KeyMap.All(), a:keymap)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/key_map.vim
"CLASS: MenuController
"============================================================
let s:MenuController = {}
let g:NERDTreeMenuController = s:MenuController

"FUNCTION: MenuController.New(menuItems) {{{1
"create a new menu controller that operates on the given menu items
function! s:MenuController.New(menuItems)
    let newMenuController =  copy(self)
    if a:menuItems[0].isSeparator()
        let newMenuController.menuItems = a:menuItems[1:-1]
    else
        let newMenuController.menuItems = a:menuItems
    endif
    return newMenuController
endfunction

"FUNCTION: MenuController.showMenu() {{{1
"start the main loop of the menu and get the user to choose/execute a menu
"item
function! s:MenuController.showMenu()
    call self._saveOptions()

    try
        let self.selection = 0

        let done = 0
        while !done
            redraw!
            call self._echoPrompt()
            let key = nr2char(getchar())
            let done = self._handleKeypress(key)
        endwhile
    finally
        call self._restoreOptions()
    endtry

    if self.selection != -1
        let m = self._current()
        call m.execute()
    endif
endfunction

"FUNCTION: MenuController._echoPrompt() {{{1
function! s:MenuController._echoPrompt()
    echo "NERDTree Menu. Use j/k/enter and the shortcuts indicated"
    echo "=========================================================="

    for i in range(0, len(self.menuItems)-1)
        if self.selection == i
            echo "> " . self.menuItems[i].text
        else
            echo "  " . self.menuItems[i].text
        endif
    endfor
endfunction

"FUNCTION: MenuController._current(key) {{{1
"get the MenuItem that is currently selected
function! s:MenuController._current()
    return self.menuItems[self.selection]
endfunction

"FUNCTION: MenuController._handleKeypress(key) {{{1
"change the selection (if appropriate) and return 1 if the user has made
"their choice, 0 otherwise
function! s:MenuController._handleKeypress(key)
    if a:key == 'j'
        call self._cursorDown()
    elseif a:key == 'k'
        call self._cursorUp()
    elseif a:key == nr2char(27) "escape
        let self.selection = -1
        return 1
    elseif a:key == "\r" || a:key == "\n" "enter and ctrl-j
        return 1
    else
        let index = self._nextIndexFor(a:key)
        if index != -1
            let self.selection = index
            if len(self._allIndexesFor(a:key)) == 1
                return 1
            endif
        endif
    endif

    return 0
endfunction

"FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
"get indexes to all menu items with the given shortcut
function! s:MenuController._allIndexesFor(shortcut)
    let toReturn = []

    for i in range(0, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            call add(toReturn, i)
        endif
    endfor

    return toReturn
endfunction

"FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
"get the index to the next menu item with the given shortcut, starts from the
"current cursor location and wraps around to the top again if need be
function! s:MenuController._nextIndexFor(shortcut)
    for i in range(self.selection+1, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    for i in range(0, self.selection)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    return -1
endfunction

"FUNCTION: MenuController._setCmdheight() {{{1
"sets &cmdheight to whatever is needed to display the menu
function! s:MenuController._setCmdheight()
    let &cmdheight = len(self.menuItems) + 3
endfunction

"FUNCTION: MenuController._saveOptions() {{{1
"set any vim options that are required to make the menu work (saving their old
"values)
function! s:MenuController._saveOptions()
    let self._oldLazyredraw = &lazyredraw
    let self._oldCmdheight = &cmdheight
    set nolazyredraw
    call self._setCmdheight()
endfunction

"FUNCTION: MenuController._restoreOptions() {{{1
"restore the options we saved in _saveOptions()
function! s:MenuController._restoreOptions()
    let &cmdheight = self._oldCmdheight
    let &lazyredraw = self._oldLazyredraw
endfunction

"FUNCTION: MenuController._cursorDown() {{{1
"move the cursor to the next menu item, skipping separators
function! s:MenuController._cursorDown()
    let done = 0
    while !done
        if self.selection < len(self.menuItems)-1
            let self.selection += 1
        else
            let self.selection = 0
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

"FUNCTION: MenuController._cursorUp() {{{1
"move the cursor to the previous menu item, skipping separators
function! s:MenuController._cursorUp()
    let done = 0
    while !done
        if self.selection > 0
            let self.selection -= 1
        else
            let self.selection = len(self.menuItems)-1
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/menu_controller.vim
"CLASS: Bookmark
"============================================================
let s:Bookmark = {}
let g:NERDTreeBookmark = s:Bookmark

" FUNCTION: Bookmark.activate() {{{1
function! s:Bookmark.activate(...)
    call self.open(a:0 ? a:1 : {})
endfunction

" FUNCTION: Bookmark.AddBookmark(name, path) {{{1
" Class method to add a new bookmark to the list, if a previous bookmark exists
" with the same name, just update the path for that bookmark
function! s:Bookmark.AddBookmark(name, path)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            let i.path = a:path
            return
        endif
    endfor
    call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
    call s:Bookmark.Sort()
endfunction

" FUNCTION: Bookmark.Bookmarks()   {{{1
" Class method to get all bookmarks. Lazily initializes the bookmarks global
" variable
function! s:Bookmark.Bookmarks()
    if !exists("g:NERDTreeBookmarks")
        let g:NERDTreeBookmarks = []
    endif
    return g:NERDTreeBookmarks
endfunction

" FUNCTION: Bookmark.BookmarkExistsFor(name)   {{{1
" class method that returns 1 if a bookmark with the given name is found, 0
" otherwise
function! s:Bookmark.BookmarkExistsFor(name)
    try
        call s:Bookmark.BookmarkFor(a:name)
        return 1
    catch /^NERDTree.BookmarkNotFoundError/
        return 0
    endtry
endfunction

" FUNCTION: Bookmark.BookmarkFor(name)   {{{1
" Class method to get the bookmark that has the given name. {} is return if no
" bookmark is found
function! s:Bookmark.BookmarkFor(name)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            return i
        endif
    endfor
    throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'
endfunction

" FUNCTION: Bookmark.BookmarkNames()   {{{1
" Class method to return an array of all bookmark names
function! s:Bookmark.BookmarkNames()
    let names = []
    for i in s:Bookmark.Bookmarks()
        call add(names, i.name)
    endfor
    return names
endfunction

" FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
" Class method to read all bookmarks from the bookmarks file initialize
" bookmark objects for each one.
"
" Args:
" silent - dont echo an error msg if invalid bookmarks are found
function! s:Bookmark.CacheBookmarks(silent)
    if filereadable(g:NERDTreeBookmarksFile)
        let g:NERDTreeBookmarks = []
        let g:NERDTreeInvalidBookmarks = []
        let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
        let invalidBookmarksFound = 0
        for i in bookmarkStrings

            "ignore blank lines
            if i != ''

                let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')

                try
                    let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                    call add(g:NERDTreeBookmarks, bookmark)
                catch /^NERDTree.InvalidArgumentsError/
                    call add(g:NERDTreeInvalidBookmarks, i)
                    let invalidBookmarksFound += 1
                endtry
            endif
        endfor
        if invalidBookmarksFound
            call s:Bookmark.Write()
            if !a:silent
                call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
            endif
        endif
        call s:Bookmark.Sort()
    endif
endfunction

" FUNCTION: Bookmark.compareTo(otherbookmark) {{{1
" Compare these two bookmarks for sorting purposes
function! s:Bookmark.compareTo(otherbookmark)
    return a:otherbookmark.name < self.name
endfunction
" FUNCTION: Bookmark.ClearAll() {{{1
" Class method to delete all bookmarks.
function! s:Bookmark.ClearAll()
    for i in s:Bookmark.Bookmarks()
        call i.delete()
    endfor
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.delete() {{{1
" Delete this bookmark. If the node for this bookmark is under the current
" root, then recache bookmarks for its Path object
function! s:Bookmark.delete()
    let node = {}
    try
        let node = self.getNode(1)
    catch /^NERDTree.BookmarkedNodeNotFoundError/
    endtry
    call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
    if !empty(node)
        call node.path.cacheDisplayString()
    endif
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{1
" Gets the treenode for this bookmark
"
" Args:
" searchFromAbsoluteRoot: specifies whether we should search from the current
" tree root, or the highest cached node
function! s:Bookmark.getNode(searchFromAbsoluteRoot)
    let searchRoot = a:searchFromAbsoluteRoot ? g:NERDTreeDirNode.AbsoluteTreeRoot() : b:NERDTreeRoot
    let targetNode = searchRoot.findNode(self.path)
    if empty(targetNode)
        throw "NERDTree.BookmarkedNodeNotFoundError: no node was found for bookmark: " . self.name
    endif
    return targetNode
endfunction

" FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{1
" Class method that finds the bookmark with the given name and returns the
" treenode for it.
function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    return bookmark.getNode(a:searchFromAbsoluteRoot)
endfunction

" FUNCTION: Bookmark.GetSelected() {{{1
" returns the Bookmark the cursor is over, or {}
function! s:Bookmark.GetSelected()
    let line = getline(".")
    let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    if name != line
        try
            return s:Bookmark.BookmarkFor(name)
        catch /^NERDTree.BookmarkNotFoundError/
            return {}
        endtry
    endif
    return {}
endfunction

" FUNCTION: Bookmark.InvalidBookmarks()   {{{1
" Class method to get all invalid bookmark strings read from the bookmarks
" file
function! s:Bookmark.InvalidBookmarks()
    if !exists("g:NERDTreeInvalidBookmarks")
        let g:NERDTreeInvalidBookmarks = []
    endif
    return g:NERDTreeInvalidBookmarks
endfunction

" FUNCTION: Bookmark.mustExist() {{{1
function! s:Bookmark.mustExist()
    if !self.path.exists()
        call s:Bookmark.CacheBookmarks(1)
        throw "NERDTree.BookmarkPointsToInvalidLocationError: the bookmark \"".
            \ self.name ."\" points to a non existing location: \"". self.path.str()
    endif
endfunction

" FUNCTION: Bookmark.New(name, path) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.New(name, path)
    if a:name =~# ' '
        throw "NERDTree.IllegalBookmarkNameError: illegal name:" . a:name
    endif

    let newBookmark = copy(self)
    let newBookmark.name = a:name
    let newBookmark.path = a:path
    return newBookmark
endfunction

" FUNCTION: Bookmark.open([options]) {{{1
"Args:
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' (vertical split), 'h'
"           (horizontal split), 't' (new tab) or 'p' (previous window).
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
"
function! s:Bookmark.open(...)
    let opts = a:0 ? a:1 : {}

    if self.path.isDirectory && !has_key(opts, 'where')
        call self.toRoot()
    else
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    endif
endfunction

" FUNCTION: Bookmark.openInNewTab(options) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.openInNewTab(options)
    call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
    call self.open(a:options)
endfunction

" FUNCTION: Bookmark.setPath(path)   {{{1
" makes this bookmark point to the given path
function! s:Bookmark.setPath(path)
    let self.path = a:path
endfunction

" FUNCTION: Bookmark.Sort()   {{{1
" Class method that sorts all bookmarks
function! s:Bookmark.Sort()
    let CompareFunc = function("nerdtree#compareBookmarks")
    call sort(s:Bookmark.Bookmarks(), CompareFunc)
endfunction

" FUNCTION: Bookmark.str()   {{{1
" Get the string that should be rendered in the view for this bookmark
function! s:Bookmark.str()
    let pathStrMaxLen = winwidth(nerdtree#getTreeWinNum()) - 4 - len(self.name)
    if &nu
        let pathStrMaxLen = pathStrMaxLen - &numberwidth
    endif

    let pathStr = self.path.str({'format': 'UI'})
    if len(pathStr) > pathStrMaxLen
        let pathStr = '<' . strpart(pathStr, len(pathStr) - pathStrMaxLen)
    endif
    return '>' . self.name . ' ' . pathStr
endfunction

" FUNCTION: Bookmark.toRoot() {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.toRoot()
    if self.validate()
        try
            let targetNode = self.getNode(1)
        catch /^NERDTree.BookmarkedNodeNotFoundError/
            let targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path)
        endtry
        call targetNode.makeRoot()
        call nerdtree#renderView()
        call targetNode.putCursorHere(0, 0)
    endif
endfunction

" FUNCTION: Bookmark.ToRoot(name) {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.ToRoot(name)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    call bookmark.toRoot()
endfunction

" FUNCTION: Bookmark.validate() {{{1
function! s:Bookmark.validate()
    if self.path.exists()
        return 1
    else
        call s:Bookmark.CacheBookmarks(1)
        call nerdtree#renderView()
        call nerdtree#echo(self.name . "now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.")
        return 0
    endif
endfunction

" FUNCTION: Bookmark.Write()   {{{1
" Class method to write all bookmarks to the bookmarks file
function! s:Bookmark.Write()
    let bookmarkStrings = []
    for i in s:Bookmark.Bookmarks()
        call add(bookmarkStrings, i.name . ' ' . i.path.str())
    endfor

    "add a blank line before the invalid ones
    call add(bookmarkStrings, "")

    for j in s:Bookmark.InvalidBookmarks()
        call add(bookmarkStrings, j)
    endfor
    call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/bookmark.vim
"we need to use this number many times for sorting... so we calculate it only
"once here
let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')

"CLASS: Path
"============================================================
let s:Path = {}
let g:NERDTreePath = s:Path

"FUNCTION: Path.AbsolutePathFor(str) {{{1
function! s:Path.AbsolutePathFor(str)
    let prependCWD = 0
    if nerdtree#runningWindows()
        let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
    else
        let prependCWD = a:str !~# '^/'
    endif

    let toReturn = a:str
    if prependCWD
        let toReturn = getcwd() . s:Path.Slash() . a:str
    endif

    return toReturn
endfunction

"FUNCTION: Path.bookmarkNames() {{{1
function! s:Path.bookmarkNames()
    if !exists("self._bookmarkNames")
        call self.cacheDisplayString()
    endif
    return self._bookmarkNames
endfunction

"FUNCTION: Path.cacheDisplayString() {{{1
function! s:Path.cacheDisplayString()
    let self.cachedDisplayString = self.getLastPathComponent(1)

    if self.isExecutable
        let self.cachedDisplayString = self.cachedDisplayString . '*'
    endif

    let self._bookmarkNames = []
    for i in g:NERDTreeBookmark.Bookmarks()
        if i.path.equals(self)
            call add(self._bookmarkNames, i.name)
        endif
    endfor
    if !empty(self._bookmarkNames)
        let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
    endif

    if self.isSymLink
        let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
    endif

    if self.isReadOnly
        let self.cachedDisplayString .=  ' [RO]'
    endif
endfunction

"FUNCTION: Path.changeToDir() {{{1
function! s:Path.changeToDir()
    let dir = self.str({'format': 'Cd'})
    if self.isDirectory ==# 0
        let dir = self.getParent().str({'format': 'Cd'})
    endif

    try
        execute "cd " . dir
        call nerdtree#echo("CWD is now: " . getcwd())
    catch
        throw "NERDTree.PathChangeError: cannot change CWD to " . dir
    endtry
endfunction

"FUNCTION: Path.compareTo() {{{1
"
"Compares this Path to the given path and returns 0 if they are equal, -1 if
"this Path is "less than" the given path, or 1 if it is "greater".
"
"Args:
"path: the path object to compare this to
"
"Return:
"1, -1 or 0
function! s:Path.compareTo(path)
    let thisPath = self.getLastPathComponent(1)
    let thatPath = a:path.getLastPathComponent(1)

    "if the paths are the same then clearly we return 0
    if thisPath ==# thatPath
        return 0
    endif

    let thisSS = self.getSortOrderIndex()
    let thatSS = a:path.getSortOrderIndex()

    "compare the sort sequences, if they are different then the return
    "value is easy
    if thisSS < thatSS
        return -1
    elseif thisSS > thatSS
        return 1
    else
        "if the sort sequences are the same then compare the paths
        "alphabetically
        let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
        if pathCompare
            return -1
        else
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.Create(fullpath) {{{1
"
"Factory method.
"
"Creates a path object with the given path. The path is also created on the
"filesystem. If the path already exists, a NERDTree.Path.Exists exception is
"thrown. If any other errors occur, a NERDTree.Path exception is thrown.
"
"Args:
"fullpath: the full filesystem path to the file/dir to create
function! s:Path.Create(fullpath)
    "bail if the a:fullpath already exists
    if isdirectory(a:fullpath) || filereadable(a:fullpath)
        throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
    endif

    try

        "if it ends with a slash, assume its a dir create it
        if a:fullpath =~# '\(\\\|\/\)$'
            "whack the trailing slash off the end if it exists
            let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')

            call mkdir(fullpath, 'p')

        "assume its a file and create
        else
            call writefile([], a:fullpath)
        endif
    catch
        throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
    endtry

    return s:Path.New(a:fullpath)
endfunction

"FUNCTION: Path.copy(dest) {{{1
"
"Copies the file/dir represented by this Path to the given location
"
"Args:
"dest: the location to copy this dir/file to
function! s:Path.copy(dest)
    if !s:Path.CopyingSupported()
        throw "NERDTree.CopyingNotSupportedError: Copying is not supported on this OS"
    endif

    let dest = s:Path.WinToUnixPath(a:dest)

    let cmd = g:NERDTreeCopyCmd . " " . escape(self.str(), nerdtree#escChars()) . " " . escape(dest, nerdtree#escChars())
    let success = system(cmd)
    if success != 0
        throw "NERDTree.CopyError: Could not copy ''". self.str() ."'' to: '" . a:dest . "'"
    endif
endfunction

"FUNCTION: Path.CopyingSupported() {{{1
"
"returns 1 if copying is supported for this OS
function! s:Path.CopyingSupported()
    return exists('g:NERDTreeCopyCmd')
endfunction

"FUNCTION: Path.copyingWillOverwrite(dest) {{{1
"
"returns 1 if copy this path to the given location will cause files to
"overwritten
"
"Args:
"dest: the location this path will be copied to
function! s:Path.copyingWillOverwrite(dest)
    if filereadable(a:dest)
        return 1
    endif

    if isdirectory(a:dest)
        let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
        if filereadable(path)
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.delete() {{{1
"
"Deletes the file represented by this path.
"Deletion of directories is not supported
"
"Throws NERDTree.Path.Deletion exceptions
function! s:Path.delete()
    if self.isDirectory

        let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
        let success = system(cmd)

        if v:shell_error != 0
            throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
        endif
    else
        let success = delete(self.str())
        if success != 0
            throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
        endif
    endif

    "delete all bookmarks for this path
    for i in self.bookmarkNames()
        let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
        call bookmark.delete()
    endfor
endfunction

"FUNCTION: Path.displayString() {{{1
"
"Returns a string that specifies how the path should be represented as a
"string
function! s:Path.displayString()
    if self.cachedDisplayString ==# ""
        call self.cacheDisplayString()
    endif

    return self.cachedDisplayString
endfunction

"FUNCTION: Path.edit() {{{1
function! s:Path.edit()
    exec "edit " . self.str({'format': 'Edit'})
endfunction

"FUNCTION: Path.extractDriveLetter(fullpath) {{{1
"
"If running windows, cache the drive letter for this path
function! s:Path.extractDriveLetter(fullpath)
    if nerdtree#runningWindows()
        if a:fullpath =~ '^\(\\\\\|\/\/\)'
            "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
            let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
            let self.drive = substitute(self.drive, '/', '\', "g")
        else
            let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
        endif
    else
        let self.drive = ''
    endif

endfunction

"FUNCTION: Path.exists() {{{1
"return 1 if this path points to a location that is readable or is a directory
function! s:Path.exists()
    let p = self.str()
    return filereadable(p) || isdirectory(p)
endfunction

"FUNCTION: Path.getDir() {{{1
"
"Returns this path if it is a directory, else this paths parent.
"
"Return:
"a Path object
function! s:Path.getDir()
    if self.isDirectory
        return self
    else
        return self.getParent()
    endif
endfunction

"FUNCTION: Path.getParent() {{{1
"
"Returns a new path object for this paths parent
"
"Return:
"a new Path object
function! s:Path.getParent()
    if nerdtree#runningWindows()
        let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    else
        let path = '/'. join(self.pathSegments[0:-2], '/')
    endif

    return s:Path.New(path)
endfunction

"FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
"
"Gets the last part of this path.
"
"Args:
"dirSlash: if 1 then a trailing slash will be added to the returned value for
"directory nodes.
function! s:Path.getLastPathComponent(dirSlash)
    if empty(self.pathSegments)
        return ''
    endif
    let toReturn = self.pathSegments[-1]
    if a:dirSlash && self.isDirectory
        let toReturn = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path.getSortOrderIndex() {{{1
"returns the index of the pattern in g:NERDTreeSortOrder that this path matches
function! s:Path.getSortOrderIndex()
    let i = 0
    while i < len(g:NERDTreeSortOrder)
        if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
            return i
        endif
        let i = i + 1
    endwhile
    return s:NERDTreeSortStarIndex
endfunction

"FUNCTION: Path.isUnixHiddenFile() {{{1
"check for unix hidden files
function! s:Path.isUnixHiddenFile()
    return self.getLastPathComponent(0) =~# '^\.'
endfunction

"FUNCTION: Path.isUnixHiddenPath() {{{1
"check for unix path with hidden components
function! s:Path.isUnixHiddenPath()
    if self.getLastPathComponent(0) =~# '^\.'
        return 1
    else
        for segment in self.pathSegments
            if segment =~# '^\.'
                return 1
            endif
        endfor
        return 0
    endif
endfunction

"FUNCTION: Path.ignore() {{{1
"returns true if this path should be ignored
function! s:Path.ignore()
    "filter out the user specified paths to ignore
    if b:NERDTreeIgnoreEnabled
        for i in g:NERDTreeIgnore
            if self._ignorePatternMatches(i)
                return 1
            endif
        endfor
    endif

    "dont show hidden files unless instructed to
    if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
        return 1
    endif

    if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
        return 1
    endif

    if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
        return 1
    endif

    return 0
endfunction

"FUNCTION: Path._ignorePatternMatches(pattern) {{{1
"returns true if this path matches the given ignore pattern
function! s:Path._ignorePatternMatches(pattern)
    let pat = a:pattern
    if strpart(pat,len(pat)-7) == '[[dir]]'
        if !self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-7)
    elseif strpart(pat,len(pat)-8) == '[[file]]'
        if self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-8)
    endif

    return self.getLastPathComponent(0) =~# pat
endfunction

"FUNCTION: Path.isUnder(path) {{{1
"return 1 if this path is somewhere under the given path in the filesystem.
"
"a:path should be a dir
function! s:Path.isUnder(path)
    if a:path.isDirectory == 0
        return 0
    endif

    let this = self.str()
    let that = a:path.str()
    return stridx(this, that . s:Path.Slash()) == 0
endfunction

"FUNCTION: Path.JoinPathStrings(...) {{{1
function! s:Path.JoinPathStrings(...)
    let components = []
    for i in a:000
        let components = extend(components, split(i, '/'))
    endfor
    return '/' . join(components, '/')
endfunction

"FUNCTION: Path.equals() {{{1
"
"Determines whether 2 path objects are "equal".
"They are equal if the paths they represent are the same
"
"Args:
"path: the other path obj to compare this with
function! s:Path.equals(path)
    return self.str() ==# a:path.str()
endfunction

"FUNCTION: Path.New() {{{1
"The Constructor for the Path object
function! s:Path.New(path)
    let newPath = copy(self)

    call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))

    let newPath.cachedDisplayString = ""

    return newPath
endfunction

"FUNCTION: Path.Slash() {{{1
"return the slash to use for the current OS
function! s:Path.Slash()
    return nerdtree#runningWindows() ? '\' : '/'
endfunction

"FUNCTION: Path.Resolve() {{{1
"Invoke the vim resolve() function and return the result
"This is necessary because in some versions of vim resolve() removes trailing
"slashes while in other versions it doesn't.  This always removes the trailing
"slash
function! s:Path.Resolve(path)
    let tmp = resolve(a:path)
    return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
endfunction

"FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
"
"
"Throws NERDTree.Path.InvalidArguments exception.
function! s:Path.readInfoFromDisk(fullpath)
    call self.extractDriveLetter(a:fullpath)

    let fullpath = s:Path.WinToUnixPath(a:fullpath)

    if getftype(fullpath) ==# "fifo"
        throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
    endif

    let self.pathSegments = split(fullpath, '/')

    let self.isReadOnly = 0
    if isdirectory(a:fullpath)
        let self.isDirectory = 1
    elseif filereadable(a:fullpath)
        let self.isDirectory = 0
        let self.isReadOnly = filewritable(a:fullpath) ==# 0
    else
        throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
    endif

    let self.isExecutable = 0
    if !self.isDirectory
        let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    endif

    "grab the last part of the path (minus the trailing slash)
    let lastPathComponent = self.getLastPathComponent(0)

    "get the path to the new node with the parent dir fully resolved
    let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent

    "if  the last part of the path is a symlink then flag it as such
    let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    if self.isSymLink
        let self.symLinkDest = s:Path.Resolve(fullpath)

        "if the link is a dir then slap a / on the end of its dest
        if isdirectory(self.symLinkDest)

            "we always wanna treat MS windows shortcuts as files for
            "simplicity
            if hardPath !~# '\.lnk$'

                let self.symLinkDest = self.symLinkDest . '/'
            endif
        endif
    endif
endfunction

"FUNCTION: Path.refresh() {{{1
function! s:Path.refresh()
    call self.readInfoFromDisk(self.str())
    call self.cacheDisplayString()
endfunction

"FUNCTION: Path.rename() {{{1
"
"Renames this node on the filesystem
function! s:Path.rename(newPath)
    if a:newPath ==# ''
        throw "NERDTree.InvalidArgumentsError: Invalid newPath for renaming = ". a:newPath
    endif

    let success =  rename(self.str(), a:newPath)
    if success != 0
        throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
    endif
    call self.readInfoFromDisk(a:newPath)

    for i in self.bookmarkNames()
        let b = g:NERDTreeBookmark.BookmarkFor(i)
        call b.setPath(copy(self))
    endfor
    call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: Path.str() {{{1
"
"Returns a string representation of this Path
"
"Takes an optional dictionary param to specify how the output should be
"formatted.
"
"The dict may have the following keys:
"  'format'
"  'escape'
"  'truncateTo'
"
"The 'format' key may have a value of:
"  'Cd' - a string to be used with the :cd command
"  'Edit' - a string to be used with :e :sp :new :tabedit etc
"  'UI' - a string used in the NERD tree UI
"
"The 'escape' key, if specified will cause the output to be escaped with
"shellescape()
"
"The 'truncateTo' key causes the resulting string to be truncated to the value
"'truncateTo' maps to. A '<' char will be prepended.
function! s:Path.str(...)
    let options = a:0 ? a:1 : {}
    let toReturn = ""

    if has_key(options, 'format')
        let format = options['format']
        if has_key(self, '_strFor' . format)
            exec 'let toReturn = self._strFor' . format . '()'
        else
            raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
        endif
    else
        let toReturn = self._str()
    endif

    if nerdtree#has_opt(options, 'escape')
        let toReturn = shellescape(toReturn)
    endif

    if has_key(options, 'truncateTo')
        let limit = options['truncateTo']
        if len(toReturn) > limit
            let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
        endif
    endif

    return toReturn
endfunction

"FUNCTION: Path._strForUI() {{{1
function! s:Path._strForUI()
    let toReturn = '/' . join(self.pathSegments, '/')
    if self.isDirectory && toReturn != '/'
        let toReturn  = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path._strForCd() {{{1
"
" returns a string that can be used with :cd
function! s:Path._strForCd()
    return escape(self.str(), nerdtree#escChars())
endfunction

"FUNCTION: Path._strForEdit() {{{1
"
"Return: the string for this path that is suitable to be used with the :edit
"command
function! s:Path._strForEdit()
    let p = escape(self.str({'format': 'UI'}), nerdtree#escChars())
    let cwd = getcwd() . s:Path.Slash()

    "return a relative path if we can
    let isRelative = 0
    if nerdtree#runningWindows()
        let isRelative = stridx(tolower(p), tolower(cwd)) == 0
    else
        let isRelative = stridx(p, cwd) == 0
    endif

    if isRelative
        let p = strpart(p, strlen(cwd))

        "handle the edge case where the file begins with a + (vim interprets
        "the +foo in `:e +foo` as an option to :edit)
        if p[0] == "+"
            let p = '\' . p
        endif
    endif

    if p ==# ''
        let p = '.'
    endif

    return p
endfunction

"FUNCTION: Path._strForGlob() {{{1
function! s:Path._strForGlob()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    let toReturn = lead . join(self.pathSegments, s:Path.Slash())

    if !nerdtree#runningWindows()
        let toReturn = escape(toReturn, nerdtree#escChars())
    endif
    return toReturn
endfunction

"FUNCTION: Path._str() {{{1
"
"Gets the string path for this path object that is appropriate for the OS.
"EG, in windows c:\foo\bar
"    in *nix  /foo/bar
function! s:Path._str()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    return lead . join(self.pathSegments, s:Path.Slash())
endfunction

"FUNCTION: Path.strTrunk() {{{1
"Gets the path without the last segment on the end.
function! s:Path.strTrunk()
    return self.drive . '/' . join(self.pathSegments[0:-2], '/')
endfunction

" FUNCTION: Path.tabnr() {{{1
" return the number of the first tab that is displaying this file
"
" return 0 if no tab was found
function! s:Path.tabnr()
    let str = self.str()
    for t in range(tabpagenr('$'))
        for b in tabpagebuflist(t+1)
            if str == expand('#' . b . ':p')
                return t+1
            endif
        endfor
    endfor
    return 0
endfunction

"FUNCTION: Path.WinToUnixPath(pathstr){{{1
"Takes in a windows path and returns the unix equiv
"
"A class level method
"
"Args:
"pathstr: the windows path to convert
function! s:Path.WinToUnixPath(pathstr)
    if !nerdtree#runningWindows()
        return a:pathstr
    endif

    let toReturn = a:pathstr

    "remove the x:\ of the front
    let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")

    "remove the \\ network share from the front
    let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")

    "convert all \ chars to /
    let toReturn = substitute(toReturn, '\', '/', "g")

    return toReturn
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/path.vim
"CLASS: TreeDirNode
"A subclass of NERDTreeFileNode.
"
"The 'composite' part of the file/dir composite.
"============================================================
let s:TreeDirNode = copy(g:NERDTreeFileNode)
let g:NERDTreeDirNode = s:TreeDirNode

"FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
"class method that returns the highest cached ancestor of the current root
function! s:TreeDirNode.AbsoluteTreeRoot()
    let currentNode = b:NERDTreeRoot
    while currentNode.parent != {}
        let currentNode = currentNode.parent
    endwhile
    return currentNode
endfunction

"FUNCTION: TreeDirNode.activate([options]) {{{1
unlet s:TreeDirNode.activate
function! s:TreeDirNode.activate(...)
    let opts = a:0 ? a:1 : {}
    call self.toggleOpen(opts)
    call nerdtree#renderView()
    call self.putCursorHere(0, 0)
endfunction

"FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
"Adds the given treenode to the list of children for this node
"
"Args:
"-treenode: the node to add
"-inOrder: 1 if the new node should be inserted in sorted order
function! s:TreeDirNode.addChild(treenode, inOrder)
    call add(self.children, a:treenode)
    let a:treenode.parent = self

    if a:inOrder
        call self.sortChildren()
    endif
endfunction

"FUNCTION: TreeDirNode.close() {{{1
"Closes this directory
function! s:TreeDirNode.close()
    let self.isOpen = 0
endfunction

"FUNCTION: TreeDirNode.closeChildren() {{{1
"Closes all the child dir nodes of this node
function! s:TreeDirNode.closeChildren()
    for i in self.children
        if i.path.isDirectory
            call i.close()
            call i.closeChildren()
        endif
    endfor
endfunction

"FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
"Instantiates a new child node for this node with the given path. The new
"nodes parent is set to this node.
"
"Args:
"path: a Path object that this node will represent/contain
"inOrder: 1 if the new node should be inserted in sorted order
"
"Returns:
"the newly created node
function! s:TreeDirNode.createChild(path, inOrder)
    let newTreeNode = g:NERDTreeFileNode.New(a:path)
    call self.addChild(newTreeNode, a:inOrder)
    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.findNode(path) {{{1
"Will find one of the children (recursively) that has the given path
"
"Args:
"path: a path object
unlet s:TreeDirNode.findNode
function! s:TreeDirNode.findNode(path)
    if a:path.equals(self.path)
        return self
    endif
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    if self.path.isDirectory
        for i in self.children
            let retVal = i.findNode(a:path)
            if retVal != {}
                return retVal
            endif
        endfor
    endif
    return {}
endfunction

"FUNCTION: TreeDirNode.getChildCount() {{{1
"Returns the number of children this node has
function! s:TreeDirNode.getChildCount()
    return len(self.children)
endfunction

"FUNCTION: TreeDirNode.getChild(path) {{{1
"Returns child node of this node that has the given path or {} if no such node
"exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChild(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    let index = self.getChildIndex(a:path)
    if index ==# -1
        return {}
    else
        return self.children[index]
    endif

endfunction

"FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
"returns the child at the given index
"Args:
"indx: the index to get the child from
"visible: 1 if only the visible children array should be used, 0 if all the
"children should be searched.
function! s:TreeDirNode.getChildByIndex(indx, visible)
    let array_to_search = a:visible? self.getVisibleChildren() : self.children
    if a:indx > len(array_to_search)
        throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
    endif
    return array_to_search[a:indx]
endfunction

"FUNCTION: TreeDirNode.getChildIndex(path) {{{1
"Returns the index of the child node of this node that has the given path or
"-1 if no such node exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChildIndex(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return -1
    endif

    "do a binary search for the child
    let a = 0
    let z = self.getChildCount()
    while a < z
        let mid = (a+z)/2
        let diff = a:path.compareTo(self.children[mid].path)

        if diff ==# -1
            let z = mid
        elseif diff ==# 1
            let a = mid+1
        else
            return mid
        endif
    endwhile
    return -1
endfunction

"FUNCTION: TreeDirNode.GetSelected() {{{1
"Returns the current node if it is a dir node, or else returns the current
"nodes parent
unlet s:TreeDirNode.GetSelected
function! s:TreeDirNode.GetSelected()
    let currentDir = g:NERDTreeFileNode.GetSelected()
    if currentDir != {} && !currentDir.isRoot()
        if currentDir.path.isDirectory ==# 0
            let currentDir = currentDir.parent
        endif
    endif
    return currentDir
endfunction

"FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
"Returns the number of visible children this node has
function! s:TreeDirNode.getVisibleChildCount()
    return len(self.getVisibleChildren())
endfunction

"FUNCTION: TreeDirNode.getVisibleChildren() {{{1
"Returns a list of children to display for this node, in the correct order
"
"Return:
"an array of treenodes
function! s:TreeDirNode.getVisibleChildren()
    let toReturn = []
    for i in self.children
        if i.path.ignore() ==# 0
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
"returns 1 if this node has any childre, 0 otherwise..
function! s:TreeDirNode.hasVisibleChildren()
    return self.getVisibleChildCount() != 0
endfunction

"FUNCTION: TreeDirNode._initChildren() {{{1
"Removes all childen from this node and re-reads them
"
"Args:
"silent: 1 if the function should not echo any "please wait" messages for
"large directories
"
"Return: the number of child nodes read
function! s:TreeDirNode._initChildren(silent)
    "remove all the current child nodes
    let self.children = []

    "get an array of all the files in the nodes dir
    let dir = self.path
    let globDir = dir.str({'format': 'Glob'})

    if version >= 703
        let filesStr = globpath(globDir, '*', 1) . "\n" . globpath(globDir, '.*', 1)
    else
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
    endif

    let files = split(filesStr, "\n")

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ...")
    endif

    let invalidFilesFound = 0
    for i in files

        "filter out the .. and . directories
        "Note: we must match .. AND ../ cos sometimes the globpath returns
        "../ for path with strange chars (eg $)
        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

            "put the next file in a new node and attach it
            try
                let path = g:NERDTreePath.New(i)
                call self.createChild(path, 0)
            catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                let invalidFilesFound += 1
            endtry
        endif
    endfor

    call self.sortChildren()

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
    endif

    if invalidFilesFound
        call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
    endif
    return self.getChildCount()
endfunction

"FUNCTION: TreeDirNode.New(path) {{{1
"Returns a new TreeNode object with the given path and parent
"
"Args:
"path: a path object representing the full filesystem path to the file/dir that the node represents
unlet s:TreeDirNode.New
function! s:TreeDirNode.New(path)
    if a:path.isDirectory != 1
        throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
    endif

    let newTreeNode = copy(self)
    let newTreeNode.path = a:path

    let newTreeNode.isOpen = 0
    let newTreeNode.children = []

    let newTreeNode.parent = {}

    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.open([opts]) {{{1
"Open the dir in the current tree or in a new tree elsewhere.
"
"If opening in the current tree, return the number of cached nodes.
unlet s:TreeDirNode.open
function! s:TreeDirNode.open(...)
    let opts = a:0 ? a:1 : {}

    if has_key(opts, 'where') && !empty(opts['where'])
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    else
        let self.isOpen = 1
        if self.children ==# []
            return self._initChildren(0)
        else
            return 0
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.openAlong([opts]) {{{1
"recursive open the dir if it has only one directory child.
"
"return the level of opened directories.
function! s:TreeDirNode.openAlong(...)
    let opts = a:0 ? a:1 : {}
    let level = 0

    let node = self
    while node.path.isDirectory
        call node.open(opts)
        let level += 1
        if node.getVisibleChildCount() == 1
            let node = node.getChildByIndex(0, 1)
        else
            break
        endif
    endwhile
    return level
endfunction

" FUNCTION: TreeDirNode.openExplorer() {{{1
" opens an explorer window for this node in the previous window (could be a
" nerd tree or a netrw)
function! s:TreeDirNode.openExplorer()
    call self.open({'where': 'p'})
endfunction

"FUNCTION: TreeDirNode.openInNewTab(options) {{{1
unlet s:TreeDirNode.openInNewTab
function! s:TreeDirNode.openInNewTab(options)
    call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
    call self.open({'where': 't'})
endfunction

"FUNCTION: TreeDirNode._openInNewTab() {{{1
function! s:TreeDirNode._openInNewTab()
    tabnew
    call g:NERDTreeCreator.CreatePrimary(self.path.str())
endfunction

"FUNCTION: TreeDirNode.openRecursively() {{{1
"Opens this treenode and all of its children whose paths arent 'ignored'
"because of the file filters.
"
"This method is actually a wrapper for the OpenRecursively2 method which does
"the work.
function! s:TreeDirNode.openRecursively()
    call self._openRecursively2(1)
endfunction

"FUNCTION: TreeDirNode._openRecursively2() {{{1
"Opens this all children of this treenode recursively if either:
"   *they arent filtered by file filters
"   *a:forceOpen is 1
"
"Args:
"forceOpen: 1 if this node should be opened regardless of file filters
function! s:TreeDirNode._openRecursively2(forceOpen)
    if self.path.ignore() ==# 0 || a:forceOpen
        let self.isOpen = 1
        if self.children ==# []
            call self._initChildren(1)
        endif

        for i in self.children
            if i.path.isDirectory ==# 1
                call i._openRecursively2(0)
            endif
        endfor
    endif
endfunction

"FUNCTION: TreeDirNode.refresh() {{{1
unlet s:TreeDirNode.refresh
function! s:TreeDirNode.refresh()
    call self.path.refresh()

    "if this node was ever opened, refresh its children
    if self.isOpen || !empty(self.children)
        "go thru all the files/dirs under this node
        let newChildNodes = []
        let invalidFilesFound = 0
        let dir = self.path
        let globDir = dir.str({'format': 'Glob'})
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
        let files = split(filesStr, "\n")
        for i in files
            "filter out the .. and . directories
            "Note: we must match .. AND ../ cos sometimes the globpath returns
            "../ for path with strange chars (eg $)
            if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

                try
                    "create a new path and see if it exists in this nodes children
                    let path = g:NERDTreePath.New(i)
                    let newNode = self.getChild(path)
                    if newNode != {}
                        call newNode.refresh()
                        call add(newChildNodes, newNode)

                    "the node doesnt exist so create it
                    else
                        let newNode = g:NERDTreeFileNode.New(path)
                        let newNode.parent = self
                        call add(newChildNodes, newNode)
                    endif


                catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                    let invalidFilesFound = 1
                endtry
            endif
        endfor

        "swap this nodes children out for the children we just read/refreshed
        let self.children = newChildNodes
        call self.sortChildren()

        if invalidFilesFound
            call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.reveal(path) {{{1
"reveal the given path, i.e. cache and open all treenodes needed to display it
"in the UI
function! s:TreeDirNode.reveal(path)
    if !a:path.isUnder(self.path)
        throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
    endif

    call self.open()

    if self.path.equals(a:path.getParent())
        let n = self.findNode(a:path)
        call nerdtree#renderView()
        call n.putCursorHere(1,0)
        return
    endif

    let p = a:path
    while !p.getParent().equals(self.path)
        let p = p.getParent()
    endwhile

    let n = self.findNode(p)
    call n.reveal(a:path)
endfunction

"FUNCTION: TreeDirNode.removeChild(treenode) {{{1
"
"Removes the given treenode from this nodes set of children
"
"Args:
"treenode: the node to remove
"
"Throws a NERDTree.ChildNotFoundError if the given treenode is not found
function! s:TreeDirNode.removeChild(treenode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:treenode)
            call remove(self.children, i)
            return
        endif
    endfor

    throw "NERDTree.ChildNotFoundError: child node was not found"
endfunction

"FUNCTION: TreeDirNode.sortChildren() {{{1
"
"Sorts the children of this node according to alphabetical order and the
"directory priority.
"
function! s:TreeDirNode.sortChildren()
    let CompareFunc = function("nerdtree#compareNodes")
    call sort(self.children, CompareFunc)
endfunction

"FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
"Opens this directory if it is closed and vice versa
function! s:TreeDirNode.toggleOpen(...)
    let opts = a:0 ? a:1 : {}
    if self.isOpen ==# 1
        call self.close()
    else
        if g:NERDTreeCasadeOpenSingleChildDir == 0
            call self.open(opts)
        else
            call self.openAlong(opts)
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
"Replaces the child of this with the given node (where the child node's full
"path matches a:newNode's fullpath). The search for the matching node is
"non-recursive
"
"Arg:
"newNode: the node to graft into the tree
function! s:TreeDirNode.transplantChild(newNode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:newNode)
            let self.children[i] = a:newNode
            let a:newNode.parent = self
            break
        endif
    endfor
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/tree_dir_node.vim
"CLASS: Opener
"============================================================
let s:Opener = {}
let g:NERDTreeOpener = s:Opener

"FUNCTION: Opener._checkToCloseTree(newtab) {{{1
"Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
"if the tree should be closed now.
"
"Args:
"a:newtab - boolean. If set, only close the tree now if we are opening the
"target in a new tab. This is needed because we have to close tree before we
"leave the tab
function! s:Opener._checkToCloseTree(newtab)
    if self._keepopen
        return
    endif

    if (a:newtab && self._where == 't') || !a:newtab
        call nerdtree#closeTreeIfQuitOnOpen()
    endif
endfunction

"FUNCTION: Opener._gotoTargetWin() {{{1
function! s:Opener._gotoTargetWin()
    if b:NERDTreeType ==# "secondary"
        if self._where == 'v'
            vsplit
        elseif self._where == 'h'
            split
        elseif self._where == 't'
            tabnew
        endif
    else
        call self._checkToCloseTree(1)

        if self._where == 'v'
            call self._newVSplit()
        elseif self._where == 'h'
            call self._newSplit()
        elseif self._where == 't'
            tabnew
        elseif self._where == 'p'
            call self._previousWindow()
        endif

        call self._checkToCloseTree(0)
    endif
endfunction

"FUNCTION: Opener.New(path, opts) {{{1
"Args:
"
"a:path: The path object that is to be opened.
"
"a:opts:
"
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' or 'h' or 't' (for open in
"           new tab)
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
function! s:Opener.New(path, opts)
    let newObj = copy(self)

    let newObj._path = a:path
    let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
    let newObj._reuse = nerdtree#has_opt(a:opts, 'reuse')
    let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    let newObj._treetype = b:NERDTreeType
    call newObj._saveCursorPos()

    return newObj
endfunction

"FUNCTION: Opener._newSplit() {{{1
function! s:Opener._newSplit()
    " Save the user's settings for splitbelow and splitright
    let savesplitbelow=&splitbelow
    let savesplitright=&splitright

    " 'there' will be set to a command to move from the split window
    " back to the explorer window
    "
    " 'back' will be set to a command to move from the explorer window
    " back to the newly split window
    "
    " 'right' and 'below' will be set to the settings needed for
    " splitbelow and splitright IF the explorer is the only window.
    "
    let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
    let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
    let right= g:NERDTreeWinPos ==# "left"
    let below=0

    " Attempt to go to adjacent window
    call nerdtree#exec(back)

    let onlyOneWin = (winnr("$") ==# 1)

    " If no adjacent window, set splitright and splitbelow appropriately
    if onlyOneWin
        let &splitright=right
        let &splitbelow=below
    else
        " found adjacent window - invert split direction
        let &splitright=!right
        let &splitbelow=!below
    endif

    let splitMode = onlyOneWin ? "vertical" : ""

    " Open the new window
    try
        exec(splitMode." sp ")
    catch /^Vim\%((\a\+)\)\=:E37/
        call nerdtree#putCursorInTreeWin()
        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
    catch /^Vim\%((\a\+)\)\=:/
        "do nothing
    endtry

    "resize the tree window if no other window was open before
    if onlyOneWin
        let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
        call nerdtree#exec(there)
        exec("silent ". splitMode ." resize ". size)
        call nerdtree#exec('wincmd p')
    endif

    " Restore splitmode settings
    let &splitbelow=savesplitbelow
    let &splitright=savesplitright
endfunction

"FUNCTION: Opener._newVSplit() {{{1
function! s:Opener._newVSplit()
    let winwidth = winwidth(".")
    if winnr("$")==#1
        let winwidth = g:NERDTreeWinSize
    endif

    call nerdtree#exec("wincmd p")
    vnew

    "resize the nerd tree back to the original size
    call nerdtree#putCursorInTreeWin()
    exec("silent vertical resize ". winwidth)
    call nerdtree#exec('wincmd p')
endfunction

"FUNCTION: Opener.open(target) {{{1
function! s:Opener.open(target)
    if self._path.isDirectory
        call self._openDirectory(a:target)
    else
        call self._openFile()
    endif
endfunction

"FUNCTION: Opener._openFile() {{{1
function! s:Opener._openFile()
    if self._reuse && self._reuseWindow()
        return
    endif

    call self._gotoTargetWin()

    if self._treetype ==# "secondary"
        call self._path.edit()
    else
        call self._path.edit()


        if self._stay
            call self._restoreCursorPos()
        endif
    endif
endfunction

"FUNCTION: Opener._openDirectory(node) {{{1
function! s:Opener._openDirectory(node)
    if self._treetype ==# "secondary"
        call self._gotoTargetWin()
        call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
    else
        call self._gotoTargetWin()
        if empty(self._where)
            call a:node.makeRoot()
            call nerdtree#renderView()
            call a:node.putCursorHere(0, 0)
        elseif self._where == 't'
            call g:NERDTreeCreator.CreatePrimary(a:node.path.str())
        else
            call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
        endif
    endif

    if self._stay
        call self._restoreCursorPos()
    endif
endfunction

"FUNCTION: Opener._previousWindow() {{{1
function! s:Opener._previousWindow()
    if !nerdtree#isWindowUsable(winnr("#")) && nerdtree#firstUsableWindow() ==# -1
        call self._newSplit()
    else
        try
            if !nerdtree#isWindowUsable(winnr("#"))
                call nerdtree#exec(nerdtree#firstUsableWindow() . "wincmd w")
            else
                call nerdtree#exec('wincmd p')
            endif
        catch /^Vim\%((\a\+)\)\=:E37/
            call nerdtree#putCursorInTreeWin()
            throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
        catch /^Vim\%((\a\+)\)\=:/
            echo v:exception
        endtry
    endif
endfunction

"FUNCTION: Opener._restoreCursorPos(){{{1
function! s:Opener._restoreCursorPos()
    call nerdtree#exec('normal ' . self._tabnr . 'gt')
    call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w')
endfunction

"FUNCTION: Opener._reuseWindow(){{{1
"put the cursor in the first window we find for this file
"
"return 1 if we were successful
function! s:Opener._reuseWindow()
    "check the current tab for the window
    let winnr = bufwinnr('^' . self._path.str() . '$')
    if winnr != -1
        call nerdtree#exec(winnr . "wincmd w")
        call self._checkToCloseTree(0)
        return 1
    else
        "check other tabs
        let tabnr = self._path.tabnr()
        if tabnr
            call self._checkToCloseTree(1)
            call nerdtree#exec('normal! ' . tabnr . 'gt')
            let winnr = bufwinnr('^' . self._path.str() . '$')
            call nerdtree#exec(winnr . "wincmd w")
            return 1
        endif
    endif
    return 0
endfunction

"FUNCTION: Opener._saveCursorPos(){{{1
function! s:Opener._saveCursorPos()
    let self._bufnr = bufnr("")
    let self._tabnr = tabpagenr()
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/opener.vim
"CLASS: MenuItem
"============================================================
let s:MenuItem = {}
let g:NERDTreeMenuItem = s:MenuItem

"FUNCTION: MenuItem.All() {{{1
"get all top level menu items
function! s:MenuItem.All()
    if !exists("s:menuItems")
        let s:menuItems = []
    endif
    return s:menuItems
endfunction

"FUNCTION: MenuItem.AllEnabled() {{{1
"get all top level menu items that are currently enabled
function! s:MenuItem.AllEnabled()
    let toReturn = []
    for i in s:MenuItem.All()
        if i.enabled()
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: MenuItem.Create(options) {{{1
"make a new menu item and add it to the global list
function! s:MenuItem.Create(options)
    let newMenuItem = copy(self)

    let newMenuItem.text = a:options['text']
    let newMenuItem.shortcut = a:options['shortcut']
    let newMenuItem.children = []

    let newMenuItem.isActiveCallback = -1
    if has_key(a:options, 'isActiveCallback')
        let newMenuItem.isActiveCallback = a:options['isActiveCallback']
    endif

    let newMenuItem.callback = -1
    if has_key(a:options, 'callback')
        let newMenuItem.callback = a:options['callback']
    endif

    if has_key(a:options, 'parent')
        call add(a:options['parent'].children, newMenuItem)
    else
        call add(s:MenuItem.All(), newMenuItem)
    endif

    return newMenuItem
endfunction

"FUNCTION: MenuItem.CreateSeparator(options) {{{1
"make a new separator menu item and add it to the global list
function! s:MenuItem.CreateSeparator(options)
    let standard_options = { 'text': '--------------------',
                \ 'shortcut': -1,
                \ 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.CreateSubmenu(options) {{{1
"make a new submenu and add it to global list
function! s:MenuItem.CreateSubmenu(options)
    let standard_options = { 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.enabled() {{{1
"return 1 if this menu item should be displayed
"
"delegates off to the isActiveCallback, and defaults to 1 if no callback was
"specified
function! s:MenuItem.enabled()
    if self.isActiveCallback != -1
        return {self.isActiveCallback}()
    endif
    return 1
endfunction

"FUNCTION: MenuItem.execute() {{{1
"perform the action behind this menu item, if this menuitem has children then
"display a new menu for them, otherwise deletegate off to the menuitem's
"callback
function! s:MenuItem.execute()
    if len(self.children)
        let mc = s:MenuController.New(self.children)
        call mc.showMenu()
    else
        if self.callback != -1
            call {self.callback}()
        endif
    endif
endfunction

"FUNCTION: MenuItem.isSeparator() {{{1
"return 1 if this menuitem is a separator
function! s:MenuItem.isSeparator()
    return self.callback == -1 && self.children == []
endfunction

"FUNCTION: MenuItem.isSubmenu() {{{1
"return 1 if this menuitem is a submenu
function! s:MenuItem.isSubmenu()
    return self.callback == -1 && !empty(self.children)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/lib/nerdtree/menu_item.vim
" ============================================================================
" File:        fs_menu.vim
" Description: plugin for the NERD Tree that provides a file system menu
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 17 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_fs_menu")
    finish
endif
let g:loaded_nerdtree_fs_menu = 1

"Automatically delete the buffer after deleting or renaming a file
if !exists("g:NERDTreeAutoDeleteBuffer")
    let g:NERDTreeAutoDeleteBuffer = 0
endif

call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})

if has("gui_mac") || has("gui_macvim") 
    call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
    call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
endif

if g:NERDTreePath.CopyingSupported()
    call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
endif

"FUNCTION: s:echo(msg){{{1
function! s:echo(msg)
    redraw
    echomsg "NERDTree: " . a:msg
endfunction

"FUNCTION: s:echoWarning(msg){{{1
function! s:echoWarning(msg)
    echohl warningmsg
    call s:echo(a:msg)
    echohl normal
endfunction

"FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is deleted
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToDelBuffer(bufnum, msg)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that all windows which display the just deleted filename
        " now display an empty buffer (so a layout is preserved).
        " Is not it better to close single tabs with this file only ?
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':enew! ' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction

"FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is replaced with a new one
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToRenameBuffer(bufnum, msg, newFileName)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that a new buffer is loaded
        exec "badd " . a:newFileName
        " 2. ensure that all windows which display the just deleted filename
        " display a buffer for a new filename. 
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':e! " . a:newFileName . "' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction
"FUNCTION: NERDTreeAddNode(){{{1
function! NERDTreeAddNode()
    let curDirNode = g:NERDTreeDirNode.GetSelected()

    let newNodeName = input("Add a childnode\n".
                          \ "==========================================================\n".
                          \ "Enter the dir/file name to be created. Dirs end with a '/'\n" .
                          \ "", curDirNode.path.str() . g:NERDTreePath.Slash(), "file")

    if newNodeName ==# ''
        call s:echo("Node Creation Aborted.")
        return
    endif

    try
        let newPath = g:NERDTreePath.Create(newNodeName)
        let parentNode = b:NERDTreeRoot.findNode(newPath.getParent())

        let newTreeNode = g:NERDTreeFileNode.New(newPath)
        if parentNode.isOpen || !empty(parentNode.children)
            call parentNode.addChild(newTreeNode, 1)
            call NERDTreeRender()
            call newTreeNode.putCursorHere(1, 0)
        endif
    catch /^NERDTree/
        call s:echoWarning("Node Not Created.")
    endtry
endfunction

"FUNCTION: NERDTreeMoveNode(){{{1
function! NERDTreeMoveNode()
    let curNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Rename the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path for the node:                          \n" .
                          \ "", curNode.path.str(), "file")

    if newNodePath ==# ''
        call s:echo("Node Renaming Aborted.")
        return
    endif

    try
        let bufnum = bufnr(curNode.path.str())

        call curNode.rename(newNodePath)
        call NERDTreeRender()

        "if the node is open in a buffer, ask the user if they want to
        "close that buffer
        if bufnum != -1
            let prompt = "\nNode renamed.\n\nThe old file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Replace this buffer with a new file? (yN)"
            call s:promptToRenameBuffer(bufnum,  prompt, newNodePath)
        endif

        call curNode.putCursorHere(1, 0)

        redraw
    catch /^NERDTree/
        call s:echoWarning("Node Not Renamed.")
    endtry
endfunction

" FUNCTION: NERDTreeDeleteNode() {{{1
function! NERDTreeDeleteNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let confirmed = 0

    if currentNode.path.isDirectory
        let choice =input("Delete the current node\n" .
                         \ "==========================================================\n" .
                         \ "STOP! To delete this entire directory, type 'yes'\n" .
                         \ "" . currentNode.path.str() . ": ")
        let confirmed = choice ==# 'yes'
    else
        echo "Delete the current node\n" .
           \ "==========================================================\n".
           \ "Are you sure you wish to delete the node:\n" .
           \ "" . currentNode.path.str() . " (yN):"
        let choice = nr2char(getchar())
        let confirmed = choice ==# 'y'
    endif


    if confirmed
        try
            call currentNode.delete()
            call NERDTreeRender()

            "if the node is open in a buffer, ask the user if they want to
            "close that buffer
            let bufnum = bufnr(currentNode.path.str())
            if buflisted(bufnum)
                let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Delete this buffer? (yN)"
                call s:promptToDelBuffer(bufnum, prompt)
            endif

            redraw
        catch /^NERDTree/
            call s:echoWarning("Could not remove node")
        endtry
    else
        call s:echo("delete aborted")
    endif

endfunction

" FUNCTION: NERDTreeCopyNode() {{{1
function! NERDTreeCopyNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Copy the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path to copy the node to:                   \n" .
                          \ "", currentNode.path.str(), "file")

    if newNodePath != ""
        "strip trailing slash
        let newNodePath = substitute(newNodePath, '\/$', '', '')

        let confirmed = 1
        if currentNode.path.copyingWillOverwrite(newNodePath)
            call s:echo("Warning: copying may overwrite files! Continue? (yN)")
            let choice = nr2char(getchar())
            let confirmed = choice ==# 'y'
        endif

        if confirmed
            try
                let newNode = currentNode.copy(newNodePath)
                if !empty(newNode)
                    call NERDTreeRender()
                    call newNode.putCursorHere(0, 0)
                endif
            catch /^NERDTree/
                call s:echoWarning("Could not copy node")
            endtry
        endif
    else
        call s:echo("Copy aborted.")
    endif
    redraw
endfunction

function! NERDTreeQuickLook()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        call system("qlmanage -p 2>/dev/null '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeRevealInFinder()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open -R '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeExecuteFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open '" . treenode.path.str() . "'")
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/nerdtree_plugin/fs_menu.vim
" ============================================================================
" File:        exec_menuitem.vim
" Description: plugin for NERD Tree that provides an execute file menu item
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 22 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_exec_menuitem")
    finish
endif
let g:loaded_nerdtree_exec_menuitem = 1

call NERDTreeAddMenuItem({
            \ 'text': '(!)Execute file',
            \ 'shortcut': '!',
            \ 'callback': 'NERDTreeExecFile',
            \ 'isActiveCallback': 'NERDTreeExecFileActive' })

function! NERDTreeExecFileActive()
    let node = g:NERDTreeFileNode.GetSelected()
    return !node.path.isDirectory && node.path.isExecutable
endfunction

function! NERDTreeExecFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    echo "==========================================================\n"
    echo "Complete the command to execute (add arguments etc):\n"
    let cmd = treenode.path.str({'escape': 1})
    let cmd = input(':!', cmd . ' ')

    if cmd != ''
        exec ':!' . cmd
    else
        echo "Aborted"
    endif
endfunction
zhimakaimen:/nerdtree_plugin/exec_menuitem.vim
Copyright (C) 2010 http://github.com/gmarik

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
zhimakaimen:/bundle/vundle/LICENSE-MIT.txt
doc/tags
.netrwhist
zhimakaimen:/bundle/vundle/.gitignore
*vundle.txt* Vundle the plug-in manager for Vim.     *vundle*

CONTENTS ~
                                                   *vundle-contents*
===========================================================================

1. About                                           |vundle-about|
2. Why Vundle                                      |vundle-why-vundle|
3. Quick start                                     |vundle-quickstart|
4. Scripts                                         |vundle-scripts|
   4.1. Configure scripts                          |vundle-scripts-configure|
   4.2. Installing scripts                         |vundle-scripts-install|
   4.3. Updating scripts                           |vundle-scripts-update|
   4.4. Searching scripts                          |vundle-scripts-search|
   4.5. Listing scripts                            |vundle-scripts-list|
   4.6. Cleanup                                    |vundle-scripts-cleanup|
5. Interactive mode                                |vundle-interactive|
6. Key mappings                                    |vundle-keymappings|
7. Options                                         |vundle-options|

===========================================================================

ABOUT                                              *vundle-about*

Vundle is a short cut for Vim bundle and is the Vim plug-in manager.

2. WHY VUNDLE ~
                                                   *vundle-why-vundle*
Vundle allows to:

- keep track and configure your scripts right in `.vimrc`
- install configured scripts (aka bundle) 
- update configured scripts
- search [all available vim scripts] by name
- clean up from unused scripts

Also *Vundle* :

- manages runtime path of your installed scripts
- regenerates helptags automatically

Vundle takes advantage of [vim-scripts.org](http://vim-scripts.org) 
in order to install/search [all available vim scripts]

3. QUICK START ~
                                                    *vundle-quickstart*
1) Setup Vundle: >

    git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle

2) Configure bundles:

   Sample `.vimrc`: >

     set nocompatible               " be iMproved
     filetype off                   " required!

     set rtp+=~/.vim/vundle.git/ 
     call vundle#rc()

     " let Vundle manage Vundle
     Bundle 'gmarik/vundle'

     " My Bundles here:
     "
     " original repos on github
     Bundle 'tpope/vim-fugitive'
     Bundle 'Lokaltog/vim-easymotion'
     Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}
     " vim-scripts repos
     Bundle 'L9'
     Bundle 'FuzzyFinder'
     Bundle 'rails.vim'
     " non github repos
     Bundle 'git://git.wincent.com/command-t.git'
     " git repos on your local machine (ie. when working on your own plugin)
     Bundle 'file:///Users/gmarik/path/to/plugin'
     " ...

     filetype plugin indent on     " required!
     " or 
     " filetype plugin on          " to not use the indentation settings set by plugins

3) Install configured bundles:

   Launch `vim`, run >

    :BundleInstall

Installing requires [Git] and triggers [Git clone](http://gitref.org/creating/#clone) for 
each configured repo to `~/.vim/bundle/`.

4. SCRIPTS ~
                                                    *vundle-scripts*
4.1 CONFIGURE SCRIPTS ~
                                      *vundle-scripts-configure* *Bundle*
Before installing scripts they need to be configured. It's done using `Bundle`
command in `.vimrc`: >

    Bundle 'git_repo_uri'       " 'git_repo_uri' should be a valid uri to git repository 
or >
    Bundle 'script_name'        " 'script-name' should be an official script name (see |vundle-scripts-search| )

Vundle loves Github, that's why short uris can be used with commands: >

    Bundle 'tpope/vim-fugitive'

equals full uri >

    Bundle 'http://github.com/tpope/vim-fugitive.git'

NOTE: Vundle defaults to http:// protocol for the short URIs


4.2 INSTALL SCRIPTS ~
                                      *vundle-scripts-install* *BundleInstall*
run >
    :BundleInstall

installs configured scripts. Newly installed scripts will be automatically
enabled. Except special cases requiring compilation or pre-configuration.

BundleInstall allows to install scripts by name:>

    :BundleInstall unite.vim

installs and activates unite.vim. You can use Tab to auto-complete known script names.
NOTE: installation, as just described, doesn't automatically configure scripts; 
you have to configure them manually.

4.3 UPDATE SCRIPTS ~
                                      *vundle-scripts-update* *BundleInstall!*
run >
    :BundleInstall!             " NOTE: bang(!)

installs or updates configured scripts.
press u after updates complete to see the changelog of all updated bundles.

4.4 SEARCHING ~
                                       *vundle-scripts-search* *BundleSearch*
run >
    :BundleSearch foo

lists bundles matching 'foo' in new a new split window, ie:
>
    Bundle "VimFootnotes"
    Bundle "foo.vim"
>
and >

    :BundleSearch! foo

refreshes script list before performing actual search.

If command is run without argument: >

    :BundleSearch!

it will display all known scripts

Searching requires [`curl`](http://curl.haxx.se/)

4.5 LISTING BUNDLES ~
                                     *vundle-scripts-list* *BundleList*

To quickly pull list of installed bundles use >

    :BundleList


4.6 CLEANING UP ~
                                     *vundle-scripts-cleanup* *BundleClean*
run >

    :BundleClean

confirms removal of unused script-dirs from `.vim/bundle/`.

                                                            *BundleClean!*
>
    :BundleClean!

removes unused dirs with no questions.


                                     *vundle-interactive*
5. INTERACTIVE MODE ~

Vundle provides simple interactive mode to help you explore new scripts easily.
Interactive mode is available as result of any commands that display list of
bundles. For instance, running: >

    :BundleSearch! unite

triggers search for scripts matching 'unite' and yields a split window with
content: >

    "Keymap: i - Install bundle; c - Cleanup; r - Refine list; R - Reload list
    "Search results for: unite
    Bundle 'unite.vim'
    Bundle 'unite-yarm'
    Bundle 'unite-gem'
    Bundle 'unite-locate'
    Bundle 'unite-font'
    Bundle 'unite-colorscheme'

As the first line(starting with `"Keymap:`) shows, certain actions may be applied
to selected bundles .  Move cursor over line `Bundle 'unite.vim'` and press i 
key(install, see |vundle-keymappings| for more details). 
After unite.vim is installed - `:Unite file` command should be
available to prove 'unite.vim' availability.

NOTE: Interactive installation doesn't update your .vimrc configuration.

                                     *vundle-keymappings*
6. KEY MAPPINGS ~

KEY | DESCRIPTION
----|-------------------------- >
 i  |  run :BundleInstall with name taken from line cursor is positioned on
 I  |  same as i, but runs :BundleInstall! to update bundle
 D  |  delete selected bundle( be careful not to remove local modifications)
 c  |  run :BundleClean
 s  |  run :BundleSearch
 R  |  fetch fresh script list from server
.

                                     *vundle-options*
7. OPTIONS ~

>
  let g:vundle_default_git_proto = 'git'

makes Vundle use `git` instead default `https` when building absolute repo URIs


vim:tw=78:ts=8:ft=help:norl:
zhimakaimen:/bundle/vundle/doc/vundle.txt
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=GBK">
<title>E:\Program Files\Vim\vimfiles\bundle\vundle\doc\vundle.txt.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v6">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,number_lines">
<style type="text/css">
<!--
pre { font-family: monospace; color: #dcdccc; background-color: #3f3f3f; }
body { font-family: monospace; color: #dcdccc; background-color: #3f3f3f; }
.lnr { color: #9fafaf; background-color: #262626; }
.Comment { color: #7f9f7f; font-style: italic; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr">49 </span><span class="Comment">    git clone <a href="http://github.com/gmarik/vundle.git">http://github.com/gmarik/vundle.git</a> ~/.vim/vundle.git</span>
</pre>
</body>
</html>
zhimakaimen:/bundle/vundle/doc/vundle.txt.html
" vim -u test/vimrc
set nocompatible

set nowrap

let root = '/tmp/!vundle-test/bundles/'
let src = 'http://github.com/gmarik/vundle.git' 

" let src = '~/.vim/bundle/vundle/.git' 

" Vundle Options
" let g:vundle_default_git_proto = 'git'

if !isdirectory(expand(root, 1).'/vundle')
  exec '!git clone '.src.' '.shellescape(root, 1).'/vundle'
endif

filetype off
syntax on

runtime macros/matchit.vim

exec 'set rtp+='.root.'/vundle'

call vundle#rc(root)

Bundle "gmarik/vundle"

" vim-scripts name
Bundle 'molokai'

" github username with dashes
Bundle 'vim-scripts/ragtag.vim'

" original repo
Bundle 'altercation/vim-colors-solarized'
" with extension
Bundle 'nelstrom/vim-mac-classic-theme.git'
"
"  invalid uri
Bundle 'nonexistinguser/yupppierepo.git'

" full uri
Bundle 'https://github.com/vim-scripts/vim-game-of-life'
" full uri
Bundle 'git@github.com:gmarik/ingretu.git'
" short uri
Bundle 'gh:gmarik/snipmate.vim.git'
Bundle 'github:mattn/gist-vim.git'

" local uri stuff
Bundle '~/Dropbox/.gitrepos/utilz.vim.git'
" Bundle 'file://Dropbox/.gitrepos/utilz.vim.git'

" with options
Bundle 'rstacruz/sparkup.git', {'rtp': 'vim/'}

" Camel case
Bundle 'vim-scripts/RubySinatra'

" syntax issue #203
Bundle 'jimenezrick/vimerl'

filetype plugin indent on      " Automatically detect file types.

set wildignore+=doc              " should not break helptags
set wildignore+=.git             " should not break clone
set wildignore+=.git/*             " should not break clone
set wildignore+=*/.git/*
" TODO: helptags fails with this
" set wildignore+=doc/*             " should not break clone
" set wildignore+=*/doc/*

au VimEnter * BundleInstall

" e test/files/erlang.erl
zhimakaimen:/bundle/vundle/test/vimrc
set nocompatible
syntax on
filetype off
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()
Bundle 'gmarik/vundle'
filetype plugin indent on

zhimakaimen:/bundle/vundle/test/minirc.vim
-module(mmc_logmon_sup).
-behaviour(supervisor).
-export([init/1]).

init(_) ->
    {ok, {
        {one_for_one, 5, 1},
        [
            {listener,
                {aaa, start_link, []},
                permanent, 100, worker,
                [aaa]
            },
            {server,
                {bbb, start_link, []},
                permanent, 100, worker,
                [bbb]
            }
        ]
    }}.
zhimakaimen:/bundle/vundle/test/files/test.erl
" Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim
" Author:       gmarik
" HomePage:     http://github.com/gmarik/vundle
" Readme:       http://github.com/gmarik/vundle/blob/master/README.md
" Version:      0.9

com! -nargs=+         Bundle
\ call vundle#config#bundle(<args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall
\ call vundle#installer#new('!' == '<bang>', <q-args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch
\ call vundle#scripts#all('!'=='<bang>', <q-args>)

com! -nargs=? -bang -complete=custom,vundle#scripts#complete Bundles
\ call vundle#scripts#all('!'=='<bang>', <q-args>)

com! -nargs=0 -bang BundleList
\ call vundle#installer#list('!'=='<bang>')

com! -nargs=? -bang   BundleClean
\ call vundle#installer#clean('!' == '<bang>')

com! -nargs=0         BundleDocs 
\ call vundle#installer#helptags(g:bundles)

" Aliases
com! BundleUpdate BundleInstall!

if (has('signs'))
sign define Vu_error    text=!  texthl=Error
sign define Vu_active   text=>  texthl=Comment
sign define Vu_todate   text=.  texthl=Comment
sign define Vu_new      text=+  texthl=Comment
sign define Vu_updated  text=*  texthl=Comment
sign define Vu_deleted  text=-  texthl=Comment
sign define Vu_helptags text=*  texthl=Comment
endif


func! vundle#rc(...) abort
  let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)
  let g:updated_bundles = []
  let g:vundle_log = []
  let g:vundle_changelog = ['Updated Bundles:']
  call vundle#config#init()
endf
zhimakaimen:/bundle/vundle/autoload/vundle.vim
func! vundle#scripts#all(bang, ...)
  let b:match = ''
  let info = ['"Keymap: i - Install bundle; c - Cleanup; s - Search; R - Reload list']
  let matches = s:load_scripts(a:bang)
  if !empty(a:1)
    let matches = filter(matches, 'v:val =~? "'.escape(a:1,'"').'"')
    let info += ['"Search results for: '.a:1]
    " TODO: highlight matches
    let b:match = a:1
  endif
  call vundle#scripts#view('search',info, vundle#scripts#bundle_names(reverse(matches)))
  redraw
  echo len(matches).' bundles found'
endf

func! vundle#scripts#reload() abort
  silent exec ':BundleSearch! '.(exists('b:match') ? b:match : '')
  redraw
endf

func! vundle#scripts#complete(a,c,d)
  return join(s:load_scripts(0),"\n")
endf

func! s:view_log()
  if !exists('g:vundle_log_file')
    let g:vundle_log_file = tempname()
  endif

  call writefile(g:vundle_log, g:vundle_log_file)
  execute 'silent pedit ' . g:vundle_log_file

  wincmd P | wincmd H
endf

func! s:create_changelog() abort
  for bundle_data in g:updated_bundles
    let initial_sha = bundle_data[0]
    let updated_sha = bundle_data[1]
    let bundle      = bundle_data[2]

    let cmd = 'cd '.shellescape(bundle.path()).
          \              ' && git log --pretty=format:"%s   %an, %ar" --graph '.
          \               initial_sha.'..'.updated_sha

    let cmd = g:shellesc_cd(cmd)

    let updates = system(cmd)

    call add(g:vundle_changelog, '')
    call add(g:vundle_changelog, 'Updated Bundle: '.bundle.name)

    if bundle.uri =~ "https://github.com"
      call add(g:vundle_changelog, 'Compare at: '.bundle.uri[0:-5].'/compare/'.initial_sha.'...'.updated_sha)
    endif

    for update in split(updates, '\n')
      let update = substitute(update, '\s\+$', '', '')
      call add(g:vundle_changelog, '  '.update)
    endfor
  endfor
endf

func! s:view_changelog()
  call s:create_changelog()

  if !exists('g:vundle_changelog_file')
    let g:vundle_changelog_file = tempname()
  endif

  call writefile(g:vundle_changelog, g:vundle_changelog_file)
  execute 'silent pedit ' . g:vundle_changelog_file

  wincmd P | wincmd H
endf

func! vundle#scripts#bundle_names(names)
  return map(copy(a:names), ' printf("Bundle ' ."'%s'".'", v:val) ')
endf

func! vundle#scripts#view(title, headers, results)
  if exists('g:vundle_view') && bufloaded(g:vundle_view)
    exec g:vundle_view.'bd!'
  endif

  exec 'silent pedit [Vundle] '.a:title

  wincmd P | wincmd H

  let g:vundle_view = bufnr('%')
  "
  " make buffer modifiable 
  " to append without errors
  set modifiable

  call append(0, a:headers + a:results)

  setl buftype=nofile
  setl noswapfile

  setl cursorline
  setl nonu ro noma ignorecase 
  if (exists('&relativenumber')) | setl norelativenumber | endif

  setl ft=vundle
  setl syntax=vim
  syn keyword vimCommand Bundle
  syn keyword vimCommand Helptags

  com! -buffer -bang -nargs=1 DeleteBundle
    \ call vundle#installer#run('vundle#installer#delete', split(<q-args>,',')[0], ['!' == '<bang>', <args>])

  com! -buffer -bang -nargs=? InstallAndRequireBundle   
    \ call vundle#installer#run('vundle#installer#install_and_require', split(<q-args>,',')[0], ['!' == '<bang>', <q-args>])

  com! -buffer -bang -nargs=? InstallBundle
    \ call vundle#installer#run('vundle#installer#install', split(<q-args>,',')[0], ['!' == '<bang>', <q-args>])

  com! -buffer -bang -nargs=0 InstallHelptags 
    \ call vundle#installer#run('vundle#installer#docs', 'helptags', [])

  com! -buffer -nargs=0 VundleLog call s:view_log()

  com! -buffer -nargs=0 VundleChangelog call s:view_changelog()

  nnoremap <buffer> q :silent bd!<CR>
  nnoremap <buffer> D :exec 'Delete'.getline('.')<CR>

  nnoremap <buffer> add  :exec 'Install'.getline('.')<CR>
  nnoremap <buffer> add! :exec 'Install'.substitute(getline('.'), '^Bundle ', 'Bundle! ', '')<CR>

  nnoremap <buffer> i :exec 'InstallAndRequire'.getline('.')<CR>
  nnoremap <buffer> I :exec 'InstallAndRequire'.substitute(getline('.'), '^Bundle ', 'Bundle! ', '')<CR>

  nnoremap <buffer> l :VundleLog<CR>
  nnoremap <buffer> u :VundleChangelog<CR>
  nnoremap <buffer> h :h vundle<CR>
  nnoremap <buffer> ? :norm h<CR>

  nnoremap <buffer> c :BundleClean<CR>
  nnoremap <buffer> C :BundleClean!<CR>

  nnoremap <buffer> s :BundleSearch 
  nnoremap <buffer> R :call vundle#scripts#reload()<CR>

  " goto first line after headers
  exec ':'.(len(a:headers) + 1)
endf

func! s:fetch_scripts(to)
  let scripts_dir = fnamemodify(expand(a:to, 1), ":h")
  if !isdirectory(scripts_dir)
    call mkdir(scripts_dir, "p")
  endif

  let l:vim_scripts_json = 'http://vim-scripts.org/api/scripts.json'
  if executable("curl")
    let cmd = 'curl --fail -s -o '.shellescape(a:to).' '.l:vim_scripts_json
  elseif executable("wget")
    let temp = shellescape(tempname())
    let cmd = 'wget -q -O '.temp.' '.l:vim_scripts_json. ' && mv -f '.temp.' '.shellescape(a:to)
    if (has('win32') || has('win64')) 
      let cmd = substitute(cmd, 'mv -f ', 'move /Y ', '') " change force flag
      let cmd = g:shellesc(cmd)
    end
  else
    echoerr 'Error curl or wget is not available!'
    return 1
  endif

  call system(cmd)

  if (0 != v:shell_error)
    echoerr 'Error fetching scripts!'
    return v:shell_error
  endif
  return 0
endf

func! s:load_scripts(bang)
  let f = expand(g:bundle_dir.'/.vundle/script-names.vim-scripts.org.json', 1)
  if a:bang || !filereadable(f)
    if 0 != s:fetch_scripts(f)
      return []
    end
  endif
  return eval(readfile(f, 'b')[0])
endf
zhimakaimen:/bundle/vundle/autoload/vundle/scripts.vim
func! vundle#installer#new(bang, ...) abort
  let bundles = (a:1 == '') ?
        \ g:bundles :
        \ map(copy(a:000), 'vundle#config#bundle(v:val, {})')

  let names = vundle#scripts#bundle_names(map(copy(bundles), 'v:val.name_spec'))
  call vundle#scripts#view('Installer',['" Installing bundles to '.expand(g:bundle_dir, 1)], names +  ['Helptags'])

  call s:process(a:bang, (a:bang ? 'add!' : 'add'))

  call vundle#config#require(bundles)
endf


func! s:process(bang, cmd)
  let msg = ''

  redraw
  sleep 1m

  let lines = (getline('.','$')[0:-2])

  for line in lines
    redraw

    exec ':norm '.a:cmd

    if 'error' == g:vundle_last_status
      let msg = 'With errors; press l to view log'
    endif

    if 'updated' == g:vundle_last_status && empty(msg)
      let msg = 'Bundles updated; press u to view changelog'
    endif

    " goto next one
    exec ':+1'

    setl nomodified
  endfor

  redraw
  echo 'Done! '.msg
endf

func! vundle#installer#run(func_name, name, ...) abort
  let n = a:name

  echo 'Processing '.n
  call s:sign('active')

  sleep 1m

  let status = call(a:func_name, a:1)

  call s:sign(status)

  redraw

  if 'new' == status
    echo n.' installed'
  elseif 'updated' == status
    echo n.' updated'
  elseif 'todate' == status
    echo n.' already installed'
  elseif 'deleted' == status
    echo n.' deleted'
  elseif 'helptags' == status
    echo n.' regenerated'
  elseif 'error' == status
    echohl Error
    echo 'Error processing '.n
    echohl None
    sleep 1
  else
    throw 'whoops, unknown status:'.status
  endif

  let g:vundle_last_status = status

  return status
endf

func! s:sign(status) 
  if (!has('signs'))
    return
  endif

  exe ":sign place ".line('.')." line=".line('.')." name=Vu_". a:status ." buffer=" . bufnr("%")
endf

func! vundle#installer#install_and_require(bang, name) abort
  let result = vundle#installer#install(a:bang, a:name)
  let b = vundle#config#bundle(a:name, {})
  call vundle#installer#helptags([b])
  call vundle#config#require([b])
  return result
endf

func! vundle#installer#install(bang, name) abort
  if !isdirectory(g:bundle_dir) | call mkdir(g:bundle_dir, 'p') | endif

  let b = vundle#config#init_bundle(a:name, {})

  return s:sync(a:bang, b)
endf

func! vundle#installer#docs() abort
  let error_count = vundle#installer#helptags(g:bundles)
  if error_count > 0
      return 'error'
  endif
  return 'helptags'
endf

func! vundle#installer#helptags(bundles) abort
  let bundle_dirs = map(copy(a:bundles),'v:val.rtpath')
  let help_dirs = filter(bundle_dirs, 's:has_doc(v:val)')

  call s:log('')
  call s:log('Helptags:')

  let statuses = map(copy(help_dirs), 's:helptags(v:val)')
  let errors = filter(statuses, 'v:val == 0')

  call s:log('Helptags: '.len(help_dirs).' bundles processed')

  return len(errors)
endf

func! vundle#installer#list(bang) abort
  let bundles = vundle#scripts#bundle_names(map(copy(g:bundles), 'v:val.name_spec'))
  call vundle#scripts#view('list', ['" My Bundles'], bundles)
  redraw
  echo len(g:bundles).' bundles configured'
endf


func! vundle#installer#clean(bang) abort
  let bundle_dirs = map(copy(g:bundles), 'v:val.path()') 
  let all_dirs = (v:version > 702 || (v:version == 702 && has("patch51")))
  \   ? split(globpath(g:bundle_dir, '*', 1), "\n")
  \   : split(globpath(g:bundle_dir, '*'), "\n")
  let x_dirs = filter(all_dirs, '0 > index(bundle_dirs, v:val)')

  if empty(x_dirs)
    let headers = ['" All clean!']
    let names = []
  else
    let headers = ['" Removing bundles:']
    let names = vundle#scripts#bundle_names(map(copy(x_dirs), 'fnamemodify(v:val, ":t")'))
  end

  call vundle#scripts#view('clean', headers, names)
  redraw

  if (a:bang || empty(names))
    call s:process(a:bang, 'D')
  else
    call inputsave()
    let response = input('Continue? [Y/n]: ')
    call inputrestore()
    if (response =~? 'y' || response == '')
      call s:process(a:bang, 'D')
    endif
  endif
endf


func! vundle#installer#delete(bang, dir_name) abort

  let cmd = (has('win32') || has('win64')) ?
  \           'rmdir /S /Q' :
  \           'rm -rf'

  let bundle = vundle#config#init_bundle(a:dir_name, {})
  let cmd .= ' '.shellescape(bundle.path())

  let out = s:system(cmd)

  call s:log('')
  call s:log('Bundle '.a:dir_name)
  call s:log('$ '.cmd)
  call s:log('> '.out)

  if 0 != v:shell_error
    return 'error'
  else
    return 'deleted'
  endif
endf

func! s:has_doc(rtp) abort
  return isdirectory(a:rtp.'/doc')
  \   && (!filereadable(a:rtp.'/doc/tags') || filewritable(a:rtp.'/doc/tags'))
  \   && (v:version > 702 || (v:version == 702 && has("patch51")))
  \     ? !(empty(glob(a:rtp.'/doc/*.txt', 1)) && empty(glob(a:rtp.'/doc/*.??x', 1)))
  \     : !(empty(glob(a:rtp.'/doc/*.txt')) && empty(glob(a:rtp.'/doc/*.??x')))
endf

func! s:helptags(rtp) abort
  let doc_path = a:rtp.'/doc/'
  call s:log(':helptags '.doc_path)
  try
    execute 'helptags ' . doc_path
  catch
    call s:log("> Error running :helptags ".doc_path)
    return 0
  endtry
  return 1
endf

func! s:sync(bang, bundle) abort
  let git_dir = expand(a:bundle.path().'/.git/', 1)
  if isdirectory(git_dir) || filereadable(expand(a:bundle.path().'/.git', 1))
    if !(a:bang) | return 'todate' | endif
    let cmd = 'cd '.shellescape(a:bundle.path()).' && git pull && git submodule update --init --recursive'

    let cmd = g:shellesc_cd(cmd)

    let get_current_sha = 'cd '.shellescape(a:bundle.path()).' && git rev-parse HEAD'
    let get_current_sha = g:shellesc_cd(get_current_sha)
    let initial_sha = s:system(get_current_sha)[0:15]
  else
    let cmd = 'git clone --recursive '.shellescape(a:bundle.uri).' '.shellescape(a:bundle.path())
    let initial_sha = ''
  endif

  let out = s:system(cmd)
  call s:log('')
  call s:log('Bundle '.a:bundle.name_spec)
  call s:log('$ '.cmd)
  call s:log('> '.out)

  if 0 != v:shell_error
    return 'error'
  end

  if empty(initial_sha)
    return 'new'
  endif

  let updated_sha = s:system(get_current_sha)[0:15]

  if initial_sha == updated_sha
    return 'todate'
  endif

  call add(g:updated_bundles, [initial_sha, updated_sha, a:bundle])
  return 'updated'
endf

func! g:shellesc(cmd) abort
  if (has('win32') || has('win64'))
    if &shellxquote != '('                           " workaround for patch #445
      return '"'.a:cmd.'"'                          " enclose in quotes so && joined cmds work
    endif
  endif
  return a:cmd
endf

func! g:shellesc_cd(cmd) abort
  if (has('win32') || has('win64'))
    let cmd = substitute(a:cmd, '^cd ','cd /d ','')  " add /d switch to change drives
    let cmd = g:shellesc(cmd)
    return cmd
  else
    return a:cmd
  endif
endf

func! s:system(cmd) abort
  return system(a:cmd)
endf

func! s:log(str) abort
  let fmt = '%y%m%d %H:%M:%S'
  call add(g:vundle_log, '['.strftime(fmt).'] '.a:str)
  return a:str
endf
zhimakaimen:/bundle/vundle/autoload/vundle/installer.vim
func! vundle#config#bundle(arg, ...)
  let bundle = vundle#config#init_bundle(a:arg, a:000)
  call s:rtp_rm_a()
  call add(g:bundles, bundle)
  call s:rtp_add_a()
  return bundle
endf

func! vundle#config#init()
  if !exists('g:bundles') | let g:bundles = [] | endif
  call s:rtp_rm_a()
  let g:bundles = []
endf

func! vundle#config#require(bundles) abort
  for b in a:bundles
    call s:rtp_add(b.rtpath)
    call s:rtp_add(g:bundle_dir)
    " TODO: it has to be relative rtpath, not bundle.name
    exec 'runtime! '.b.name.'/plugin/*.vim'
    exec 'runtime! '.b.name.'/after/*.vim'
    call s:rtp_rm(g:bundle_dir)
  endfor
endf

func! vundle#config#init_bundle(name, opts)
  if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
    echo "Spurious leading and/or trailing whitespace found in bundle spec '" . a:name . "'"
  endif
  let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')))
  let b = extend(opts, copy(s:bundle))
  let b.rtpath = s:rtpath(opts)
  return b
endf

func! s:parse_options(opts)
  " TODO: improve this
  if len(a:opts) != 1 | return {} | endif

  if type(a:opts[0]) == type({})
    return a:opts[0]
  else
    return {'rev': a:opts[0]}
  endif
endf

func! s:parse_name(arg)
  let arg = a:arg
  let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'

  if    arg =~? '^\s*\(gh\|github\):\S\+'
  \  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
    let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
    if uri !~? '\.git$'
      let uri .= '.git'
    endif
    let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
  elseif arg =~? '^\s*\(git@\|git://\)\S\+' 
  \   || arg =~? '\(file\|https\?\)://'
  \   || arg =~? '\.git\s*$'
    let uri = arg
    let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
  else
    let name = arg
    let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
  endif
  return {'name': name, 'uri': uri, 'name_spec': arg }
endf

func! s:rtp_rm_a()
  let paths = map(copy(g:bundles), 'v:val.rtpath')
  let prepends = join(paths, ',')
  let appends = join(paths, '/after,').'/after'
  exec 'set rtp-='.fnameescape(prepends)
  exec 'set rtp-='.fnameescape(appends)
endf

func! s:rtp_add_a()
  let paths = map(copy(g:bundles), 'v:val.rtpath')
  let prepends = join(paths, ',')
  let appends = join(paths, '/after,').'/after'
  exec 'set rtp^='.fnameescape(prepends)
  exec 'set rtp+='.fnameescape(appends)
endf

func! s:rtp_rm(dir) abort
  exec 'set rtp-='.fnameescape(expand(a:dir, 1))
  exec 'set rtp-='.fnameescape(expand(a:dir.'/after', 1))
endf

func! s:rtp_add(dir) abort
  exec 'set rtp^='.fnameescape(expand(a:dir, 1))
  exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))
endf

func! s:expand_path(path) abort
  return simplify(expand(a:path, 1))
endf

func! s:rtpath(opts)
  return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
endf

let s:bundle = {}

func! s:bundle.path()
  return s:expand_path(g:bundle_dir.'/'.self.name)
endf

zhimakaimen:/bundle/vundle/autoload/vundle/config.vim
Quickly install with:

    git clone git://github.com/msanders/snipmate.vim.git
	cd snipmate.vim
	cp -R * ~/.vim
zhimakaimen:/bundle/snipmate.vim/README.markdown
{
  "name" : "snipmate",
  "version" : "dev",
  "author" : "Michael Sanders <msanders42@gmail.com>",
  "repository" : {"type": "git", "url": "git://github.com/msanders/snipmate.vim.git"},
  "dependencies" : {},
  "description" : "snipMate.vim aims to be a concise vim script that implements some of TextMate's snippets features in Vim."
}
zhimakaimen:/bundle/snipmate.vim/plugin-info.txt
" These are the mappings for snipMate.vim. Putting it here ensures that it
" will be mapped after other plugins such as supertab.vim.
if !exists('loaded_snips') || exists('s:did_snips_mappings')
	finish
endif
let s:did_snips_mappings = 1

" This is put here in the 'after' directory in order for snipMate to override
" other plugin mappings (e.g., supertab).
"
" You can safely adjust these mappings to your preferences (as explained in
" :help snipMate-remap).
ino <silent> <tab> <c-r>=TriggerSnippet()<cr>
snor <silent> <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>
ino <silent> <s-tab> <c-r>=BackwardsSnippet()<cr>
snor <silent> <s-tab> <esc>i<right><c-r>=BackwardsSnippet()<cr>
ino <silent> <c-r><tab> <c-r>=ShowAvailableSnips()<cr>

" The default mappings for these are annoying & sometimes break snipMate.
" You can change them back if you want, I've put them here for convenience.
snor <bs> b<bs>
snor <right> <esc>a
snor <left> <esc>bi
snor ' b<bs>'
snor ` b<bs>`
snor % b<bs>%
snor U b<bs>U
snor ^ b<bs>^
snor \ b<bs>\
snor <c-x> b<bs><c-x>

" By default load snippets in snippets_dir
if empty(snippets_dir)
	finish
endif

call GetSnippets(snippets_dir, '_') " Get global snippets

au FileType * if &ft != 'help' | call GetSnippets(snippets_dir, &ft) | endif
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/bundle/snipmate.vim/after/plugin/snipMate.vim
'snippets'	snipMate.txt	/*'snippets'*
.snippet	snipMate.txt	/*.snippet*
.snippets	snipMate.txt	/*.snippets*
ExtractSnips()	snipMate.txt	/*ExtractSnips()*
ExtractSnipsFile()	snipMate.txt	/*ExtractSnipsFile()*
Filename()	snipMate.txt	/*Filename()*
ReloadAllSnippets()	snipMate.txt	/*ReloadAllSnippets()*
ReloadSnippets()	snipMate.txt	/*ReloadSnippets()*
ResetAllSnippets()	snipMate.txt	/*ResetAllSnippets()*
ResetSnippets()	snipMate.txt	/*ResetSnippets()*
g:snippets_dir	snipMate.txt	/*g:snippets_dir*
g:snips_author	snipMate.txt	/*g:snips_author*
i_CTRL-R_<Tab>	snipMate.txt	/*i_CTRL-R_<Tab>*
list-snippets	snipMate.txt	/*list-snippets*
multi_snip	snipMate.txt	/*multi_snip*
snipMate	snipMate.txt	/*snipMate*
snipMate-$#	snipMate.txt	/*snipMate-$#*
snipMate-${#:}	snipMate.txt	/*snipMate-${#:}*
snipMate-${#}	snipMate.txt	/*snipMate-${#}*
snipMate-author	snipMate.txt	/*snipMate-author*
snipMate-commands	snipMate.txt	/*snipMate-commands*
snipMate-contact	snipMate.txt	/*snipMate-contact*
snipMate-description	snipMate.txt	/*snipMate-description*
snipMate-disadvantages	snipMate.txt	/*snipMate-disadvantages*
snipMate-expandtab	snipMate.txt	/*snipMate-expandtab*
snipMate-features	snipMate.txt	/*snipMate-features*
snipMate-filename	snipMate.txt	/*snipMate-filename*
snipMate-indenting	snipMate.txt	/*snipMate-indenting*
snipMate-license	snipMate.txt	/*snipMate-license*
snipMate-placeholders	snipMate.txt	/*snipMate-placeholders*
snipMate-remap	snipMate.txt	/*snipMate-remap*
snipMate-settings	snipMate.txt	/*snipMate-settings*
snipMate-usage	snipMate.txt	/*snipMate-usage*
snipMate.txt	snipMate.txt	/*snipMate.txt*
snippet	snipMate.txt	/*snippet*
snippet-syntax	snipMate.txt	/*snippet-syntax*
snippets	snipMate.txt	/*snippets*
zhimakaimen:/bundle/snipmate.vim/doc/tags
*snipMate.txt*  Plugin for using TextMate-style snippets in Vim.

snipMate                                       *snippet* *snippets* *snipMate*
Last Change: December 27, 2009

|snipMate-description|   Description
|snipMate-syntax|        Snippet syntax
|snipMate-usage|         Usage
|snipMate-settings|      Settings
|snipMate-features|      Features
|snipMate-disadvantages| Disadvantages to TextMate
|snipMate-contact|       Contact
|snipMate-license|       License

For Vim version 7.0 or later.
This plugin only works if 'compatible' is not set.
{Vi does not have any of these features.}

==============================================================================
DESCRIPTION                                             *snipMate-description*

snipMate.vim implements some of TextMate's snippets features in Vim. A
snippet is a piece of often-typed text that you can insert into your
document using a trigger word followed by a <tab>.

For instance, in a C file using the default installation of snipMate.vim, if
you type "for<tab>" in insert mode, it will expand a typical for loop in C: >

 for (i = 0; i < count; i++) {

 }


To go to the next item in the loop, simply <tab> over to it; if there is
repeated code, such as the "i" variable in this example, you can simply
start typing once it's highlighted and all the matches specified in the
snippet will be updated. To go in reverse, use <shift-tab>.

==============================================================================
SYNTAX                                                        *snippet-syntax*

Snippets can be defined in two ways. They can be in their own file, named
after their trigger in 'snippets/<filetype>/<trigger>.snippet', or they can be
defined together in a 'snippets/<filetype>.snippets' file. Note that dotted
'filetype' syntax is supported -- e.g., you can use >

	:set ft=html.eruby

to activate snippets for both HTML and eRuby for the current file.

The syntax for snippets in *.snippets files is the following: >

 snippet trigger
 	expanded text
	more expanded text

Note that the first hard tab after the snippet trigger is required, and not
expanded in the actual snippet. The syntax for *.snippet files is the same,
only without the trigger declaration and starting indentation.

Also note that snippets must be defined using hard tabs. They can be expanded
to spaces later if desired (see |snipMate-indenting|).

"#" is used as a line-comment character in *.snippets files; however, they can
only be used outside of a snippet declaration. E.g.: >

 # this is a correct comment
 snippet trigger
 	expanded text
 snippet another_trigger
 	# this isn't a comment!
	expanded text
<
This should hopefully be obvious with the included syntax highlighting.

                                                               *snipMate-${#}*
Tab stops ~

By default, the cursor is placed at the end of a snippet. To specify where the
cursor is to be placed next, use "${#}", where the # is the number of the tab
stop. E.g., to place the cursor first on the id of a <div> tag, and then allow
the user to press <tab> to go to the middle of it:
 >
 snippet div
 	<div id="${1}">
		${2}
	</div>
<
                        *snipMate-placeholders* *snipMate-${#:}* *snipMate-$#*
Placeholders ~

Placeholder text can be supplied using "${#:text}", where # is the number of
the tab stop. This text then can be copied throughout the snippet using "$#",
given # is the same number as used before. So, to make a C for loop: >

 snippet for
 	for (${2:i}; $2 < ${1:count}; $1++) {
		${4}
	}

This will cause "count" to first be selected and change if the user starts
typing. When <tab> is pressed, the "i" in ${2}'s position will be selected;
all $2 variables will default to "i" and automatically be updated if the user
starts typing.
NOTE: "$#" syntax is used only for variables, not for tab stops as in TextMate.

Variables within variables are also possible. For instance: >

 snippet opt
 	<option value="${1:option}">${2:$1}</option>

Will, as usual, cause "option" to first be selected and update all the $1
variables if the user starts typing. Since one of these variables is inside of
${2}, this text will then be used as a placeholder for the next tab stop,
allowing the user to change it if he wishes.

To copy a value throughout a snippet without supplying default text, simply
use the "${#:}" construct without the text; e.g.: >

 snippet foo
 	${1:}bar$1
<                                                          *snipMate-commands*
Interpolated Vim Script ~

Snippets can also contain Vim script commands that are executed (via |eval()|)
when the snippet is inserted. Commands are given inside backticks (`...`); for
TextMates's functionality, use the |system()| function. E.g.: >

 snippet date
 	`system("date +%Y-%m-%d")`

will insert the current date, assuming you are on a Unix system. Note that you
can also (and should) use |strftime()| for this example.

Filename([{expr}] [, {defaultText}])             *snipMate-filename* *Filename()*

Since the current filename is used often in snippets, a default function
has been defined for it in snipMate.vim, appropriately called Filename().

With no arguments, the default filename without an extension is returned;
the first argument specifies what to place before or after the filename,
and the second argument supplies the default text to be used if the file
has not been named. "$1" in the first argument is replaced with the filename;
if you only want the filename to be returned, the first argument can be left
blank. Examples: >

 snippet filename
 	`Filename()`
 snippet filename_with_default
 	`Filename('', 'name')`
 snippet filename_foo
 	`filename('$1_foo')`

The first example returns the filename if it the file has been named, and an
empty string if it hasn't. The second returns the filename if it's been named,
and "name" if it hasn't. The third returns the filename followed by "_foo" if
it has been named, and an empty string if it hasn't.

                                                                   *multi_snip*
To specify that a snippet can have multiple matches in a *.snippets file, use
this syntax: >

 snippet trigger A description of snippet #1
 	expand this text
 snippet trigger A description of snippet #2
 	expand THIS text!

In this example, when "trigger<tab>" is typed, a numbered menu containing all
of the descriptions of the "trigger" will be shown; when the user presses the
corresponding number, that snippet will then be expanded.

To create a snippet with multiple matches using *.snippet files,
simply place all the snippets in a subdirectory with the trigger name:
'snippets/<filetype>/<trigger>/<name>.snippet'.

==============================================================================
USAGE                                                         *snipMate-usage*

                                                 *'snippets'* *g:snippets_dir*
Snippets are by default looked for any 'snippets' directory in your
'runtimepath'. Typically, it is located at '~/.vim/snippets/' on *nix or
'$HOME\vimfiles\snippets\' on Windows. To change that location or add another
one, change the g:snippets_dir variable in your |.vimrc| to your preferred
directory, or use the |ExtractSnips()|function. This will be used by the
|globpath()| function, and so accepts the same syntax as it (e.g.,
comma-separated paths).

ExtractSnipsFile({directory}, {filetype})     *ExtractSnipsFile()* *.snippets*

ExtractSnipsFile() extracts the specified *.snippets file for the given
filetype. A .snippets file contains multiple snippet declarations for the
filetype. It is further explained above, in |snippet-syntax|.

ExtractSnips({directory}, {filetype})             *ExtractSnips()* *.snippet*

ExtractSnips() extracts *.snippet files from the specified directory and
defines them as snippets for the given filetype. The directory tree should
look like this: 'snippets/<filetype>/<trigger>.snippet'. If the snippet has
multiple matches, it should look like this:
'snippets/<filetype>/<trigger>/<name>.snippet' (see |multi_snip|).

ResetAllSnippets()                                       *ResetAllSnippets()*
ResetAllSnippets() removes all snippets from memory. This is useful to put at
the top of a snippet setup file for if you would like to |:source| it multiple
times.

ResetSnippets({filetype})                                   *ResetSnippets()*
ResetSnippets() removes all snippets from memory for the given filetype.

ReloadAllSnippets()                                     *ReloadAllSnippets()*
ReloadAllSnippets() reloads all snippets for all filetypes. This is useful for
testing and debugging.

ReloadSnippets({filetype})                                 *ReloadSnippets()*
ReloadSnippets() reloads all snippets for the given filetype.

                                             *list-snippets* *i_CTRL-R_<Tab>*
If you would like to see what snippets are available, simply type <c-r><tab>
in the current buffer to show a list via |popupmenu-completion|.

==============================================================================
SETTINGS                                  *snipMate-settings* *g:snips_author*

The g:snips_author string (similar to $TM_FULLNAME in TextMate) should be set
to your name; it can then be used in snippets to automatically add it. E.g.: >

 let g:snips_author = 'Hubert Farnsworth'
 snippet name
 	`g:snips_author`
<
                                     *snipMate-expandtab* *snipMate-indenting*
If you would like your snippets to be expanded using spaces instead of tabs,
just enable 'expandtab' and set 'softtabstop' to your preferred amount of
spaces. If 'softtabstop' is not set, 'shiftwidth' is used instead.

                                                              *snipMate-remap*
snipMate does not come with a setting to customize the trigger key, but you
can remap it easily in the two lines it's defined in the 'after' directory
under 'plugin/snipMate.vim'. For instance, to change the trigger key
to CTRL-J, just change this: >

 ino <tab> <c-r>=TriggerSnippet()<cr>
 snor <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>

to this: >
 ino <c-j> <c-r>=TriggerSnippet()<cr>
 snor <c-j> <esc>i<right><c-r>=TriggerSnippet()<cr>

==============================================================================
FEATURES                                                   *snipMate-features*

snipMate.vim has the following features among others:
  - The syntax of snippets is very similar to TextMate's, allowing
    easy conversion.
  - The position of the snippet is kept transparently (i.e. it does not use
    markers/placeholders written to the buffer), which allows you to escape
    out of an incomplete snippet, something particularly useful in Vim.
  - Variables in snippets are updated as-you-type.
  - Snippets can have multiple matches.
  - Snippets can be out of order. For instance, in a do...while loop, the
    condition can be added before the code.
  - [New] File-based snippets are supported.
  - [New] Triggers after non-word delimiters are expanded, e.g. "foo"
    in "bar.foo".
  - [New] <shift-tab> can now be used to jump tab stops in reverse order.

==============================================================================
DISADVANTAGES                                         *snipMate-disadvantages*

snipMate.vim currently has the following disadvantages to TextMate's snippets:
    - There is no $0; the order of tab stops must be explicitly stated.
    - Placeholders within placeholders are not possible. E.g.: >

      '<div${1: id="${2:some_id}}">${3}</div>'
<
      In TextMate this would first highlight ' id="some_id"', and if
      you hit delete it would automatically skip ${2} and go to ${3}
      on the next <tab>, but if you didn't delete it it would highlight
      "some_id" first. You cannot do this in snipMate.vim.
    - Regex cannot be performed on variables, such as "${1/.*/\U&}"
    - Placeholders cannot span multiple lines.
    - Activating snippets in different scopes of the same file is
      not possible.

Perhaps some of these features will be added in a later release.

==============================================================================
CONTACT                                   *snipMate-contact* *snipMate-author*

To contact the author (Michael Sanders), please email:
 msanders42+snipmate <at> gmail <dot> com

I greatly appreciate any suggestions or improvements offered for the script.

==============================================================================
LICENSE                                                     *snipMate-license*

snipMate is released under the MIT license:

Copyright 2009-2010 Michael Sanders. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The software is provided "as is", without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in the
software.

==============================================================================

vim:tw=78:ts=8:ft=help:norl:
zhimakaimen:/bundle/snipmate.vim/doc/snipMate.txt
" File:          snipMate.vim
" Author:        Michael Sanders
" Version:       0.84
" Description:   snipMate.vim implements some of TextMate's snippets features in
"                Vim. A snippet is a piece of often-typed text that you can
"                insert into your document using a trigger word followed by a "<tab>".
"
"                For more help see snipMate.txt; you can do this by using:
"                :helptags ~/.vim/doc
"                :h snipMate.txt

if exists('loaded_snips') || &cp || version < 700
	finish
endif
let loaded_snips = 1
if !exists('snips_author') | let snips_author = 'Me' | endif

au BufRead,BufNewFile *.snippets\= set ft=snippet
au FileType snippet setl noet fdm=indent

let s:snippets = {} | let s:multi_snips = {}

if !exists('snippets_dir')
	let snippets_dir = substitute(globpath(&rtp, 'snippets/'), "\n", ',', 'g')
endif

fun! MakeSnip(scope, trigger, content, ...)
	let multisnip = a:0 && a:1 != ''
	let var = multisnip ? 's:multi_snips' : 's:snippets'
	if !has_key({var}, a:scope) | let {var}[a:scope] = {} | endif
	if !has_key({var}[a:scope], a:trigger)
		let {var}[a:scope][a:trigger] = multisnip ? [[a:1, a:content]] : a:content
	elseif multisnip | let {var}[a:scope][a:trigger] += [[a:1, a:content]]
	else
		echom 'Warning in snipMate.vim: Snippet '.a:trigger.' is already defined.'
				\ .' See :h multi_snip for help on snippets with multiple matches.'
	endif
endf

fun! ExtractSnips(dir, ft)
	for path in split(globpath(a:dir, '*'), "\n")
		if isdirectory(path)
			let pathname = fnamemodify(path, ':t')
			for snipFile in split(globpath(path, '*.snippet'), "\n")
				call s:ProcessFile(snipFile, a:ft, pathname)
			endfor
		elseif fnamemodify(path, ':e') == 'snippet'
			call s:ProcessFile(path, a:ft)
		endif
	endfor
endf

" Processes a single-snippet file; optionally add the name of the parent
" directory for a snippet with multiple matches.
fun s:ProcessFile(file, ft, ...)
	let keyword = fnamemodify(a:file, ':t:r')
	if keyword  == '' | return | endif
	try
		let text = join(readfile(a:file), "\n")
	catch /E484/
		echom "Error in snipMate.vim: couldn't read file: ".a:file
	endtry
	return a:0 ? MakeSnip(a:ft, a:1, text, keyword)
			\  : MakeSnip(a:ft, keyword, text)
endf

fun! ExtractSnipsFile(file, ft)
	if !filereadable(a:file) | return | endif
	let text = readfile(a:file)
	let inSnip = 0
	for line in text + ["\n"]
		if inSnip && (line[0] == "\t" || line == '')
			let content .= strpart(line, 1)."\n"
			continue
		elseif inSnip
			call MakeSnip(a:ft, trigger, content[:-2], name)
			let inSnip = 0
		endif

		if line[:6] == 'snippet'
			let inSnip = 1
			let trigger = strpart(line, 8)
			let name = ''
			let space = stridx(trigger, ' ') + 1
			if space " Process multi snip
				let name = strpart(trigger, space)
				let trigger = strpart(trigger, 0, space - 1)
			endif
			let content = ''
		endif
	endfor
endf

" Reset snippets for filetype.
fun! ResetSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	for dict in [s:snippets, s:multi_snips, g:did_ft]
		if has_key(dict, ft)
			unlet dict[ft]
		endif
	endfor
endf

" Reset snippets for all filetypes.
fun! ResetAllSnippets()
	let s:snippets = {} | let s:multi_snips = {} | let g:did_ft = {}
endf

" Reload snippets for filetype.
fun! ReloadSnippets(ft)
	let ft = a:ft == '' ? '_' : a:ft
	call ResetSnippets(ft)
	call GetSnippets(g:snippets_dir, ft)
endf

" Reload snippets for all filetypes.
fun! ReloadAllSnippets()
	for ft in keys(g:did_ft)
		call ReloadSnippets(ft)
	endfor
endf

let g:did_ft = {}
fun! GetSnippets(dir, filetypes)
	for ft in split(a:filetypes, '\.')
		if has_key(g:did_ft, ft) | continue | endif
		call s:DefineSnips(a:dir, ft, ft)
		if ft == 'objc' || ft == 'cpp' || ft == 'cs'
			call s:DefineSnips(a:dir, 'c', ft)
		elseif ft == 'xhtml'
			call s:DefineSnips(a:dir, 'html', 'xhtml')
		endif
		let g:did_ft[ft] = 1
	endfor
endf

" Define "aliasft" snippets for the filetype "realft".
fun s:DefineSnips(dir, aliasft, realft)
	for path in split(globpath(a:dir, a:aliasft.'/')."\n".
					\ globpath(a:dir, a:aliasft.'-*/'), "\n")
		call ExtractSnips(path, a:realft)
	endfor
	for path in split(globpath(a:dir, a:aliasft.'.snippets')."\n".
					\ globpath(a:dir, a:aliasft.'-*.snippets'), "\n")
		call ExtractSnipsFile(path, a:realft)
	endfor
endf

fun! TriggerSnippet()
	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingForward == "<tab>"
			let SuperTabKey = "\<c-n>"
		elseif g:SuperTabMappingBackward == "<tab>"
			let SuperTabKey = "\<c-p>"
		endif
	endif

	if pumvisible() " Update snippet if completion is used, or deal with supertab
		if exists('SuperTabKey')
			call feedkeys(SuperTabKey) | return ''
		endif
		call feedkeys("\<esc>a", 'n') " Close completion menu
		call feedkeys("\<tab>") | return ''
	endif

	if exists('g:snipPos') | return snipMate#jumpTabStop(0) | endif

	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let [trigger, snippet] = s:GetSnippet(word, scope)
		" If word is a trigger for a snippet, delete the trigger & expand
		" the snippet.
		if snippet != ''
			let col = col('.') - len(trigger)
			sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
			return snipMate#expandSnip(snippet, col)
		endif
	endfor

	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<tab>"
endf

fun! BackwardsSnippet()
	if exists('g:snipPos') | return snipMate#jumpTabStop(1) | endif

	if exists('g:SuperTabMappingForward')
		if g:SuperTabMappingBackward == "<s-tab>"
			let SuperTabKey = "\<c-p>"
		elseif g:SuperTabMappingForward == "<s-tab>"
			let SuperTabKey = "\<c-n>"
		endif
	endif
	if exists('SuperTabKey')
		call feedkeys(SuperTabKey)
		return ''
	endif
	return "\<s-tab>"
endf

" Check if word under cursor is snippet trigger; if it isn't, try checking if
" the text after non-word characters is (e.g. check for "foo" in "bar.foo")
fun s:GetSnippet(word, scope)
	let word = a:word | let snippet = ''
	while snippet == ''
		if exists('s:snippets["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:snippets[a:scope][word]
		elseif exists('s:multi_snips["'.a:scope.'"]["'.escape(word, '\"').'"]')
			let snippet = s:ChooseSnippet(a:scope, word)
			if snippet == '' | break | endif
		else
			if match(word, '\W') == -1 | break | endif
			let word = substitute(word, '.\{-}\W', '', '')
		endif
	endw
	if word == '' && a:word != '.' && stridx(a:word, '.') != -1
		let [word, snippet] = s:GetSnippet('.', a:scope)
	endif
	return [word, snippet]
endf

fun s:ChooseSnippet(scope, trigger)
	let snippet = []
	let i = 1
	for snip in s:multi_snips[a:scope][a:trigger]
		let snippet += [i.'. '.snip[0]]
		let i += 1
	endfor
	if i == 2 | return s:multi_snips[a:scope][a:trigger][0][1] | endif
	let num = inputlist(snippet) - 1
	return num == -1 ? '' : s:multi_snips[a:scope][a:trigger][num][1]
endf

fun! ShowAvailableSnips()
	let line  = getline('.')
	let col   = col('.')
	let word  = matchstr(getline('.'), '\S\+\%'.col.'c')
	let words = [word]
	if stridx(word, '.')
		let words += split(word, '\.', 1)
	endif
	let matchlen = 0
	let matches = []
	for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
		let triggers = has_key(s:snippets, scope) ? keys(s:snippets[scope]) : []
		if has_key(s:multi_snips, scope)
			let triggers += keys(s:multi_snips[scope])
		endif
		for trigger in triggers
			for word in words
				if word == ''
					let matches += [trigger] " Show all matches if word is empty
				elseif trigger =~ '^'.word
					let matches += [trigger]
					let len = len(word)
					if len > matchlen | let matchlen = len | endif
				endif
			endfor
		endfor
	endfor

	" This is to avoid a bug with Vim when using complete(col - matchlen, matches)
	" (Issue#46 on the Google Code snipMate issue tracker).
	call setline(line('.'), substitute(line, repeat('.', matchlen).'\%'.col.'c', '', ''))
	call complete(col, matches)
	return ''
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/bundle/snipmate.vim/plugin/snipMate.vim
# snippets for making snippets :)
snippet snip
	snippet ${1:trigger}
		${2}
snippet msnip
	snippet ${1:trigger} ${2:description}
		${3}
zhimakaimen:/bundle/snipmate.vim/snippets/snippet.snippets
# #!/bin/zsh
snippet #!
	#!/bin/zsh

snippet if
	if ${1:condition}; then
		${2:# statements}
	fi
snippet ife
	if ${1:condition}; then
		${2:# statements}
	else
		${3:# statements}
	fi
snippet elif
	elif ${1:condition} ; then
		${2:# statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:# statements}
	done
snippet fore
	for ${1:item} in ${2:list}; do
		${3:# statements}
	done
snippet wh
	while ${1:condition}; do
		${2:# statements}
	done
snippet until
	until ${1:condition}; do
		${2:# statements}
	done
snippet repeat
	repeat ${1:integer}; do
		${2:# statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
snippet select
	select ${1:answer} in ${2:choices}; do
		${3:# statements}
	done
snippet (
	( ${1:#statements} )
snippet {
	{ ${1:#statements} }
snippet [
	[[ ${1:test} ]]
snippet always
	{ ${1:try} } always { ${2:always} }
snippet fun
	function ${1:name} (${2:args}) {
		${3:# body}
	}
zhimakaimen:/bundle/snipmate.vim/snippets/zsh.snippets
# #!/bin/bash
snippet #!
	#!/bin/bash
	
snippet if
	if [[ ${1:condition} ]]; then
		${2:#statements}
	fi
snippet elif
	elif [[ ${1:condition} ]]; then
		${2:#statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:#statements}
	done
snippet wh
	while [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet until
	until [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
zhimakaimen:/bundle/snipmate.vim/snippets/sh.snippets
# #import <...>
snippet Imp
	#import <${1:Cocoa/Cocoa.h}>${2}
# #import "..."
snippet imp
	#import "${1:`Filename()`.h}"${2}
# @selector(...)
snippet sel
	@selector(${1:method}:)${3}
# @"..." string
snippet s
	@"${1}"${2}
# Object
snippet o
	${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};${5}
# NSLog(...)
snippet log
	NSLog(@"${1:%@}"${2});${3}
# Class
snippet objc
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{
	}
	@end

	@implementation $1
	${3}
	@end
# Class Interface
snippet int
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
snippet @interface
	@interface ${1:`Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${4}
	@end
# Class Implementation
snippet impl
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
snippet @implementation
	@implementation ${1:`Filename('', 'someClass')`}
	${2}
	@end
# Protocol
snippet pro
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
snippet @protocol
	@protocol ${1:`Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${3}
	@end
# init Definition
snippet init
	- (id)init
	{
		if (self = [super init]) {
			${1}
		}
		return self;
	}
# dealloc Definition
snippet dealloc
	- (void) dealloc
	{
		${1:deallocations}
		[super dealloc];
	}
snippet su
	[super ${1:init}]${2}
snippet ibo
	IBOutlet ${1:NSSomeClass} *${2:$1};${3}
# Category
snippet cat
	@interface ${1:NSObject} (${2:MyCategory})
	@end

	@implementation $1 ($2)
	${3}
	@end
# Category Interface
snippet cath
	@interface ${1:`Filename('$1', 'NSObject')`} (${2:MyCategory})
	${3}
	@end
# Method
snippet m
	- (${1:id})${2:method}
	{
		${3}
	}
# Method declaration
snippet md
	- (${1:id})${2:method};${3}
# IBAction declaration
snippet ibad
	- (IBAction)${1:method}:(${2:id})sender;${3}
# IBAction method
snippet iba
	- (IBAction)${1:method}:(${2:id})sender
	{
		${3}
	}
# awakeFromNib method
snippet wake
	- (void)awakeFromNib
	{
		${1}
	}
# Class Method
snippet M
	+ (${1:id})${2:method}
	{
		${3:return nil;}
	}
# Sub-method (Call super)
snippet sm
	- (${1:id})${2:method}
	{
		[super $2];${3}
		return self;
	}
# Accessor Methods For:
# Object
snippet objacc
	- (${1:id})${2:thing}
	{
		return $2;
	}

	- (void)set$2:($1)${3:new$2}
	{
		[$3 retain];
		[$2 release];
		$2 = $3;
	}${4}
# for (object in array)
snippet forin
	for (${1:Class} *${2:some$1} in ${3:array}) {
		${4}
	}
snippet fore
	for (${1:object} in ${2:array}) {
		${3:statements}
	}
snippet forarray
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
snippet fora
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${4}
	}
# Try / Catch Block
snippet	@try
	@try {
		${1:statements}
	}
	@catch (NSException * e) {
		${2:handler}
	}
	@finally {
		${3:statements}
	}
snippet @catch
	@catch (${1:exception}) {
		${2:handler}
	}
snippet @finally
	@finally {
		${1:statements}
	}
# IBOutlet
# @property (Objective-C 2.0)
snippet prop
	@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};${4}
# @synthesize (Objective-C 2.0)
snippet syn
	@synthesize ${1:property};${2}
# [[ alloc] init]
snippet alloc
	[[${1:foo} alloc] init${2}];${3}
snippet a
	[[${1:foo} alloc] init${2}];${3}
# retain
snippet ret
	[${1:foo} retain];${2}
# release
snippet rel
	[${1:foo} release];
# autorelease
snippet arel
	[${1:foo} autorelease];
# autorelease pool
snippet pool
	NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];
	${2:/* code */}
	[$1 drain];
# Throw an exception
snippet except
	NSException *${1:badness};
	$1 = [NSException exceptionWithName:@"${2:$1Name}"
	                             reason:@"${3}"
	                           userInfo:nil];
	[$1 raise];
snippet prag
	#pragma mark ${1:-}
snippet cl
	@class ${1:Foo};${2}
snippet color
	[[NSColor ${1:blackColor}] set];
# NSArray
snippet array
	NSMutableArray *${1:array} = [NSMutable array];${2}
snippet nsa
	NSArray ${1}
snippet nsma
	NSMutableArray ${1}
snippet aa
	NSArray * array;${1}
snippet ma
	NSMutableArray * array;${1}
# NSDictionary
snippet dict
	NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];${2}
snippet nsd
	NSDictionary ${1}
snippet nsmd
	NSMutableDictionary ${1}
# NSString
snippet nss
	NSString ${1}
snippet nsms
	NSMutableString ${1}
zhimakaimen:/bundle/snipmate.vim/snippets/objc.snippets
snippet php
	<?php
	${1}
	?>
snippet ec
	echo "${1:string}"${2};
snippet inc
	include '${1:file}';${2}
snippet inc1
	include_once '${1:file}';${2}
snippet req
	require '${1:file}';${2}
snippet req1
	require_once '${1:file}';${2}
# $GLOBALS['...']
snippet globals
	$GLOBALS['${1:variable}']${2: = }${3:something}${4:;}${5}
snippet $_ COOKIE['...']
	$_COOKIE['${1:variable}']${2}
snippet $_ ENV['...']
	$_ENV['${1:variable}']${2}
snippet $_ FILES['...']
	$_FILES['${1:variable}']${2}
snippet $_ Get['...']
	$_GET['${1:variable}']${2}
snippet $_ POST['...']
	$_POST['${1:variable}']${2}
snippet $_ REQUEST['...']
	$_REQUEST['${1:variable}']${2}
snippet $_ SERVER['...']
	$_SERVER['${1:variable}']${2}
snippet $_ SESSION['...']
	$_SESSION['${1:variable}']${2}
# Start Docblock
snippet /*
	/**
	 * ${1}
	 **/
# Class - post doc
snippet doc_cp
	/**
	 * ${1:undocumented class}
	 *
	 * @package ${2:default}
	 * @author ${3:`g:snips_author`}
	**/${4}
# Class Variable - post doc
snippet doc_vp
	/**
	 * ${1:undocumented class variable}
	 *
	 * @var ${2:string}
	 **/${3}
# Class Variable
snippet doc_v
	/**
	 * ${3:undocumented class variable}
	 *
	 * @var ${4:string}
	 **/
	${1:var} $${2};${5}
# Class
snippet doc_c
	/**
	 * ${3:undocumented class}
	 *
	 * @packaged ${4:default}
	 * @author ${5:`g:snips_author`}
	 **/
	${1:}class ${2:}
	{${6}
	} // END $1class $2
# Constant Definition - post doc
snippet doc_dp
	/**
	 * ${1:undocumented constant}
	 **/${2}
# Constant Definition
snippet doc_d
	/**
	 * ${3:undocumented constant}
	 **/
	define(${1}, ${2});${4}
# Function - post doc
snippet doc_fp
	/**
	 * ${1:undocumented function}
	 *
	 * @return ${2:void}
	 * @author ${3:`g:snips_author`}
	 **/${4}
# Function signature
snippet doc_s
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3});${7}
# Function
snippet doc_f
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 **/
	${1}function ${2}(${3})
	{${7}
	}
# Header
snippet doc_h
	/**
	 * ${1}
	 *
	 * @author ${2:`g:snips_author`}
	 * @version ${3:$Id$}
	 * @copyright ${4:$2}, `strftime('%d %B, %Y')`
	 * @package ${5:default}
	 **/
	
	/**
	 * Define DocBlock
	 *//
# Interface
snippet doc_i
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 **/
	interface ${1:}
	{${5}
	} // END interface $1
# class ...
snippet class
	/**
	 * ${1}
	 **/
	class ${2:ClassName}
	{
		${3}
		function ${4:__construct}(${5:argument})
		{
			${6:// code...}
		}
	}
# define(...)
snippet def
	define('${1}'${2});${3}
# defined(...)
snippet def?
	${1}defined('${2}')${3}
snippet wh
	while (${1:/* condition */}) {
		${2:// code...}
	}
# do ... while
snippet do
	do {
		${2:// code... }
	} while (${1:/* condition */});
snippet if
	if (${1:/* condition */}) {
		${2:// code...}
	}
snippet ife
	if (${1:/* condition */}) {
		${2:// code...}
	} else {
		${3:// code...}
	}
	${4}
snippet else
	else {
		${1:// code...}
	}
snippet elseif
	elseif (${1:/* condition */}) {
		${2:// code...}
	}
# Tertiary conditional
snippet t
	$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};${5}
snippet switch
	switch ($${1:variable}) {
		case '${2:value}':
			${3:// code...}
			break;
		${5}
		default:
			${4:// code...}
			break;
	}
snippet case
	case '${1:value}':
		${2:// code...}
		break;${3}
snippet for
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4: // code...}
	}
snippet foreach
	foreach ($${1:variable} as $${2:key}) {
		${3:// code...}
	}
snippet fun
	${1:public }function ${2:FunctionName}(${3})
	{
		${4:// code...}
	}
# $... = array (...)
snippet array
	$${1:arrayName} = array('${2}' => ${3});${4}
zhimakaimen:/bundle/snipmate.vim/snippets/php.snippets
# #!/usr/bin/perl
snippet #!
	#!/usr/bin/perl

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	}
	else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression} if ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression} unless ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression} while ${2:condition};${3}
# C-style For Loop
snippet cfor
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4:# body...}
	}
# For loop one-line
snippet xfor
	${1:expression} for @${2:array};${3}
# Foreach Loop
snippet for
	foreach my $${1:x} (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet fore
	${1:expression} foreach @${2:array};${3}
# Package
snippet cl
	package ${1:ClassName};

	use base qw(${2:ParentClass});

	sub new {
		my $class = shift;
		$class = ref $class if ref $class;
		my $self = bless {}, $class;
		$self;
	}

	1;${3}
# Read File
snippet slurp
	my $${1:var};
	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}
zhimakaimen:/bundle/snipmate.vim/snippets/perl.snippets
# \begin{}...\end{}
snippet begin
	\begin{${1:env}}
		${2}
	\end{$1}
# Tabular
snippet tab
	\begin{${1:tabular}}{${2:c}}
	${3}
	\end{$1}
# Align(ed)
snippet ali
	\begin{align${1:ed}}
		${2}
	\end{align$1}
# Gather(ed)
snippet gat
	\begin{gather${1:ed}}
		${2}
	\end{gather$1}
# Equation
snippet eq
	\begin{equation}
		${1}
	\end{equation}
# Unnumbered Equation
snippet \
	\\[
		${1}
	\\]
# Enumerate
snippet enum
	\begin{enumerate}
		\item ${1}
	\end{enumerate}
# Itemize
snippet item
	\begin{itemize}
		\item ${1}
	\end{itemize}
# Description
snippet desc
	\begin{description}
		\item[${1}] ${2}
	\end{description}
# Matrix
snippet mat
	\begin{${1:p/b/v/V/B/small}matrix}
		${2}
	\end{$1matrix}
# Cases
snippet cas
	\begin{cases}
		${1:equation}, &\text{ if }${2:case}\\
		${3}
	\end{cases}
# Split
snippet spl
	\begin{split}
		${1}
	\end{split}
# Part
snippet part
	\part{${1:part name}} % (fold)
	\label{prt:${2:$1}}
	${3}
	% part $2 (end)
# Chapter
snippet cha
	\chapter{${1:chapter name}} % (fold)
	\label{cha:${2:$1}}
	${3}
	% chapter $2 (end)
# Section
snippet sec
	\section{${1:section name}} % (fold)
	\label{sec:${2:$1}}
	${3}
	% section $2 (end)
# Sub Section
snippet sub
	\subsection{${1:subsection name}} % (fold)
	\label{sub:${2:$1}}
	${3}
	% subsection $2 (end)
# Sub Sub Section
snippet subs
	\subsubsection{${1:subsubsection name}} % (fold)
	\label{ssub:${2:$1}}
	${3}
	% subsubsection $2 (end)
# Paragraph
snippet par
	\paragraph{${1:paragraph name}} % (fold)
	\label{par:${2:$1}}
	${3}
	% paragraph $2 (end)
# Sub Paragraph
snippet subp
	\subparagraph{${1:subparagraph name}} % (fold)
	\label{subp:${2:$1}}
	${3}
	% subparagraph $2 (end)
snippet itd
	\item[${1:description}] ${2:item}
snippet figure
	${1:Figure}~\ref{${2:fig:}}${3}
snippet table
	${1:Table}~\ref{${2:tab:}}${3}
snippet listing
	${1:Listing}~\ref{${2:list}}${3}
snippet section
	${1:Section}~\ref{${2:sec:}}${3}
snippet page
	${1:page}~\pageref{${2}}${3}
zhimakaimen:/bundle/snipmate.vim/snippets/tex.snippets
# a farbox header snip
snippet til
	Title: ${1}
	Status: ${2:Public}
	Tags: ${3}
	Date: time${4}

	[TOC]
# a code block snip
# a bug occurs starting with ``
snippet code
	```${1:verilog}
	${2}
	```

# a Tex numbered equation block snip
snippet equ
	$$
	\begin{equation}
		${1:your equation}
	\end{equation}
	$$

# \begin{}...\end{}
snippet begin
	$$
	\begin{${1:env}}
		${2}
	\end{$1}
	$$

# linker snip
snippet lin
	[${1}](${2:http://}${3})

zhimakaimen:/bundle/snipmate.vim/snippets/markdown.snippets
# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet req
	require "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet deft
	def test_${1:case_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end		
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end	
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eaid
	each_index do |${1:i}|
	end
snippet eak
	each_key { |${1:key}| ${2} }
snippet eakd
	each_key do |${1:key}|
		${2}
	end
snippet eal
	each_line { |${1:line}| ${2} }
snippet eald
	each_line do |${1:line}|
		${2}
	end		
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${3}
	end			
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet easd-
	each_slice(${1:2}) do |${2:group}|
		${3}
	end		
snippet eav
	each_value { |${1:val}| ${2} }
snippet eavd
	each_value do |${1:val}| 
		${2}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet eawid
	each_with_index do |${1:e},${2:i}|
		${3}
	end
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet reved
	reverse_each do |${1:e}|
		${2}
	end	
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end		
snippet map
	map { |${1:e}| ${2} }
snippet mapd
	map do |${1:e}| 
		${2}
	end		
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet cold
	collect do |${1:e}|
		${2}
	end
snippet det
	detect { |${1:e}| ${2} }
snippet detd
	detect do |${1:e}|
		${2}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet find
	find do |${1:e}|
		${2}
	end		
snippet fina
	find_all { |${1:e}| ${2} }
snippet finad
	find_all do |${1:e}|
		${2}
	end			
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end		
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet pard
	partition do |${1:e}|
		${2}
	end		
snippet rej
	reject { |${1:e}| ${2} }
snippet rejd
	reject do |${1:e}|
		${2}
	end
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end		
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet :
	:${1:key} => ${2:"value"}${3}
snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
snippet patfh
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end
zhimakaimen:/bundle/snipmate.vim/snippets/ruby.snippets
# module and export all
snippet mod
	-module(${1:`Filename('', 'my')`}).
	
	-compile([export_all]).
	
	start() ->
	    ${2}
	
	stop() ->
	    ok.
# define directive
snippet def
	-define(${1:macro}, ${2:body}).${3}
# export directive
snippet exp
	-export([${1:function}/${2:arity}]).
# include directive
snippet inc
	-include("${1:file}").${2}
# behavior directive
snippet beh
	-behaviour(${1:behaviour}).${2}
# if expression
snippet if
	if
	    ${1:guard} ->
	        ${2:body}
	end
# case expression
snippet case
	case ${1:expression} of
	    ${2:pattern} ->
	        ${3:body};
	end
# record directive
snippet rec
	-record(${1:record}, {
	    ${2:field}=${3:value}}).${4}
zhimakaimen:/bundle/snipmate.vim/snippets/erlang.snippets
# Read File Into Vector
snippet readfile
	std::vector<char> v;
	if (FILE *${2:fp} = fopen(${1:"filename"}, "r")) {
		char buf[1024];
		while (size_t len = fread(buf, 1, sizeof(buf), $2))
			v.insert(v.end(), buf, buf + len);
		fclose($2);
	}${3}
# std::map
snippet map
	std::map<${1:key}, ${2:value}> map${3};
# std::vector
snippet vector
	std::vector<${1:char}> v${2};
# Namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* $1 */
# Class
snippet cl
	class ${1:`Filename('$1_t', 'name')`} {
	public:
		$1 (${2:arguments});
		virtual ~$1 ();

	private:
		${3:/* data */}
	};
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4:/* code */}
	}
zhimakaimen:/bundle/snipmate.vim/snippets/cpp.snippets
snippet #!
	#!/usr/bin/env python

snippet imp
	import ${1:module}
# Module Docstring
snippet docs
	'''
	File: ${1:`Filename('$1.py', 'foo.py')`}
	Author: ${2:`g:snips_author`}
	Description: ${3}
	'''
snippet wh
	while ${1:condition}:
		${2:# code...}
snippet for
	for ${1:needle} in ${2:haystack}:
		${3:# code...}
# New Class
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${6}
# New Function
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${4:pass}
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${3}
# New Method
snippet defs
	def ${1:mname}(self, ${2:arg}):
		${3:pass}
# New Property
snippet property
	def ${1:foo}():
		doc = "${2:The $1 property.}"
		def fget(self):
			${3:return self._$1}
		def fset(self, value):
			${4:self._$1 = value}
# Lambda
snippet ld
	${1:var} = lambda ${2:vars} : ${3:action}
snippet .
	self.
snippet try Try/Except
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
snippet try Try/Except/Else
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
snippet try Try/Except/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	finally:
		${5:pass}
snippet try Try/Except/Else/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
	finally:
		${6:pass}
# if __name__ == '__main__':
snippet ifmain
	if __name__ == '__main__':
		${1:main()}
# __magic__
snippet _
	__${1:init}__${2}
zhimakaimen:/bundle/snipmate.vim/snippets/python.snippets
snippet header
	" File: ${1:`expand('%:t')`}
	" Author: ${2:`g:snips_author`}
	" Description: ${3}
	${4:" Last Modified: `strftime("%B %d, %Y")`}
snippet guard
	if exists('${1:did_`Filename()`}') || &cp${2: || version < 700}
		finish
	endif
	let $1 = 1${3}
snippet f
	fun ${1:function_name}(${2})
		${3:" code}
	endf
snippet for
	for ${1:needle} in ${2:haystack}
		${3:" code}
	endfor
snippet wh
	while ${1:condition}
		${2:" code}
	endw
snippet if
	if ${1:condition}
		${2:" code}
	endif
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	endif
zhimakaimen:/bundle/snipmate.vim/snippets/vim.snippets
snippet .
	.${1:class_name}
	{
		${2:font-size:}
	}
	
snippet sel
	${1:selector_name}
	{
		${2:font-size:}
	}
	
snippet #
	#${1:id_name}
	{
		${2:font-size:}
	}
zhimakaimen:/bundle/snipmate.vim/snippets/css.snippets
zhimakaimen:/bundle/snipmate.vim/snippets/.gitignore
snippet if
	If ${1:condition} Then
		${2:; True code}
	EndIf
snippet el
	Else
		${1}
snippet elif
	ElseIf ${1:condition} Then
		${2:; True code}
# If/Else block
snippet ifel
	If ${1:condition} Then
		${2:; True code}
	Else
		${3:; Else code}
	EndIf
# If/ElseIf/Else block
snippet ifelif
	If ${1:condition 1} Then
		${2:; True code}
	ElseIf ${3:condition 2} Then
		${4:; True code}
	Else
		${5:; Else code}
	EndIf
# Switch block
snippet switch
	Switch (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSwitch
# Select block
snippet select
	Select (${1:condition})
	Case {$2:case1}:
		{$3:; Case 1 code}
	Case Else:
		{$4:; Else code}
	EndSelect
# While loop
snippet while
	While (${1:condition})
		${2:; code...}
	WEnd
# For loop
snippet for
	For ${1:n} = ${3:1} to ${2:count}
		${4:; code...}
	Next
# New Function
snippet func
	Func ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${4:Return}
	EndFunc
# Message box
snippet msg
	MsgBox(${3:MsgType}, ${1:"Title"}, ${2:"Message Text"})
# Debug Message
snippet debug
	MsgBox(0, "Debug", ${1:"Debug Message"})
# Show Variable Debug Message
snippet showvar
	MsgBox(0, "${1:VarName}", $1)
zhimakaimen:/bundle/snipmate.vim/snippets/autoit.snippets
# #!/usr/bin/env tclsh
snippet #!
	#!/usr/bin/env tclsh
	
# Process
snippet pro
	proc ${1:function_name} {${2:args}} {
		${3:#body ...}
	}
#xif
snippet xif
	${1:expr}? ${2:true} : ${3:false}
# Conditional
snippet if
	if {${1}} {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if {${1}} {
		${2:# body...}
	} else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if {${1}} {
		${2:# body...}
	} elseif {${3}} {
		${4:# elsif...}
	} else {
		${5:# else...}
	}
# If catch then
snippet ifc
	if { [catch {${1:#do something...}} ${2:err}] } {
		${3:# handle failure...}
	}
# Catch
snippet catch
	catch {${1}} ${2:err} ${3:options}
# While Loop
snippet wh
	while {${1}} {
		${2:# body...}
	}
# For Loop
snippet for
	for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {
		${4:# body...}
	}
# Foreach Loop
snippet fore
	foreach ${1:x} {${2:#list}} {
		${3:# body...}
	}
# after ms script...
snippet af
	after ${1:ms} ${2:#do something}
# after cancel id
snippet afc
	after cancel ${1:id or script}
# after idle
snippet afi
	after idle ${1:script}
# after info id
snippet afin
	after info ${1:id}
# Expr
snippet exp
	expr {${1:#expression here}}
# Switch
snippet sw
	switch ${1:var} {
		${3:pattern 1} {
			${4:#do something}
		}
		default {
			${2:#do something}
		}
	}
# Case
snippet ca
	${1:pattern} {
		${2:#do something}
	}${3}
# Namespace eval
snippet ns
	namespace eval ${1:path} {${2:#script...}}
# Namespace current
snippet nsc
	namespace current
zhimakaimen:/bundle/snipmate.vim/snippets/tcl.snippets
# a verilog header 
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Device: ${2:EP2C35}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//
# the revision details
snippet rev
	
	//`strftime("%c")`: ${1:created}
# module extract
snippet mod
	module ${1:name_of_module} 
	(
		${2:input}
	);
	endmodule
# module with parameters
snippet mp
	module ${1:name_of_module} 
	#(
	//parameter declaration
		parameter
	)
	(
		${2:input}
	);
	endmodule
# initial block
snippet ini
	initial
	begin
		${1:/*statements*/}
	end
# begin-end pair
snippet beg
	begin
		${1:/*statements*/}
	end
# fork-join pair
snippet fo
	fork
		${1:/*statements*/}
	join
# a wire variables declare
snippet wire
	wire [${2:7}:${1:0}] ${3:/*variables*/};
# a reg variables declare 
snippet reg
	reg [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare
snippet input
	input [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet output
	output [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet inout
	inout [${2:7}:${1:0}] ${3:/*variables*/};
# module inst boost
snippet inst a autoinst snip
	${1:name_of_module} m$1 
	(/*autoinst*/);
# inst with parameters
snippet ip
	${1:name_of_module} 
	#(/*autoinstparam*/)
	m$1 
	(/*autoinst*/);

# else if statement
# snippet eif
# 	else if (${1} ${2:=}= ${3})
# 	begin
# 		${4:/*statements*/}
# 	end
# if statement
snippet if
	if (${1:a} ${2:=}= ${3:b})
	begin
		${4:/*statements*/}
	end
# assign statement
snippet ass
	assign
		${1} = ${2};
# always block statement
snippet alw a combinational always block
	always @(${1:/*autosense*/})
	begin
		${2:/*statements*/}
	end
snippet alw a clk triggered always block
	always @(${1:pos}edge ${2:clk})
	begin
		${3:/*statements*/}
	end
snippet alw a clk triggered always block with reset signal
	always @(${1:pos}edge ${2:clk} or ${3:neg}edge ${4:rst_n})
	begin
		if (!$4)
		begin
			${5:/*autoreset*/}
		end
		else
		begin
			${6:/*statements*/}
		end
	end
# time scale statement
snippet ts
	`timescale 1ns/${1:100ps}
# include statement
snippet inc
	`include "${1:define}.v"
# else block
snippet else
	else
	begin
		${1}
	end
# an inc snip
snippet acc
	${1:var} <= $1 + ${2:8}'d1;
# state machine snip
snippet sm
	//state reg
	(* syn_encoding = "safe" *)reg [${1:7}:0] ns_$2, cs_${2:mmm};
	//state parameters
	localparam 
		${5:sIDLE} = 0,
	always @(posedge ${3:clk} or negedge ${4:rst_n})
		if (!$4)
			cs_$2 <= $5;
		else
			cs_$2 <= ns_$2;

	always @(*)
	begin
		ns_$2 = cs_$2;
		case (cs_$2)
			$5:
			default:
				ns_$2 = $5;
		endcase
	end
# parameterized bit oprand
snippet p0
	{(${1:pWIDTH}){1'b0}};
snippet p1
	{{(${1:pWIDTH}-1){1'b0}}, 1'b1};
# Altera Synthesis Attributes
snippet sa full case
	(* full_case *)
snippet sa parallel case
	(* parallel_case *)
snippet sa keep
	(* keep *)
snippet sa preserve
	(* preserve *)
snippet sa noprune
	(* noprune *)
snippet sa encoding
	(* syn_encoding = "safe" *)
# end of verilog snippets

zhimakaimen:/bundle/snipmate.vim/snippets/verilog.snippets
# my snippet

The verilog.snippets file is with verilog-mode compatibility.
zhimakaimen:/bundle/snipmate.vim/snippets/README.markdown
# a c header
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Project: ${2:sup}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//Author: Zhou Chuanrui
	//E-mail: zhouchuanrui@foxmail.com
	//
# main()
snippet main
	int main(int argc, const char *argv[])
	{
		${1}
		return 0;
	}
snippet mainn
	int main(void)
	{
		${1}
		return 0;
	}
# #include <...>
snippet inc
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet def
	#define
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
snippet once
	#ifndef ${1:`toupper(Filename('$1_H', 'UNTITLED_H'))`}

	#define $1

	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if (${1:/* condition */}) 
	{
		${2:/* code */}
	}
snippet el
	else
	{
		${1}
	}
# Ternary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do
	{
		${2:/* code */}
	} while (${1:/* condition */});
# While Loop
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# For Loop
snippet for
	for (${2:i} = 0; $2 < ${1:count}; $2${3:++})
	{
		${4:/* code */}
	}
# Custom For Loop
snippet forr
	for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
	{
		${5:/* code */}
	}
# Function
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Function Declaration
snippet fund
	${1:void} ${2:function_name}(${3});${4}
# Typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};${3}
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`}
	{
		${2:/* data */}
	}${3: /* optional variable list */};${4}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }
	{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Typdef enum
snippet tde
	typedef enum
	{
		${1:/* data */}
	} ${2:foo};
# printf
# unfortunately version this isn't as nice as TextMates's, given the lack of a
# dynamic `...`
snippet pr
	printf("${1:%s}\n"${2});${3}
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
# This is kind of convenient
snippet .
	[${1}]${2}
zhimakaimen:/bundle/snipmate.vim/snippets/c.snippets
# Prototype
snippet proto
	${1:class_name}.prototype.${2:method_name} =
	function(${3:first_argument}) {
		${4:// body...}
	};
# Function
snippet fun
	function ${1:function_name} (${2:argument}) {
		${3:// body...}
	}
# Anonymous Function
snippet f
	function(${1}) {${2}};
# if
snippet if
	if (${1:true}) {${2}}
# if ... else
snippet ife
	if (${1:true}) {${2}}
	else{${3}}
# tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# switch
snippet switch
	switch(${1:expression}) {
		case '${3:case}':
			${4:// code}
			break;
		${5}
		default:
			${2:// code}
	}
# case
snippet case
	case '${1:case}':
		${2:// code}
		break;
	${3}
# for (...) {...}
snippet for
	for (var ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {
		${4:$1[$2]}
	};
# for (...) {...} (Improved Native For-Loop)
snippet forr
	for (var ${2:i} = ${1:Things}.length - 1; $2 >= 0; $2${3:--}) {
		${4:$1[$2]}
	};
# while (...) {...}
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# do...while
snippet do
	do {
		${2:/* code */}
	} while (${1:/* condition */});
# Object Method
snippet :f
	${1:method_name}: function(${2:attribute}) {
		${4}
	}${3:,}
# setTimeout function
snippet timeout
	setTimeout(function() {${3}}${2}, ${1:10};
# Get Elements
snippet get
	getElementsBy${1:TagName}('${2}')${3}
# Get Element
snippet gett
	getElementBy${1:Id}('${2}')${3}
zhimakaimen:/bundle/snipmate.vim/snippets/javascript.snippets
snippet main
	public static void main (String [] args)
	{
		${1:/* code */}
	}
snippet pu
	public
snippet po
	protected
snippet pr
	private
snippet st
	static
snippet fi
	final
snippet ab
	abstract
snippet re
	return
snippet br
	break;
snippet de
	default:
		${1}
snippet ca
	catch(${1:Exception} ${2:e}) ${3}
snippet th
	throw 
snippet sy
	synchronized
snippet im
	import
snippet imp
	implements
snippet ext
	extends 
snippet j.u
	java.util
snippet j.i
	java.io.
snippet j.b
	java.beans.
snippet j.n
	java.net.
snippet j.m
	java.math.
snippet if
	if (${1}) ${2}
snippet el
	else 
snippet elif
	else if (${1}) ${2}
snippet wh
	while (${1}) ${2}
snippet for
	for (${1}; ${2}; ${3}) ${4}
snippet fore
	for (${1} : ${2}) ${3}
snippet sw
	switch (${1}) ${2}
snippet cs
	case ${1}:
		${2}
	${3}
snippet tc
	public class ${1:`Filename()`} extends ${2:TestCase}
snippet t
	public void test${1:Name}() throws Exception ${2}
snippet cl
	class ${1:`Filename("", "untitled")`} ${2}
snippet in
	interface ${1:`Filename("", "untitled")`} ${2:extends Parent}${3}
snippet m
	${1:void} ${2:method}(${3}) ${4:throws }${5}
snippet v
	${1:String} ${2:var}${3: = null}${4};${5}
snippet co
	static public final ${1:String} ${2:var} = ${3};${4}
snippet cos
	static public final String ${1:var} = "${2}";${3}
snippet as
	assert ${1:test} : "${2:Failure message}";${3}
snippet try
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	}
snippet tryf
	try {
		${3}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
snippet rst
	ResultSet ${1:rst}${2: = null}${3};${4}
zhimakaimen:/bundle/snipmate.vim/snippets/java.snippets
snippet def
	<%def name="${1:name}">
		${2:}
	</%def>
snippet call
	<%call expr="${1:name}">
		${2:}
	</%call>
snippet doc
	<%doc>
		${1:}
	</%doc>
snippet text
	<%text>
		${1:}
	</%text>
snippet for
	% for ${1:i} in ${2:iter}:
		${3:}
	% endfor
snippet if if
	% if ${1:condition}:
		${2:}
	% endif
snippet if if/else
	% if ${1:condition}:
		${2:}
	% else:
		${3:}
	% endif
snippet try
	% try:
		${1:}
	% except${2:}:
		${3:pass}
	% endtry
snippet wh
	% while ${1:}:
		${2:}
	% endwhile
snippet $
	${ ${1:} }
snippet <%
	<% ${1:} %>
snippet <!%
	<!% ${1:} %>
snippet inherit
	<%inherit file="${1:filename}" />
snippet include
	<%include file="${1:filename}" />
snippet namespace
	<%namespace file="${1:name}" />
snippet page
	<%page args="${1:}" />
zhimakaimen:/bundle/snipmate.vim/snippets/mako.snippets
" Syntax highlighting for snippet files (used for snipMate.vim)
" Hopefully this should make snippets a bit nicer to write!
syn match snipComment '^#.*'
syn match placeHolder '\${\d\+\(:.\{-}\)\=}' contains=snipCommand
syn match tabStop '\$\d\+'
syn match snipCommand '[^\\]`.\{-}`'
syn match snippet '^snippet.*' transparent contains=multiSnipText,snipKeyword
syn match multiSnipText '\S\+ \zs.*' contained
syn match snipKeyword '^snippet'me=s+8 contained
syn match snipError "^[^#s\t].*$"

hi link snipComment   Comment
hi link multiSnipText String
hi link snipKeyword   Keyword
hi link snipComment   Comment
hi link placeHolder   Special
hi link tabStop       Special
hi link snipCommand   String
hi link snipError     Error
zhimakaimen:/bundle/snipmate.vim/syntax/snippet.vim
fun! Filename(...)
	let filename = expand('%:t:r')
	if filename == '' | return a:0 == 2 ? a:2 : '' | endif
	return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
endf

fun s:RemoveSnippet()
	unl! g:snipPos s:curPos s:snipLen s:endCol s:endLine s:prevLen
	     \ s:lastBuf s:oldWord
	if exists('s:update')
		unl s:startCol s:origWordLen s:update
		if exists('s:oldVars') | unl s:oldVars s:oldEndCol | endif
	endif
	aug! snipMateAutocmds
endf

fun snipMate#expandSnip(snip, col)
	let lnum = line('.') | let col = a:col

	let snippet = s:ProcessSnippet(a:snip)
	" Avoid error if eval evaluates to nothing
	if snippet == '' | return '' | endif

	" Expand snippet onto current position with the tab stops removed
	let snipLines = split(substitute(snippet, '$\d\+\|${\d\+.\{-}}', '', 'g'), "\n", 1)

	let line = getline(lnum)
	let afterCursor = strpart(line, col - 1)
	" Keep text after the cursor
	if afterCursor != "\t" && afterCursor != ' '
		let line = strpart(line, 0, col - 1)
		let snipLines[-1] .= afterCursor
	else
		let afterCursor = ''
		" For some reason the cursor needs to move one right after this
		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
			let col += 1
		endif
	endif

	call setline(lnum, line.snipLines[0])

	" Autoindent snippet according to previous indentation
	let indent = matchend(line, '^.\{-}\ze\(\S\|$\)') + 1
	call append(lnum, map(snipLines[1:], "'".strpart(line, 0, indent - 1)."'.v:val"))

	" Open any folds snippet expands into
	if &fen | sil! exe lnum.','.(lnum + len(snipLines) - 1).'foldopen' | endif

	let [g:snipPos, s:snipLen] = s:BuildTabStops(snippet, lnum, col - indent, indent)

	if s:snipLen
		aug snipMateAutocmds
			au CursorMovedI * call s:UpdateChangedSnip(0)
			au InsertEnter * call s:UpdateChangedSnip(1)
		aug END
		let s:lastBuf = bufnr(0) " Only expand snippet while in current buffer
		let s:curPos = 0
		let s:endCol = g:snipPos[s:curPos][1]
		let s:endLine = g:snipPos[s:curPos][0]

		call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])
		let s:prevLen = [line('$'), col('$')]
		if g:snipPos[s:curPos][2] != -1 | return s:SelectWord() | endif
	else
		unl g:snipPos s:snipLen
		" Place cursor at end of snippet if no tab stop is given
		let newlines = len(snipLines) - 1
		call cursor(lnum + newlines, indent + len(snipLines[-1]) - len(afterCursor)
					\ + (newlines ? 0: col - 1))
	endif
	return ''
endf

" Prepare snippet to be processed by s:BuildTabStops
fun s:ProcessSnippet(snip)
	let snippet = a:snip
	" Evaluate eval (`...`) expressions.
	" Backquotes prefixed with a backslash "\" are ignored.
	" Using a loop here instead of a regex fixes a bug with nested "\=".
	if stridx(snippet, '`') != -1
		while match(snippet, '\(^\|[^\\]\)`.\{-}[^\\]`') != -1
			let snippet = substitute(snippet, '\(^\|[^\\]\)\zs`.\{-}[^\\]`\ze',
		                \ substitute(eval(matchstr(snippet, '\(^\|[^\\]\)`\zs.\{-}[^\\]\ze`')),
		                \ "\n\\%$", '', ''), '')
		endw
		let snippet = substitute(snippet, "\r", "\n", 'g')
		let snippet = substitute(snippet, '\\`', '`', 'g')
	endif

	" Place all text after a colon in a tab stop after the tab stop
	" (e.g. "${#:foo}" becomes "${:foo}foo").
	" This helps tell the position of the tab stops later.
	let snippet = substitute(snippet, '${\d\+:\(.\{-}\)}', '&\1', 'g')

	" Update the a:snip so that all the $# become the text after
	" the colon in their associated ${#}.
	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
	let i = 1
	while stridx(snippet, '${'.i) != -1
		let s = matchstr(snippet, '${'.i.':\zs.\{-}\ze}')
		if s != ''
			let snippet = substitute(snippet, '$'.i, s.'&', 'g')
		endif
		let i += 1
	endw

	if &et " Expand tabs to spaces if 'expandtab' is set.
		return substitute(snippet, '\t', repeat(' ', &sts ? &sts : &sw), 'g')
	endif
	return snippet
endf

" Counts occurences of haystack in needle
fun s:Count(haystack, needle)
	let counter = 0
	let index = stridx(a:haystack, a:needle)
	while index != -1
		let index = stridx(a:haystack, a:needle, index+1)
		let counter += 1
	endw
	return counter
endf

" Builds a list of a list of each tab stop in the snippet containing:
" 1.) The tab stop's line number.
" 2.) The tab stop's column number
"     (by getting the length of the string between the last "\n" and the
"     tab stop).
" 3.) The length of the text after the colon for the current tab stop
"     (e.g. "${1:foo}" would return 3). If there is no text, -1 is returned.
" 4.) If the "${#:}" construct is given, another list containing all
"     the matches of "$#", to be replaced with the placeholder. This list is
"     composed the same way as the parent; the first item is the line number,
"     and the second is the column.
fun s:BuildTabStops(snip, lnum, col, indent)
	let snipPos = []
	let i = 1
	let withoutVars = substitute(a:snip, '$\d\+', '', 'g')
	while stridx(a:snip, '${'.i) != -1
		let beforeTabStop = matchstr(withoutVars, '^.*\ze${'.i.'\D')
		let withoutOthers = substitute(withoutVars, '${\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')

		let j = i - 1
		call add(snipPos, [0, 0, -1])
		let snipPos[j][0] = a:lnum + s:Count(beforeTabStop, "\n")
		let snipPos[j][1] = a:indent + len(matchstr(withoutOthers, '.*\(\n\|^\)\zs.*\ze${'.i.'\D'))
		if snipPos[j][0] == a:lnum | let snipPos[j][1] += a:col | endif

		" Get all $# matches in another list, if ${#:name} is given
		if stridx(withoutVars, '${'.i.':') != -1
			let snipPos[j][2] = len(matchstr(withoutVars, '${'.i.':\zs.\{-}\ze}'))
			let dots = repeat('.', snipPos[j][2])
			call add(snipPos[j], [])
			let withoutOthers = substitute(a:snip, '${\d\+.\{-}}\|$'.i.'\@!\d\+', '', 'g')
			while match(withoutOthers, '$'.i.'\(\D\|$\)') != -1
				let beforeMark = matchstr(withoutOthers, '^.\{-}\ze'.dots.'$'.i.'\(\D\|$\)')
				call add(snipPos[j][3], [0, 0])
				let snipPos[j][3][-1][0] = a:lnum + s:Count(beforeMark, "\n")
				let snipPos[j][3][-1][1] = a:indent + (snipPos[j][3][-1][0] > a:lnum
				                           \ ? len(matchstr(beforeMark, '.*\n\zs.*'))
				                           \ : a:col + len(beforeMark))
				let withoutOthers = substitute(withoutOthers, '$'.i.'\ze\(\D\|$\)', '', '')
			endw
		endif
		let i += 1
	endw
	return [snipPos, i - 1]
endf

fun snipMate#jumpTabStop(backwards)
	let leftPlaceholder = exists('s:origWordLen')
	                      \ && s:origWordLen != g:snipPos[s:curPos][2]
	if leftPlaceholder && exists('s:oldEndCol')
		let startPlaceholder = s:oldEndCol + 1
	endif

	if exists('s:update')
		call s:UpdatePlaceholderTabStops()
	else
		call s:UpdateTabStops()
	endif

	" Don't reselect placeholder if it has been modified
	if leftPlaceholder && g:snipPos[s:curPos][2] != -1
		if exists('startPlaceholder')
			let g:snipPos[s:curPos][1] = startPlaceholder
		else
			let g:snipPos[s:curPos][1] = col('.')
			let g:snipPos[s:curPos][2] = 0
		endif
	endif

	let s:curPos += a:backwards ? -1 : 1
	" Loop over the snippet when going backwards from the beginning
	if s:curPos < 0 | let s:curPos = s:snipLen - 1 | endif

	if s:curPos == s:snipLen
		let sMode = s:endCol == g:snipPos[s:curPos-1][1]+g:snipPos[s:curPos-1][2]
		call s:RemoveSnippet()
		return sMode ? "\<tab>" : TriggerSnippet()
	endif

	call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])

	let s:endLine = g:snipPos[s:curPos][0]
	let s:endCol = g:snipPos[s:curPos][1]
	let s:prevLen = [line('$'), col('$')]

	return g:snipPos[s:curPos][2] == -1 ? '' : s:SelectWord()
endf

fun s:UpdatePlaceholderTabStops()
	let changeLen = s:origWordLen - g:snipPos[s:curPos][2]
	unl s:startCol s:origWordLen s:update
	if !exists('s:oldVars') | return | endif
	" Update tab stops in snippet if text has been added via "$#"
	" (e.g., in "${1:foo}bar$1${2}").
	if changeLen != 0
		let curLine = line('.')

		for pos in g:snipPos
			if pos == g:snipPos[s:curPos] | continue | endif
			let changed = pos[0] == curLine && pos[1] > s:oldEndCol
			let changedVars = 0
			let endPlaceholder = pos[2] - 1 + pos[1]
			" Subtract changeLen from each tab stop that was after any of
			" the current tab stop's placeholders.
			for [lnum, col] in s:oldVars
				if lnum > pos[0] | break | endif
				if pos[0] == lnum
					if pos[1] > col || (pos[2] == -1 && pos[1] == col)
						let changed += 1
					elseif col < endPlaceholder
						let changedVars += 1
					endif
				endif
			endfor
			let pos[1] -= changeLen * changed
			let pos[2] -= changeLen * changedVars " Parse variables within placeholders
                                                  " e.g., "${1:foo} ${2:$1bar}"

			if pos[2] == -1 | continue | endif
			" Do the same to any placeholders in the other tab stops.
			for nPos in pos[3]
				let changed = nPos[0] == curLine && nPos[1] > s:oldEndCol
				for [lnum, col] in s:oldVars
					if lnum > nPos[0] | break | endif
					if nPos[0] == lnum && nPos[1] > col
						let changed += 1
					endif
				endfor
				let nPos[1] -= changeLen * changed
			endfor
		endfor
	endif
	unl s:endCol s:oldVars s:oldEndCol
endf

fun s:UpdateTabStops()
	let changeLine = s:endLine - g:snipPos[s:curPos][0]
	let changeCol = s:endCol - g:snipPos[s:curPos][1]
	if exists('s:origWordLen')
		let changeCol -= s:origWordLen
		unl s:origWordLen
	endif
	let lnum = g:snipPos[s:curPos][0]
	let col = g:snipPos[s:curPos][1]
	" Update the line number of all proceeding tab stops if <cr> has
	" been inserted.
	if changeLine != 0
		let changeLine -= 1
		for pos in g:snipPos
			if pos[0] >= lnum
				if pos[0] == lnum | let pos[1] += changeCol | endif
				let pos[0] += changeLine
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] >= lnum
					if nPos[0] == lnum | let nPos[1] += changeCol | endif
					let nPos[0] += changeLine
				endif
			endfor
		endfor
	elseif changeCol != 0
		" Update the column of all proceeding tab stops if text has
		" been inserted/deleted in the current line.
		for pos in g:snipPos
			if pos[1] >= col && pos[0] == lnum
				let pos[1] += changeCol
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] >= col
					let nPos[1] += changeCol
				endif
			endfor
		endfor
	endif
endf

fun s:SelectWord()
	let s:origWordLen = g:snipPos[s:curPos][2]
	let s:oldWord = strpart(getline('.'), g:snipPos[s:curPos][1] - 1,
				\ s:origWordLen)
	let s:prevLen[1] -= s:origWordLen
	if !empty(g:snipPos[s:curPos][3])
		let s:update = 1
		let s:endCol = -1
		let s:startCol = g:snipPos[s:curPos][1] - 1
	endif
	if !s:origWordLen | return '' | endif
	let l = col('.') != 1 ? 'l' : ''
	if &sel == 'exclusive'
		return "\<esc>".l.'v'.s:origWordLen."l\<c-g>"
	endif
	return s:origWordLen == 1 ? "\<esc>".l.'gh'
							\ : "\<esc>".l.'v'.(s:origWordLen - 1)."l\<c-g>"
endf

" This updates the snippet as you type when text needs to be inserted
" into multiple places (e.g. in "${1:default text}foo$1bar$1",
" "default text" would be highlighted, and if the user types something,
" UpdateChangedSnip() would be called so that the text after "foo" & "bar"
" are updated accordingly)
"
" It also automatically quits the snippet if the cursor is moved out of it
" while in insert mode.
fun s:UpdateChangedSnip(entering)
	if exists('g:snipPos') && bufnr(0) != s:lastBuf
		call s:RemoveSnippet()
	elseif exists('s:update') " If modifying a placeholder
		if !exists('s:oldVars') && s:curPos + 1 < s:snipLen
			" Save the old snippet & word length before it's updated
			" s:startCol must be saved too, in case text is added
			" before the snippet (e.g. in "foo$1${2}bar${1:foo}").
			let s:oldEndCol = s:startCol
			let s:oldVars = deepcopy(g:snipPos[s:curPos][3])
		endif
		let col = col('.') - 1

		if s:endCol != -1
			let changeLen = col('$') - s:prevLen[1]
			let s:endCol += changeLen
		else " When being updated the first time, after leaving select mode
			if a:entering | return | endif
			let s:endCol = col - 1
		endif

		" If the cursor moves outside the snippet, quit it
		if line('.') != g:snipPos[s:curPos][0] || col < s:startCol ||
					\ col - 1 > s:endCol
			unl! s:startCol s:origWordLen s:oldVars s:update
			return s:RemoveSnippet()
		endif

		call s:UpdateVars()
		let s:prevLen[1] = col('$')
	elseif exists('g:snipPos')
		if !a:entering && g:snipPos[s:curPos][2] != -1
			let g:snipPos[s:curPos][2] = -2
		endif

		let col = col('.')
		let lnum = line('.')
		let changeLine = line('$') - s:prevLen[0]

		if lnum == s:endLine
			let s:endCol += col('$') - s:prevLen[1]
			let s:prevLen = [line('$'), col('$')]
		endif
		if changeLine != 0
			let s:endLine += changeLine
			let s:endCol = col
		endif

		" Delete snippet if cursor moves out of it in insert mode
		if (lnum == s:endLine && (col > s:endCol || col < g:snipPos[s:curPos][1]))
			\ || lnum > s:endLine || lnum < g:snipPos[s:curPos][0]
			call s:RemoveSnippet()
		endif
	endif
endf

" This updates the variables in a snippet when a placeholder has been edited.
" (e.g., each "$1" in "${1:foo} $1bar $1bar")
fun s:UpdateVars()
	let newWordLen = s:endCol - s:startCol + 1
	let newWord = strpart(getline('.'), s:startCol, newWordLen)
	if newWord == s:oldWord || empty(g:snipPos[s:curPos][3])
		return
	endif

	let changeLen = g:snipPos[s:curPos][2] - newWordLen
	let curLine = line('.')
	let startCol = col('.')
	let oldStartSnip = s:startCol
	let updateTabStops = changeLen != 0
	let i = 0

	for [lnum, col] in g:snipPos[s:curPos][3]
		if updateTabStops
			let start = s:startCol
			if lnum == curLine && col <= start
				let s:startCol -= changeLen
				let s:endCol -= changeLen
			endif
			for nPos in g:snipPos[s:curPos][3][(i):]
				" This list is in ascending order, so quit if we've gone too far.
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] > col
					let nPos[1] -= changeLen
				endif
			endfor
			if lnum == curLine && col > start
				let col -= changeLen
				let g:snipPos[s:curPos][3][i][1] = col
			endif
			let i += 1
		endif

		" "Very nomagic" is used here to allow special characters.
		call setline(lnum, substitute(getline(lnum), '\%'.col.'c\V'.
						\ escape(s:oldWord, '\'), escape(newWord, '\&'), ''))
	endfor
	if oldStartSnip != s:startCol
		call cursor(0, startCol + s:startCol - oldStartSnip)
	endif

	let s:oldWord = newWord
	let g:snipPos[s:curPos][2] = newWordLen
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/bundle/snipmate.vim/autoload/snipMate.vim
" Helper function for (x)html snippets
if exists('s:did_snip_helper') || &cp || !exists('loaded_snips')
	finish
endif
let s:did_snip_helper = 1

" Automatically closes tag if in xhtml
fun! Close()
	return stridx(&ft, 'xhtml') == -1 ? '' : ' /'
endf
zhimakaimen:/bundle/snipmate.vim/ftplugin/html_snip_helper.vim
This is a mirror of http://www.vim.org/scripts/script.php?script_id=273

The "Tag List" plugin is a source code browser plugin for Vim and
provides an overview of the structure of source code files and allows
you to efficiently browse through source code files for different
programming languages.  You can visit the taglist plugin home page for
more information:

      http://vim-taglist.sourceforge.net

You can subscribe to the taglist mailing list to post your questions
or suggestions for improvement or to report bugs. Visit the following
page for subscribing to the mailing list:

      http://groups.yahoo.com/group/taglist/

For more information about using this plugin, after installing the
taglist plugin, use the ":help taglist" command.
zhimakaimen:/bundle/taglist.vim/README
'Tlist_Auto_Highlight_Tag'	taglist.txt	/*'Tlist_Auto_Highlight_Tag'*
'Tlist_Auto_Open'	taglist.txt	/*'Tlist_Auto_Open'*
'Tlist_Auto_Update'	taglist.txt	/*'Tlist_Auto_Update'*
'Tlist_Close_On_Select'	taglist.txt	/*'Tlist_Close_On_Select'*
'Tlist_Compact_Format'	taglist.txt	/*'Tlist_Compact_Format'*
'Tlist_Ctags_Cmd'	taglist.txt	/*'Tlist_Ctags_Cmd'*
'Tlist_Display_Prototype'	taglist.txt	/*'Tlist_Display_Prototype'*
'Tlist_Display_Tag_Scope'	taglist.txt	/*'Tlist_Display_Tag_Scope'*
'Tlist_Enable_Fold_Column'	taglist.txt	/*'Tlist_Enable_Fold_Column'*
'Tlist_Exit_OnlyWindow'	taglist.txt	/*'Tlist_Exit_OnlyWindow'*
'Tlist_File_Fold_Auto_Close'	taglist.txt	/*'Tlist_File_Fold_Auto_Close'*
'Tlist_GainFocus_On_ToggleOpen'	taglist.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
'Tlist_Highlight_Tag_On_BufEnter'	taglist.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
'Tlist_Inc_Winwidth'	taglist.txt	/*'Tlist_Inc_Winwidth'*
'Tlist_Max_Submenu_Items'	taglist.txt	/*'Tlist_Max_Submenu_Items'*
'Tlist_Max_Tag_Length'	taglist.txt	/*'Tlist_Max_Tag_Length'*
'Tlist_Process_File_Always'	taglist.txt	/*'Tlist_Process_File_Always'*
'Tlist_Show_Menu'	taglist.txt	/*'Tlist_Show_Menu'*
'Tlist_Show_One_File'	taglist.txt	/*'Tlist_Show_One_File'*
'Tlist_Sort_Type'	taglist.txt	/*'Tlist_Sort_Type'*
'Tlist_Use_Horiz_Window'	taglist.txt	/*'Tlist_Use_Horiz_Window'*
'Tlist_Use_Right_Window'	taglist.txt	/*'Tlist_Use_Right_Window'*
'Tlist_Use_SingleClick'	taglist.txt	/*'Tlist_Use_SingleClick'*
'Tlist_WinHeight'	taglist.txt	/*'Tlist_WinHeight'*
'Tlist_WinWidth'	taglist.txt	/*'Tlist_WinWidth'*
:TlistAddFiles	taglist.txt	/*:TlistAddFiles*
:TlistAddFilesRecursive	taglist.txt	/*:TlistAddFilesRecursive*
:TlistClose	taglist.txt	/*:TlistClose*
:TlistDebug	taglist.txt	/*:TlistDebug*
:TlistHighlightTag	taglist.txt	/*:TlistHighlightTag*
:TlistLock	taglist.txt	/*:TlistLock*
:TlistMessages	taglist.txt	/*:TlistMessages*
:TlistOpen	taglist.txt	/*:TlistOpen*
:TlistSessionLoad	taglist.txt	/*:TlistSessionLoad*
:TlistSessionSave	taglist.txt	/*:TlistSessionSave*
:TlistShowPrototype	taglist.txt	/*:TlistShowPrototype*
:TlistShowTag	taglist.txt	/*:TlistShowTag*
:TlistToggle	taglist.txt	/*:TlistToggle*
:TlistUndebug	taglist.txt	/*:TlistUndebug*
:TlistUnlock	taglist.txt	/*:TlistUnlock*
:TlistUpdate	taglist.txt	/*:TlistUpdate*
Tlist_Get_Tag_Prototype_By_Line()	taglist.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tagname_By_Line()	taglist.txt	/*Tlist_Get_Tagname_By_Line()*
Tlist_Set_App()	taglist.txt	/*Tlist_Set_App()*
Tlist_Update_File_Tags()	taglist.txt	/*Tlist_Update_File_Tags()*
taglist-commands	taglist.txt	/*taglist-commands*
taglist-debug	taglist.txt	/*taglist-debug*
taglist-extend	taglist.txt	/*taglist-extend*
taglist-faq	taglist.txt	/*taglist-faq*
taglist-functions	taglist.txt	/*taglist-functions*
taglist-install	taglist.txt	/*taglist-install*
taglist-internet	taglist.txt	/*taglist-internet*
taglist-intro	taglist.txt	/*taglist-intro*
taglist-keys	taglist.txt	/*taglist-keys*
taglist-license	taglist.txt	/*taglist-license*
taglist-menu	taglist.txt	/*taglist-menu*
taglist-options	taglist.txt	/*taglist-options*
taglist-requirements	taglist.txt	/*taglist-requirements*
taglist-session	taglist.txt	/*taglist-session*
taglist-todo	taglist.txt	/*taglist-todo*
taglist-using	taglist.txt	/*taglist-using*
taglist.txt	taglist.txt	/*taglist.txt*
zhimakaimen:/bundle/taglist.vim/doc/tags
*taglist.txt*	Plugin for browsing source code

Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
For Vim version 6.0 and above
Last change: 2007 May 24

1. Overview 					|taglist-intro|
2. Taglist on the internet			|taglist-internet|
3. Requirements					|taglist-requirements|
4. Installation 				|taglist-install|
5. Usage 					|taglist-using|
6. Options 					|taglist-options|
7. Commands 					|taglist-commands|
8. Global functions 				|taglist-functions|
9. Extending 					|taglist-extend|
10. FAQ 					|taglist-faq|
11. License 					|taglist-license|
12. Todo					|taglist-todo|

==============================================================================
						*taglist-intro*
1. Overview~

The "Tag List" plugin is a source code browser plugin for Vim. This plugin
allows you to efficiently browse through source code files for different
programming languages. The "Tag List" plugin provides the following features:

    * Displays the tags (functions, classes, structures, variables, etc.) 
      defined in a file in a vertically or horizontally split Vim window.
    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
      in the popup menu.
    * Automatically updates the taglist window as you switch between
      files/buffers. As you open new files, the tags defined in the new files
      are added to the existing file list and the tags defined in all the
      files are displayed grouped by the filename.
    * When a tag name is selected from the taglist window, positions the
      cursor at the definition of the tag in the source file.
    * Automatically highlights the current tag name.
    * Groups the tags by their type and displays them in a foldable tree.
    * Can display the prototype and scope of a tag.
    * Can optionally display the tag prototype instead of the tag name in the
      taglist window.
    * The tag list can be sorted either by name or by chronological order.
    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
      SML, Sql, TCL, Verilog, Vim and Yacc.
    * Can be easily extended to support new languages. Support for
      existing languages can be modified easily.
    * Provides functions to display the current tag name in the Vim status
      line or the window title bar.
    * The list of tags and files in the taglist can be saved and
      restored across Vim sessions.
    * Provides commands to get the name and prototype of the current tag.
    * Runs in both console/terminal and GUI versions of Vim.
    * Works with the winmanager plugin. Using the winmanager plugin, you
      can use Vim plugins like the file explorer, buffer explorer and the
      taglist plugin at the same time like an IDE.
    * Can be used in both Unix and MS-Windows systems.

==============================================================================
						*taglist-internet*
2. Taglist on the internet~

The home page of the taglist plugin is at:
>
	http://vim-taglist.sourceforge.net/
<
You can subscribe to the taglist mailing list to post your questions or
suggestions for improvement or to send bug reports. Visit the following page
for subscribing to the mailing list:
>
	http://groups.yahoo.com/group/taglist
<
==============================================================================
						*taglist-requirements*
3. Requirements~

The taglist plugin requires the following:

    * Vim version 6.0 and above
    * Exuberant ctags 5.0 and above

The taglist plugin will work on all the platforms where the exuberant ctags
utility and Vim are supported (this includes MS-Windows and Unix based
systems).

The taglist plugin relies on the exuberant ctags utility to dynamically
generate the tag listing.  The exuberant ctags utility must be installed in
your system to use this plugin.  The exuberant ctags utility is shipped with
most of the Linux distributions.  You can download the exuberant ctags utility
from
>
	http://ctags.sourceforge.net
<
The taglist plugin doesn't use or create a tags file and there is no need to
create a tags file to use this plugin. The taglist plugin will not work with
the GNU ctags or the Unix ctags utility.

This plugin relies on the Vim "filetype" detection mechanism to determine the
type of the current file. You have to turn on the Vim filetype detection by
adding the following line to your .vimrc file:
>
	filetype on
<
The taglist plugin will not work if you run Vim in the restricted mode (using
the -Z command-line argument).

The taglist plugin uses the Vim system() function to invoke the exuberant
ctags utility. If Vim is compiled without the system() function then you
cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
Vim without the system() function for security reasons.

==============================================================================
						*taglist-install*
4. Installation~

1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
   have the following two files (the directory structure should be preserved):

	plugin/taglist.vim - main taglist plugin file
	doc/taglist.txt    - documentation (help) file

   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
   details about installing Vim plugins.
2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
   directory, start Vim and run the ":helptags ." command to process the
   taglist help file. Without this step, you cannot jump to the taglist help
   topics.
3. If the exuberant ctags utility is not present in one of the directories in
   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
   point to the location of the exuberant ctags utility (not to the directory)
   in the .vimrc file.
4. If you are running a terminal/console version of Vim and the terminal
   doesn't support changing the window width then set the
   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
5. Restart Vim.
6. You can now use the ":TlistToggle" command to open/close the taglist
   window. You can use the ":help taglist" command to get more information
   about using the taglist plugin.

To uninstall the taglist plugin, remove the plugin/taglist.vim and
doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.

==============================================================================
						*taglist-using*
5. Usage~

The taglist plugin can be used in several different ways.

1. You can keep the taglist window open during the entire editing session. On
   opening the taglist window, the tags defined in all the files in the Vim
   buffer list will be displayed in the taglist window. As you edit files, the
   tags defined in them will be added to the taglist window. You can select a
   tag from the taglist window and jump to it. The current tag will be
   highlighted in the taglist window. You can close the taglist window when
   you no longer need the window.
2. You can configure the taglist plugin to process the tags defined in all the
   edited files always. In this configuration, even if the taglist window is
   closed and the taglist menu is not displayed, the taglist plugin will
   processes the tags defined in newly edited files. You can then open the
   taglist window only when you need to select a tag and then automatically
   close the taglist window after selecting the tag.
3. You can configure the taglist plugin to display only the tags defined in
   the current file in the taglist window. By default, the taglist plugin
   displays the tags defined in all the files in the Vim buffer list. As you
   switch between files, the taglist window will be refreshed to display only
   the tags defined in the current file.
4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
   taglist plugin to display the tags defined in the current file and select a
   tag to jump to it. You can use the menu without opening the taglist window.
   By default, the Tags menu is disabled.
5. You can configure the taglist plugin to display the name of the current tag
   in the Vim window status line or in the Vim window title bar. For this to
   work without the taglist window or menu, you need to configure the taglist
   plugin to process the tags defined in a file always.
6. You can save the tags defined in multiple files to a taglist session file
   and load it when needed. You can also configure the taglist plugin to not
   update the taglist window when editing new files. You can then manually add
   files to the taglist window.

Opening the taglist window~
You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
commands. The ":TlistOpen" command opens the taglist window and jumps to it.
The ":TlistToggle" command opens or closes (toggle) the taglist window and the
cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
variable is set to 1, then the ":TlistToggle" command opens the taglist window
and moves the cursor to the taglist window.

You can map a key to invoke these commands. For example, the following command
creates a normal mode mapping for the <F8> key to toggle the taglist window.
>
	nnoremap <silent> <F8> :TlistToggle<CR>
<
Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.

To automatically open the taglist window on Vim startup, set the
'Tlist_Auto_Open' variable to 1.

You can also open the taglist window on startup using the following command
line:
>
	$ vim +TlistOpen
<
Closing the taglist window~
You can close the taglist window from the taglist window by pressing 'q' or
using the Vim ":q" command. You can also use any of the Vim window commands to
close the taglist window. Invoking the ":TlistToggle" command when the taglist
window is opened, closes the taglist window. You can also use the
":TlistClose" command to close the taglist window.

To automatically close the taglist window when a tag or file is selected, you
can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.

Jumping to a tag or a file~
You can select a tag in the taglist window either by pressing the <Enter> key
or by double clicking the tag name using the mouse. To jump to a tag on a
single mouse click set the 'Tlist_Use_SingleClick' variable to 1.

If the selected file is already opened in a window, then the cursor is moved
to that window. If the file is not currently opened in a window then the file
is opened in the window used by the taglist plugin to show the previously
selected file. If there are no usable windows, then the file is opened in a
new window.  The file is not opened in special windows like the quickfix
window, preview window and windows containing buffer with the 'buftype' option
set.

To jump to the tag in a new window, press the 'o' key. To open the file in the
previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
to the tag but still keep the cursor in the taglist window (preview).

To open the selected file in a tab, use the 't' key.  If the file is already
present in a tab then the cursor is moved to that tab otherwise the file is
opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
window is automatically opened in the newly created tab.

Instead of jumping to a tag, you can open a file by pressing the <Enter> key
or by double clicking the file name using the mouse.

In the taglist window, you can use the [[ or <Backspace> key to jump to the
beginning of the previous file. You can use the ]] or <Tab> key to jump to the
beginning of the next file. When you reach the first or last file, the search
wraps around and the jumps to the next/previous file.

Highlighting the current tag~
The taglist plugin automatically highlights the name of the current tag in the
taglist window. The Vim |CursorHold| autocmd event is used for this. If the
current tag name is not visible in the taglist window, then the taglist window
contents are scrolled to make that tag name visible. You can also use the
":TlistHighlightTag" command to force the highlighting of the current tag.

The tag name is highlighted if no activity is performed for |'updatetime'|
milliseconds. The default value for this Vim option is 4 seconds. To avoid
unexpected problems, you should not set the |'updatetime'| option to a very
low value.

To disable the automatic highlighting of the current tag name in the taglist
window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.

When entering a Vim buffer/window, the taglist plugin automatically highlights
the current tag in that buffer/window.  If you like to disable the automatic
highlighting of the current tag when entering a buffer, set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero.

Adding files to the taglist~
When the taglist window is opened, all the files in the Vim buffer list are
processed and the supported files are added to the taglist.  When you edit a
file in Vim, the taglist plugin automatically processes this file and adds it
to the taglist. If you close the taglist window, the tag information in the
taglist is retained.

To process files even when the taglist window is not open, set the
'Tlist_Process_File_Always' variable to 1.

You can manually add multiple files to the taglist without opening them using
the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.

For example, to add all the C files in the /my/project/dir directory to the
taglist, you can use the following command:
>
	:TlistAddFiles /my/project/dir/*.c
<
Note that when adding several files with a large number of tags or a large
number of files, it will take several seconds to several minutes for the
taglist plugin to process all the files. You should not interrupt the taglist
plugin by pressing <CTRL-C>.

You can recursively add multiple files from a directory tree using the
":TlistAddFilesRecursive" command:
>
	:TlistAddFilesRecursive /my/project/dir *.c
<
This command takes two arguments. The first argument specifies the directory
from which to recursively add the files. The second optional argument
specifies the wildcard matching pattern for selecting the files to add. The
default pattern is * and all the files are added.

Displaying tags for only one file~
The taglist window displays the tags for all the files in the Vim buffer list
and all the manually added files. To display the tags for only the current
active buffer, set the 'Tlist_Show_One_File' variable to 1.

Removing files from the taglist~
You can remove a file from the taglist window, by pressing the 'd' key when the
cursor is on one of the tags listed for the file in the taglist window. The
removed file will no longer be displayed in the taglist window in the current
Vim session. To again display the tags for the file, open the file in a Vim
window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
to add the file to the taglist.

When a buffer is removed from the Vim buffer list using the ":bdelete" or the
":bwipeout" command, the taglist is updated to remove the stored information
for this buffer.

Updating the tags displayed for a file~
The taglist plugin keeps track of the modification time of a file. When the
modification time changes (the file is modified), the taglist plugin
automatically updates the tags listed for that file. The modification time of
a file is checked when you enter a window containing that file or when you
load that file.

You can also update or refresh the tags displayed for a file by pressing the
"u" key in the taglist window. If an existing file is modified, after the file
is saved, the taglist plugin automatically updates the tags displayed for the
file.

You can also use the ":TlistUpdate" command to update the tags for the current
buffer after you made some changes to it. You should save the modified buffer
before you update the taglist window. Otherwise the listed tags will not
include the new tags created in the buffer. 

If you have deleted the tags displayed for a file in the taglist window using
the 'd' key, you can again display the tags for that file using the
":TlistUpdate" command.

Controlling the taglist updates~
To disable the automatic processing of new files or modified files, you can
set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
zero, the taglist is updated only when you use the ":TlistUpdate" command or
the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
this option to control which files are added to the taglist.

You can use the ":TlistLock" command to lock the taglist contents. After this
command is executed, new files are not automatically added to the taglist.
When the taglist is locked, you can use the ":TlistUpdate" command to add the
current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
command.

Displaying the tag prototype~
To display the prototype of the tag under the cursor in the taglist window,
press the space bar. If you place the cursor on a tag name in the taglist
window, then the tag prototype is displayed at the Vim status line after
|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
option is 4 seconds.

You can get the name and prototype of a tag without opening the taglist window
and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
commands. These commands will work only if the current file is already present
in the taglist. To use these commands without opening the taglist window, set
the 'Tlist_Process_File_Always' variable to 1.

You can use the ":TlistShowTag" command to display the name of the tag at or
before the specified line number in the specified file.  If the file name and
line number are not supplied, then this command will display the name of the
current tag. For example,
>
	:TlistShowTag
	:TlistShowTag myfile.java 100
<
You can use the ":TlistShowPrototype" command to display the prototype of the
tag at or before the specified line number in the specified file.  If the file
name and the line number are not supplied, then this command will display the
prototype of the current tag.  For example,
>
	:TlistShowPrototype
	:TlistShowPrototype myfile.c 50
<
In the taglist window, when the mouse is moved over a tag name, the tag
prototype is displayed in a balloon. This works only in GUI versions where
balloon evaluation is supported.

Taglist window contents~
The taglist window contains the tags defined in various files in the taglist
grouped by the filename and by the tag type (variable, function, class, etc.).
For tags with scope information (like class members, structures inside
structures, etc.), the scope information is displayed in square brackets "[]"
after the tag name.

The contents of the taglist buffer/window are managed by the taglist plugin.
The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
|'modifiable'| option is turned off for the taglist buffer. You should not
manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
manually edit the taglist buffer contents, then the taglist plugin will be out
of sync with the taglist buffer contents and the plugin will no longer work
correctly. To redisplay the taglist buffer contents again, close the taglist
window and reopen it.

Opening and closing the tag and file tree~
In the taglist window, the tag names are displayed as a foldable tree using
the Vim folding support. You can collapse the tree using the '-' key or using
the Vim |zc| fold command. You can open the tree using the '+' key or using
the Vim |zo| fold command. You can open all the folds using the '*' key or
using the Vim |zR| fold command. You can also use the mouse to open/close the
folds. You can close all the folds using the '=' key. You should not manually
create or delete the folds in the taglist window.

To automatically close the fold for the inactive files/buffers and open only
the fold for the current buffer in the taglist window, set the
'Tlist_File_Fold_Auto_Close' variable to 1.

Sorting the tags for a file~
The tags displayed in the taglist window can be sorted either by their name or
by their chronological order. The default sorting method is by the order in
which the tags appear in a file. You can change the default sort method by
setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
sort the tags by their name by pressing the "s" key in the taglist window. You
can again sort the tags by their chronological order using the "s" key. Each
file in the taglist window can be sorted using different order.

Zooming in and out of the taglist window~
You can press the 'x' key in the taglist window to maximize the taglist
window width/height. The window will be maximized to the maximum possible
width/height without closing the other existing windows. You can again press
'x' to restore the taglist window to the default width/height.

						*taglist-session*
Taglist Session~
A taglist session refers to the group of files and their tags stored in the
taglist in a Vim session.

You can save and restore a taglist session (and all the displayed tags) using
the ":TlistSessionSave" and ":TlistSessionLoad" commands.

To save the information about the tags and files in the taglist to a file, use
the ":TlistSessionSave" command and specify the filename:
>
	:TlistSessionSave <file name>
<
To load a saved taglist session, use the ":TlistSessionLoad" command: >

	:TlistSessionLoad <file name>
<
When you load a taglist session file, the tags stored in the file will be
added to the tags already stored in the taglist.

The taglist session feature can be used to save the tags for large files or a
group of frequently used files (like a project). By using the taglist session
file, you can minimize the amount to time it takes to load/refresh the taglist
for multiple files.

You can create more than one taglist session file for multiple groups of
files.

Displaying the tag name in the Vim status line or the window title bar~
You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
plugin to display the current tag name in the Vim status line or the window
title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
function to display the current tag prototype in the Vim status line or the
window title bar.

For example, the following command can be used to display the current tag name
in the status line:
>
	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
<
The following command can be used to display the current tag name in the
window title bar:
>
	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
<
Note that the current tag name can be displayed only after the file is
processed by the taglist plugin. For this, you have to either set the
'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
the taglist menu. For more information about configuring the Vim status line,
refer to the documentation for the Vim |'statusline'| option.

Changing the taglist window highlighting~
The following Vim highlight groups are defined and used to highlight the
various entities in the taglist window:

    TagListTagName  - Used for tag names
    TagListTagScope - Used for tag scope
    TagListTitle    - Used for tag titles
    TagListComment  - Used for comments
    TagListFileName - Used for filenames

By default, these highlight groups are linked to the standard Vim highlight
groups. If you want to change the colors used for these highlight groups,
prefix the highlight group name with 'My' and define it in your .vimrc or
.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
MyTagListComment and MyTagListFileName.  For example, to change the colors
used for tag names, you can use the following command:
>
    :highlight MyTagListTagName guifg=blue ctermfg=blue
<
Controlling the taglist window~
To use a horizontally split taglist window, instead of a vertically split
window, set the 'Tlist_Use_Horiz_Window' variable to 1.

To use a vertically split taglist window on the rightmost side of the Vim
window, set the 'Tlist_Use_Right_Window' variable to 1.

You can specify the width of the vertically split taglist window, by setting
the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
split taglist window, by setting the 'Tlist_WinHeight' variable.

When opening a vertically split taglist window, the Vim window width is
increased to accommodate the new taglist window. When the taglist window is
closed, the Vim window is reduced. To disable this, set the
'Tlist_Inc_Winwidth' variable to zero.

To reduce the number of empty lines in the taglist window, set the
'Tlist_Compact_Format' variable to 1.

To not display the Vim fold column in the taglist window, set the
'Tlist_Enable_Fold_Column' variable to zero.

To display the tag prototypes instead of the tag names in the taglist window,
set the 'Tlist_Display_Prototype' variable to 1.

To not display the scope of the tags next to the tag names, set the
'Tlist_Display_Tag_Scope' variable to zero.

						*taglist-keys*
Taglist window key list~
The following table lists the description of the keys that can be used
in the taglist window.

  Key           Description~

  <CR>          Jump to the location where the tag under cursor is
                defined.
  o             Jump to the location where the tag under cursor is
                defined in a new window.
  P             Jump to the tag in the previous (Ctrl-W_p) window.
  p             Display the tag definition in the file window and
                keep the cursor in the taglist window itself.
  t             Jump to the tag in a new tab. If the file is already
                opened in a tab, move to that tab.
  Ctrl-t	Jump to the tag in a new tab.
  <Space>       Display the prototype of the tag under the cursor.
  		For file names, display the full path to the file,
		file type and the number of tags. For tag types, display the
		tag type and the number of tags.
  u             Update the tags listed in the taglist window
  s             Change the sort order of the tags (by name or by order)
  d             Remove the tags for the file under the cursor
  x             Zoom-in or Zoom-out the taglist window
  +             Open a fold
  -             Close a fold
  *             Open all folds
  =             Close all folds
  [[		Jump to the beginning of the previous file
  <Backspace>	Jump to the beginning of the previous file
  ]]		Jump to the beginning of the next file
  <Tab>		Jump to the beginning of the next file
  q             Close the taglist window
  <F1>          Display help

The above keys will work in both the normal mode and the insert mode.

						*taglist-menu*
Taglist menu~
When using GUI Vim, the taglist plugin can display the tags defined in the
current file in the drop-down menu and the popup menu. By default, this
feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
variable to 1.

You can jump to a tag by selecting the tag name from the menu. You can use the
taglist menu independent of the taglist window i.e. you don't need to open the
taglist window to get the taglist menu.

When you switch between files/buffers, the taglist menu is automatically
updated to display the tags defined in the current file/buffer.

The tags are grouped by their type (variables, functions, classes, methods,
etc.) and displayed as a separate sub-menu for each type. If all the tags
defined in a file are of the same type (e.g. functions), then the sub-menu is
not used.

If the number of items in a tag type submenu exceeds the value specified by
the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
The first and last tag names in the submenu are used to form the submenu name.
The menu items are prefixed by alpha-numeric characters for easy selection by
keyboard.

If the popup menu support is enabled (the |'mousemodel'| option contains
"popup"), then the tags menu is added to the popup menu. You can access
the popup menu by right clicking on the GUI window.

You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
You can sort the tags listed in the menu either by name or by order by
selecting the 'Tags->Sort menu by->Name/Order' menu entry.

You can tear-off the Tags menu and keep it on the side of the Vim window
for quickly locating the tags.

Using the taglist plugin with the winmanager plugin~
You can use the taglist plugin with the winmanager plugin. This will allow you
to use the file explorer, buffer explorer and the taglist plugin at the same
time in different windows. To use the taglist plugin with the winmanager
plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
to use the file explorer plugin and the taglist plugin at the same time, use
the following setting: >

	let winManagerWindowLayout = 'FileExplorer|TagList'
<
Getting help~
If you have installed the taglist help file (this file), then you can use the
Vim ":help taglist-<keyword>" command to get help on the various taglist
topics.

You can press the <F1> key in the taglist window to display the help
information about using the taglist window. If you again press the <F1> key,
the help information is removed from the taglist window.

						*taglist-debug*
Debugging the taglist plugin~
You can use the ":TlistDebug" command to enable logging of the debug messages
from the taglist plugin. To display the logged debug messages, you can use the
":TlistMessages" command. To disable the logging of the debug messages, use
the ":TlistUndebug" command.

You can specify a file name to the ":TlistDebug" command to log the debug
messages to a file. Otherwise, the debug messages are stored in a script-local
variable. In the later case, to minimize memory usage, only the last 3000
characters from the debug messages are stored.

==============================================================================
						*taglist-options*
6. Options~

A number of Vim variables control the behavior of the taglist plugin. These
variables are initialized to a default value. By changing these variables you
can change the behavior of the taglist plugin. You need to change these
settings only if you want to change the behavior of the taglist plugin. You
should use the |:let| command in your .vimrc file to change the setting of any
of these variables. 

The configurable taglist variables are listed below. For a detailed
description of these variables refer to the text below this table.

|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
				taglist.
|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
|'Tlist_Auto_Update'|		Automatically update the taglist to include
				newly edited files.
|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
				selected.
|'Tlist_Compact_Format'|	Remove extra information and blank lines from
       				the taglist window.
|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
				window.
|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
				window.
|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
|'Tlist_GainFocus_On_ToggleOpen'|
				Jump to taglist window on open.
|'Tlist_Highlight_Tag_On_BufEnter'|
				On entering a buffer, automatically highlight
				the current tag.
|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
				the taglist window.
|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
|'Tlist_Process_File_Always'|	Process files even when the taglist window is
				closed.
|'Tlist_Show_Menu'|		Display the tags menu.
|'Tlist_Show_One_File'|		Show tags for the current buffer only.
|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
				taglist window.
|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
|'Tlist_WinHeight'|		Horizontally split taglist window height.
|'Tlist_WinWidth'|		Vertically split taglist window width.

						*'Tlist_Auto_Highlight_Tag'*
Tlist_Auto_Highlight_Tag~
The taglist plugin will automatically highlight the current tag in the taglist
window. If you want to disable this, then you can set the
'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
tag highlighting is disabled, the tags for a new file will still be added to
the taglist window.
>
	let Tlist_Auto_Highlight_Tag = 0
<
With the above variable set to 1, you can use the ":TlistHighlightTag" command
to highlight the current tag.

						*'Tlist_Auto_Open'*
Tlist_Auto_Open~
To automatically open the taglist window, when you start Vim, you can set the
'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
the taglist window will not be opened automatically on Vim startup.
>
	let Tlist_Auto_Open = 1
<
The taglist window is opened only when a supported type of file is opened on
Vim startup. For example, if you open text files, then the taglist window will
not be opened.

						*'Tlist_Auto_Update'*
Tlist_Auto_Update~
When a new file is edited, the tags defined in the file are automatically
processed and added to the taglist. To stop adding new files to the taglist,
set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
to 1.
>
	let Tlist_Auto_Update = 0
<
With the above variable set to 1, you can use the ":TlistUpdate" command to
add the tags defined in the current file to the taglist.

						*'Tlist_Close_On_Select'*
Tlist_Close_On_Select~
If you want to close the taglist window when a file or tag is selected, then
set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
set zero and when you select a tag or file from the taglist window, the window
is not closed.
>
	let Tlist_Close_On_Select = 1
<
						*'Tlist_Compact_Format'*
Tlist_Compact_Format~
By default, empty lines are used to separate different tag types displayed for
a file and the tags displayed for different files in the taglist window. If
you want to display as many tags as possible in the taglist window, you can
set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
>
	let Tlist_Compact_Format = 1
<
						*'Tlist_Ctags_Cmd'*
Tlist_Ctags_Cmd~
The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
ctags utility. If exuberant ctags is present in any one of the directories in
the PATH environment variable, then there is no need to set this variable.

The exuberant ctags tool can be installed under different names.  When the
taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
the PATH environment variable.  If any one of the named executable is found,
then the Tlist_Ctags_Cmd variable is set to that name.

If exuberant ctags is not present in one of the directories specified in the
PATH environment variable, then set this variable to point to the location of
the ctags utility in your system. Note that this variable should point to the
fully qualified exuberant ctags location and NOT to the directory in which
exuberant ctags is installed. If the exuberant ctags tool is not found in
either PATH or in the specified location, then the taglist plugin will not be
loaded. Examples:
>
	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
<
						*'Tlist_Display_Prototype'*
Tlist_Display_Prototype~
By default, only the tag name will be displayed in the taglist window. If you
like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
variable to 1. By default, this variable is set to zero and only tag names
will be displayed.
>
	let Tlist_Display_Prototype = 1
<
						*'Tlist_Display_Tag_Scope'*
Tlist_Display_Tag_Scope~
By default, the scope of a tag (like a C++ class) will be displayed in
square brackets next to the tag name. If you don't want the tag scopes
to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
this variable is set to 1 and the tag scopes will be displayed.
>
	let Tlist_Display_Tag_Scope = 0
<
						*'Tlist_Enable_Fold_Column'*
Tlist_Enable_Fold_Column~
By default, the Vim fold column is enabled and displayed in the taglist
window. If you wish to disable this (for example, when you are working with a
narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
variable to zero.
>
	let Tlist_Enable_Fold_Column = 1
<
						*'Tlist_Exit_OnlyWindow'*
Tlist_Exit_OnlyWindow~
If you want to exit Vim if only the taglist window is currently opened, then
set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
set to zero and the Vim instance will not be closed if only the taglist window
is present.
>
	let Tlist_Exit_OnlyWindow = 1
<
						*'Tlist_File_Fold_Auto_Close'*
Tlist_File_Fold_Auto_Close~
By default, the tags tree displayed in the taglist window for all the files is
opened. You can close/fold the tags tree for the files manually. To
automatically close the tags tree for inactive files, you can set the
'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
the tags tree for the current buffer is automatically opened and for all the
other buffers is closed.
>
	let Tlist_File_Fold_Auto_Close = 1
<
					    *'Tlist_GainFocus_On_ToggleOpen'*
Tlist_GainFocus_On_ToggleOpen~
When the taglist window is opened using the ':TlistToggle' command, this
option controls whether the cursor is moved to the taglist window or remains
in the current window. By default, this option is set to 0 and the cursor
remains in the current window. When this variable is set to 1, the cursor
moves to the taglist window after opening the taglist window.
>
	let Tlist_GainFocus_On_ToggleOpen = 1
<
					    *'Tlist_Highlight_Tag_On_BufEnter'*
Tlist_Highlight_Tag_On_BufEnter~
When you enter a Vim buffer/window, the current tag in that buffer/window is
automatically highlighted in the taglist window. If the current tag name is
not visible in the taglist window, then the taglist window contents are
scrolled to make that tag name visible. If you like to disable the automatic
highlighting of the current tag when entering a buffer, you can set the
'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
this variable is 1.
>
	let Tlist_Highlight_Tag_On_BufEnter = 0
<
						*'Tlist_Inc_Winwidth'*
Tlist_Inc_Winwidth~
By default, when the width of the window is less than 100 and a new taglist
window is opened vertically, then the window width is increased by the value
set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
of this variable is used only if you are using a vertically split taglist
window.

If your terminal doesn't support changing the window width from Vim (older
version of xterm running in a Unix system) or if you see any weird problems in
the screen due to the change in the window width or if you prefer not to
adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
window then you must set this variable to zero, otherwise the system may hang
due to a Vim limitation (explained in :help win32-problems)
>
	let Tlist_Inc_Winwidth = 0
<
						*'Tlist_Max_Submenu_Items'*
Tlist_Max_Submenu_Items~
If a file contains too many tags of a particular type (function, variable,
class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
variable, then the menu for that tag type will be split into multiple
sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
>
	let Tlist_Max_Submenu_Items = 20
<
The name of the submenu is formed using the names of the first and the last
tag entries in that submenu.

						*'Tlist_Max_Tag_Length'*
Tlist_Max_Tag_Length~
Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
used to form the tag type submenu name. The default value for this variable is
10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
less characters:
>
	let Tlist_Max_Tag_Length = 10
<
						*'Tlist_Process_File_Always'*
Tlist_Process_File_Always~
By default, the taglist plugin will generate and process the tags defined in
the newly opened files only when the taglist window is opened or when the
taglist menu is enabled. When the taglist window is closed, the taglist plugin
will stop processing the tags for newly opened files.

You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
of tags for new files even when the taglist window is closed and the taglist
menu is disabled.
>
	let Tlist_Process_File_Always = 1
<
To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
taglist window and the taglist menu, you should set this variable to 1.

						*'Tlist_Show_Menu'*
Tlist_Show_Menu~
When using GUI Vim, you can display the tags defined in the current file in a
menu named "Tags". By default, this feature is turned off. To turn on this
feature, set the 'Tlist_Show_Menu' variable to 1:
>
	let Tlist_Show_Menu = 1
<
						*'Tlist_Show_One_File'*
Tlist_Show_One_File~
By default, the taglist plugin will display the tags defined in all the loaded
buffers in the taglist window. If you prefer to display the tags defined only
in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
this variable is set to 1, as you switch between buffers, the taglist window
will be refreshed to display the tags for the current buffer and the tags for
the previous buffer will be removed.
>
	let Tlist_Show_One_File = 1
<
						*'Tlist_Sort_Type'*
Tlist_Sort_Type~
The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
taglist window. The tags can be sorted either alphabetically by their name or
by the order of their appearance in the file (chronological order). By
default, the tag names will be listed by the order in which they are defined
in the file. You can change the sort type (from name to order or from order to
name) by pressing the "s" key in the taglist window. You can also change the
default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
>
	let Tlist_Sort_Type = "name"
<
						*'Tlist_Use_Horiz_Window'*
Tlist_Use_Horiz_Window~
Be default, the tag names are displayed in a vertically split window. If you
prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
command window, then you should use a horizontally split window instead of a
vertically split window. Also, if you are using an older version of xterm in a
Unix system that doesn't support changing the xterm window width, you should
use a horizontally split window.
>
	let Tlist_Use_Horiz_Window = 1
<
						*'Tlist_Use_Right_Window'*
Tlist_Use_Right_Window~
By default, the vertically split taglist window will appear on the left hand
side. If you prefer to open the window on the right hand side, you can set the
'Tlist_Use_Right_Window' variable to 1:
>
	let Tlist_Use_Right_Window = 1
<
						*'Tlist_Use_SingleClick'*
Tlist_Use_SingleClick~
By default, when you double click on the tag name using the left mouse 
button, the cursor will be positioned at the definition of the tag. You 
can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
you single click on the tag name using the mouse. By default this variable
is set to zero.
>
	let Tlist_Use_SingleClick = 1
<
Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
the taglist window using the mouse, then Vim will crash. This problem is fixed
in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
using the mouse, you can use normal Vim window resizing commands to resize the
taglist window.

						*'Tlist_WinHeight'*
Tlist_WinHeight~
The default height of the horizontally split taglist window is 10. This can be
changed by modifying the 'Tlist_WinHeight' variable:
>
	let Tlist_WinHeight = 20
<
The |'winfixheight'| option is set for the taglist window, to maintain the
height of the taglist window, when new Vim windows are opened and existing
windows are closed.

						*'Tlist_WinWidth'*
Tlist_WinWidth~
The default width of the vertically split taglist window is 30. This can be
changed by modifying the 'Tlist_WinWidth' variable:
>
	let Tlist_WinWidth = 20
<
Note that the value of the |'winwidth'| option setting determines the minimum
width of the current window. If you set the 'Tlist_WinWidth' variable to a
value less than that of the |'winwidth'| option setting, then Vim will use the
value of the |'winwidth'| option.

When new Vim windows are opened and existing windows are closed, the taglist
plugin will try to maintain the width of the taglist window to the size
specified by the 'Tlist_WinWidth' variable.

==============================================================================
						*taglist-commands*
7. Commands~

The taglist plugin provides the following ex-mode commands:

|:TlistAddFiles|	Add multiple files to the taglist.
|:TlistAddFilesRecursive|
			Add files recursively to the taglist.
|:TlistClose|		Close the taglist window.
|:TlistDebug|		Start logging of taglist debug messages.
|:TlistLock|		Stop adding new files to the taglist.
|:TlistMessages|	Display the logged taglist plugin debug messages.
|:TlistOpen|		Open and jump to the taglist window.
|:TlistSessionSave|	Save the information about files and tags in the
			taglist to a session file.
|:TlistSessionLoad|	Load the information about files and tags stored
			in a session file to taglist.
|:TlistShowPrototype|	Display the prototype of the tag at or before the
		    	specified line number.
|:TlistShowTag|		Display the name of the tag defined at or before the
			specified line number.
|:TlistHighlightTag|	Highlight the current tag in the taglist window.
|:TlistToggle|		Open or close (toggle) the taglist window.
|:TlistUndebug|		Stop logging of taglist debug messages.
|:TlistUnlock|		Start adding new files to the taglist.
|:TlistUpdate|		Update the tags for the current buffer.

						*:TlistAddFiles*
:TlistAddFiles {file(s)} [file(s) ...]
		Add one or more specified files to the taglist. You can
		specify multiple filenames using wildcards. To specify a
		file name with space character, you should escape the space
		character with a backslash.
		Examples:
>
		    :TlistAddFiles *.c *.cpp
		    :TlistAddFiles file1.html file2.html
<
		If you specify a large number of files, then it will take some
		time for the taglist plugin to process all of them. The
		specified files will not be edited in a Vim window and will
		not be added to the Vim buffer list.

						*:TlistAddFilesRecursive*
:TlistAddFilesRecursive {directory} [ {pattern} ]
		Add files matching {pattern} recursively from the specified
		{directory} to the taglist. If {pattern} is not specified,
		then '*' is assumed. To specify the current directory, use "."
		for {directory}. To specify a directory name with space
		character, you should escape the space character with a
		backslash.
		Examples:
>
		    :TlistAddFilesRecursive myproject *.java
		    :TlistAddFilesRecursive smallproject
<
		If large number of files are present in the specified
		directory tree, then it will take some time for the taglist
		plugin to process all of them.

						*:TlistClose*
:TlistClose	Close the taglist window. This command can be used from any
		one of the Vim windows.

						*:TlistDebug*
:TlistDebug [filename]
		Start logging of debug messages from the taglist plugin.
		If {filename} is specified, then the debug messages are stored
		in the specified file. Otherwise, the debug messages are
		stored in a script local variable. If the file {filename} is
		already present, then it is overwritten.

						*:TlistLock*
:TlistLock
		Lock the taglist and don't process new files. After this
		command is executed, newly edited files will not be added to
		the taglist.

						*:TlistMessages*
:TlistMessages
		Display the logged debug messages from the taglist plugin
		in a window.  This command works only when logging to a
		script-local variable.

						*:TlistOpen*
:TlistOpen	Open and jump to the taglist window. Creates the taglist
		window, if the window is not opened currently. After executing
		this command, the cursor is moved to the taglist window.  When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags defined in them
		are displayed in the taglist window.

						*:TlistSessionSave*
:TlistSessionSave {filename}
		Saves the information about files and tags in the taglist to
		the specified file. This command can be used to save and
		restore the taglist contents across Vim sessions.

						*:TlistSessionLoad*
:TlistSessionLoad {filename}
		Load the information about files and tags stored in the
		specified session file to the taglist.

						*:TlistShowPrototype*
:TlistShowPrototype [filename] [linenumber]
		Display the prototype of the tag at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the prototype for the tag for any line number in this
		range. 

						*:TlistShowTag*
:TlistShowTag [filename] [linenumber]
		Display the name of the tag defined at or before the specified
		line number. If the file name and the line number are not
		specified, then the current file name and line number are
		used. A tag spans multiple lines starting from the line where
		it is defined to the line before the next tag. This command
		displays the tag name for any line number in this range. 

						*:TlistHighlightTag*
:TlistHighlightTag
		Highlight the current tag in the taglist window. By default,
		the taglist plugin periodically updates the taglist window to
		highlight the current tag. This command can be used to force
		the taglist plugin to highlight the current tag.

						*:TlistToggle*
:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
		window, if the window is not opened currently. Closes the
		taglist window, if the taglist window is already opened. When
		the taglist window is opened for the first time, all the files
		in the buffer list are processed and the tags are displayed in
		the taglist window. After executing this command, the cursor
		is not moved from the current window to the taglist window.

						*:TlistUndebug*
:TlistUndebug
		Stop logging of debug messages from the taglist plugin.

						*:TlistUnlock*
:TlistUnlock
		Unlock the taglist and start processing newly edited files.

						*:TlistUpdate*
:TlistUpdate	Update the tags information for the current buffer. This
		command can be used to re-process the current file/buffer and
		get the tags information. As the taglist plugin uses the file
		saved in the disk (instead of the file displayed in a Vim
		buffer), you should save a modified buffer before you update
		the taglist. Otherwise the listed tags will not include the
		new tags created in the buffer. You can use this command even
		when the taglist window is not opened.

==============================================================================
						*taglist-functions*
8. Global functions~

The taglist plugin provides several global functions that can be used from
other Vim plugins to interact with the taglist plugin. These functions are
described below.

|Tlist_Update_File_Tags()|		Update the tags for the specified file
|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
				    	before the specified line number in the
				    	specified file.
|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
					before the specified line number in
					the specified file.
|Tlist_Set_App()|			Set the name of the application
					controlling the taglist window.

					    *Tlist_Update_File_Tags()*
Tlist_Update_File_Tags({filename}, {filetype})
		Update the tags for the file {filename}. The second argument
		specifies the Vim filetype for the file. If the taglist plugin
		has not processed the file previously, then the exuberant
		ctags tool is invoked to generate the tags for the file.

					    *Tlist_Get_Tag_Prototype_By_Line()*
Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
		Return the prototype of the tag at or before the specified
		line number in the specified file. If the filename and line
		number are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Get_Tagname_By_Line()*
Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
		Return the name of the tag at or before the specified line
		number in the specified file. If the filename and line number
		are not specified, then the current buffer name and the
		current line number are used.

					    *Tlist_Set_App()*
Tlist_Set_App({appname})
		Set the name of the plugin that controls the taglist plugin
		window and buffer. This can be used to integrate the taglist
		plugin with other Vim plugins.
		
		For example, the winmanager plugin and the Cream package use
		this function and specify the appname as "winmanager" and
		"cream" respectively.
		
		By default, the taglist plugin is a stand-alone plugin and
		controls the taglist window and buffer. If the taglist window
		is controlled by an external plugin, then the appname should
		be set appropriately.

==============================================================================
						*taglist-extend*
9. Extending~

The taglist plugin supports all the languages supported by the exuberant ctags
tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
TCL, Verilog, Vim and Yacc.

You can extend the taglist plugin to add support for new languages and also
modify the support for the above listed languages.

You should NOT make modifications to the taglist plugin script file to add
support for new languages. You will lose these changes when you upgrade to the
next version of the taglist plugin. Instead you should follow the below
described instructions to extend the taglist plugin.

You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
file. The name of these variables depends on the language name and is
described below.

Modifying support for an existing language~
To modify the support for an already supported language, you have to set the
tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
with the Vim filetype name for the language file.  For example, to modify the
support for the perl language files, you have to set the tlist_perl_settings
variable. To modify the support for java files, you have to set the
tlist_java_settings variable.

To determine the filetype name used by Vim for a file, use the following
command in the buffer containing the file:

	:set filetype

The above command will display the Vim filetype for the current buffer.

The format of the value set in the tlist_xxx_settings variable is

    <language_name>;flag1:name1;flag2:name2;flag3:name3

The different fields in the value are separated by the ';' character.

The first field 'language_name' is the name used by exuberant ctags to refer
to this language file. This name can be different from the file type name used
by Vim. For example, for C++, the language name used by ctags is 'c++' but the
filetype name used by Vim is 'cpp'. To get the list of language names
supported by exuberant ctags, use the following command:

	$ ctags --list-maps=all

The remaining fields follow the format "flag:name". The sub-field 'flag' is
the language specific flag used by exuberant ctags to generate the
corresponding tags. For example, for the C language, to list only the
functions, the 'f' flag is used. To get the list of flags supported by
exuberant ctags for the various languages use the following command:

	$ ctags --list-kinds=all

The sub-field 'name' specifies the title text to use for displaying the tags
of a particular type. For example, 'name' can be set to 'functions'. This
field can be set to any text string name.

For example, to list only the classes and functions defined in a C++ language
file, add the following line to your .vimrc file:

	let tlist_cpp_settings = 'c++;c:class;f:function'

In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
exuberant ctags to list C++ classes and functions and 'class' is the title
used for the class tags and 'function' is the title used for the function tags
in the taglist window.

For example, to display only functions defined in a C file and to use "My
Functions" as the title for the function tags, use

	let tlist_c_settings = 'c;f:My Functions'

When you set the tlist_xxx_settings variable, you will override the default
setting used by the taglist plugin for the 'xxx' language. You cannot add to
the default options used by the taglist plugin for a particular file type. To
add to the options used by the taglist plugin for a language, copy the option
values from the taglist plugin file to your .vimrc file and modify it.

Adding support for a new language~
If you want to add support for a new language to the taglist plugin, you need
to first extend the exuberant ctags tool. For more information about extending
exuberant ctags, visit the following page:

    http://ctags.sourceforge.net/EXTENDING.html

To add support for a new language, set the tlist_xxx_settings variable in the
~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
name with the Vim filetype name for the new language.

For example, to extend the taglist plugin to support the latex language, you
can use the following line (assuming, you have already extended exuberant
ctags to support the latex language):

	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'

With the above line, when you edit files of filetype "tex" in Vim, the taglist
plugin will invoke the exuberant ctags tool passing the "latex" filetype and
the flags b, c and l to generate the tags. The text heading 'bibitem',
'command' and 'label' will be used in the taglist window for the tags which
are generated for the flags b, c and l respectively.

==============================================================================
						*taglist-faq*
10. Frequently Asked Questions~

Q. The taglist plugin doesn't work. The taglist window is empty and the tags
   defined in a file are not displayed. 
A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
   features supported by Vim version 6.0 and above. You can use the following
   command to get the Vim version:
>
	$ vim --version
<
   Are you using exuberant ctags version 5.0 and above? The taglist plugin
   relies on the features supported by exuberant ctags and will not work with
   GNU ctags or the Unix ctags utility. You can use the following command to
   determine whether the ctags installed in your system is exuberant ctags:
>
	$ ctags --version
<
   Is exuberant ctags present in one of the directories in your PATH? If not,
   you need to set the Tlist_Ctags_Cmd variable to point to the location of
   exuberant ctags. Use the following Vim command to verify that this is setup
   correctly:
>
	:echo system(Tlist_Ctags_Cmd . ' --version')
<
   The above command should display the version information for exuberant
   ctags.

   Did you turn on the Vim filetype detection? The taglist plugin relies on
   the filetype detected by Vim and passes the filetype to the exuberant ctags
   utility to parse the tags. Check the output of the following Vim command:
>
	:filetype
<
   The output of the above command should contain "filetype detection:ON".
   To turn on the filetype detection, add the following line to the .vimrc or
   _vimrc file:
>
	filetype on
<
   Is your version of Vim compiled with the support for the system() function?
   The following Vim command should display 1:
>
	:echo exists('*system')
<
   In some Linux distributions (particularly Suse Linux), the default Vim
   installation is built without the support for the system() function. The
   taglist plugin uses the system() function to invoke the exuberant ctags
   utility. You need to rebuild Vim after enabling the support for the
   system() function. If you use the default build options, the system()
   function will be supported. 

   Do you have the |'shellslash'| option set? You can try disabling the
   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
   utility with the path to the file, if the incorrect slashes are used, then
   you will see errors.
   
   Check the shell related Vim options values using the following command:
>
	:set shell? shellcmdflag? shellpipe?
	:set shellquote? shellredir? shellxquote?
<
   If these options are set in your .vimrc or _vimrc file, try removing those
   lines.

   Are you using a Unix shell in a MS-Windows environment? For example,
   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
   set to point to this shell? You can try resetting the SHELL environment
   variable.

   If you are using a Unix shell on MS-Windows, you should try to use
   exuberant ctags that is compiled for Unix-like environments so that
   exuberant ctags will understand path names with forward slash characters.

   Is your filetype supported by the exuberant ctags utility? The file types
   supported by the exuberant ctags utility are listed in the ctags help. If a
   file type is not supported, you have to extend exuberant ctags. You can use
   the following command to list the filetypes supported by exuberant ctags:
>
	ctags --list-languages
<
   Run the following command from the shell prompt and check whether the tags
   defined in your file are listed in the output from exuberant ctags:
>
	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
<
   If you see your tags in the output from the above command, then the
   exuberant ctags utility is properly parsing your file.

   Do you have the .ctags or _ctags or the ctags.cnf file in your home
   directory for specifying default options or for extending exuberant ctags?
   If you do have this file, check the options in this file and make sure
   these options are not interfering with the operation of the taglist plugin.

   If you are using MS-Windows, check the value of the TEMP and TMP
   environment variables. If these environment variables are set to a path
   with space characters in the name, then try using the DOS 8.3 short name
   for the path or set them to a path without the space characters in the
   name. For example, if the temporary directory name is "C:\Documents and
   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
   the following:
>
	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
<
   If exuberant ctags is installed in a directory with space characters in the
   name, then try adding the directory to the PATH environment variable or try
   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
   or try copying the exuberant ctags to a path without space characters in
   the name. For example, if exuberant ctags is installed in the directory
   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
   as below:
>
	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
<
   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
   make sure that either you have the cygwin compiled sort utility installed
   and available in your PATH or compile exuberant ctags with internal sort
   support. Otherwise, when exuberant ctags sorts the tags output by invoking
   the sort utility, it may end up invoking the MS-Windows version of
   sort.exe, thereby resulting in failure.

Q. When I try to open the taglist window, I am seeing the following error
   message. How do I fix this problem?

   Taglist: Failed to generate tags for /my/path/to/file
   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...

A. The taglist plugin will work only with the exuberant ctags tool. You
   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
   You will see an error message similar to the one shown above, if you try
   use a non-exuberant ctags program with Vim. To fix this problem, either add
   the exuberant ctags tool location to the PATH environment variable or set
   the 'Tlist_Ctags_Cmd' variable.

Q. A file has more than one tag with the same name. When I select a tag name
   from the taglist window, the cursor is positioned at the incorrect tag
   location. 
A. The taglist plugin uses the search pattern generated by the exuberant ctags
   utility to position the cursor at the location of a tag definition. If a
   file has more than one tag with the same name and same prototype, then the
   search pattern will be the same. In this case, when searching for the tag
   pattern, the cursor may be positioned at the incorrect location. 

Q. I have made some modifications to my file and introduced new
   functions/classes/variables. I have not yet saved my file. The taglist
   plugin is not displaying the new tags when I update the taglist window.
A. The exuberant ctags utility will process only files that are present in the
   disk. To list the tags defined in a file, you have to save the file and
   then update the taglist window. 

Q. I have created a ctags file using the exuberant ctags utility for my source
   tree. How do I configure the taglist plugin to use this tags file? 
A. The taglist plugin doesn't use a tags file stored in disk. For every opened
   file, the taglist plugin invokes the exuberant ctags utility to get the
   list of tags dynamically. The Vim system() function is used to invoke
   exuberant ctags and get the ctags output. This function internally uses a
   temporary file to store the output. This file is deleted after the output
   from the command is read. So you will never see the file that contains the
   output of exuberant ctags.

Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
   I keep pressing a key with the taglist window open, the current buffer
   contents are changed. Why is this?
A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
   If the |'updatetime'| option is set to a low value, then the CursorHold
   autocmd will be triggered frequently. As the taglist plugin changes
   the focus to the taglist window to highlight the current tag, this could
   interfere with the key movement resulting in changing the contents of
   the current buffer. The workaround for this problem is to not set the
   |'updatetime'| option to a low value.

==============================================================================
						*taglist-license*
11. License~
Permission is hereby granted to use and distribute the taglist plugin, with or
without modifications, provided that this copyright notice is copied with it.
Like anything else that's free, taglist.vim is provided *as is* and comes with
no warranty of any kind, either expressed or implied. In no event will the
copyright holder be liable for any damamges resulting from the use of this
software.

==============================================================================
						*taglist-todo*
12. Todo~

1. Group tags according to the scope and display them. For example,
   group all the tags belonging to a C++/Java class 
2. Support for displaying tags in a modified (not-yet-saved) file. 
3. Automatically open the taglist window only for selected filetypes.
   For other filetypes, close the taglist window. 
4. When using the shell from the MKS toolkit, the taglist plugin 
   doesn't work.
5. The taglist plugin doesn't work with files edited remotely using the
   netrw plugin. The exuberant ctags utility cannot process files over
   scp/rcp/ftp, etc.

==============================================================================

vim:tw=78:ts=8:noet:ft=help:
zhimakaimen:/bundle/taglist.vim/doc/taglist.txt
" File: taglist.vim
" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
" Version: 4.5
" Last Modified: September 21, 2007
" Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
"            Permission is hereby granted to use and distribute this code,
"            with or without modifications, provided that this copyright
"            notice is copied with it. Like anything else that's free,
"            taglist.vim is provided *as is* and comes with no warranty of any
"            kind, either expressed or implied. In no event will the copyright
"            holder be liable for any damamges resulting from the use of this
"            software.
"
" The "Tag List" plugin is a source code browser plugin for Vim and provides
" an overview of the structure of the programming language files and allows
" you to efficiently browse through source code files for different
" programming languages.  You can visit the taglist plugin home page for more
" information:
"
"       http://vim-taglist.sourceforge.net
"
" You can subscribe to the taglist mailing list to post your questions
" or suggestions for improvement or to report bugs. Visit the following
" page for subscribing to the mailing list:
"
"       http://groups.yahoo.com/group/taglist/
"
" For more information about using this plugin, after installing the
" taglist plugin, use the ":help taglist" command.
"
" Installation
" ------------
" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
"    unzip the following two files (the directory structure should be
"    preserved):
"
"       plugin/taglist.vim - main taglist plugin file
"       doc/taglist.txt    - documentation (help) file
"
"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
"    Vim help pages for more details about installing Vim plugins.
" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
"    command to process the taglist help file.
" 3. If the exuberant ctags utility is not present in your PATH, then set the
"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
"    utility (not to the directory) in the .vimrc file.
" 4. If you are running a terminal/console version of Vim and the
"    terminal doesn't support changing the window width then set the
"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
" 5. Restart Vim.
" 6. You can now use the ":TlistToggle" command to open/close the taglist
"    window. You can use the ":help taglist" command to get more
"    information about using the taglist plugin.
"
" ****************** Do not modify after this line ************************

" Line continuation used here
let s:cpo_save = &cpo
set cpo&vim

if !exists('loaded_taglist')
    " First time loading the taglist plugin
    "
    " To speed up the loading of Vim, the taglist plugin uses autoload
    " mechanism to load the taglist functions.
    " Only define the configuration variables, user commands and some
    " auto-commands and finish sourcing the file

    " The taglist plugin requires the built-in Vim system() function. If this
    " function is not available, then don't load the plugin.
    if !exists('*system')
        echomsg 'Taglist: Vim system() built-in function is not available. ' .
                    \ 'Plugin is not loaded.'
        let loaded_taglist = 'no'
        let &cpo = s:cpo_save
        finish
    endif

    " Location of the exuberant ctags tool
    if !exists('Tlist_Ctags_Cmd')
        if executable('exuberant-ctags')
            " On Debian Linux, exuberant ctags is installed
            " as exuberant-ctags
            let Tlist_Ctags_Cmd = 'exuberant-ctags'
        elseif executable('exctags')
            " On Free-BSD, exuberant ctags is installed as exctags
            let Tlist_Ctags_Cmd = 'exctags'
        elseif executable('ctags')
            let Tlist_Ctags_Cmd = 'ctags'
        elseif executable('ctags.exe')
            let Tlist_Ctags_Cmd = 'ctags.exe'
        elseif executable('tags')
            let Tlist_Ctags_Cmd = 'tags'
        else
            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
                        \ 'not found in PATH. Plugin is not loaded.'
            " Skip loading the plugin
            let loaded_taglist = 'no'
            let &cpo = s:cpo_save
            finish
        endif
    endif


    " Automatically open the taglist window on Vim startup
    if !exists('Tlist_Auto_Open')
        let Tlist_Auto_Open = 0
    endif

    " When the taglist window is toggle opened, move the cursor to the
    " taglist window
    if !exists('Tlist_GainFocus_On_ToggleOpen')
        let Tlist_GainFocus_On_ToggleOpen = 0
    endif

    " Process files even when the taglist window is not open
    if !exists('Tlist_Process_File_Always')
        let Tlist_Process_File_Always = 0
    endif

    if !exists('Tlist_Show_Menu')
        let Tlist_Show_Menu = 0
    endif

    " Tag listing sort type - 'name' or 'order'
    if !exists('Tlist_Sort_Type')
        let Tlist_Sort_Type = 'order'
    endif

    " Tag listing window split (horizontal/vertical) control
    if !exists('Tlist_Use_Horiz_Window')
        let Tlist_Use_Horiz_Window = 0
    endif

    " Open the vertically split taglist window on the left or on the right
    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
    " zero (i.e.  only for vertically split windows)
    if !exists('Tlist_Use_Right_Window')
        let Tlist_Use_Right_Window = 0
    endif

    " Increase Vim window width to display vertically split taglist window.
    " For MS-Windows version of Vim running in a MS-DOS window, this must be
    " set to 0 otherwise the system may hang due to a Vim limitation.
    if !exists('Tlist_Inc_Winwidth')
        if (has('win16') || has('win95')) && !has('gui_running')
            let Tlist_Inc_Winwidth = 0
        else
            let Tlist_Inc_Winwidth = 1
        endif
    endif

    " Vertically split taglist window width setting
    if !exists('Tlist_WinWidth')
        let Tlist_WinWidth = 30
    endif

    " Horizontally split taglist window height setting
    if !exists('Tlist_WinHeight')
        let Tlist_WinHeight = 10
    endif

    " Display tag prototypes or tag names in the taglist window
    if !exists('Tlist_Display_Prototype')
        let Tlist_Display_Prototype = 0
    endif

    " Display tag scopes in the taglist window
    if !exists('Tlist_Display_Tag_Scope')
        let Tlist_Display_Tag_Scope = 1
    endif

    " Use single left mouse click to jump to a tag. By default this is disabled.
    " Only double click using the mouse will be processed.
    if !exists('Tlist_Use_SingleClick')
        let Tlist_Use_SingleClick = 0
    endif

    " Control whether additional help is displayed as part of the taglist or
    " not.  Also, controls whether empty lines are used to separate the tag
    " tree.
    if !exists('Tlist_Compact_Format')
        let Tlist_Compact_Format = 0
    endif

    " Exit Vim if only the taglist window is currently open. By default, this is
    " set to zero.
    if !exists('Tlist_Exit_OnlyWindow')
        let Tlist_Exit_OnlyWindow = 0
    endif

    " Automatically close the folds for the non-active files in the taglist
    " window
    if !exists('Tlist_File_Fold_Auto_Close')
        let Tlist_File_Fold_Auto_Close = 0
    endif

    " Close the taglist window when a tag is selected
    if !exists('Tlist_Close_On_Select')
        let Tlist_Close_On_Select = 0
    endif

    " Automatically update the taglist window to display tags for newly
    " edited files
    if !exists('Tlist_Auto_Update')
        let Tlist_Auto_Update = 1
    endif

    " Automatically highlight the current tag
    if !exists('Tlist_Auto_Highlight_Tag')
        let Tlist_Auto_Highlight_Tag = 1
    endif
    
    " Automatically highlight the current tag on entering a buffer
    if !exists('Tlist_Highlight_Tag_On_BufEnter')
        let Tlist_Highlight_Tag_On_BufEnter = 1
    endif

    " Enable fold column to display the folding for the tag tree
    if !exists('Tlist_Enable_Fold_Column')
        let Tlist_Enable_Fold_Column = 1
    endif

    " Display the tags for only one file in the taglist window
    if !exists('Tlist_Show_One_File')
        let Tlist_Show_One_File = 0
    endif

    if !exists('Tlist_Max_Submenu_Items')
        let Tlist_Max_Submenu_Items = 20
    endif

    if !exists('Tlist_Max_Tag_Length')
        let Tlist_Max_Tag_Length = 10
    endif

    " Do not change the name of the taglist title variable. The winmanager
    " plugin relies on this name to determine the title for the taglist
    " plugin.
    let TagList_title = "__Tag_List__"

    " Taglist debug messages
    let s:tlist_msg = ''

    " Define the taglist autocommand to automatically open the taglist window
    " on Vim startup
    if g:Tlist_Auto_Open
        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
    endif

    " Refresh the taglist
    if g:Tlist_Process_File_Always
        autocmd BufEnter * call s:Tlist_Refresh()
    endif

    if g:Tlist_Show_Menu
        autocmd GUIEnter * call s:Tlist_Menu_Init()
    endif

    " When the taglist buffer is created when loading a Vim session file,
    " the taglist buffer needs to be initialized. The BufFilePost event
    " is used to handle this case.
    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()

    " Define the user commands to manage the taglist window
    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
    " For backwards compatiblity define the Tlist command
    command! -nargs=0 -bar Tlist TlistToggle
    command! -nargs=+ -complete=file TlistAddFiles
                \  call s:Tlist_Add_Files(<f-args>)
    command! -nargs=+ -complete=dir TlistAddFilesRecursive
                \ call s:Tlist_Add_Files_Recursive(<f-args>)
    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
    " For backwards compatiblity define the TlistSync command
    command! -nargs=0 -bar TlistSync TlistHighlightTag
    command! -nargs=* -complete=buffer TlistShowPrototype
                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
    command! -nargs=* -complete=buffer TlistShowTag
                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
    command! -nargs=* -complete=file TlistSessionLoad
                \ call s:Tlist_Session_Load(<q-args>)
    command! -nargs=* -complete=file TlistSessionSave
                \ call s:Tlist_Session_Save(<q-args>)
    command! -bar TlistLock let Tlist_Auto_Update=0
    command! -bar TlistUnlock let Tlist_Auto_Update=1

    " Commands for enabling/disabling debug and to display debug messages
    command! -nargs=? -complete=file -bar TlistDebug
                \ call s:Tlist_Debug_Enable(<q-args>)
    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()

    " Define autocommands to autoload the taglist plugin when needed.

    " Trick to get the current script ID
    map <SID>xx <SID>xx
    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
                                \ '\1', '')
    unmap <SID>xx

    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined Tlist_* source ' .
                \ escape(expand('<sfile>'), ' ')
    exe 'autocmd FuncUndefined TagList_* source ' .
                \ escape(expand('<sfile>'), ' ')

    let loaded_taglist = 'fast_load_done'

    if g:Tlist_Show_Menu && has('gui_running')
        call s:Tlist_Menu_Init()
    endif

    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

if !exists('s:tlist_sid')
    " Two or more versions of taglist plugin are installed. Don't
    " load this version of the plugin.
    finish
endif

unlet! s:tlist_sid

if loaded_taglist != 'fast_load_done'
    " restore 'cpo'
    let &cpo = s:cpo_save
    finish
endif

" Taglist plugin functionality is available
let loaded_taglist = 'available'

"------------------- end of user configurable options --------------------

" Default language specific settings for supported file types and tag types
"
" Variable name format:
"
"       s:tlist_def_{vim_ftype}_settings
" 
" vim_ftype - Filetype detected by Vim
"
" Value format:
"
"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
"
" ctags_ftype - File type supported by exuberant ctags
" flag        - Flag supported by exuberant ctags to generate a tag type
" name        - Name of the tag type used in the taglist window to display the
"               tags of this type
"

" assembly language
let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'

" aspperl language
let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'

" aspvbs language
let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'

" awk language
let s:tlist_def_awk_settings = 'awk;f:function'

" beta language
let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'

" c language
let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
                           \ 'v:variable;f:function'

" c++ language
let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
                             \ 'c:class;g:enum;s:struct;u:union;f:function'

" c# language
let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
                             \ 'E:event;g:enum;s:struct;i:interface;' .
                             \ 'p:properties;m:method'

" cobol language
let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
                               \ 'P:program;s:section'

" eiffel language
let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'

" erlang language
let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'

" expect (same as tcl) language
let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'

" fortran language
let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'

" HTML language
let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'

" java language
let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
                              \ 'f:field;m:method'

" javascript language
let s:tlist_def_javascript_settings = 'javascript;f:function'

" lisp language
let s:tlist_def_lisp_settings = 'lisp;f:function'

" lua language
let s:tlist_def_lua_settings = 'lua;f:function'

" makefiles
let s:tlist_def_make_settings = 'make;m:macro'

" pascal language
let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'

" perl language
let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'

" php language
let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'

" python language
let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'

" rexx language
let s:tlist_def_rexx_settings = 'rexx;s:subroutine'

" ruby language
let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
                              \ 'm:singleton method'

" scheme language
let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'

" shell language
let s:tlist_def_sh_settings = 'sh;f:function'

" C shell language
let s:tlist_def_csh_settings = 'sh;f:function'

" Z shell language
let s:tlist_def_zsh_settings = 'sh;f:function'

" slang language
let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'

" sml language
let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
                             \ 'r:structure;t:type;v:value;f:function'

" sql language
let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'

" tcl language
let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'

" vera language
let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
                                \ 'f:function;g:enum;m:member;p:program;' .
                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
                                \ 'x:externvar'

"verilog language
let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'

" vim language
let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'

" yacc language
let s:tlist_def_yacc_settings = 'yacc;l:label'

"------------------- end of language specific options --------------------

" Vim window size is changed by the taglist plugin or not
let s:tlist_winsize_chgd = -1
" Taglist window is maximized or not
let s:tlist_win_maximized = 0
" Name of files in the taglist
let s:tlist_file_names=''
" Number of files in the taglist
let s:tlist_file_count = 0
" Number of filetypes supported by taglist
let s:tlist_ftype_count = 0
" Is taglist part of other plugins like winmanager or cream?
let s:tlist_app_name = "none"
" Are we displaying brief help text
let s:tlist_brief_help = 1
" List of files removed on user request
let s:tlist_removed_flist = ""
" Index of current file displayed in the taglist window
let s:tlist_cur_file_idx = -1
" Taglist menu is empty or not
let s:tlist_menu_empty = 1

" An autocommand is used to refresh the taglist window when entering any
" buffer. We don't want to refresh the taglist window if we are entering the
" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
" variable is used to skip the refresh of the taglist window and is set
" and cleared appropriately.
let s:Tlist_Skip_Refresh = 0

" Tlist_Window_Display_Help()
function! s:Tlist_Window_Display_Help()
    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    if s:tlist_brief_help
        " Add the brief help
        call append(0, '" Press <F1> to display help text')
    else
        " Add the extensive help
        call append(0, '" <enter> : Jump to tag definition')
        call append(1, '" o : Jump to tag definition in new window')
        call append(2, '" p : Preview the tag definition')
        call append(3, '" <space> : Display tag prototype')
        call append(4, '" u : Update tag list')
        call append(5, '" s : Select sort field')
        call append(6, '" d : Remove file from taglist')
        call append(7, '" x : Zoom-out/Zoom-in taglist window')
        call append(8, '" + : Open a fold')
        call append(9, '" - : Close a fold')
        call append(10, '" * : Open all folds')
        call append(11, '" = : Close all folds')
        call append(12, '" [[ : Move to the start of previous file')
        call append(13, '" ]] : Move to the start of next file')
        call append(14, '" q : Close the taglist window')
        call append(15, '" <F1> : Remove help text')
    endif
endfunction

" Tlist_Window_Toggle_Help_Text()
" Toggle taglist plugin help text between the full version and the brief
" version
function! s:Tlist_Window_Toggle_Help_Text()
    if g:Tlist_Compact_Format
        " In compact display mode, do not display help
        return
    endif

    " Include the empty line displayed after the help text
    let brief_help_size = 1
    let full_help_size = 16

    setlocal modifiable

    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Remove the currently highlighted tag. Otherwise, the help text
    " might be highlighted by mistake
    match none

    " Toggle between brief and full help text
    if s:tlist_brief_help
        let s:tlist_brief_help = 0

        " Remove the previous help
        exe '1,' . brief_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
    else
        let s:tlist_brief_help = 1

        " Remove the previous help
        exe '1,' . full_help_size . ' delete _'

        " Adjust the start/end line numbers for the files
        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
    endif

    call s:Tlist_Window_Display_Help()

    " Restore the report option
    let &report = old_report

    setlocal nomodifiable
endfunction

" Taglist debug support
let s:tlist_debug = 0

" File for storing the debug messages
let s:tlist_debug_file = ''

" Tlist_Debug_Enable
" Enable logging of taglist debug messages.
function! s:Tlist_Debug_Enable(...)
    let s:tlist_debug = 1

    " Check whether a valid file name is supplied.
    if a:1 != ''
        let s:tlist_debug_file = fnamemodify(a:1, ':p')

        " Empty the log file
        exe 'redir! > ' . s:tlist_debug_file
        redir END

        " Check whether the log file is present/created
        if !filewritable(s:tlist_debug_file)
            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
                        \ . s:tlist_debug_file)
            let s:tlist_debug_file = ''
        endif
    endif
endfunction

" Tlist_Debug_Disable
" Disable logging of taglist debug messages.
function! s:Tlist_Debug_Disable(...)
    let s:tlist_debug = 0
    let s:tlist_debug_file = ''
endfunction

" Tlist_Debug_Show
" Display the taglist debug messages in a new window
function! s:Tlist_Debug_Show()
    if s:tlist_msg == ''
        call s:Tlist_Warning_Msg('Taglist: No debug messages')
        return
    endif

    " Open a new window to display the taglist debug messages
    new taglist_debug.txt
    " Delete all the lines (if the buffer already exists)
    silent! %delete _
    " Add the messages
    silent! put =s:tlist_msg
    " Move the cursor to the first line
    normal! gg
endfunction

" Tlist_Log_Msg
" Log the supplied debug message along with the time
function! s:Tlist_Log_Msg(msg)
    if s:tlist_debug
        if s:tlist_debug_file != ''
            exe 'redir >> ' . s:tlist_debug_file
            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
            redir END
        else
            " Log the message into a variable
            " Retain only the last 3000 characters
            let len = strlen(s:tlist_msg)
            if len > 3000
                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
            endif
            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
                        \ a:msg . "\n"
        endif
    endif
endfunction

" Tlist_Warning_Msg()
" Display a message using WarningMsg highlight group
function! s:Tlist_Warning_Msg(msg)
    echohl WarningMsg
    echomsg a:msg
    echohl None
endfunction

" Last returned file index for file name lookup.
" Used to speed up file lookup
let s:tlist_file_name_idx_cache = -1

" Tlist_Get_File_Index()
" Return the index of the specified filename
function! s:Tlist_Get_File_Index(fname)
    if s:tlist_file_count == 0 || a:fname == ''
        return -1
    endif

    " If the new filename is same as the last accessed filename, then
    " return that index
    if s:tlist_file_name_idx_cache != -1 &&
                \ s:tlist_file_name_idx_cache < s:tlist_file_count
        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
            " Same as the last accessed file
            return s:tlist_file_name_idx_cache
        endif
    endif

    " First, check whether the filename is present
    let s_fname = a:fname . "\n"
    let i = stridx(s:tlist_file_names, s_fname)
    if i == -1
        let s:tlist_file_name_idx_cache = -1
        return -1
    endif

    " Second, compute the file name index
    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
    let s:tlist_file_name_idx_cache = strlen(nl_txt)
    return s:tlist_file_name_idx_cache
endfunction

" Last returned file index for line number lookup.
" Used to speed up file lookup
let s:tlist_file_lnum_idx_cache = -1

" Tlist_Window_Get_File_Index_By_Linenum()
" Return the index of the filename present in the specified line number
" Line number refers to the line number in the taglist window
function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')

    " First try to see whether the new line number is within the range
    " of the last returned file
    if s:tlist_file_lnum_idx_cache != -1 &&
                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
            return s:tlist_file_lnum_idx_cache
        endif
    endif

    let fidx = -1

    if g:Tlist_Show_One_File
        " Displaying only one file in the taglist window. Check whether
        " the line is within the tags displayed for that file
        if s:tlist_cur_file_idx != -1
            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
                let fidx = s:tlist_cur_file_idx
            endif

        endif
    else
        " Do a binary search in the taglist
        let left = 0
        let right = s:tlist_file_count - 1

        while left < right
            let mid = (left + right) / 2

            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
                let s:tlist_file_lnum_idx_cache = mid
                return mid
            endif

            if a:lnum < s:tlist_{mid}_start
                let right = mid - 1
            else
                let left = mid + 1
            endif
        endwhile

        if left >= 0 && left < s:tlist_file_count
                    \ && a:lnum >= s:tlist_{left}_start
                    \ && a:lnum <= s:tlist_{left}_end
            let fidx = left
        endif
    endif

    let s:tlist_file_lnum_idx_cache = fidx

    return fidx
endfunction

" Tlist_Exe_Cmd_No_Acmds
" Execute the specified Ex command after disabling autocommands
function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
    let old_eventignore = &eventignore
    set eventignore=all
    exe a:cmd
    let &eventignore = old_eventignore
endfunction

" Tlist_Skip_File()
" Check whether tag listing is supported for the specified file
function! s:Tlist_Skip_File(filename, ftype)
    " Skip buffers with no names and buffers with filetype not set
    if a:filename == '' || a:ftype == ''
        return 1
    endif

    " Skip files which are not supported by exuberant ctags
    " First check whether default settings for this filetype are available.
    " If it is not available, then check whether user specified settings are
    " available. If both are not available, then don't list the tags for this
    " filetype
    let var = 's:tlist_def_' . a:ftype . '_settings'
    if !exists(var)
        let var = 'g:tlist_' . a:ftype . '_settings'
        if !exists(var)
            return 1
        endif
    endif

    " Skip files which are not readable or files which are not yet stored
    " to the disk
    if !filereadable(a:filename)
        return 1
    endif

    return 0
endfunction

" Tlist_User_Removed_File
" Returns 1 if a file is removed by a user from the taglist
function! s:Tlist_User_Removed_File(filename)
    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
endfunction

" Tlist_Update_Remove_List
" Update the list of user removed files from the taglist
" add == 1, add the file to the removed list
" add == 0, delete the file from the removed list
function! s:Tlist_Update_Remove_List(filename, add)
    if a:add
        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
    else
        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
        let text_before = strpart(s:tlist_removed_flist, 0, idx)
        let rem_text = strpart(s:tlist_removed_flist, idx)
        let next_idx = stridx(rem_text, "\n")
        let text_after = strpart(rem_text, next_idx + 1)

        let s:tlist_removed_flist = text_before . text_after
    endif
endfunction

" Tlist_FileType_Init
" Initialize the ctags arguments and tag variable for the specified
" file type
function! s:Tlist_FileType_Init(ftype)
    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
    " If the user didn't specify any settings, then use the default
    " ctags args. Otherwise, use the settings specified by the user
    let var = 'g:tlist_' . a:ftype . '_settings'
    if exists(var)
        " User specified ctags arguments
        let settings = {var} . ';'
    else
        " Default ctags arguments
        let var = 's:tlist_def_' . a:ftype . '_settings'
        if !exists(var)
            " No default settings for this file type. This filetype is
            " not supported
            return 0
        endif
        let settings = s:tlist_def_{a:ftype}_settings . ';'
    endif

    let msg = 'Taglist: Invalid ctags option setting - ' . settings

    " Format of the option that specifies the filetype and ctags arugments:
    "
    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
    "

    " Extract the file type to pass to ctags. This may be different from the
    " file type detected by Vim
    let pos = stridx(settings, ';')
    if pos == -1
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    let ctags_ftype = strpart(settings, 0, pos)
    if ctags_ftype == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif
    " Make sure a valid filetype is supplied. If the user didn't specify a
    " valid filetype, then the ctags option settings may be treated as the
    " filetype
    if ctags_ftype =~ ':'
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Remove the file type from settings
    let settings = strpart(settings, pos + 1)
    if settings == ''
        call s:Tlist_Warning_Msg(msg)
        return 0
    endif

    " Process all the specified ctags flags. The format is
    " flag1:name1;flag2:name2;flag3:name3
    let ctags_flags = ''
    let cnt = 0
    while settings != ''
        " Extract the flag
        let pos = stridx(settings, ':')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let flag = strpart(settings, 0, pos)
        if flag == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        " Remove the flag from settings
        let settings = strpart(settings, pos + 1)

        " Extract the tag type name
        let pos = stridx(settings, ';')
        if pos == -1
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let name = strpart(settings, 0, pos)
        if name == ''
            call s:Tlist_Warning_Msg(msg)
            return 0
        endif
        let settings = strpart(settings, pos + 1)

        let cnt = cnt + 1

        let s:tlist_{a:ftype}_{cnt}_name = flag
        let s:tlist_{a:ftype}_{cnt}_fullname = name
        let ctags_flags = ctags_flags . flag
    endwhile

    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
    let s:tlist_{a:ftype}_count = cnt
    let s:tlist_{a:ftype}_ctags_flags = ctags_flags

    " Save the filetype name
    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
    let s:tlist_ftype_count = s:tlist_ftype_count + 1

    return 1
endfunction

" Tlist_Detect_Filetype
" Determine the filetype for the specified file using the filetypedetect
" autocmd.
function! s:Tlist_Detect_Filetype(fname)
    " Ignore the filetype autocommands
    let old_eventignore = &eventignore
    set eventignore=FileType

    " Save the 'filetype', as this will be changed temporarily
    let old_filetype = &filetype

    " Run the filetypedetect group of autocommands to determine
    " the filetype
    exe 'doautocmd filetypedetect BufRead ' . a:fname

    " Save the detected filetype
    let ftype = &filetype

    " Restore the previous state
    let &filetype = old_filetype
    let &eventignore = old_eventignore

    return ftype
endfunction

" Tlist_Get_Buffer_Filetype
" Get the filetype for the specified buffer
function! s:Tlist_Get_Buffer_Filetype(bnum)
    let buf_ft = getbufvar(a:bnum, '&filetype')

    if bufloaded(a:bnum)
        " For loaded buffers, the 'filetype' is already determined
        return buf_ft
    endif

    " For unloaded buffers, if the 'filetype' option is set, return it
    if buf_ft != ''
        return buf_ft
    endif

    " Skip non-existent buffers
    if !bufexists(a:bnum)
        return ''
    endif

    " For buffers whose filetype is not yet determined, try to determine
    " the filetype
    let bname = bufname(a:bnum)

    return s:Tlist_Detect_Filetype(bname)
endfunction

" Tlist_Discard_TagInfo
" Discard the stored tag information for a file
function! s:Tlist_Discard_TagInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    let ftype = s:tlist_{a:fidx}_filetype

    " Discard information about the tags defined in the file
    let i = 1
    while i <= s:tlist_{a:fidx}_tag_count
        let fidx_i = 's:tlist_' . a:fidx . '_' . i
        unlet! {fidx_i}_tag
        unlet! {fidx_i}_tag_name
        unlet! {fidx_i}_tag_type
        unlet! {fidx_i}_ttype_idx
        unlet! {fidx_i}_tag_proto
        unlet! {fidx_i}_tag_searchpat
        unlet! {fidx_i}_tag_linenum
        let i = i + 1
    endwhile

    let s:tlist_{a:fidx}_tag_count = 0

    " Discard information about tag type groups
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{a:fidx}_{ttype} != ''
            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
            let {fidx_ttype} = ''
            let {fidx_ttype}_offset = 0
            let cnt = {fidx_ttype}_count
            let {fidx_ttype}_count = 0
            let j = 1
            while j <= cnt
                unlet! {fidx_ttype}_{j}
                let j = j + 1
            endwhile
        endif
        let i = i + 1
    endwhile

    " Discard the stored menu command also
    let s:tlist_{a:fidx}_menu_cmd = ''
endfunction

" Tlist_Window_Update_Line_Offsets
" Update the line offsets for tags for files starting from start_idx
" and displayed in the taglist window by the specified offset
function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
    let i = a:start_idx

    while i < s:tlist_file_count
        if s:tlist_{i}_visible
            " Update the start/end line number only if the file is visible
            if a:increment
                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
            else
                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
            endif
        endif
        let i = i + 1
    endwhile
endfunction

" Tlist_Discard_FileInfo
" Discard the stored information for a file
function! s:Tlist_Discard_FileInfo(fidx)
    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
                \ s:tlist_{a:fidx}_filename . ')')
    call s:Tlist_Discard_TagInfo(a:fidx)

    let ftype = s:tlist_{a:fidx}_filetype

    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        unlet! s:tlist_{a:fidx}_{ttype}
        unlet! s:tlist_{a:fidx}_{ttype}_offset
        unlet! s:tlist_{a:fidx}_{ttype}_count
        let i = i + 1
    endwhile

    unlet! s:tlist_{a:fidx}_filename
    unlet! s:tlist_{a:fidx}_sort_type
    unlet! s:tlist_{a:fidx}_filetype
    unlet! s:tlist_{a:fidx}_mtime
    unlet! s:tlist_{a:fidx}_start
    unlet! s:tlist_{a:fidx}_end
    unlet! s:tlist_{a:fidx}_valid
    unlet! s:tlist_{a:fidx}_visible
    unlet! s:tlist_{a:fidx}_tag_count
    unlet! s:tlist_{a:fidx}_menu_cmd
endfunction

" Tlist_Window_Remove_File_From_Display
" Remove the specified file from display
function! s:Tlist_Window_Remove_File_From_Display(fidx)
    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
                \ s:tlist_{a:fidx}_filename . ')')
    " If the file is not visible then no need to remove it
    if !s:tlist_{a:fidx}_visible
        return
    endif

    " Remove the tags displayed for the specified file from the window
    let start = s:tlist_{a:fidx}_start
    " Include the empty line after the last line also
    if g:Tlist_Compact_Format
        let end = s:tlist_{a:fidx}_end
    else
        let end = s:tlist_{a:fidx}_end + 1
    endif

    setlocal modifiable
    exe 'silent! ' . start . ',' . end . 'delete _'
    setlocal nomodifiable

    " Correct the start and end line offsets for all the files following
    " this file, as the tags for this file are removed
    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
endfunction

" Tlist_Remove_File
" Remove the file under the cursor or the specified file index
" user_request - User requested to remove the file from taglist
function! s:Tlist_Remove_File(file_idx, user_request)
    let fidx = a:file_idx

    if fidx == -1
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif
    endif
    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')

    let save_winnr = winnr()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Taglist window is open, remove the file from display

        if save_winnr != winnum
            let old_eventignore = &eventignore
            set eventignore=all
            exe winnum . 'wincmd w'
        endif

        call s:Tlist_Window_Remove_File_From_Display(fidx)

        if save_winnr != winnum
            exe save_winnr . 'wincmd w'
            let &eventignore = old_eventignore
        endif
    endif

    let fname = s:tlist_{fidx}_filename

    if a:user_request
        " As the user requested to remove the file from taglist,
        " add it to the removed list
        call s:Tlist_Update_Remove_List(fname, 1)
    endif

    " Remove the file name from the taglist list of filenames
    let idx = stridx(s:tlist_file_names, fname . "\n")
    let text_before = strpart(s:tlist_file_names, 0, idx)
    let rem_text = strpart(s:tlist_file_names, idx)
    let next_idx = stridx(rem_text, "\n")
    let text_after = strpart(rem_text, next_idx + 1)
    let s:tlist_file_names = text_before . text_after

    call s:Tlist_Discard_FileInfo(fidx)

    " Shift all the file variables by one index
    let i = fidx + 1

    while i < s:tlist_file_count
        let j = i - 1

        let s:tlist_{j}_filename = s:tlist_{i}_filename
        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
        let s:tlist_{j}_start = s:tlist_{i}_start
        let s:tlist_{j}_end = s:tlist_{i}_end
        let s:tlist_{j}_valid = s:tlist_{i}_valid
        let s:tlist_{j}_visible = s:tlist_{i}_visible
        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd

        let k = 1
        while k <= s:tlist_{j}_tag_count
            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
            let k = k + 1
        endwhile

        let ftype = s:tlist_{i}_filetype

        let k = 1
        while k <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{k}_name
            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
            if s:tlist_{j}_{ttype} != ''
                let l = 1
                while l <= s:tlist_{j}_{ttype}_count
                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
                    let l = l + 1
                endwhile
            endif
            let k = k + 1
        endwhile

        " As the file and tag information is copied to the new index,
        " discard the previous information
        call s:Tlist_Discard_FileInfo(i)

        let i = i + 1
    endwhile

    " Reduce the number of files displayed
    let s:tlist_file_count = s:tlist_file_count - 1

    if g:Tlist_Show_One_File
        " If the tags for only one file is displayed and if we just
        " now removed that file, then invalidate the current file idx
        if s:tlist_cur_file_idx == fidx
            let s:tlist_cur_file_idx = -1
        endif
    endif
endfunction

" Tlist_Window_Goto_Window
" Goto the taglist window
function! s:Tlist_Window_Goto_Window()
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        if winnr() != winnum
            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
        endif
    endif
endfunction

" Tlist_Window_Create
" Create a new taglist window. If it is already open, jump to it
function! s:Tlist_Window_Create()
    call s:Tlist_Log_Msg('Tlist_Window_Create()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    " If used with winmanager don't open windows. Winmanager will handle
    " the window/buffer management
    if s:tlist_app_name == "winmanager"
        return
    endif

    " Create a new window. If user prefers a horizontal window, then open
    " a horizontally split window. Otherwise open a vertically split
    " window
    if g:Tlist_Use_Horiz_Window
        " Open a horizontally split window
        let win_dir = 'botright'
        " Horizontal window height
        let win_size = g:Tlist_WinHeight
    else
        if s:tlist_winsize_chgd == -1
            " Open a vertically split window. Increase the window size, if
            " needed, to accomodate the new window
            if g:Tlist_Inc_Winwidth &&
                        \ &columns < (80 + g:Tlist_WinWidth)
                " Save the original window position
                let s:tlist_pre_winx = getwinposx()
                let s:tlist_pre_winy = getwinposy()

                " one extra column is needed to include the vertical split
                let &columns= &columns + g:Tlist_WinWidth + 1

                let s:tlist_winsize_chgd = 1
            else
                let s:tlist_winsize_chgd = 0
            endif
        endif

        if g:Tlist_Use_Right_Window
            " Open the window at the rightmost place
            let win_dir = 'botright vertical'
        else
            " Open the window at the leftmost place
            let win_dir = 'topleft vertical'
        endif
        let win_size = g:Tlist_WinWidth
    endif

    " If the tag listing temporary buffer already exists, then reuse it.
    " Otherwise create a new buffer
    let bufnum = bufnr(g:TagList_title)
    if bufnum == -1
        " Create a new buffer
        let wcmd = g:TagList_title
    else
        " Edit the existing buffer
        let wcmd = '+buffer' . bufnum
    endif

    " Create the taglist window
    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd

    " Save the new window position
    let s:tlist_winx = getwinposx()
    let s:tlist_winy = getwinposy()

    " Initialize the taglist window
    call s:Tlist_Window_Init()
endfunction

" Tlist_Window_Zoom
" Zoom (maximize/minimize) the taglist window
function! s:Tlist_Window_Zoom()
    if s:tlist_win_maximized
        " Restore the window back to the previous size
        if g:Tlist_Use_Horiz_Window
            exe 'resize ' . g:Tlist_WinHeight
        else
            exe 'vert resize ' . g:Tlist_WinWidth
        endif
        let s:tlist_win_maximized = 0
    else
        " Set the window size to the maximum possible without closing other
        " windows
        if g:Tlist_Use_Horiz_Window
            resize
        else
            vert resize
        endif
        let s:tlist_win_maximized = 1
    endif
endfunction

" Tlist_Ballon_Expr
" When the mouse cursor is over a tag in the taglist window, display the
" tag prototype (balloon)
function! Tlist_Ballon_Expr()
    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
    if fidx == -1
        return ''
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
    if tidx == 0
        return ''
    endif

    " Get the tag search pattern and display it
    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Window_Check_Width
" Check the width of the taglist window. For horizontally split windows, the
" 'winfixheight' option is used to fix the height of the window. For
" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
" need to handle window width changes from this function.
function! s:Tlist_Window_Check_Width()
    let tlist_winnr = bufwinnr(g:TagList_title)
    if tlist_winnr == -1
        return
    endif

    let width = winwidth(tlist_winnr)
    if width != g:Tlist_WinWidth
        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
                    \ "width from " . width . " to " . g:Tlist_WinWidth)
        let save_winnr = winnr()
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
        endif
        exe 'vert resize ' . g:Tlist_WinWidth
        if save_winnr != tlist_winnr
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Window_Exit_Only_Window
" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
" taglist window is present.
function! s:Tlist_Window_Exit_Only_Window()
    " Before quitting Vim, delete the taglist buffer so that
    " the '0 mark is correctly set to the previous buffer.
    if v:version < 700
	if winbufnr(2) == -1
	    bdelete
	    quit
	endif
    else
	if winbufnr(2) == -1
	    if tabpagenr('$') == 1
		" Only one tag page is present
		bdelete
		quit
	    else
		" More than one tab page is present. Close only the current
		" tab page
		close
	    endif
	endif
    endif
endfunction

" Tlist_Window_Init
" Set the default options for the taglist window
function! s:Tlist_Window_Init()
    call s:Tlist_Log_Msg('Tlist_Window_Init()')

    " The 'readonly' option should not be set for the taglist buffer.
    " If Vim is started as "view/gview" or if the ":view" command is
    " used, then the 'readonly' option is set for all the buffers.
    " Unset it for the taglist buffer
    setlocal noreadonly

    " Set the taglist buffer filetype to taglist
    setlocal filetype=taglist

    " Define taglist window element highlighting
    syntax match TagListComment '^" .*'
    syntax match TagListFileName '^[^" ].*$'
    syntax match TagListTitle '^  \S.*$'
    syntax match TagListTagScope  '\s\[.\{-\}\]$'

    " Define the highlighting only if colors are supported
    if has('gui_running') || &t_Co > 2
        " Colors to highlight various taglist window elements
        " If user defined highlighting group exists, then use them.
        " Otherwise, use default highlight groups.
        if hlexists('MyTagListTagName')
            highlight link TagListTagName MyTagListTagName
        else
            highlight default link TagListTagName Search
        endif
        " Colors to highlight comments and titles
        if hlexists('MyTagListComment')
            highlight link TagListComment MyTagListComment
        else
            highlight clear TagListComment
            highlight default link TagListComment Comment
        endif
        if hlexists('MyTagListTitle')
            highlight link TagListTitle MyTagListTitle
        else
            highlight clear TagListTitle
            highlight default link TagListTitle Title
        endif
        if hlexists('MyTagListFileName')
            highlight link TagListFileName MyTagListFileName
        else
            highlight clear TagListFileName
            highlight default TagListFileName guibg=Grey ctermbg=darkgray
                        \ guifg=white ctermfg=white
        endif
        if hlexists('MyTagListTagScope')
            highlight link TagListTagScope MyTagListTagScope
        else
            highlight clear TagListTagScope
            highlight default link TagListTagScope Identifier
        endif
    else
        highlight default TagListTagName term=reverse cterm=reverse
    endif

    " Folding related settings
    setlocal foldenable
    setlocal foldminlines=0
    setlocal foldmethod=manual
    setlocal foldlevel=9999
    if g:Tlist_Enable_Fold_Column
        setlocal foldcolumn=3
    else
        setlocal foldcolumn=0
    endif
    setlocal foldtext=v:folddashes.getline(v:foldstart)

    if s:tlist_app_name != "winmanager"
        " Mark buffer as scratch
        silent! setlocal buftype=nofile
        if s:tlist_app_name == "none"
            silent! setlocal bufhidden=delete
        endif
        silent! setlocal noswapfile
        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
        " buffers. So if the taglist buffer is unlisted, multiple taglist
        " windows will be opened. This bug is fixed in Vim 6.1 and above
        if v:version >= 601
            silent! setlocal nobuflisted
        endif
    endif

    silent! setlocal nowrap

    " If the 'number' option is set in the source window, it will affect the
    " taglist window. So forcefully disable 'number' option for the taglist
    " window
    silent! setlocal nonumber

    " Use fixed height when horizontally split window is used
    if g:Tlist_Use_Horiz_Window
        if v:version >= 602
            set winfixheight
        endif
    endif
    if !g:Tlist_Use_Horiz_Window && v:version >= 700
        set winfixwidth
    endif

    " Setup balloon evaluation to display tag prototype
    if v:version >= 700 && has('balloon_eval')
        setlocal balloonexpr=Tlist_Ballon_Expr()
        set ballooneval
    endif

    " Setup the cpoptions properly for the maps to work
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    " Create buffer local mappings for jumping to the tags and sorting the list
    nnoremap <buffer> <silent> <CR>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> o
                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    nnoremap <buffer> <silent> p
                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    nnoremap <buffer> <silent> P
                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    nnoremap <buffer> <silent> t
                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    nnoremap <buffer> <silent> <C-t>
                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    nnoremap <buffer> <silent> <2-LeftMouse>
                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    nnoremap <buffer> <silent> s
                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    nnoremap <buffer> <silent> + :silent! foldopen<CR>
    nnoremap <buffer> <silent> - :silent! foldclose<CR>
    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    nnoremap <buffer> <silent> q :close<CR>

    " Insert mode mappings
    inoremap <buffer> <silent> <CR>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    " Windows needs return
    inoremap <buffer> <silent> <Return>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> o
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
    inoremap <buffer> <silent> p
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
    inoremap <buffer> <silent> P
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
    if v:version >= 700
    inoremap <buffer> <silent> t
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
    inoremap <buffer> <silent> <C-t>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
    endif
    inoremap <buffer> <silent> <2-LeftMouse>
                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
    inoremap <buffer> <silent> s
                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
    inoremap <buffer> <silent> <Space>       <C-o>:call
                                    \ <SID>Tlist_Window_Show_Info()<CR>
    inoremap <buffer> <silent> u
                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
    inoremap <buffer> <silent> q    <C-o>:close<CR>

    " Map single left mouse click if the user wants this functionality
    if g:Tlist_Use_SingleClick == 1
        " Contributed by Bindu Wavell
        " attempt to perform single click mapping, it would be much
        " nicer if we could nnoremap <buffer> ... however vim does
        " not fire the <buffer> <leftmouse> when you use the mouse
        " to enter a buffer.
        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
                    \ '<bar> endif <CR>'
        if maparg('<leftmouse>', 'n') == ''
            " no mapping for leftmouse
            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
        else
            " we have a mapping
            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
            let mapcmd = mapcmd . substitute(substitute(
                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
                        \ '\c^<leftmouse>', '', '')
            let mapcmd = mapcmd . clickmap
            exe mapcmd
        endif
    endif

    " Define the taglist autocommands
    augroup TagListAutoCmds
        autocmd!
        " Display the tag prototype for the tag under the cursor.
        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
        " Highlight the current tag periodically
        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)

        " Adjust the Vim window width when taglist window is closed
        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
        " Close the fold for this buffer when leaving the buffer
        if g:Tlist_File_Fold_Auto_Close
            autocmd BufEnter * silent
                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
        endif
        " Exit Vim itself if only the taglist window is present (optional)
        if g:Tlist_Exit_OnlyWindow
	    autocmd BufEnter __Tag_List__ nested
			\ call s:Tlist_Window_Exit_Only_Window()
        endif
        if s:tlist_app_name != "winmanager" &&
                    \ !g:Tlist_Process_File_Always &&
                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
            " Auto refresh the taglist window
            autocmd BufEnter * call s:Tlist_Refresh()
        endif

        if !g:Tlist_Use_Horiz_Window
            if v:version < 700
                autocmd WinEnter * call s:Tlist_Window_Check_Width()
            endif
        endif
        if v:version >= 700
            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
        endif
    augroup end

    " Restore the previous cpoptions settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Window_Refresh
" Display the tags for all the files in the taglist window
function! s:Tlist_Window_Refresh()
    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
    " Set report option to a huge value to prevent informational messages
    " while deleting the lines
    let old_report = &report
    set report=99999

    " Mark the buffer as modifiable
    setlocal modifiable

    " Delete the contents of the buffer to the black-hole register
    silent! %delete _

    " As we have cleared the taglist window, mark all the files
    " as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    if g:Tlist_Compact_Format == 0
        " Display help in non-compact mode
        call s:Tlist_Window_Display_Help()
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " If the tags for only one file should be displayed in the taglist
    " window, then no need to add the tags here. The bufenter autocommand
    " will add the tags for that file.
    if g:Tlist_Show_One_File
        return
    endif

    " List all the tags for the previously processed files
    " Do this only if taglist is configured to display tags for more than
    " one file. Otherwise, when Tlist_Show_One_File is configured,
    " tags for the wrong file will be displayed.
    let i = 0
    while i < s:tlist_file_count
        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
                    \ s:tlist_{i}_filetype)
        let i = i + 1
    endwhile

    if g:Tlist_Auto_Update
        " Add and list the tags for all buffers in the Vim buffer list
        let i = 1
        let last_bufnum = bufnr('$')
        while i <= last_bufnum
            if buflisted(i)
                let fname = fnamemodify(bufname(i), ':p')
                let ftype = s:Tlist_Get_Buffer_Filetype(i)
                " If the file doesn't support tag listing, skip it
                if !s:Tlist_Skip_File(fname, ftype)
                    call s:Tlist_Window_Refresh_File(fname, ftype)
                endif
            endif
            let i = i + 1
        endwhile
    endif

    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
    if g:Tlist_File_Fold_Auto_Close
        " Close all the folds
        silent! %foldclose
    endif

    " Move the cursor to the top of the taglist window
    normal! gg
endfunction

" Tlist_Post_Close_Cleanup()
" Close the taglist window and adjust the Vim window width
function! s:Tlist_Post_Close_Cleanup()
    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
    " Mark all the files as not visible
    let i = 0
    while i < s:tlist_file_count
        let s:tlist_{i}_visible = 0
        let i = i + 1
    endwhile

    " Remove the taglist autocommands
    silent! autocmd! TagListAutoCmds

    " Clear all the highlights
    match none

    silent! syntax clear TagListTitle
    silent! syntax clear TagListComment
    silent! syntax clear TagListTagScope

    " Remove the left mouse click mapping if it was setup initially
    if g:Tlist_Use_SingleClick
        if hasmapto('<LeftMouse>')
            nunmap <LeftMouse>
        endif
    endif

    if s:tlist_app_name != "winmanager"
    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
                \ s:tlist_winsize_chgd != 1 ||
                \ &columns < (80 + g:Tlist_WinWidth)
        " No need to adjust window width if using horizontally split taglist
        " window or if columns is less than 101 or if the user chose not to
        " adjust the window width
    else
        " If the user didn't manually move the window, then restore the window
        " position to the pre-taglist position
        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
                    \ getwinposx() == s:tlist_winx &&
                    \ getwinposy() == s:tlist_winy
            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
        endif

        " Adjust the Vim window width
        let &columns= &columns - (g:Tlist_WinWidth + 1)
    endif
    endif

    let s:tlist_winsize_chgd = -1

    " Reset taglist state variables
    if s:tlist_app_name == "winmanager"
        let s:tlist_app_name = "none"
    endif
    let s:tlist_window_initialized = 0
endfunction

" Tlist_Window_Refresh_File()
" List the tags defined in the specified file in a Vim window
function! s:Tlist_Window_Refresh_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx != -1
        let file_listed = 1
    else
        let file_listed = 0
    endif

    if !file_listed
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(a:filename)
            return
        endif
    endif

    if file_listed && s:tlist_{fidx}_visible
        " Check whether the file tags are currently valid
        if s:tlist_{fidx}_valid
            " Goto the first line in the file
            exe s:tlist_{fidx}_start

            " If the line is inside a fold, open the fold
            if foldclosed('.') != -1
                exe "silent! " . s:tlist_{fidx}_start . "," .
                            \ s:tlist_{fidx}_end . "foldopen!"
            endif
            return
        endif

        " Discard and remove the tags for this file from display
        call s:Tlist_Discard_TagInfo(fidx)
        call s:Tlist_Window_Remove_File_From_Display(fidx)
    endif

    " Process and generate a list of tags defined in the file
    if !file_listed || !s:tlist_{fidx}_valid
        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
        if ret_fidx == -1
            return
        endif
        let fidx = ret_fidx
    endif

    " Set report option to a huge value to prevent informational messages
    " while adding lines to the taglist window
    let old_report = &report
    set report=99999

    if g:Tlist_Show_One_File
        " Remove the previous file
        if s:tlist_cur_file_idx != -1
            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
            let s:tlist_{s:tlist_cur_file_idx}_start = 0
            let s:tlist_{s:tlist_cur_file_idx}_end = 0
        endif
        let s:tlist_cur_file_idx = fidx
    endif

    " Mark the buffer as modifiable
    setlocal modifiable

    " Add new files to the end of the window. For existing files, add them at
    " the same line where they were previously present. If the file is not
    " visible, then add it at the end
    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
        if g:Tlist_Compact_Format
            let s:tlist_{fidx}_start = line('$')
        else
            let s:tlist_{fidx}_start = line('$') + 1
        endif
    endif

    let s:tlist_{fidx}_visible = 1

    " Goto the line where this file should be placed
    if g:Tlist_Compact_Format
        exe s:tlist_{fidx}_start
    else
        exe s:tlist_{fidx}_start - 1
    endif

    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
    if g:Tlist_Compact_Format == 0
        silent! put =txt
    else
        silent! put! =txt
        " Move to the next line
        exe line('.') + 1
    endif
    let file_start = s:tlist_{fidx}_start

    " Add the tag names grouped by tag type to the buffer with a title
    let i = 1
    let ttype_cnt = s:tlist_{a:ftype}_count
    while i <= ttype_cnt
        let ttype = s:tlist_{a:ftype}_{i}_name
        " Add the tag type only if there are tags for that type
        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
        let ttype_txt = {fidx_ttype}
        if ttype_txt != ''
            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
            if g:Tlist_Compact_Format == 0
                let ttype_start_lnum = line('.') + 1
                silent! put =txt
            else
                let ttype_start_lnum = line('.')
                silent! put! =txt
            endif
            silent! put =ttype_txt

            let {fidx_ttype}_offset = ttype_start_lnum - file_start

            " create a fold for this tag type
            let fold_start = ttype_start_lnum
            let fold_end = fold_start + {fidx_ttype}_count
            exe fold_start . ',' . fold_end  . 'fold'

            " Adjust the cursor position
            if g:Tlist_Compact_Format == 0
                exe ttype_start_lnum + {fidx_ttype}_count
            else
                exe ttype_start_lnum + {fidx_ttype}_count + 1
            endif

            if g:Tlist_Compact_Format == 0
                " Separate the tag types by a empty line
                silent! put =''
            endif
        endif
        let i = i + 1
    endwhile

    if s:tlist_{fidx}_tag_count == 0
        if g:Tlist_Compact_Format == 0
            silent! put =''
        endif
    endif

    let s:tlist_{fidx}_end = line('.') - 1

    " Create a fold for the entire file
    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                \ s:tlist_{fidx}_end . 'foldopen!'

    " Goto the starting line for this file,
    exe s:tlist_{fidx}_start

    if s:tlist_app_name == "winmanager"
        " To handle a bug in the winmanager plugin, add a space at the
        " last line
        call setline('$', ' ')
    endif

    " Mark the buffer as not modifiable
    setlocal nomodifiable

    " Restore the report option
    let &report = old_report

    " Update the start and end line numbers for all the files following this
    " file
    let start = s:tlist_{fidx}_start
    " include the empty line after the last line
    if g:Tlist_Compact_Format
        let end = s:tlist_{fidx}_end
    else
        let end = s:tlist_{fidx}_end + 1
    endif
    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)

    " Now that we have updated the taglist window, update the tags
    " menu (if present)
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Init_File
" Initialize the variables for a new file
function! s:Tlist_Init_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
    " Add new files at the end of the list
    let fidx = s:tlist_file_count
    let s:tlist_file_count = s:tlist_file_count + 1
    " Add the new file name to the taglist list of file names
    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"

    " Initialize the file variables
    let s:tlist_{fidx}_filename = a:filename
    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
    let s:tlist_{fidx}_filetype = a:ftype
    let s:tlist_{fidx}_mtime = -1
    let s:tlist_{fidx}_start = 0
    let s:tlist_{fidx}_end = 0
    let s:tlist_{fidx}_valid = 0
    let s:tlist_{fidx}_visible = 0
    let s:tlist_{fidx}_tag_count = 0
    let s:tlist_{fidx}_menu_cmd = ''

    " Initialize the tag type variables
    let i = 1
    while i <= s:tlist_{a:ftype}_count
        let ttype = s:tlist_{a:ftype}_{i}_name
        let s:tlist_{fidx}_{ttype} = ''
        let s:tlist_{fidx}_{ttype}_offset = 0
        let s:tlist_{fidx}_{ttype}_count = 0
        let i = i + 1
    endwhile

    return fidx
endfunction

" Tlist_Get_Tag_Type_By_Tag
" Return the tag type for the specified tag index
function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'

    " Already parsed and have the tag name
    if exists(ttype_var)
        return {ttype_var}
    endif

    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)

    return {ttype_var}
endfunction

" Tlist_Get_Tag_Prototype
function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'

    " Already parsed and have the tag prototype
    if exists(tproto_var)
        return {tproto_var}
    endif

    " Parse and extract the tag prototype
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let tag_proto = strpart(tag_line, start, end - start)
    let {tproto_var} = substitute(tag_proto, '\s*', '', '')

    return {tproto_var}
endfunction

" Tlist_Get_Tag_SearchPat
function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'

    " Already parsed and have the tag search pattern
    if exists(tpat_var)
        return {tpat_var}
    endif

    " Parse and extract the tag search pattern
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = stridx(tag_line, '/^') + 2
    let end = stridx(tag_line, '/;"' . "\t")
    if tag_line[end - 1] == '$'
        let end = end -1
    endif
    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
                        \ (tag_line[end] == '$' ? '\$' : '')

    return {tpat_var}
endfunction

" Tlist_Get_Tag_Linenum
" Return the tag line number, given the tag index
function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'

    " Already parsed and have the tag line number
    if exists(tline_var)
        return {tline_var}
    endif

    " Parse and extract the tag line number
    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
    let start = strridx(tag_line, 'line:') + 5
    let end = strridx(tag_line, "\t")
    if end < start
        let {tline_var} = strpart(tag_line, start) + 0
    else
        let {tline_var} = strpart(tag_line, start, end - start) + 0
    endif

    return {tline_var}
endfunction

" Tlist_Parse_Tagline
" Parse a tag line from the ctags output. Separate the tag output based on the
" tag type and store it in the tag type variable.
" The format of each line in the ctags output is:
"
"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
"
function! s:Tlist_Parse_Tagline(tag_line)
    if a:tag_line == ''
        " Skip empty lines
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)

    " Make sure the tag type is a valid and supported one
    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
        " Line is not in proper tags format or Tag type is not supported
        return
    endif

    " Update the total tag count
    let s:tidx = s:tidx + 1

    " The following variables are used to optimize this code.  Vim is slow in
    " using curly brace names. To reduce the amount of processing needed, the
    " curly brace variables are pre-processed here
    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype

    " Update the count of this tag type
    let ttype_idx = {fidx_ttype}_count + 1
    let {fidx_ttype}_count = ttype_idx

    " Store the ctags output for this tag
    let {fidx_tidx}_tag = a:tag_line

    " Store the tag index and the tag type index (back pointers)
    let {fidx_ttype}_{ttype_idx} = s:tidx
    let {fidx_tidx}_ttype_idx = ttype_idx

    " Extract the tag name
    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))

    " Extract the tag scope/prototype
    if g:Tlist_Display_Prototype
        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
    else
        let ttxt = '    ' . tag_name

        " Add the tag scope, if it is available and is configured. Tag
        " scope is the last field after the 'line:<num>\t' field
        if g:Tlist_Display_Tag_Scope
            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
            if tag_scope != ''
                let ttxt = ttxt . ' [' . tag_scope . ']'
            endif
        endif
    endif

    " Add this tag to the tag type variable
    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

    " Save the tag name
    let {fidx_tidx}_tag_name = tag_name
endfunction

" Tlist_Process_File
" Get the list of tags defined in the specified file and store them
" in Vim variables. Returns the file index where the tags are stored.
function! s:Tlist_Process_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
                \ a:ftype . ')')
    " Check whether this file is supported
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return -1
    endif

    " If the tag types for this filetype are not yet created, then create
    " them now
    let var = 's:tlist_' . a:ftype . '_count'
    if !exists(var)
        if s:Tlist_FileType_Init(a:ftype) == 0
            return -1
        endif
    endif

    " If this file is already processed, then use the cached values
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " First time, this file is loaded
        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
    else
        " File was previously processed. Discard the tag information
        call s:Tlist_Discard_TagInfo(fidx)
    endif

    let s:tlist_{fidx}_valid = 1

    " Exuberant ctags arguments to generate a tag list
    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '

    " Form the ctags argument depending on the sort type
    if s:tlist_{fidx}_sort_type == 'name'
        let ctags_args = ctags_args . '--sort=yes'
    else
        let ctags_args = ctags_args . '--sort=no'
    endif

    " Add the filetype specific arguments
    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args

    " Ctags command to produce output with regexp for locating the tags
    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'

    if &shellxquote == '"'
        " Double-quotes within double-quotes will not work in the
        " command-line.If the 'shellxquote' option is set to double-quotes,
        " then escape the double-quotes in the ctags command-line.
        let ctags_cmd = escape(ctags_cmd, '"')
    endif

    " In Windows 95, if not using cygwin, disable the 'shellslash'
    " option. Otherwise, this will cause problems when running the
    " ctags command.
    if has('win95') && !has('win32unix')
        let old_shellslash = &shellslash
        set noshellslash
    endif

    if has('win32') && !has('win32unix') && !has('win95')
                \ && (&shell =~ 'cmd.exe')
        " Windows does not correctly deal with commands that have more than 1
        " set of double quotes.  It will strip them all resulting in:
        " 'C:\Program' is not recognized as an internal or external command
        " operable program or batch file.  To work around this, place the
        " command inside a batch file and call the batch file.
        " Do this only on Win2K, WinXP and above.
        " Contributed by: David Fishburn.
        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
                    \ '\taglist.cmd'
        exe 'redir! > ' . s:taglist_tempfile
        silent echo ctags_cmd
        redir END

        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
        let ctags_cmd = '"' . s:taglist_tempfile . '"'
    endif

    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)

    " Run ctags and get the tag list
    let cmd_output = system(ctags_cmd)

    " Restore the value of the 'shellslash' option.
    if has('win95') && !has('win32unix')
        let &shellslash = old_shellslash
    endif

    if exists('s:taglist_tempfile')
        " Delete the temporary cmd file created on MS-Windows
        call delete(s:taglist_tempfile)
    endif

    " Handle errors
    if v:shell_error
        let msg = "Taglist: Failed to generate tags for " . a:filename
        call s:Tlist_Warning_Msg(msg)
        if cmd_output != ''
            call s:Tlist_Warning_Msg(cmd_output)
        endif
        return fidx
    endif

    " Store the modification time for the file
    let s:tlist_{fidx}_mtime = getftime(a:filename)

    " No tags for current file
    if cmd_output == ''
        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
        return fidx
    endif

    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)

    if v:version > 601
        " The following script local variables are used by the
        " Tlist_Parse_Tagline() function.
        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let s:fidx = fidx
        let s:tidx = 0

        " Process the ctags output one line at a time.  The substitute()
        " command is used to parse the tag lines instead of using the
        " matchstr()/stridx()/strpart() functions for performance reason
        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = s:tidx

        " The following script local variables are no longer needed
        unlet! s:ctags_flags
        unlet! s:tidx
        unlet! s:fidx
    else
        " Due to a bug in Vim earlier than version 6.1,
        " we cannot use substitute() to parse the ctags output.
        " Instead the slow str*() functions are used
        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
        let tidx = 0

        while cmd_output != ''
            " Extract one line at a time
            let idx = stridx(cmd_output, "\n")
            let one_line = strpart(cmd_output, 0, idx)
            " Remove the line from the tags output
            let cmd_output = strpart(cmd_output, idx + 1)

            if one_line == ''
                " Line is not in proper tags format
                continue
            endif

            " Extract the tag type
            let ttype = s:Tlist_Extract_Tagtype(one_line)

            " Make sure the tag type is a valid and supported one
            if ttype == '' || stridx(ctags_flags, ttype) == -1
                " Line is not in proper tags format or Tag type is not
                " supported
                continue
            endif

            " Update the total tag count
            let tidx = tidx + 1

            " The following variables are used to optimize this code.  Vim is
            " slow in using curly brace names. To reduce the amount of
            " processing needed, the curly brace variables are pre-processed
            " here
            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype

            " Update the count of this tag type
            let ttype_idx = {fidx_ttype}_count + 1
            let {fidx_ttype}_count = ttype_idx

            " Store the ctags output for this tag
            let {fidx_tidx}_tag = one_line

            " Store the tag index and the tag type index (back pointers)
            let {fidx_ttype}_{ttype_idx} = tidx
            let {fidx_tidx}_ttype_idx = ttype_idx

            " Extract the tag name
            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))

            " Extract the tag scope/prototype
            if g:Tlist_Display_Prototype
                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
            else
                let ttxt = '    ' . tag_name

                " Add the tag scope, if it is available and is configured. Tag
                " scope is the last field after the 'line:<num>\t' field
                if g:Tlist_Display_Tag_Scope
                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
                    if tag_scope != ''
                        let ttxt = ttxt . ' [' . tag_scope . ']'
                    endif
                endif
            endif

            " Add this tag to the tag type variable
            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"

            " Save the tag name
            let {fidx_tidx}_tag_name = tag_name
        endwhile

        " Save the number of tags for this file
        let s:tlist_{fidx}_tag_count = tidx
    endif

    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
                \ ' tags in ' . a:filename)

    return fidx
endfunction

" Tlist_Update_File
" Update the tags for a file (if needed)
function! Tlist_Update_File(filename, ftype)
    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(a:filename, a:ftype)
        return
    endif

    " Convert the file name to a full path
    let fname = fnamemodify(a:filename, ':p')

    " First check whether the file already exists
    let fidx = s:Tlist_Get_File_Index(fname)

    if fidx != -1 && s:tlist_{fidx}_valid
        " File exists and the tags are valid
        " Check whether the file was modified after the last tags update
        " If it is modified, then update the tags
        if s:tlist_{fidx}_mtime == getftime(fname)
            return
        endif
    else
        " If the tags were removed previously based on a user request,
        " as we are going to update the tags (based on the user request),
        " remove the filename from the deleted list
        call s:Tlist_Update_Remove_List(fname, 0)
    endif

    " If the taglist window is opened, update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        " Taglist window is not present. Just update the taglist
        " and return
        call s:Tlist_Process_File(fname, a:ftype)
    else
        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
            " If tags for only one file are displayed and we are not
            " updating the tags for that file, then no need to
            " refresh the taglist window. Otherwise, the taglist
            " window should be updated.
            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
                call s:Tlist_Process_File(fname, a:ftype)
                return
            endif
        endif

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Save the cursor position
        let save_line = line('.')
        let save_col = col('.')

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(fname, a:ftype)

        " Restore the cursor position
        if v:version >= 601
            call cursor(save_line, save_col)
        else
            exe save_line
            exe 'normal! ' . save_col . '|'
        endif

        if winnr() != save_winnr
            " Go back to the original window
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(1)
    endif
endfunction

" Tlist_Window_Close
" Close the taglist window
function! s:Tlist_Window_Close()
    call s:Tlist_Log_Msg('Tlist_Window_Close()')
    " Make sure the taglist window exists
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    if winnr() == winnum
        " Already in the taglist window. Close it and return
        if winbufnr(2) != -1
            " If a window other than the taglist window is open,
            " then only close the taglist window.
            close
        endif
    else
        " Goto the taglist window, close it and then come back to the
        " original window
        let curbufnr = bufnr('%')
        exe winnum . 'wincmd w'
        close
        " Need to jump back to the original window only if we are not
        " already in that window
        let winnum = bufwinnr(curbufnr)
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
    endif
endfunction

" Tlist_Window_Mark_File_Window
" Mark the current window as the file window to use when jumping to a tag.
" Only if the current window is a non-plugin, non-preview and non-taglist
" window
function! s:Tlist_Window_Mark_File_Window()
    if getbufvar('%', '&buftype') == '' && !&previewwindow
        let w:tlist_file_window = "yes"
    endif
endfunction

" Tlist_Window_Open
" Open and refresh the taglist window
function! s:Tlist_Window_Open()
    call s:Tlist_Log_Msg('Tlist_Window_Open()')
    " If the window is open, jump to it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        " Jump to the existing window
        if winnr() != winnum
            exe winnum . 'wincmd w'
        endif
        return
    endif

    if s:tlist_app_name == "winmanager"
        " Taglist plugin is no longer part of the winmanager app
        let s:tlist_app_name = "none"
    endif

    " Get the filename and filetype for the specified buffer
    let curbuf_name = fnamemodify(bufname('%'), ':p')
    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
    let cur_lnum = line('.')

    " Mark the current window as the desired window to open a file when a tag
    " is selected.
    call s:Tlist_Window_Mark_File_Window()

    " Open the taglist window
    call s:Tlist_Window_Create()

    call s:Tlist_Window_Refresh()

    if g:Tlist_Show_One_File
        " Add only the current buffer and file
        "
        " If the file doesn't support tag listing, skip it
        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
        endif
    endif

    if g:Tlist_File_Fold_Auto_Close
        " Open the fold for the current file, as all the folds in
        " the taglist window are closed
        let fidx = s:Tlist_Get_File_Index(curbuf_name)
        if fidx != -1
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen!"
        endif
    endif

    " Highlight the current tag
    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
endfunction

" Tlist_Window_Toggle()
" Open or close a taglist window
function! s:Tlist_Window_Toggle()
    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
    " If taglist window is open then close it.
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        call s:Tlist_Window_Close()
        return
    endif

    call s:Tlist_Window_Open()

    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
    " set
    if !g:Tlist_GainFocus_On_ToggleOpen
        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Process_Filelist
" Process multiple files. Each filename is separated by "\n"
" Returns the number of processed files
function! s:Tlist_Process_Filelist(file_names)
    let flist = a:file_names

    " Enable lazy screen updates
    let old_lazyredraw = &lazyredraw
    set lazyredraw

    " Keep track of the number of processed files
    let fcnt = 0

    " Process one file at a time
    while flist != ''
        let nl_idx = stridx(flist, "\n")
        let one_file = strpart(flist, 0, nl_idx)

        " Remove the filename from the list
        let flist = strpart(flist, nl_idx + 1)

        if one_file == ''
            continue
        endif

        " Skip directories
        if isdirectory(one_file)
            continue
        endif

        let ftype = s:Tlist_Detect_Filetype(one_file)

        echon "\r                                                              "
        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')

        let fcnt = fcnt + 1

        call Tlist_Update_File(one_file, ftype)
    endwhile

    " Clear the displayed informational messages
    echon "\r                                                            "

    " Restore the previous state
    let &lazyredraw = old_lazyredraw

    return fcnt
endfunction

" Tlist_Process_Dir
" Process the files in a directory matching the specified pattern
function! s:Tlist_Process_Dir(dir_name, pat)
    let flist = glob(a:dir_name . '/' . a:pat) . "\n"

    let fcnt = s:Tlist_Process_Filelist(flist)

    let len = strlen(a:dir_name)
    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
        let glob_expr = a:dir_name . '*'
    else
        let glob_expr = a:dir_name . '/*'
    endif
    let all_files = glob(glob_expr) . "\n"

    while all_files != ''
        let nl_idx = stridx(all_files, "\n")
        let one_file = strpart(all_files, 0, nl_idx)

        let all_files = strpart(all_files, nl_idx + 1)
        if one_file == ''
            continue
        endif

        " Skip non-directory names
        if !isdirectory(one_file)
            continue
        endif

        echon "\r                                                              "
        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
    endwhile

    return fcnt
endfunction

" Tlist_Add_Files_Recursive
" Add files recursively from a directory
function! s:Tlist_Add_Files_Recursive(dir, ...)
    let dir_name = fnamemodify(a:dir, ':p')
    if !isdirectory(dir_name)
        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
        return
    endif

    if a:0 == 1
        " User specified file pattern
        let pat = a:1
    else
        " Default file pattern
        let pat = '*'
    endif

    echon "\r                                                              "
    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
    let fcnt = s:Tlist_Process_Dir(dir_name, pat)

    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Add_Files
" Add the specified list of files to the taglist
function! s:Tlist_Add_Files(...)
    let flist = ''
    let i = 1

    " Get all the files matching the file patterns supplied as argument
    while i <= a:0
        let flist = flist . glob(a:{i}) . "\n"
        let i = i + 1
    endwhile

    if flist == ''
        call s:Tlist_Warning_Msg('Error: No matching files are found')
        return
    endif

    let fcnt = s:Tlist_Process_Filelist(flist)
    echon "\rAdded " . fcnt . " files to the taglist"
endfunction

" Tlist_Extract_Tagtype
" Extract the tag type from the tag text
function! s:Tlist_Extract_Tagtype(tag_line)
    " The tag type is after the tag prototype field. The prototype field
    " ends with the /;"\t string. We add 4 at the end to skip the characters
    " in this special string..
    let start = strridx(a:tag_line, '/;"' . "\t") + 4
    let end = strridx(a:tag_line, 'line:') - 1
    let ttype = strpart(a:tag_line, start, end - start)

    return ttype
endfunction

" Tlist_Extract_Tag_Scope
" Extract the tag scope from the tag text
function! s:Tlist_Extract_Tag_Scope(tag_line)
    let start = strridx(a:tag_line, 'line:')
    let end = strridx(a:tag_line, "\t")
    if end <= start
        return ''
    endif

    let tag_scope = strpart(a:tag_line, end + 1)
    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)

    return tag_scope
endfunction

" Tlist_Refresh()
" Refresh the taglist
function! s:Tlist_Refresh()
    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
    " If we are entering the buffer from one of the taglist functions, then
    " no need to refresh the taglist window again.
    if s:Tlist_Skip_Refresh
        " We still need to update the taglist menu
        if g:Tlist_Show_Menu
            call s:Tlist_Menu_Update_File(0)
        endif
        return
    endif

    " If part of the winmanager plugin and not configured to process
    " tags always and not configured to display the tags menu, then return
    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
                \ && !g:Tlist_Show_Menu
        return
    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let tlist_win = bufwinnr(g:TagList_title)

    " If the taglist window is not opened and not configured to process
    " tags always and not displaying the tags menu, then return
    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " If the taglist should not be auto updated, then return
        if !g:Tlist_Auto_Update
            return
        endif
    endif

    let cur_lnum = line('.')

    if fidx == -1
        " Update the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
    else
        let mtime = getftime(filename)
        if s:tlist_{fidx}_mtime != mtime
            " Invalidate the tags listed for this file
            let s:tlist_{fidx}_valid = 0

            " Update the taglist and the window
            call Tlist_Update_File(filename, ftype)

            " Store the new file modification time
            let s:tlist_{fidx}_mtime = mtime
        endif
    endif

    " Update the taglist window
    if tlist_win != -1
        " Disable screen updates
        let old_lazyredraw = &lazyredraw
        set nolazyredraw

        " Save the current window number
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
            " Save the cursor position
            let save_line = line('.')
            let save_col = col('.')
        endif

        " Update the taglist window
        call s:Tlist_Window_Refresh_File(filename, ftype)

        " Open the fold for the file
        exe "silent! " . s:tlist_{fidx}_start . "," .
                    \ s:tlist_{fidx}_end . "foldopen!"

        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
                " If displaying tags for only one file in the taglist
                " window and about to display the tags for a new file,
                " then center the current tag line for the new file
                let center_tag_line = 1
            else
                let center_tag_line = 0
            endif

            " Highlight the current tag
            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
        else
            " Restore the cursor position
            if v:version >= 601
                call cursor(save_line, save_col)
            else
                exe save_line
                exe 'normal! ' . save_col . '|'
            endif
        endif

        " Jump back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
        endif

        " Restore screen updates
        let &lazyredraw = old_lazyredraw
    endif

    " Update the taglist menu
    if g:Tlist_Show_Menu
        call s:Tlist_Menu_Update_File(0)
    endif
endfunction

" Tlist_Change_Sort()
" Change the sort order of the tag listing
" caller == 'cmd', command used in the taglist window
" caller == 'menu', taglist menu
" action == 'toggle', toggle sort from name to order and vice versa
" action == 'set', set the sort order to sort_type
function! s:Tlist_Change_Sort(caller, action, sort_type)
    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
    if a:caller == 'cmd'
        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
        if fidx == -1
            return
        endif

        " Remove the previous highlighting
        match none
    elseif a:caller == 'menu'
        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
        if fidx == -1
            return
        endif
    endif

    if a:action == 'toggle'
        let sort_type = s:tlist_{fidx}_sort_type

        " Toggle the sort order from 'name' to 'order' and vice versa
        if sort_type == 'name'
            let s:tlist_{fidx}_sort_type = 'order'
        else
            let s:tlist_{fidx}_sort_type = 'name'
        endif
    else
        let s:tlist_{fidx}_sort_type = a:sort_type
    endif

    " Invalidate the tags listed for this file
    let s:tlist_{fidx}_valid = 0

    if a:caller  == 'cmd'
        " Save the current line for later restoration
        let curline = '\V\^' . getline('.') . '\$'

        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                    \   s:tlist_{fidx}_filetype)

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

        " Go back to the cursor line before the tag list is sorted
        call search(curline, 'w')

        call s:Tlist_Menu_Update_File(1)
    else
        call s:Tlist_Menu_Remove_File()

        call s:Tlist_Refresh()
    endif
endfunction

" Tlist_Update_Current_File()
" Update taglist for the current buffer by regenerating the tag list
" Contributed by WEN Guopeng.
function! s:Tlist_Update_Current_File()
    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
    if winnr() == bufwinnr(g:TagList_title)
        " In the taglist window. Update the current file
        call s:Tlist_Window_Update_File()
    else
        " Not in the taglist window. Update the current buffer
        let filename = fnamemodify(bufname('%'), ':p')
        let fidx = s:Tlist_Get_File_Index(filename)
        if fidx != -1
            let s:tlist_{fidx}_valid = 0
        endif
        let ft = s:Tlist_Get_Buffer_Filetype('%')
        call Tlist_Update_File(filename, ft)
    endif
endfunction

" Tlist_Window_Update_File()
" Update the tags displayed in the taglist window
function! s:Tlist_Window_Update_File()
    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    " Remove the previous highlighting
    match none

    " Save the current line for later restoration
    let curline = '\V\^' . getline('.') . '\$'

    let s:tlist_{fidx}_valid = 0

    " Update the taglist window
    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
                \ s:tlist_{fidx}_filetype)

    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'

    " Go back to the tag line before the list is updated
    call search(curline, 'w')
endfunction

" Tlist_Window_Get_Tag_Type_By_Linenum()
" Return the tag type index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
    let ftype = s:tlist_{a:fidx}_filetype

    " Determine to which tag type the current line number belongs to using the
    " tag type start line number and the number of tags in a tag type
    let i = 1
    while i <= s:tlist_{ftype}_count
        let ttype = s:tlist_{ftype}_{i}_name
        let start_lnum =
                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
        if a:lnum >= start_lnum && a:lnum <= end
            break
        endif
        let i = i + 1
    endwhile

    " Current line doesn't belong to any of the displayed tag types
    if i > s:tlist_{ftype}_count
        return ''
    endif

    return ttype
endfunction

" Tlist_Window_Get_Tag_Index()
" Return the tag index for the specified line in the taglist window
function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)

    " Current line doesn't belong to any of the displayed tag types
    if ttype == ''
        return 0
    endif

    " Compute the index into the displayed tags for the tag type
    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
    let tidx = a:lnum - ttype_lnum
    if tidx == 0
        return 0
    endif

    " Get the corresponding tag line and return it
    return s:tlist_{a:fidx}_{ttype}_{tidx}
endfunction

" Tlist_Window_Highlight_Line
" Highlight the current line
function! s:Tlist_Window_Highlight_Line()
    " Clear previously selected name
    match none

    " Highlight the current line
    if g:Tlist_Display_Prototype == 0
        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
    else
        let pat = '/\%' . line('.') . 'l.*/'
    endif

    exe 'match TagListTagName ' . pat
endfunction

" Tlist_Window_Open_File
" Open the specified file in either a new window or an existing window
" and place the cursor at the specified tag pattern
function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
                \ a:win_ctrl . ')')
    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
    let s:Tlist_Skip_Refresh = 1

    if s:tlist_app_name == "winmanager"
        " Let the winmanager edit the file
        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
    else

    if a:win_ctrl == 'newtab'
        " Create a new tab
        exe 'tabnew ' . escape(a:filename, ' ')
        " Open the taglist window in the new tab
        call s:Tlist_Window_Open()
    endif

    if a:win_ctrl == 'checktab'
        " Check whether the file is present in any of the tabs.
        " If the file is present in the current tab, then use the
        " current tab.
        if bufwinnr(a:filename) != -1
            let file_present_in_tab = 1
            let i = tabpagenr()
        else
            let i = 1
            let bnum = bufnr(a:filename)
            let file_present_in_tab = 0
            while i <= tabpagenr('$')
                if index(tabpagebuflist(i), bnum) != -1
                    let file_present_in_tab = 1
                    break
                endif
                let i += 1
            endwhile
        endif

        if file_present_in_tab
            " Goto the tab containing the file
            exe 'tabnext ' . i
        else
            " Open a new tab
            exe 'tabnew ' . escape(a:filename, ' ')

            " Open the taglist window
            call s:Tlist_Window_Open()
        endif
    endif

    let winnum = -1
    if a:win_ctrl == 'prevwin'
        " Open the file in the previous window, if it is usable
        let cur_win = winnr()
        wincmd p
        if &buftype == '' && !&previewwindow
            exe "edit " . escape(a:filename, ' ')
            let winnum = winnr()
        else
            " Previous window is not usable
            exe cur_win . 'wincmd w'
        endif
    endif

    " Goto the window containing the file.  If the window is not there, open a
    " new window
    if winnum == -1
        let winnum = bufwinnr(a:filename)
    endif

    if winnum == -1
        " Locate the previously used window for opening a file
        let fwin_num = 0
        let first_usable_win = 0

        let i = 1
        let bnum = winbufnr(i)
        while bnum != -1
            if getwinvar(i, 'tlist_file_window') == 'yes'
                let fwin_num = i
                break
            endif
            if first_usable_win == 0 &&
                        \ getbufvar(bnum, '&buftype') == '' &&
                        \ !getwinvar(i, '&previewwindow')
                " First non-taglist, non-plugin and non-preview window
                let first_usable_win = i
            endif
            let i = i + 1
            let bnum = winbufnr(i)
        endwhile

        " If a previously used window is not found, then use the first
        " non-taglist window
        if fwin_num == 0
            let fwin_num = first_usable_win
        endif

        if fwin_num != 0
            " Jump to the file window
            exe fwin_num . "wincmd w"

            " If the user asked to jump to the tag in a new window, then split
            " the existing window into two.
            if a:win_ctrl == 'newwin'
                split
            endif
            exe "edit " . escape(a:filename, ' ')
        else
            " Open a new window
            if g:Tlist_Use_Horiz_Window
                exe 'leftabove split ' . escape(a:filename, ' ')
            else
                if winbufnr(2) == -1
                    " Only the taglist window is present
                    if g:Tlist_Use_Right_Window
                        exe 'leftabove vertical split ' .
                                    \ escape(a:filename, ' ')
                    else
                        exe 'rightbelow vertical split ' .
                                    \ escape(a:filename, ' ')
                    endif

                    " Go to the taglist window to change the window size to
                    " the user configured value
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                    if g:Tlist_Use_Horiz_Window
                        exe 'resize ' . g:Tlist_WinHeight
                    else
                        exe 'vertical resize ' . g:Tlist_WinWidth
                    endif
                    " Go back to the file window
                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
                else
                    " A plugin or help window is also present
                    wincmd w
                    exe 'leftabove split ' . escape(a:filename, ' ')
                endif
            endif
        endif
        " Mark the window, so that it can be reused.
        call s:Tlist_Window_Mark_File_Window()
    else
        if v:version >= 700
            " If the file is opened in more than one window, then check
            " whether the last accessed window has the selected file.
            " If it does, then use that window.
            let lastwin_bufnum = winbufnr(winnr('#'))
            if bufnr(a:filename) == lastwin_bufnum
                let winnum = winnr('#')
            endif
        endif
        exe winnum . 'wincmd w'

        " If the user asked to jump to the tag in a new window, then split the
        " existing window into two.
        if a:win_ctrl == 'newwin'
            split
        endif
    endif
    endif

    " Jump to the tag
    if a:tagpat != ''
        " Add the current cursor position to the jump list, so that user can
        " jump back using the ' and ` marks.
        mark '
        silent call search(a:tagpat, 'w')

        " Bring the line to the middle of the window
        normal! z.

        " If the line is inside a fold, open the fold
        if foldclosed('.') != -1
            .foldopen
        endif
    endif

    " If the user selects to preview the tag then jump back to the
    " taglist window
    if a:win_ctrl == 'preview'
        " Go back to the taglist window
        let winnum = bufwinnr(g:TagList_title)
        exe winnum . 'wincmd w'
    else
        " If the user has selected to close the taglist window, when a
        " tag is selected, close the taglist  window
        if g:Tlist_Close_On_Select
            call s:Tlist_Window_Goto_Window()
            close

            " Go back to the window displaying the selected file
            let wnum = bufwinnr(a:filename)
            if wnum != -1 && wnum != winnr()
                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
            endif
        endif
    endif

    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
endfunction

" Tlist_Window_Jump_To_Tag()
" Jump to the location of the current tag
" win_ctrl == useopen - Reuse the existing file window
" win_ctrl == newwin - Open a new window
" win_ctrl == preview - Preview the tag
" win_ctrl == prevwin - Open in previous window
" win_ctrl == newtab - Open in new tab
function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a closed fold, then use the first line of the fold
    " and jump to the file.
    let lnum = foldclosed('.')
    if lnum == -1
        " Jump to the selected tag or file
        let lnum = line('.')
    else
        " Open the closed fold
        .foldopen!
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    " Get the tag output for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx != 0
        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)

        " Highlight the tagline
        call s:Tlist_Window_Highlight_Line()
    else
        " Selected a line which is not a tag name. Just edit the file
        let tagpat = ''
    endif

    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
endfunction

" Tlist_Window_Show_Info()
" Display information about the entry under the cursor
function! s:Tlist_Window_Show_Info()
    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')

    " Clear the previously displayed line
    echo

    " Do not process comment lines and empty lines
    let curline = getline('.')
    if curline =~ '^\s*$' || curline[0] == '"'
        return
    endif

    " If inside a fold, then don't display the prototype
    if foldclosed('.') != -1
        return
    endif

    let lnum = line('.')

    " Get the file index
    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
    if fidx == -1
        return
    endif

    if lnum == s:tlist_{fidx}_start
        " Cursor is on a file name
        let fname = s:tlist_{fidx}_filename
        if strlen(fname) > 50
            let fname = fnamemodify(fname, ':t')
        endif
        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
        return
    endif

    " Get the tag output line for the current tag
    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
    if tidx == 0
        " Cursor is on a tag type
        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
        if ttype == ''
            return
        endif

        let ttype_name = ''

        let ftype = s:tlist_{fidx}_filetype
        let i = 1
        while i <= s:tlist_{ftype}_count
            if ttype == s:tlist_{ftype}_{i}_name
                let ttype_name = s:tlist_{ftype}_{i}_fullname
                break
            endif
            let i = i + 1
        endwhile

        echo 'Tag type=' . ttype_name .
                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
        return
    endif

    " Get the tag search pattern and display it
    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Find_Nearest_Tag_Idx
" Find the tag idx nearest to the supplied line number
" Returns -1, if a tag couldn't be found for the specified line number
function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
    let sort_type = s:tlist_{a:fidx}_sort_type

    let left = 1
    let right = s:tlist_{a:fidx}_tag_count

    if sort_type == 'order'
        " Tags sorted by order, use a binary search.
        " The idea behind this function is taken from the ctags.vim script (by
        " Alexey Marinichev) available at the Vim online website.

        " If the current line is the less than the first tag, then no need to
        " search
        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)

        if a:linenum < first_lnum
            return -1
        endif

        while left < right
            let middle = (right + left + 1) / 2
            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)

            if middle_lnum == a:linenum
                let left = middle
                break
            endif

            if middle_lnum > a:linenum
                let right = middle - 1
            else
                let left = middle
            endif
        endwhile
    else
        " Tags sorted by name, use a linear search. (contributed by Dave
        " Eggum).
        " Look for a tag with a line number less than or equal to the supplied
        " line number. If multiple tags are found, then use the tag with the
        " line number closest to the supplied line number. IOW, use the tag
        " with the highest line number.
        let closest_lnum = 0
        let final_left = 0
        while left <= right
            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)

            if lnum < a:linenum && lnum > closest_lnum
                let closest_lnum = lnum
                let final_left = left
            elseif lnum == a:linenum
                let closest_lnum = lnum
                let final_left = left
                break
            else
                let left = left + 1
            endif
        endwhile
        if closest_lnum == 0
            return -1
        endif
        if left >= right
            let left = final_left
        endif
    endif

    return left
endfunction

" Tlist_Window_Highlight_Tag()
" Highlight the current tag
" cntx == 1, Called by the taglist plugin itself
" cntx == 2, Forced by the user through the TlistHighlightTag command
" center = 1, move the tag line to the center of the taglist window
function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
    " Highlight the current tag only if the user configured the
    " taglist plugin to do so or if the user explictly invoked the
    " command to highlight the current tag.
    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
        return
    endif

    if a:filename == ''
        return
    endif

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
        return
    endif

    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        return
    endif

    " If the file is currently not displayed in the taglist window, then retrn
    if !s:tlist_{fidx}_visible
        return
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return
    endif

    " Ignore all autocommands
    let old_ei = &eventignore
    set eventignore=all

    " Save the original window number
    let org_winnr = winnr()

    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    " Go to the taglist window
    if !in_taglist_window
        exe winnum . 'wincmd w'
    endif

    " Clear previously selected name
    match none

    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
    if tidx == -1
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        let lnum = line('.')

        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
            " Move the cursor to the beginning of the file
            exe s:tlist_{fidx}_start
        endif

        if foldclosed('.') != -1
            .foldopen
        endif

        call winline()

        if !in_taglist_window
            exe org_winnr . 'wincmd w'
        endif

        " Restore the autocommands
        let &eventignore = old_ei
        return
    endif

    " Extract the tag type
    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)

    " Compute the line number
    " Start of file + Start of tag type + offset
    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
                \ s:tlist_{fidx}_{tidx}_ttype_idx

    " Goto the line containing the tag
    exe lnum

    " Open the fold
    if foldclosed('.') != -1
        .foldopen
    endif

    if a:center
        " Move the tag line to the center of the taglist window
        normal! z.
    else
        " Make sure the current tag line is visible in the taglist window.
        " Calling the winline() function makes the line visible.  Don't know
        " of a better way to achieve this.
        call winline()
    endif

    " Highlight the tag name
    call s:Tlist_Window_Highlight_Line()

    " Go back to the original window
    if !in_taglist_window
        exe org_winnr . 'wincmd w'
    endif

    " Restore the autocommands
    let &eventignore = old_ei
    return
endfunction

" Tlist_Get_Tag_Prototype_By_Line
" Get the prototype for the tag on or before the specified line number in the
" current buffer
function! Tlist_Get_Tag_Prototype_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
                                \ '<line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Expand the file to a fully qualified name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag text using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
endfunction

" Tlist_Get_Tagname_By_Line
" Get the tag name on or before the specified line number in the
" current buffer
function! Tlist_Get_Tagname_By_Line(...)
    if a:0 == 0
        " Arguments are not supplied. Use the current buffer name
        " and line number
        let filename = bufname('%')
        let linenr = line('.')
    elseif a:0 == 2
        " Filename and line number are specified
        let filename = a:1
        let linenr = a:2
        if linenr !~ '\d\+'
            " Invalid line number
            return ""
        endif
    else
        " Sufficient arguments are not supplied
        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
        call s:Tlist_Warning_Msg(msg)
        return ""
    endif

    " Make sure the current file has a name
    let filename = fnamemodify(filename, ':p')
    if filename == ''
        return ""
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1
        return ""
    endif

    " If there are no tags for this file, then no need to proceed further
    if s:tlist_{fidx}_tag_count == 0
        return ""
    endif

    " Get the tag name using the line number
    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
    if tidx == -1
        return ""
    endif

    return s:tlist_{fidx}_{tidx}_tag_name
endfunction

" Tlist_Window_Move_To_File
" Move the cursor to the beginning of the current file or the next file
" or the previous file in the taglist window
" dir == -1, move to start of current or previous function
" dir == 1, move to start of next function
function! s:Tlist_Window_Move_To_File(dir)
    if foldlevel('.') == 0
        " Cursor is on a non-folded line (it is not in any of the files)
        " Move it to a folded line
        if a:dir == -1
            normal! zk
        else
            " While moving down to the start of the next fold,
            " no need to do go to the start of the next file.
            normal! zj
            return
        endif
    endif

    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
    if fidx == -1
        return
    endif

    let cur_lnum = line('.')

    if a:dir == -1
        if cur_lnum > s:tlist_{fidx}_start
            " Move to the beginning of the current file
            exe s:tlist_{fidx}_start
            return
        endif

        if fidx != 0
            " Move to the beginning of the previous file
            let fidx = fidx - 1
        else
            " Cursor is at the first file, wrap around to the last file
            let fidx = s:tlist_file_count - 1
        endif

        exe s:tlist_{fidx}_start
        return
    else
        " Move to the beginning of the next file
        let fidx = fidx + 1

        if fidx >= s:tlist_file_count
            " Cursor is at the last file, wrap around to the first file
            let fidx = 0
        endif

        if s:tlist_{fidx}_start != 0
            exe s:tlist_{fidx}_start
        endif
        return
    endif
endfunction

" Tlist_Session_Load
" Load a taglist session (information about all the displayed files
" and the tags) from the specified file
function! s:Tlist_Session_Load(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
        return
    endif

    let sessionfile = a:1

    if !filereadable(sessionfile)
        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
        call s:Tlist_Warning_Msg(msg)
        return
    endif

    " Mark the current window as the file window
    call s:Tlist_Window_Mark_File_Window()

    " Source the session file
    exe 'source ' . sessionfile

    let new_file_count = g:tlist_file_count
    unlet! g:tlist_file_count

    let i = 0
    while i < new_file_count
        let ftype = g:tlist_{i}_filetype
        unlet! g:tlist_{i}_filetype

        if !exists('s:tlist_' . ftype . '_count')
            if s:Tlist_FileType_Init(ftype) == 0
                let i = i + 1
                continue
            endif
        endif

        let fname = g:tlist_{i}_filename
        unlet! g:tlist_{i}_filename

        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            let s:tlist_{fidx}_visible = 0
            let i = i + 1
            continue
        else
            " As we are loading the tags from the session file, if this
            " file was previously deleted by the user, now we need to
            " add it back. So remove the file from the deleted list.
            call s:Tlist_Update_Remove_List(fname, 0)
        endif

        let fidx = s:Tlist_Init_File(fname, ftype)

        let s:tlist_{fidx}_filename = fname

        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
        unlet! g:tlist_{i}_sort_type

        let s:tlist_{fidx}_filetype = ftype
        let s:tlist_{fidx}_mtime = getftime(fname)

        let s:tlist_{fidx}_start = 0
        let s:tlist_{fidx}_end = 0

        let s:tlist_{fidx}_valid = 1

        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
        unlet! g:tlist_{i}_tag_count

        let j = 1
        while j <= s:tlist_{fidx}_tag_count
            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
            unlet! g:tlist_{i}_{j}_tag
            unlet! g:tlist_{i}_{j}_tag_name
            unlet! g:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name

            if exists('g:tlist_' . i . '_' . ttype)
                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
                unlet! g:tlist_{i}_{ttype}
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
                unlet! g:tlist_{i}_{ttype}_count

                let k = 1
                while k <= s:tlist_{fidx}_{ttype}_count
                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
                    unlet! g:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            else
                let s:tlist_{fidx}_{ttype} = ''
                let s:tlist_{fidx}_{ttype}_offset = 0
                let s:tlist_{fidx}_{ttype}_count = 0
            endif

            let j = j + 1
        endwhile

        let i = i + 1
    endwhile

    " If the taglist window is open, then update it
    let winnum = bufwinnr(g:TagList_title)
    if winnum != -1
        let save_winnr = winnr()

        " Goto the taglist window
        call s:Tlist_Window_Goto_Window()

        " Refresh the taglist window
        call s:Tlist_Window_Refresh()

        " Go back to the original window
        if save_winnr != winnr()
            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
        endif
    endif
endfunction

" Tlist_Session_Save
" Save a taglist session (information about all the displayed files
" and the tags) into the specified file
function! s:Tlist_Session_Save(...)
    if a:0 == 0 || a:1 == ''
        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
        return
    endif

    let sessionfile = a:1

    if s:tlist_file_count == 0
        " There is nothing to save
        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
        return
    endif

    if filereadable(sessionfile)
        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
        if ans !=? 'y'
            return
        endif

        echo "\n"
    endif

    let old_verbose = &verbose
    set verbose&vim

    exe 'redir! > ' . sessionfile

    silent! echo '" Taglist session file. This file is auto-generated.'
    silent! echo '" File information'
    silent! echo 'let tlist_file_count = ' . s:tlist_file_count

    let i = 0

    while i < s:tlist_file_count
        " Store information about the file
        silent! echo 'let tlist_' . i . "_filename = '" .
                                            \ s:tlist_{i}_filename . "'"
        silent! echo 'let tlist_' . i . '_sort_type = "' .
                                                \ s:tlist_{i}_sort_type . '"'
        silent! echo 'let tlist_' . i . '_filetype = "' .
                                            \ s:tlist_{i}_filetype . '"'
        silent! echo 'let tlist_' . i . '_tag_count = ' .
                                                        \ s:tlist_{i}_tag_count
        " Store information about all the tags
        let j = 1
        while j <= s:tlist_{i}_tag_count
            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
                        \ s:tlist_{i}_{j}_tag_name . '"'
            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
                        \ s:tlist_{i}_{j}_ttype_idx
            let j = j + 1
        endwhile

        " Store information about all the tags grouped by their type
        let ftype = s:tlist_{i}_filetype
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{i}_{ttype}_count != 0
                let txt = escape(s:tlist_{i}_{ttype}, '"\')
                let txt = substitute(txt, "\n", "\\\\n", 'g')
                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
                                                \ txt . '"'
                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
                                                     \ s:tlist_{i}_{ttype}_count
                let k = 1
                while k <= s:tlist_{i}_{ttype}_count
                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
                    let k = k + 1
                endwhile
            endif
            let j = j + 1
        endwhile

        silent! echo

        let i = i + 1
    endwhile

    redir END

    let &verbose = old_verbose
endfunction

" Tlist_Buffer_Removed
" A buffer is removed from the Vim buffer list. Remove the tags defined
" for that file
function! s:Tlist_Buffer_Removed(filename)
    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')

    " Make sure a valid filename is supplied
    if a:filename == ''
        return
    endif

    " Get tag list index of the specified file
    let fidx = s:Tlist_Get_File_Index(a:filename)
    if fidx == -1
        " File not present in the taglist
        return
    endif

    " Remove the file from the list
    call s:Tlist_Remove_File(fidx, 0)
endfunction

" When a buffer is deleted, remove the file from the taglist
autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))

" Tlist_Window_Open_File_Fold
" Open the fold for the specified file and close the fold for all the
" other files
function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')

    " Make sure the taglist window is present
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
        return
    endif

    " Save the original window number
    let org_winnr = winnr()
    if org_winnr == winnum
        let in_taglist_window = 1
    else
        let in_taglist_window = 0
    endif

    if in_taglist_window
        " When entering the taglist window, no need to update the folds
        return
    endif

    " Go to the taglist window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
    endif

    " Close all the folds
    silent! %foldclose

    " Get tag list index of the specified file
    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    if filereadable(fname)
        let fidx = s:Tlist_Get_File_Index(fname)
        if fidx != -1
            " Open the fold for the file
            exe "silent! " . s:tlist_{fidx}_start . "," .
                        \ s:tlist_{fidx}_end . "foldopen"
        endif
    endif

    " Go back to the original window
    if !in_taglist_window
        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
    endif
endfunction

" Tlist_Window_Check_Auto_Open
" Open the taglist window automatically on Vim startup.
" Open the window only when files present in any of the Vim windows support
" tags.
function! s:Tlist_Window_Check_Auto_Open()
    let open_window = 0

    let i = 1
    let buf_num = winbufnr(i)
    while buf_num != -1
        let filename = fnamemodify(bufname(buf_num), ':p')
        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
        if !s:Tlist_Skip_File(filename, ft)
            let open_window = 1
            break
        endif
        let i = i + 1
        let buf_num = winbufnr(i)
    endwhile

    if open_window
        call s:Tlist_Window_Toggle()
    endif
endfunction

" Tlist_Refresh_Folds
" Remove and create the folds for all the files displayed in the taglist
" window. Used after entering a tab. If this is not done, then the folds
" are not properly created for taglist windows displayed in multiple tabs.
function! s:Tlist_Refresh_Folds()
    let winnum = bufwinnr(g:TagList_title)
    if winnum == -1
        return
    endif

    let save_wnum = winnr()
    exe winnum . 'wincmd w'

    " First remove all the existing folds
    normal! zE

    " Create the folds for each in the tag list
    let fidx = 0
    while fidx < s:tlist_file_count
        let ftype = s:tlist_{fidx}_filetype

        " Create the folds for each tag type in a file
        let j = 1
        while j <= s:tlist_{ftype}_count
            let ttype = s:tlist_{ftype}_{j}_name
            if s:tlist_{fidx}_{ttype}_count
                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
                let e = s + s:tlist_{fidx}_{ttype}_count
                exe s . ',' . e . 'fold'
            endif
            let j = j + 1
        endwhile

        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
                    \ s:tlist_{fidx}_end . 'foldopen!'
        let fidx = fidx + 1
    endwhile

    exe save_wnum . 'wincmd w'
endfunction

function! s:Tlist_Menu_Add_Base_Menu()
    call s:Tlist_Log_Msg('Adding the base menu')

    " Add the menu
    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Name
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
    anoremenu <silent> T&ags.Sort\ menu\ by.Order
                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
    anoremenu T&ags.-SEP1-           :

    if &mousemodel =~ 'popup'
        anoremenu <silent> PopUp.T&ags.Refresh\ menu
                    \ :call <SID>Tlist_Menu_Refresh()<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
        anoremenu PopUp.T&ags.-SEP1-           :
    endif
endfunction

let s:menu_char_prefix =
            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

" Tlist_Menu_Get_Tag_Type_Cmd
" Get the menu command for the specified tag type
" fidx - File type index
" ftype - File Type
" add_ttype_name - To add or not to add the tag type name to the menu entries
" ttype_idx - Tag type index
function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
    " Curly brace variable name optimization
    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx

    let ttype = s:tlist_{ftype_ttype_idx}_name
    if a:add_ttype_name
        " If the tag type name contains space characters, escape it. This
        " will be used to create the menu entries.
        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
    endif

    " Curly brace variable name optimization
    let fidx_ttype = a:fidx . '_' . ttype

    " Number of tag entries for this tag type
    let tcnt = s:tlist_{fidx_ttype}_count
    if tcnt == 0 " No entries for this tag type
        return ''
    endif

    let mcmd = ''

    " Create the menu items for the tags.
    " Depending on the number of tags of this type, split the menu into
    " multiple sub-menus, if needed.
    if tcnt > g:Tlist_Max_Submenu_Items
        let j = 1
        while j <= tcnt
            let final_index = j + g:Tlist_Max_Submenu_Items - 1
            if final_index > tcnt
                let final_index = tcnt
            endif

            " Extract the first and last tag name and form the
            " sub-menu name
            let tidx = s:tlist_{fidx_ttype}_{j}
            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            let tidx = s:tlist_{fidx_ttype}_{final_index}
            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name

            " Truncate the names, if they are greater than the
            " max length
            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)

            " Form the menu command prefix
            let m_prefix = 'anoremenu <silent> T\&ags.'
            if a:add_ttype_name
                let m_prefix = m_prefix . ttype_fullname . '.'
            endif
            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'

            " Character prefix used to number the menu items (hotkey)
            let m_prefix_idx = 0

            while j <= final_index
                let tidx = s:tlist_{fidx_ttype}_{j}

                let tname = s:tlist_{a:fidx}_{tidx}_tag_name

                let mcmd = mcmd . m_prefix . '\&' .
                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
                            \ tidx . ')<CR>|'

                let m_prefix_idx = m_prefix_idx + 1
                let j = j + 1
            endwhile
        endwhile
    else
        " Character prefix used to number the menu items (hotkey)
        let m_prefix_idx = 0

        let m_prefix = 'anoremenu <silent> T\&ags.'
        if a:add_ttype_name
            let m_prefix = m_prefix . ttype_fullname . '.'
        endif
        let j = 1
        while j <= tcnt
            let tidx = s:tlist_{fidx_ttype}_{j}

            let tname = s:tlist_{a:fidx}_{tidx}_tag_name

            let mcmd = mcmd . m_prefix . '\&' .
                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
                        \ . ')<CR>|'

            let m_prefix_idx = m_prefix_idx + 1
            let j = j + 1
        endwhile
    endif

    return mcmd
endfunction

" Update the taglist menu with the tags for the specified file
function! s:Tlist_Menu_File_Refresh(fidx)
    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
    " The 'B' flag is needed in the 'cpoptions' option
    let old_cpoptions = &cpoptions
    set cpoptions&vim

    exe s:tlist_{a:fidx}_menu_cmd

    " Update the popup menu (if enabled)
    if &mousemodel =~ 'popup'
        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
                                        \ ' PopUp.T\\\&ags.', "g")
        exe cmd
    endif

    " The taglist menu is not empty now
    let s:tlist_menu_empty = 0

    " Restore the 'cpoptions' settings
    let &cpoptions = old_cpoptions
endfunction

" Tlist_Menu_Update_File
" Add the taglist menu
function! s:Tlist_Menu_Update_File(clear_menu)
    if !has('gui_running')
        " Not running in GUI mode
        return
    endif

    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)

    " Remove the tags menu
    if a:clear_menu
        call s:Tlist_Menu_Remove_File()

    endif

    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    if &buftype != ''
        return
    endif

    let filename = fnamemodify(bufname('%'), ':p')
    let ftype = s:Tlist_Get_Buffer_Filetype('%')

    " If the file doesn't support tag listing, skip it
    if s:Tlist_Skip_File(filename, ftype)
        return
    endif

    let fidx = s:Tlist_Get_File_Index(filename)
    if fidx == -1 || !s:tlist_{fidx}_valid
        " Check whether this file is removed based on user request
        " If it is, then don't display the tags for this file
        if s:Tlist_User_Removed_File(filename)
            return
        endif

        " Process the tags for the file
        let fidx = s:Tlist_Process_File(filename, ftype)
        if fidx == -1
            return
        endif
    endif

    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
    if fname != ''
        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
        anoremenu T&ags.-SEP2-           :
    endif

    if !s:tlist_{fidx}_tag_count
        return
    endif

    if s:tlist_{fidx}_menu_cmd != ''
        " Update the menu with the cached command
        call s:Tlist_Menu_File_Refresh(fidx)

        return
    endif

    " We are going to add entries to the tags menu, so the menu won't be
    " empty
    let s:tlist_menu_empty = 0

    let cmd = ''

    " Determine whether the tag type name needs to be added to the menu
    " If more than one tag type is present in the taglisting for a file,
    " then the tag type name needs to be present
    let add_ttype_name = -1
    let i = 1
    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
        let ttype = s:tlist_{ftype}_{i}_name
        if s:tlist_{fidx}_{ttype}_count
            let add_ttype_name = add_ttype_name + 1
        endif
        let i = i + 1
    endwhile

    " Process the tags by the tag type and get the menu command
    let i = 1
    while i <= s:tlist_{ftype}_count
        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
        if mcmd != ''
            let cmd = cmd . mcmd
        endif

        let i = i + 1
    endwhile

    " Cache the menu command for reuse
    let s:tlist_{fidx}_menu_cmd = cmd

    " Update the menu
    call s:Tlist_Menu_File_Refresh(fidx)
endfunction

" Tlist_Menu_Remove_File
" Remove the tags displayed in the tags menu
function! s:Tlist_Menu_Remove_File()
    if !has('gui_running') || s:tlist_menu_empty
        return
    endif

    call s:Tlist_Log_Msg('Removing the tags menu for a file')

    " Cleanup the Tags menu
    silent! unmenu T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu PopUp.T&ags
    endif

    " Add a dummy menu item to retain teared off menu
    noremenu T&ags.Dummy l

    silent! unmenu! T&ags
    if &mousemodel =~ 'popup'
        silent! unmenu! PopUp.T&ags
    endif

    call s:Tlist_Menu_Add_Base_Menu()

    " Remove the dummy menu item
    unmenu T&ags.Dummy

    let s:tlist_menu_empty = 1
endfunction

" Tlist_Menu_Refresh
" Refresh the taglist menu
function! s:Tlist_Menu_Refresh()
    call s:Tlist_Log_Msg('Refreshing the tags menu')
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx != -1
        " Invalidate the cached menu command
        let s:tlist_{fidx}_menu_cmd = ''
    endif

    " Update the taglist, menu and window
    call s:Tlist_Update_Current_File()
endfunction

" Tlist_Menu_Jump_To_Tag
" Jump to the selected tag
function! s:Tlist_Menu_Jump_To_Tag(tidx)
    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
    if fidx == -1
        return
    endif

    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
    if tagpat == ''
        return
    endif

    " Add the current cursor position to the jump list, so that user can
    " jump back using the ' and ` marks.
    mark '

    silent call search(tagpat, 'w')

    " Bring the line to the middle of the window
    normal! z.

    " If the line is inside a fold, open the fold
    if foldclosed('.') != -1
        .foldopen
    endif
endfunction

" Tlist_Menu_Init
" Initialize the taglist menu
function! s:Tlist_Menu_Init()
    call s:Tlist_Menu_Add_Base_Menu()

    " Automatically add the tags defined in the current file to the menu
    augroup TagListMenuCmds
        autocmd!

        if !g:Tlist_Process_File_Always
            autocmd BufEnter * call s:Tlist_Refresh()
        endif
        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
    augroup end

    call s:Tlist_Menu_Update_File(0)
endfunction

" Tlist_Vim_Session_Load
" Initialize the taglist window/buffer, which is created when loading
" a Vim session file.
function! s:Tlist_Vim_Session_Load()
    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')

    " Initialize the taglist window
    call s:Tlist_Window_Init()

    " Refresh the taglist window
    call s:Tlist_Window_Refresh()
endfunction

" Tlist_Set_App
" Set the name of the external plugin/application to which taglist
" belongs.
" Taglist plugin is part of another plugin like cream or winmanager.
function! Tlist_Set_App(name)
    if a:name == ""
        return
    endif

    let s:tlist_app_name = a:name
endfunction

" Winmanager integration

" Initialization required for integration with winmanager
function! TagList_Start()
    " If current buffer is not taglist buffer, then don't proceed
    if bufname('%') != '__Tag_List__'
        return
    endif

    call Tlist_Set_App('winmanager')

    " Get the current filename from the winmanager plugin
    let bufnum = WinManagerGetLastEditedFile()
    if bufnum != -1
        let filename = fnamemodify(bufname(bufnum), ':p')
        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
    endif

    " Initialize the taglist window, if it is not already initialized
    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
        call s:Tlist_Window_Init()
        call s:Tlist_Window_Refresh()
        let s:tlist_window_initialized = 1
    endif

    " Update the taglist window
    if bufnum != -1
        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
            call s:Tlist_Window_Refresh_File(filename, ftype)
        endif
    endif
endfunction

function! TagList_IsValid()
    return 0
endfunction

function! TagList_WrapUp()
    return 0
endfunction

" restore 'cpo'
let &cpo = s:cpo_save
unlet s:cpo_save

zhimakaimen:/bundle/taglist.vim/plugin/taglist.vim
["test.vim","test.zip","test_syntax.vim","ToggleCommentify.vim","DoxyGen-Syntax","keepcase.vim","ifdef-highlighting","vimbuddy.vim","buffoptions.vim","fortune.vim","drawing.vim","ctags.vim","closetag.vim","htmlcmd.vim","ccase.vim","compiler.tar.gz","ls.vim","calendar.vim","dl.vim","jcommenter.vim","info.vim","hunspchk.zip","EnhCommentify.vim","LoadHeaderFile.vim","mailbrowser.vim","vimmailr.zip","format.vim","vimxmms.tar.gz","sourceSafe.zip","python.vim","a.vim","vimrc.tcl","oravim.txt","javabean.vim","jbean.vim","vimvccmd.zip","dbhelper.tgz","matchit.zip","DrawIt","rcs-menu.vim","bufexplorer.zip","sccs-menu.vim","completeWord.py","Mail_Sig.set","Mail_mutt_alias.set","Mail_Re.set","Triggers.vim","Mail_cc.set","lh-brackets","cscope_macros.vim","calendar.vim","colorize.vim","ConvertBase.vim","TagsMenu.zip","perl.vim","oberon.vim","cvsmenu.vim","dtags","delphi.vim","Embperl_Syntax.zip","whatdomain.vim","emacs.vim","po.vim","CD.vim","_vim_wok_visualcpp01.zip","nqc.vim","vfp.vim","project.tar.gz","pt.vim.gz","dctl.vim.gz","foo.vim","word_complete.vim","aux2tags.vim","javaimp.vim","uri-ref","incfiles.vim","functags.vim","wordlist.vim","files2menu.pm","translate.vim","AppendComment.vim","let-modeline.vim","gdbvim.tar.gz","Mkcolorscheme.vim","brief.vim","plkeyb.vim","vimtips.zip","savevers.vim","vcscommand.vim","nsis.vim","borland.vim","tex.vim","express.vim","winmanager","methods.vim","sqlplus.vim","spec.vim","mail.tgz","TagsBase.zip","nlist.vim","DirDiff.vim","regview.vim","BlockHL","desert.vim","colorscheme_template.vim","SelectBuf","bufNwinUtils.vim","lightWeightArray.vim","golden.vim","torte.vim","borland.vim","idutils","MultiPrompt.vim","blue.vim","csharp.vim","cs.vim","Shell.vim","vim.vim","Decho","asu1dark.vim","Astronaut","sum.vim","quickhigh.tgz","selbuff.vim","ctx-1.15.vim","runscript.vim","random_vim_tip.tar.gz","PushPop.vim","usr2latex.pl","spellcheck.vim","PopupBuffer.vim","TableTab.vim","djgpp.vim","vim-spell.tar.gz","ada.vim","ada.vim","which.vim","VirMark.vim","oracle.vim","sql.vim","words_tools.vim","chcmdmod.vim","increment.vim","CmdlineCompl.vim","SearchCompl.vim","perl_io.vim","darkslategray.vim","undoins.vim","cisco-syntax.tar.gz","ShowMarks","EasyHtml.vim","ctags.vim","ant_menu.vim","increment.vim","autoload_cscope.vim","foldutil.vim","minibufexpl.vim","gtkvim.tgz","FavMenu.vim","auctex.vim","ruby-macros.vim","html-macros.vim","vimsh.tar.gz","libList.vim","perforce.vim","idevim.tgz","email.vim","mcant.vim","multvals.vim","TeTrIs.vim","boxdraw","tf.vim","CreateMenuPath.vim","Lineup--A-simple-text-aligner","Justify","A-better-tcl-indent","ViMail","remcmd.vim","prt_mgr.zip","SuperTab","treeexplorer","vtreeexplorer","bk-menu.vim","glib.vim","win-manager-Improved","ruby-menu.vim","renumber.vim","navajo.vim","wcd.vim","RExplorer","fortune.vim","MRU","Engspchk","vcal.vim","genutils","template-file-loader","charset.vim","ComplMenu.vim","bcbuf.vim","quickfonts.vim","DSP-Make","vimconfig","morse.vim","LaTeX-Help","MRU-Menu","ctx","Perldoc.vim","fine_blue.vim","sokoban.vim","linuxmag.vim","c.vim","lh-vim-lib","tagmenu.vim","xmms-play-and-enqueue","cmvc.vim","tex.vim","bccalc.vim","mkview.vim","VIlisp.vim","mu-template","xl_tiv.vim","night.vim","einstimer.vim","closeb","Brown","Expand-Template","search-in-runtime","Brace-Complete-for-CCpp","Smart-Tabs","spell.vim","print_bw.zip","std_c.zip","Naught-n-crosses","SourceSafe-Integration","Michaels-Standard-Settings","Hex-Output","Visual-Mapping-Maker","perforce","xul.vim","cream-capitalization","mu-marks","imaps.vim","JavaRun","Buffer-Menus","cream-ascii","vimRubyX","update_vim","bnf.vim","lid.vim","UserMenu.vim","midnight.vim","tmpl.vim","ihtml.vim","pascii","XSLT-syntax","htmlmap","lastchange.vim","manxome-foes-colorscheme","vimdoc","doc.vim","csc.vim","aspnet.vim","brief.vim","java.vim","Nsis-color","byteme.vim","scite-colors","Cool-colors","navajo-night","multi.vim","taglist.vim","User-Defined-Type-Highlighter","camo.vim","adrian.vim","PrintWithLNum","sybase.vim","Projmgr","netdict","ExecPerl","candy.vim","txt2pdf.vim","unilatex.vim","potts.vim","sessmgr","outlineMode.vim","aqua","serverlist.vim","ruby-matchit","autodate.vim","xian.vim","utl.vim","Align","bluegreen","showbrace","latextags","vimfortune","TabIndent","Vimacs","xmledit","AnsiEsc.vim","ftpluginruby.vim","pyimp.vim","sql_iabbr.vim","gnome-doc.vim","xemacs-colorscheme","fog-colorscheme","CSV-delimited-field-jumper","cream-sort","grep.vim","ipsec_conf.vim","EDIFACT-position-in-a-segment","tomatosoup.vim","xchat-log-syntax","broadcast.vim","vera.vim","f.vim","highlightline.vim","hungarian_to_english","Buffer-Search","srecord.vim","reformat.vim","multivim","JavaImp.vim","PHPcollection","JHTML-syntax-file","Nightshimmer","cfengine-syntax-file","code2html","prt_hdr","cream-progressbar","QuickAscii","bw.vim","lh-cpp","vtags","vtags_def","ASP-maps","tforge.vim","pf.vim","sand","fstab-syntax","MqlMenu.vim","lcscheck.vim","php.vim","textlink.vim","White-Dust","ruby.vim","Highlight-UnMatched-Brackets","localColorSchemes.vim","multipleRanges.vim","getVar.vim","variableSort.vim","vimrc_nopik","dbext.vim","openroad.vim","java_apidoc.vim","ABAP.vim","rcsdiff.vim","snippet.vim","opsplorer","cream-showinvisibles","bash-support.vim","ldraw.vim","DirDo.vim","oceandeep","atomcoder-vim","Expmod","timstamp.vim","Red-Black","ftpluginruby.vim","indentruby.vim","Denim","mof.vim","vim-game-of-life","ia64.vim","d.vim","PreviewTag.vim","ShowLine.vim","ShowBlockName.vim","SyntaxAttr.vim","DarkOcean.vim","ibmedit.vim","python_match.vim","rnc.vim","LbdbQuery.vim","scratch-utility","plp.vim","LaTeX-functions","ocean.vim","spectre.vim","bugfixes-to-vim-indent-for-verilog","gri.vim","scilab.vim","ShowFunc.vim","maxima.vim","ironman.vim","sean.vim","regRedir.vim","colormenu.vim","eruby.vim","getmail.vim","colour_flip.pl","blackdust.vim","CVSAnnotate.vim","beanshell.vim","svn.vim","muf.vim","tex.vim","cvopsefsa.vim","ActionScript","plsql.vim","Zenburn","Kent-Vim-Extensions","plsql.vim","Registryedit-win32","syslog-syntax-file","MySQL-script-runner","elinks.vim","eukleides.vim","jcl.vim","midnight2.vim","smlisp.vim","lustre","lustre-syntax","VimFootnotes","biogoo.vim","Get-Win32-Short-Name","Get-UNC-Path-Win32","pythonhelper","javaGetSet.vim","copycppdectoimp.vim","cppgetset.vim","titlecase.vim","stata.vim","localvimrc","lilac.vim","spacehi.vim","deldiff.vim","Syntax-for-the-BETA-programming-language","JavaDecompiler.vim","exim.vim","java_checkstyle.vim","gmt.vim","xhtml.vim","EasyAccents","draw.vim","HTML.zip","sql.vim","php_abb","xgen.vim","noweb.vim","PCP-header","vim-templates","rrd.vim","TTCoach","nw.vim","rainbow.zip","VB-Line-Number","vimspell","perl_h2xs","emodeline","VEC","fnaqevan","HTML-Photo-Board","cream-vimabbrev","mup.vim","BlockComment.vim","SearchComplete","LaTeX-Suite-aka-Vim-LaTeX","Transparent","python.vim","aj.vim","MultipleSearch","toothpik.vim","cscomment.vim","cuecat.vim","tagexplorer.vim","ddldbl.vim","markjump.vim","SAPDB_Pascal.vim","Posting","cream-keytest","ManPageView","java_getset.vim","debug.vim","SQLUtilities","Cpp-code-template-generator","ri-browser","sql.vim","poser.vim","waimea.vim","sql.vim","SpellChecker","foldlist","OO-code-completion","transvim.vim","Macromedia-Director-Lingo-Syntax","oz.vim","python_box.vim","greputil.vim","mercury.vim","ZoomWin","mailsig","Varrays","casejump.vim","Printer-Dialog","Indent-Finder","mrswin.vim","python_fold","sr.vim","TVO--The-Vim-Outliner","csv-color","CVS-conflict-highlight","PHPDoc-Script-PDocS","mru.vim","tar.vim","VimITunes.vim","Visual-Studio-.NET-compiler-file","cscope-menu","pdbvim","cppcomplete","mh","blockquote.vim","Mixed-sourceassembly-syntax-objdump","elvis-c-highlighting","colorer-color-scheme","ntservices","PHP-dictionary","tiger.vim","tiger.vim","tab-syntax","cream-email-munge","FavEx","apdl.vim","velocity.vim","russian-menu-translation","nuweb.vim","flyaccent.vim","ebnf.vim","IDLATL-Helper","as.vim","Mines","coffee.vim","adp.vim","mruex","HiCurLine","perl-support.vim","BOG","spreadsheet.vim","BufClose.vim","MPD-syntax-highlighting","help.vim","rd.vim","rcsvers.vim","ASPRecolor.vim","HTML--insert","ctrlax.vim","desc.vim","ntprocesses","caramel.vim","GTK","autolisp-help","wintersday.vim","darkdot","TEXT--fill-char","gnu-c","psp.vim","dawn","allfold","fgl.vim","autonumbering-in-vim","cg.vim","matlab.vim","comment.vim","pyljpost.vim","todolist.vim","northsky","fgl.c","JavaBrowser","seashell","BlackSea","PapayaWhip","ChocolateLiquor","guifontpp.vim","TaQua","HelpClose","colorpalette.vim","python-tools","execmap","cmake.vim","cmake.vim","vimwc.sh","vimbadword.sh","oceanblack.vim","php.vim-html-enhanced","cream-numberlines","asmMIPS","valgrind.vim","toc.vim","Qt.vim","ctags.vim","dante.vim","cpp.vim","gisdk","CRefVim","ruler.vim","Asciitable.vim","Adaryn.vim","BreakPts","brookstream","Russian-menu-for-gvimwin32","Conflict2Diff","tagsubmenu","m4pic.vim","nightwish.vim","Color-Sampler-Pack","ShowPairs","MarkShift","SeeTab","putty","resolv.conf-syntax","cf.vim","make-element","Reindent","otf.vim","sparc.vim","getdp","COMMENT.vim","WC.vim","gmsh.vim","SYN2HTML","tcsoft.vim","GetLatestVimScripts","WML-Wireless-Markup-Language-syntax","Color-Scheme-Test","greyblue.vim","colorize","DOS-Commands","fte.vim","chordpro.vim","vectorscript.vim","uniq.vim","stol.vim","ldap_schema.vim","ldif.vim","proc.vim","esperanto","epperl.vim","headers.vim","sip.vim","gpg.vim","gnupg","xml_cbks","VimDebug","scratch.vim","FeralToggleCommentify.vim","hexman.vim","Dotnet-Dictionaries","random.vim","matrix.vim","VisIncr","autumn.vim","listmaps.vim","Maxlen.vim","MakeDoxygenComment","VS-like-Class-Completion","GenerateMatlabFunctionComment","pgn.vim","genindent.vim","fluxbox.vim","ferallastchange.vim","blockhl2.vim","cschemerotate.vim","ftplugin-for-Calendar","Comment-Tools","incbufswitch.vim","feralalign.vim","VimTweak","calibre.vim","cleanphp","actionscript.vim","POD-Folder","VimSpeak","ample.vim","quancept.vim","po.vim","timecolor.vim","timecolor.vim","Visual-Cpp","NEdit","OIL.vim","cg.vim","parrot.vim","xmmsctrl.vim","isi2bib","sketch.vim","gdl.vim","msp.vim","brainfuck-syntax","sfl.vim","browser-like-scrolling-for-readonly-file","nuvola.vim","SideBar.vim","MSIL-Assembly","cygwin.vim","mupad.vim","trash.vim","wiki.vim","tagMenu","local_vimrc.vim","Hanoi-Tower","sudo.vim","co.vim","xmidas.vim","folddigest.vim","quicksession.vim","sql.vim","pam.vim","kickstart.vim","mdl.vim","gor.vim","yaml.vim","sbutils","movewin.vim","SwapHeader","svn.vim","dhcpd.vim","curcmdmode","cmdalias.vim","Intellisense-for-Vim","HelpExtractor","pic.vim","aiseered.vim","winhelp","opengl.vim","ttcn-syntax","ttcn-indent","VDLGBX.DLL","python_encoding.vim","showpairs-mutated","dusk","LogCVSCommit","peaksea","lpc.vim","hlcontext.vim","dont-click","gvim-with-tabs","VHDL-indent","ttcn-dict","mis.vim","table.vim","Source-Control","ocamlhelp.vim","umber-green","vgrep","lebrief.vim","vimcdoc","whereis.vim","highlight_cursor.vim","ntp.vim","php_console.vim","sessions.vim","pyfold","oasis.vim","gdm.vim","fluka.vim","vartabs.vim","delek.vim","qt2vimsyntax","tokens.vim","set_utf8.vim","python.vim","Relaxed-Green","simpleandfriendly.vim","ttcn-ftplugin","promela.vim","xterm16.vim","bmichaelsen","preview.vim","Walk.vim","FindMakefile","MixCase.vim","javaDoc.vim","gramadoir.vim","XQuery-syntax","expand.vim","zrf.vim","truegrid.vim","dks-il2-tex.vim","vimcommander","Smart-Diffsplit","robinhood.vim","darkblue2.vim","billw.vim","mail.vim","white.vim","HHCS_D","enumratingptn","HHCS","ephtml","rgbasm.vim","Mouse-Toggle","BlockWork","avrasm.vim","yum.vim","asmM68k.vim","find_in_files","mp.vim","Intellisense","VimNotes","gq","TT2-syntax","xmaslights.vim","smartmake","httpclog","RTF-1.6-Spec-in-Vim-Help-Format","systemc_syntax.tar.gz","selected-resizer","PureBasic-Syntax-file","macro.vim","python.vim","text.py","yo-speller","increment.vim","nasl.vim","ptl.vim","pyab","mars.vim","howto-ftplugin","SrchRplcHiGrp.vim","latex-mik.vim","Pydiction","Posting","Gothic","File-local-variables","less.vim","FX-HLSL","NSIS-2.0--Syntax","table_format.vim","LocateOpen","Destructive-Paste","inform.vim","VikiDeplate","cscope-quickfix","BlackBeauty","visual_studio.vim","unmswin.vim","Israelli-hebrew-shifted","phoneticvisual-hebrew-keyboard-mapphone","Redundant-phoneticvisual-Hebrew-keyboar","changesqlcase.vim","changeColorScheme.vim","allout.vim","Syntax-context-abbreviations","srec.vim","emacsmode","bufman.vim","automation.vim","GVColors","Posting","RegExpRef","passwd","buttercream.vim","fluxkeys.vim","ods.vim","AutoAlign","FormatBlock","FormatComment.vim","docbkhelper","armasm","EvalSelection.vim","edo_sea","pylint.vim","winpos.vim","gtags.vim","Viewing-Procmail-Log","Toggle","perl_synwrite.vim","ViewOutput","CharTab","nesC","Tower-of-Hanoi","sharp-Plugin-Added","ratfor.vim","fvl.vim","yiheb-il.vim","sql.vim","Editable-User-Interface-EUI-eui_vim","html_umlaute","nvi.vim","unicodeswitch.vim","pydoc.vim","nedit2","adam.vim","po.vim","sieve.vim","AsNeeded","Nibble","fdcc.vim","CSS-2.1-Specification","sqlldr.vim","tex_autoclose.vim","bufmenu2","svncommand.vim","timestamp.vim","html_portuquese","AutoFold.vim","russian-phonetic_utf-8.vim","colorsel.vim","XpMenu","timelog.vim","virata.vim","VimIRC.vim","TogFullscreen.vim","database-client","ftpsync","svg.vim","Karma-Decompiler","autosession.vim","newheader.vim","sccs.vim","screen.vim","edifact.vim","pqmagic.vim","ProjectBrowse","n3.vim","groovy.vim","StyleChecker--perl","2tex.vim","Scons-compiler-plugin","qf.vim","af.vim","aspnet.vim","psql.vim","multiselect","xml2latex","ToggleComment","php-doc","YAPosting","blugrine","latex_pt","replace","DumpStr.vim","RemoteSaveAll.vim","FTP-Completion","nexus.vim","uptime.vim","asmx86","php.vim-for-php5","autoit.vim","pic18fxxx","IncrediBuild.vim","folds.vim","chela_light","rest.vim","indentpython.vim","Siebel-VB-Script-SVB","Tibet","Maxscript","svn-diff.vim","idf.vim","ssa.vim","GtkFileChooser","Simple-templates","onsgmls.vim","mappinggroup.vim","metacosm.vim","ASPJScript","DoxygenToolkit.vim","VHT","pdftotext","rpl","rpl","rpl","aspvbs.vim","FiletypeRegisters","nant-compiler-script","tbf-vimfiles","Window-Sizes","menu_pt_br.vimfix","TransferChinese.vim","gtk-vim-syntax","2htmlj","glsl.vim","SearchInBuffers.vim","Docbook-XSL-compiler-file","Phrases","Olive","Lynx-Offline-Documentation-Browser","srec.vim","srec.vim","lingo.vim","buflist","lingodirector.vim","PLI-Tools","clipbrd","check-mutt-attachments.vim","corewars.vim","redcode.vim","potwiki.vim","updt.vim","revolutions.vim","feralstub.vim","Phoenity-discontinued","aftersyntax.vim","IndentHL","xmlwf.vim","Visual-Mark","errsign","log.vim","msvc2003","scalefont","uc.vim","commenter","OOP.vim","cream-iso639.vim","cream-iso3166-1","HTMLxC.vim","vimgrep.vim","array.vim","vimtabs.vim","CodeReviewer.vim","cube.vim","uc.vim","uc.vim","sf.vim","monday","ST20-compiler-plugin","R.vim","octave.vim","delete.py","groff-keymap","The-Mail-Suite-tms","browser.vim","InteractHL.vim","curBuf.vim","vsutil.vim","DavesVimPack","Menu-Autohide","pygtk_color","Vive.vim","actionscript.vim","greputils","HC12-syntax-highlighting","asp.vim","click.vim","cecutil","mingw.vim","abap.vim","vimsh","dsPIC30f","BufOnly.vim","ConfirmQuit.vim","fasm-compiler","python_calltips","netrw.vim","cscope_win","lindo.vim","VUT","replvim.sh","xmms.vim","HiColors","MS-Word-from-VIM","multiwin.vim","multiAPIsyntax","earth.vim","Black-Angus","tpp.vim","cfengine.vim","sas.vim","InsertTry.vim","VimRegEx.vim","blitzbasic.vim","Archive","cream-statusline-prototype","TabLaTeX","buffer-perlpython.pl","txt2tags-menu","hamster.vim","hamster.vim","clearsilver","hamster.vim","VB.NET-Syntax","VB.NET-Indent","ACScope","ptu","java_src_link.vim","AutumnLeaf","WhatsMissing.vim","bulgarian.vim","edifile.vim","rcs.vim","pydoc.vim","TWiki-Syntax","pmd.vim","BodySnatcher","MapleSyrup","ooosetup.vim","reverse.vim","mod_tcsoft.vim","PHP-correct-Indenting","anttestreport","lingo.vim","lpl.vim","UpdateModDate.vim","vimUnit","lxTrace","vim2ansi","synmark.vim","vim_faq.vim","jhlight.vim","javascript.vim","css.vim","scratch.vim","Japanese-Keymapping","vcbc.vim","scilab.tar.gz","scilab.tar.gz","tree","FileTree","Cisco-ACL-syntax-highlighting-rules","header.vim","inkpot","jhdark","C-fold","ccimpl.vim","bufkill.vim","perl-test-manage.vim","GetFDCText.vim","cygwin_utils.vim","globalreplace.vim","remote-PHP-debugger","xbl.vim","JavaKit","ledger.vim","ledger.vim","txt2tags","unhtml","pagemaker6","tSkeleton","foldcol.vim","jexplorer","html_danish","EditJava","tolerable.vim","Wiked","substitute.vim","sharp-Indent","GoboLinux-ColorScheme","Abc-Menu","DetectIndent","templates.vim","tComment","Rhythmbox-Control-Plugin","sharp-Syntax","oceanlight","OAL-Syntax","PVCS-access","context_complete.vim","fileaccess","avr.vim","tesei.vim","MultipleSearch2.vim","uniface.vim","turbo.vim","rotate.vim","cream-replacemulti","cleanswap","matrix.vim","hcc.vim","wc.vim","AutoUpload","expander.vim","vfp8.vim","vis","omlet.vim","ocaml.annot.pl","nodiff.vim","increment_new.vim","namazu.vim","c.vim","bsh.vim","WhereFrom","oo","Java-Syntax-and-Folding","ProvideX-Syntax","DNA-Tools","vimCU","cvsvimdiff","latexmenu","XML-Indent","AddIfndefGuard","Vim-JDE","cvsdiff.vim","Super-Shell-Indent","cool.vim","Perldoc-from-VIM","The-NERD-Commenter","darkblack.vim","OpenGLSL","monkeyd-configuration-syntax","OCaml-instructions-signature---parser","plist.vim","my-_vimrc-for-Windows-2000XP7-users","DotOutlineTree","Vim-klip-for-Serence-Klipfolio-Windows","explorer-reader.vim","recent.vim","crontab.freebsd.vim","Rainbow-Parenthesis","mom.vim","DoTagStuff","gentypes.py","YankRing.vim","mathml.vim","xhtml.vim","MS-SQL-Server-Syntax","Mark","autoit.vim","Guardian","octave.vim","Markdown-syntax","desert256.vim","Embedded-Vim-Preprocessor","cvsmenu.vim-updated","Omap.vim","swig","cccs.vim","vc_diff","Teradata-syntax","timekeeper","trt.vim","greens","VIMEN","pike.vim","aspvbs.vim","wood.vim","custom","sienna","tmda_filter.vim","cstol.vim","tex_umlaute","Quick-access-file-Menu","IComplete","Emacs-outline-mode","teol.vim","acsb","drcstubs","drc_indent","rubikscube.vim","php_check_syntax.vim","Mathematica-Syntax-File","Mathematica-Indent-File","SpotlightOpen","autoscroll","vsearch.vim","quantum.vim","ToggleOptions.vim","crontab.vim","tagselect","TinyBufferExplorer","TortoiseSVN.vim","nasl.vim","sadic.tgz","tabs.vim","otherfile.vim","otherfile.vim","LogiPat","luarefvim","keywords.vim","Pida","nightshade.vim","form.vim","rsl.vim","Color-Scheme-Explorer","Project-Browser-or-File-explorer-for-vim","Shortcut-functions-for-KeepCase-script-","maximize.dll","recycle.dll-and-recycle.vim","php_funcinfo.vim","T7ko","cguess","php_template","another-dark-scheme","java_fold","DataStage-Universe-Basic","vimplate","vimplate","bwftmenu.vim","asmM6502.vim","udvm.vim","bwHomeEndAdv.vim","bwUtility.vim","snippetsEmu","perlprove.vim","Dynamic-Keyword-Highlighting","CSVTK","ps2vsm","advantage","The-Stars-Color-Scheme","bufferlist.vim","Impact","Windows-PowerShell-Syntax-Plugin","xslt","verilogams.vim","XHTML-1.0-strict-help-file","sudoku","tidy","Pleasant-colorscheme","VST","A-soft-mellow-color-scheme","Professional-colorscheme-for-Vim","pluginfonts.vim","TabBar","Autoproject","last_change","last_change","AutoTag","switchtags.vim","dmd","VIM-Email-Client","cxxcomplete","The-Vim-Gardener","Colortest","Mud","Mud","Modelines-Bundle","syntaxada.vim","Night-Vision-Colorscheme","PDV--phpDocumentor-for-Vim","eraseSubword","larlet.vim","Cthulhian","SmartCase","HP-41-syntax-file","HP-41-file-type-plugin","Last-Modified","cloudy","xslhelper.vim","adobe.vim","Peppers","syntaxconkyrc.vim","bookmarks.vim","Zopedav","CVSconflict","TextMarker","ldap.vim","asmh8300","TailMinusF","QFixToggle","fpc.vim","Chars2HTML","cfengine-log-file-highlighting","syntaxuil.vim","cHeaderFinder","syntaxudev.vim","charon","SessionMgr","UniCycle","interfaces","gdbvim","build.vim","jay-syntax","d.vim","GreedyBackspace.vim","BuildWin","py_jump.vim","motus.vim","fish.vim","Processing-Syntax","range-search.vim","xml.vim","tagSetting.vim","javap.vim","desertedocean.vim","Zen-Color-Scheme","DarkZen-Color-Scheme","gnupg-symmetric.vim","desertedocean.vim","understated","impactG","DesertedOceanBurnt","Local-configuration","OMNeTpp-NED-syntax-file","Workspace-Manager","bwTemplate","vim_colors","brsccs.vim","bibFindIndex","Auto-debug-your-vim","shorewall.vim","carvedwood","avs.vim","jadl.vim","openvpn","softblue","bufmap.vim","corn","dtdmenu","iptables","CarvedWoodCool","darkerdesert","selection_eval.vim","cfname","checksyntax","textutil.vim","haml.zip","Dev-Cpp-Scheme","HiMtchBrkt","Compiler-Plugin-for-msbuild-csc","XML-Folding","compilerpython.vim","winmanager","xsl-fo","XML-Completion","telstar.vim","colors","AllBuffersToOneWindow.vim","MoveLine","Altair-OptiStruct-Syntax","Low-Contrast-Color-Schemes","vera.vim","VHDL-indent-93-syntax","svn_commit","cecscope","baycomb","VCard-syntax","copypath.vim","CycleColor","Grape-Color","moin.vim","glark.vim","syntaxm4.vim","dtd2vim","docbook44","moria","Ant","netrw.vim","far","bayQua","promela","lbnf.vim","watermark","Sift","vim7-install.sh","yellow","maude.vim","Modeliner","Surveyor","muttrc.vim","CmdlineCompl.vim","cvops-aut.vim","kid.vim","marklar.vim","spectro.vim","StickyCursor","fasm.vim","django.vim","ScrollColors","PluginKiller","jr.vim","JavaScript-syntax","pyte","Sudoku-Solver","Efficient-python-folding","derefined","initng","Align.vim","all-colors-pack","rfc2html","delins.vim","slr.vim","Vimball","Search-unFold","jbase.vim","jbase.vim","LargeFile","TabLineSet.vim","XHTML-1.0-Strict-vim7-xml-data-file","autohi","manuscript.vim","screenpaste.vim","VimVS6","SwitchExt","VhdlNav","smcl.vim","changelog","ClassTree","icalendar.vim","OmniCppComplete","maven2.vim","WinWalker.vim","cmaxx","magic.vim","vbnet.vim","javaimports.vim","habiLight","comments.vim","FlexWiki-syntax-highlighting","timing.vim","backburnerEdit_Visual_Block.vim","txt.vim","amarok.vim","vimproject","TagsParser","remind","pluginbackup.vim","colorsmartin_krischik.vim","Highlighter.vim","mousefunc-option-patch","GetChar-event-patch","pythoncomplete","Tabline-wrapping-patch","foxpro.vim","abolish.vim","perl_search_lib","compilergnat.vim","ftpluginada.vim","bluez","jVim","Simple-Color-Scheme","ScreenShot","autoproto.vim","autoloadadacomplete.vim","CD_Plus","xul.vim","Toggle-Window-Size","icansee.vim","KDE-GVIM-vimopen","Neverness-colour-scheme","Rainbow-Parenthsis-Bundle","patchreview.vim","forth.vim","ftdetectada.vim","gtd","rails.vim","abnf","montz.vim","redstring.vim","php.vim","SQLComplete.vim","systemverilog.vim","settlemyer.vim","findstr.vim","crt.vim","css.vim","tcl.vim","cr-bs-del-space-tab.vim","FlagIt","lookupfile","vim-addon-background-cmd","tobase","Erlang-plugin-package","actionscript.vim","verilog_systemverilog.vim","myghty.vim","ShowFunc","skk.vim","unimpaired.vim","octave.vim","crestore.vim","comment.vim","showhide.vim","warsow.vim","blacklight","color_toon","yanktmp.vim","highlight.vim","pop11.vim","Smooth-Scroll","developer","tcl.vim","colornames","gsl.vim","HelpWords","color_peruse","Chrome-syntax-script","Ada-Bundle","IncRoman.vim","Access-SQL-Syntax-file","vj","phps","Satori-Color-Scheme","SWIG-syntax","tdl.vim","afterimage.vim","cshelper","vimtips_with_comments","scvim","phpx","TIMEIT","phpfolding.vim","pastie.vim","x12-syntax","liquid.vim","doriath.vim","findfuncname.vim","XChat-IRC-Log","gnuchangelog","sh.vim","svncommand-tng","matlab_run.vim","candycode.vim","JDL-syntax-file","myfold.vim","SourceCodeObedience","MultiTabs","cpp.vim","AfterColors.vim","zzsplash","SuperTab-continued.","switch_headers.vim","tikiwiki.vim","str2numchar.vim","addexecmod.vim","ASL","scrollfix","asmx86_64","freya","highlight_current_line.vim","proe.vim","git.zip","cobol.zip","quilt","doxygenerator","The-NERD-tree","dw_colors","mint","redocommand","rubycomplete.vim","asm8051.vim","buftabs","tavi.vim","Alternate-workspace","campfire","blink","doorhinge.vim","darktango.vim","blueprint.vim","pdf.vim","Drupal-5.0-function-dictionary","toggle_words.vim","twilight","Tab-Name","tidy-compiler-script","Vexorian-color-scheme","ekvoli","IndexedSearch","Darcs","DNA-sequence-highlighter","plaintex.vim","Tango-colour-scheme","jdox","MakeInBuilddir","mail_indenter","IndentConsistencyCop","IndentConsistencyCopAutoCmds","tailtab.vim","desertEx","SnippetsMgr","StateExp","VPars","surround.vim","C_Epita","vimGTD","vimksh","Remove-Trailing-Spaces","edc-support","vdb.vim","vdb-duplicated","redcode.vim","Marks-Browser","php_getset.vim","FencView.vim","scons.vim","SWIFT-ATE-Syntax","Business-Objects-Syntax","Test.Base-syntax","darker-robin","Tail-Bundle","tcl_snit.vim","tcl_sqlite.vim","tcl.vim","tabula.vim","WLS-Mode","gvimext.dll--support-tabs-under-VIM-7","renamer.vim","cf.vim","vimpager","pyljvim","capslock.vim","ruby_imaps","Templeet","sal-syntax","exUtility","tAssert","perlcritic-compiler-script","rdark","aedit","vbugle","echofunc.vim","applescript.vim","gnuplot.vim","RunVim.applescript","Info.plist","filetype.vim","R-MacOSX","Utility","vst_with_syn","nightflight.vim","amifmt.vim","compilerflex.vim","javascript.vim","toggle_word.vim","GotoFileArg.vim","kib_darktango.vim","tGpg","kib_plastic","surrparen","TTrCodeAssistor","sparql.vim","BinarySearchMove","lbdbq","kate.vim","conlangs","lojban","surrogat","aspnetcs","lua-support","code_complete","tcl_itcl.vim","tcl_togl.vim","recent.vim","SnipSnap","lispcomplete.vim","etk-vim-syntax","woc","DAMOS-tools","Haml","Menu_SQL_Templates.vim","tcl_critcl.vim","Vimgrep-Replace","cvsdiff","Wombat","tcmdbar.vim","scala.vim","mlint.vim","polycl.vim","cscope-wrapper","apachestyle","javacomplete","hexsearch.vim","wikipedia.vim","Bexec","Audacious-Control","tagscan","erm.vim","fcsh-tools","vibrantink","autoloadTemplate.vim","SETL2","svnvimdiff","smarty.vim","polycfg.vim","IndentHL","c16gui","eclipse.vim","compview","brief2","SearchFold","MultiEnc.vim","calmar256-lightdark.vim","Vimplate-Enhanced","guicolorscheme.vim","Infobasic-Set-Syntax-FTDetect-FTPlugi","Random-Tip-Displayer","gotofile","greplace.vim","sqlvim.sh","Windows-PowerShell-Indent-File","Windows-PowerShell-File-Type-Plugin","buffers_search_and_replace","Yankcode","vimbuddy.vim","NAnt-completion","NAnt-syntax","incfilesearch.vim","NetSend.vim","Hints-for-C-Library-Functions","Hints-for-C-Library-Functions","smp","writebackup","writebackupVersionControl","html-improved-indentation","VimSpy","asciidoc.vim","des3.vim","st.vim","RDF-Namespace-complete","bufpos","BlitzBasic-syntax-and-indentation","tEchoPair","IndentAnything","Javascript-Indentation","nicotine.vim","screenplay","jman.vim","OceanBlack256","haproxy","gitdiff.vim","NesC-Syntax-Highlighting","arpalert","AutoClose","carrot.vim","SearchSyntaxError","clarity.vim","Twitter","Xdebugxs-dictionary-of-functions","textmate16.vim","Jinja","native.vim","mako.vim","eZVim","Directory-specific-settings","errormarker.vim","kpl.vim","tlib","tmru","tselectfiles","tselectbuffer","doctest-syntax","simplefold","genshi.vim","django.vim","fruity.vim","summerfruit.vim","projtags.vim","psql.vim","verilog_emacsauto.vim","securemodelines","voodu.vim","vimoutliner-colorscheme-fix","AutoComplPop","ck.vim","svndiff","Increment-and-Decrement-number","felix.vim","python_import.vim","scmCloseParens","nginx.vim","AnyPrinter","DiffGoFile","automated-rafb.net-uploader-plugin","LustyExplorer","vividchalk.vim","CimpTabulate.vim","vmake","Vim-Setup-system","gmcs.vim","ragtag.vim","synic.vim","vcsnursery","FindFile","ael.vim","freefem.vim","skill_comment.vim","REPL","ReloadScript","camelcasemotion","tmboxbrowser","snipper","creole.vim","QuickBuf","SuperPre","in.vim","perlhelp.vim","tbibtools","vdm.vim","mySqlGenQueryMenu.vim","Scheme-Mode","clibs.vim","cvsps-syntax","javalog.vim","ChocolatePapaya","vpp.vim","omniperl","context-complier-plugin","bbs.vim","syntaxalgol68.vim","Rename","DBGp-client","maxscript.vim","svndiff.vim","visSum.vim","html_french","git-commit","rectcut","OOP-javascript-indentation","Syntax-for-XUL","todo.vim","autofmt","drools.vim","fx.vim","stingray","JSON.vim","QuickFixFilterUtil","outline","Dictionary","VimExplorer","gvim-pdfsync","systemverilog.vim","Vimpress","yavdb","doxygen-support.vim","smart_cr","yasnippets","SmartX","CharSort","cimpl","Tabmerge","Simple256","vimscript-coding-aids","tie.vim","lodgeit.vim","Ruby-Snippets","gvim-extensions-for-TALpTAL","indenthaskell.vim","Highlight-and-Mark-Lines","deb.vim","trivial256","Parameter-Helpers","JET_toggle","pyconsole_vim.vim","lettuce.vim","rcscript","rcscript","Easy-alignment-to-column","Sass","vimremote.sh","halfmove","vimff","GtagsClient","FuzzyFinder","runtests.vim","mosalisp.vim","khaki.vim","two2tango","gitvimdiff","kwiki.vim","Shell-History","triangle.vim","NightVision","confluencewiki.vim","railscasts","bruce.vim","undo_tags","iast.vim","sas.vim","blinking_cursor","lookup.vim","python_ifold","gobgen","ColorSchemeMenuMaker","karma.vim","progressbar-widget","greplist.vim","buffer-status-menu.vim","AutoClose","sessionman.vim","dbext4rdb","openssl.vim","DrillCtg","ttoc","cheat.vim","no_quarter","tregisters","ttags","3DGlasses.vim","Gettext-PO-file-compiler","headerguard.vim","Tailf","erlang-indent-file","brew.vim","camlanot.vim","motion.vim","taskpaper.vim","MarkLines","4NT-Bundle","vimblog.vim","makeprgs","swap-parameters","trag","colorful256.vim","F6_Comment-old","F6_Comment","hookcursormoved","narrow_region","QuickComment","tcalc","AutoScrollMode","of.vim","VimPdb","myvim.vim","mips.vim","Flash-Live-Support-Agent-and-Chatroom","nosql.vim","BlockDiff","vimpp","LustyJuggler","enscript-highlight","idlang.vim","asmc54xx","TranslateIt","ttagecho","soso.vim","PropBank-Semantic-Role-Annotations","matchparenpp","winwkspaceexplorer","Warm-grey","haskell.vim","coq-syntax","xemacs-mouse-drag-copy","checksum.vim","executevimscript","newlisp","yate","ttagcomplete","bbcode","yet-another-svn-script","switch-files","rcg_gui","rcg_term","indenthtml.vim","setsyntax","phtml.vim","industrial","Coq-indent","autoresize.vim","mysqlquery","comments.vim","javascript.vim","gen_vimoptrc.vim","TI-Basic-Syntax","code-snippet","refactor","WuYe","Acpp","view_diff","verilog.vim","reloaded.vim","complval.vim","Puppet-Syntax-Highlighting","Smartput","Tab-Menu","narrow","fakeclip","xml_autons","textobj-user","textobj-datetime","EnvEdit.vim","kwbdi.vim","R.vim","oberon2","hiveminder.vim","scratch","csv-reader","BBCode","chords","robocom","autohotkey-ahk","pspad-colors-scheme","Torquescript-syntax-highlighting","Processing","Io-programming-language-syntax","GCov-plugin","gcov.vim","webpreview","speeddating.vim","HeaderCVS","bg.py","basic-colors","Twitter","SDL-library-syntax-for-C","accurev","Wikidoc-syntax-highlighting","symfony.vim","Noweb","XmlPretty","Socialtext-wiki-syntax-highlighting","byter","tintin.vim","tabpage_sort.vim","syntax-highlighting-for-tintinttpp","repeat.vim","Css-Pretty","PBwiki-syntax-highlighting","sgf.vim","xoria256.vim","undobranche_viewer.vim","showmarks","unibasic.vim","nice-vim","GOBject-Builder-gob2","prmths","VimTrac","quiltdiff","ncss.vim","css_color.vim","sessions.vim","snippets.vim","RecentFiles","marvim","greenvision","leo256","altfile","diffchanges.vim","timestamp","VFT--VIM-Form-Toolkit","DataStage-Server-and-Parallel","sharp-Syntax","GNU-R","renamec.vim","ukrainian-enhanced.vim","patran.vim","dakota.vim","Doxygen-via-Doxygen","jammy.vim","osx_like","PERLDOC2","head.vim","repmo.vim","Railscasts-Theme-GUIand256color","cwiki","rdhelp.txt","cqml.vim","Source-Explorer-srcexpl.vim","ColorSchemeEditor","reliable","vimlatex","smoothPageScroll.vim","file-line","git-file.vim","pig.vim","Latex-Text-Formatter","earendel","Luinnar","dtrace-syntax-file","MountainDew.vim","Syntax-for-Fasta","fpdf.vim","number-marks","Unicode-Macro-Table","antlr3.vim","beauty256","rastafari.vim","gauref.vim","northland.vim","SCMDiff","Boost-Build-v2-BBv2-syntax","vimgen","TwitVim","CoremoSearch","runzip","Relativize","Txtfmt-The-Vim-Highlighter","pyrex.vim","Shobogenzo","seoul","Obvious-Mode","VimTAP","Switch","darkspectrum","qfn","groovy.vim","debugger.py","Limp","bensday","Allegro-4.2-syntax-file","CmdlineComplete","tinymode.vim","STL-improved","sort-python-imports","vimwiki","browser.vim","autopreview","pacific.vim","beachcomber.vim","WriteRoom-for-Vim","h80","nc.vim","rtorrent-syntax-file","previewtag","WarzoneResourceFileSyntax","useful-optistruct-functions","StringComplete","darkrobot.vim","256-jungle","vcsbzr.vim","openser.vim","RemoveDups.VIM","less.bat","upf.vim","darkroom","FFeedVim","xml_taginsert","pac.vim","common_vimrc","journal.vim","publish.vim","railstab.vim","musicbox.vim","buffergrep","dark-ruby","bpel.vim","Git-Branch-Info","Named-Buffers","Contrasty","nagios-syntax","occur.vim","xtemplate","EZComment","vera.vim","silent.vim","colorful","apachelogs.vim","vim-rpcpaste","pygdb","AutoInclude","nightflight2.vim","gladecompletion.vim","flydiff","textobj-fold","textobj-jabraces","DevEiate-theme","jptemplate","cmdlinehelp","blackboard.vim","pink","brook.vim","huerotation.vim","cup.vim","vmv","Specky","fgl.vim","ctags.exe","loremipsum","smartchr","skeleton","linglang","Resolve","SwapIt","Glob-Edit","sipngrep","sipngrep-helper","codepad","fortran.vim","perl-mauke.vim","Gembase-dml-plugins","foldsearch","spring.vim","vimdb.vim","Textile-for-VIM","Text-Especially-LaTeX-Formatter","Clever-Tabs","portablemsys","GoogleSearchVIM","Indent-Highlight","softlight.vim","sofu.vim","QuickName","thegoodluck","auto_wc.vim","zoom.vim","zshr.vim","TextFormat","LaTeX-error-filter","batch.vim","catn.vim","nopaste.vim","Tumblr","log.vim","chlordane.vim","pathogen.vim","session.vim","backup.vim","metarw","metarw-git","ku","bundle","simple-pairs","molokai","postmail.vim","dictview.vim","ku-bundle","ku-metarw","Vimchant","bufmru.vim","trinity.vim","Chimp","indentgenie.vim","rootwater.vim","RltvNmbr.vim","stlrefvim","FastGrep","textobj-lastpat","Superior-Haskell-Interaction-Mode-SHIM","Nekthuth","tags-for-std-cpp-STL-streams-...","clue","louver.vim","diff_navigator","simplewhite.vim","vimxmms2","autoincludex.vim","ScopeVerilog","vcsc.py","darkbone.vim","CCTree","vimmp","Duplicated","sqloracle.vim","automatic-for-Verilog","ClosePairs","dokuwiki.vim","if_v8","vim-addon-sql","htmlspecialchars","mlint.vim","win9xblueback.vim","Verilog-constructs-plugin","RemoveIfdef","Note-Maker","winter.vim","buf2html.vim","sqlite_c","endwise.vim","cern_root.vim","conomode.vim","pdc.vim","CSApprox","MPC-syntax","Django-Projects","QuickTemplate","darkeclipse.vim","Fly-Between-Projects","Cutting-and-pasting-txt-file-in-middle","Fly-Between-Projects","hfile","cheat","sqlplsql","Russian-PLansliterated","advice","stackreg","Pit-Configuration","Robotbattle-Scripting-Language","Lissard-syntax","MatlabFilesEdition","Refactor-Color-Scheme","sql_iabbr-2","ku-args","Yow","lastchange","Miranda-syntax-highlighting","Tango2","textobj-diff","jQuery","Merb-and-Datamapper","Format-Helper","quickrun","gadgetxml.vim","PySmell","Wordnet.vim","Gist.vim","Transmit-FTP","arpeggio","nour.vim","code_complete-new-update","LineCommenter","autocorrect.vim","literal_tango.vim","commentToggle","corporation","W3AF-script-syntax-file","Side-C","Php-Doc","fuzzyjump.vim","shymenu","EasyGrep","Php-Doc","TagManager-BETA","pyflakes.vim","VimLocalHistory","Python-Documentation","Download-Vim-Scripts-as-Cron-Task","UpdateDNSSerial","narrow","Pago","PylonsCommand","sqlserver.vim","msdn_help.vim","nightsky","miko","eyapp","google","outputz","mtys-vimrc","unibox","enzyme.vim","AutoTmpl","AutoTmpl","Python-Syntax-Folding","kellys","session_dialog.vim","wombat256.vim","cdargs","submode","sandbox","translit","smartword","paintbox","Csound-compiler-plugin","python_open_module","Gentooish","ini-syntax-definition","cbackup.vim","Persistent-Abbreviations","ActionScript-3-Omnicomplete","grsecurity.vim","maroloccio","pygtk_syntax","Quagmire","Gorilla","textobj-indent","python_check_syntax.vim","proc.vim","fortran_codecomplete.vim","Rack.Builder-syntax","maroloccio2","eclm_wombat.vim","maroloccio3","ViBlip","pty.vim","Fruidle","Pimp","Changed","shellinsidevim.vim","blood","toggle_unit_tests","VimClojure","fly.vim","lightcolors","vanzan_color","tetragrammaton","VimIM","0scan","DBGp-Remote-Debugger-Interface","Spiderhawk","proton","RunView","guepardo.vim","charged-256.vim","ctxabbr","widower.vim","lilydjwg_green","norwaytoday","WOIM.vim","Dpaste.com-Plugin","reorder-tabs","searchfold.vim","wokmarks.vim","Jifty-syntax","Scratch","Thousand-separator","Perl-MooseX.Declare-Syntax","jpythonfold.vim","Thesaurus","IndentCommentPrefix","po.vim","slimv.vim","nxc.vim","muttaliasescomplete.vim","d.vim","cca.vim","Lucius","earthburn","ashen.vim","css-color-preview","snipMate","Mastermind-board-game","StarRange","SearchCols.vim","EditSimilar","Buffer-grep","repy.vim","xsltassistant.vim","php.vim","BusyBee","wps.vim","Vicle","jam.vim","irssilog.vim","CommentAnyWay","jellybeans.vim","myprojects","gitignore","Match-Bracket-for-Objective-C","gams.vim","numbertotext","NumberToEnglish","ansi_blows.vim","bufMenuToo","simple_comments.vim","runVimTests","utf8-math","Vim-Rspec","Blazer","LogMgr","vimdecdef","apidock.vim","ack.vim","Darkdevel","codeburn","std-includes","WinMove","summerfruit256.vim","lint.vim","Session-manager","spec.vim","Fdgrep","blogit.vim","popup_it","quickfixsigns","lilydjwg_dark","upAndDown","PDV-revised","glimpse","vylight","FSwitch","HTML-AutoCloseTag","Zmrok","LBufWin","tmarks","Skittles-Dark","gvimfullscreen_win32","lighttpd-syntax","reorder.vim","todolist.vim","Symfony","wargreycolorscheme","paster.vim","Haskell-Cuteness","svk","nextfile","vimuiex","TaskList.vim","send.vim","PA_translator","textobj-entire","xptemplate","Rubytest.vim","vimstall","sdticket","vimtemplate","graywh","SpamAssassin-syntax","ctk.vim","textobj-function","neocomplcache","up2picasaweb","ku-quickfix","TODO-List","ProtoDef","Cabal.vim","Vimya","exVim","Vim-R-plugin","explorer","compilerjsl.vim","dosbatch-indent","nimrod.vim","csindent.vim","SearchPosition","smartmatcheol.vim","google.vim","ScmFrontEnd-former-name--MinSCM","blogger","jlj.vim","tango-morning.vim","haskell.vim","PLI-Auto-Complete","python_coverage.vim","Erlang_detectVariable","bandit.vim","TagHighlight","Templates-for-Files-and-Function-Groups","darkburn","PBASIC-syntax","darkZ","fitnesse.vim","bblean.vim","cuteErrorMarker","Arduino-syntax-file","squirrel.vim","Simple-R-Omni-Completion","VOoM","Changing-color-script","g15vim","clips.vim","plumbing.vim","ywvim","mako.vim","HtmlHelper","Mark","setget","shell_it","fastlane","TuttiColori-Colorscheme","tango-desert.vim","Hoogle","smarttill","cocoa.vim","altercmd","supercat.vim","nature.vim","GoogleReader.vim","textobj-verticalbar","cursoroverdictionary","Colorzone","colorsupport.vim","FastLadder.vim","herald.vim","zOS-Enterprise-Compiler-PLI","cuteTodoList","iabassist","dual.vim","kalt.vim","kaltex.vim","fbc.vim","operator-user","ats-lang-vim","MediaWiki-folding-and-syntax-highlight","EnhancedJumps","elise.vim","elisex.vim","Dictionary-file-for-Luxology-Modo-Python","argtextobj.vim","PKGBUILD","editsrec","regreplop.vim","ReplaceWithRegister","mrpink","tiddlywiki","PA_ruby_ri","EnumToCase","commentop.vim","SudoEdit.vim","vimrc","Screen-vim---gnu-screentmux","sign-diff","nextCS","Tag-Signature-Balloons","UltiSnips","textobj-syntax","mutt-aliases","mutt-canned","Proj","arc.vim","AutoFenc.vim","cssvar","math","Rename2","translit_converter","Syntax-Highlighting-for-db2diag.log","jsbeautify","tkl.vim","jslint.vim","donbass.vim","sherlock.vim","Notes","Buffer-Reminder-Remake","PreviewDialog","Logcat-syntax-highlighter","Syntastic","bib_autocomp.vim","v2.vim","bclear","vimper","blue.vim","ruby.vim","greek_polytonic.vim","git-cheat","falcon.vim","nuweb-multi-language","d8g_01","d8g_02","d8g_03","d8g_04","vimdiff-vcs","falcon.vim","banned.vim","delimitMate.vim","evening_2","color-chooser.vim","forneus","Mustang2","Quich-Filter","Tortoise","qtmplsel.vim","falcon.vim","falcon.vim","dull","Better-Javascript-Indentation","Join.vim","emv","vimscript","pipe.vim","JumpInCode","Conque-Shell","Crazy-Home-Key","grex","whitebox.vim","logpad.vim","vilight.vim","tir_black","gui2term.py","moss","python-tag-import","Django-helper-utils","operator-replace","DumbBuf","template-init.vim","wwwsearch","cpan.vim","Melt-Vim","InsertList","rargs.vim","cmdline-increment.vim","popup_it","perdirvimrc--Autoload-vimrc-files-per-di","hybridevel","phpErrorMarker","Functionator","CheckAttach.vim","SoftTabStops","Pasto","tango.vim","Windows-PowerShell-indent-enhanced","NERD_tree-Project","JavaScript-syntax-add-E4X-support","php_localvarcheck.vim","chocolate.vim","assistant","md5.vim","Nmap-syntax-highlight","haxe_plugin","fontsize.vim","InsertChar","hlasm.vim","term.vim","MailApp","PyMol-syntax","hornet.vim","Execute-selection-in-Python-and-append","testname","Asneeded-2","smarty-syntax","DBGp-client","sqlplus.vim","unicode.vim","baan.vim","libperl.vim","filter","multisearch.vim","RTM.vim","Cobalt-Colour-scheme","roo.vim","csv.vim","mimicpak","xmms2ctrl","buf_it","template.vim","phpcodesniffer.vim","wikinotes","powershellCall","HiVim","QuickFixHighlight","noused","coldgreen.vim","vorg","FlipLR","simple-comment","ywchaos","haskellFold","pod-helper.vim","Script-Walker","color-codes-SQL-keywords-from-Oracle-11g","FindInNERDTree","Speedware","perlomni.vim","go.vim","go.vim","github-theme","vimmpc","exjumplist","textobj-fatpack","grey2","prettyprint.vim","JumpInCode-new-update","GNU-as-syntax","NSIS-syntax-highlighting","colqer","gemcolors","Go-Syntax","fortran_line_length","Ruby-Single-Test","OmniTags","FindMate","signature_block.vim","record-repeat.vim","php.vim","signal_dec_VHDL","HTML-menu-for-GVIM","spinner.vim","RDoc","XPstatusline","rc.vim","mib_translator","Markdown","growlnotify.vim","JavaAspect","gsession.vim","cgc.vim","manuscript","CodeOverview","bluechia.vim","slurper.vim","create_start_fold_marker.vim","doubleTap","filetype-completion.vim","vikitasks","PyPit","open-terminal-filemanager","Chrysoprase","circos.vim","TxtBrowser","gitolite.vim","ShowFunc.vim","AuthorInfo","Cfengine-3-ftplugin","Cfengine-version-3-syntax","vim-addon-manager","Vim-Condensed-Quick-Reference","hlint","Enhanced-Ex","Flex-Development-Support","restart.vim","selfdot","syntaxGemfile.vim","spidermonkey.vim","pep8","startup_profile","extended-help","tplugin","SpitVspit","Preamble","Mercury-compiler-support","FirstEffectiveLine.vim","vimomni","std.vim","tocterm","apt-complete.vim","SnippetComplete","Dictionary-List-Replacements","Vimrc-Version-Numbering","mark_tools","rfc-syntax","fontzoom.vim","histwin.vim","vim-addon-fcsh","vim-addon-actions","superSnipMate","bzr-commit","hexHighlight.vim","Multi-Replace","strawimodo","vim-addon-mw-utils","actionscript3id.vim","RubySinatra","ccvext.vim","visualstar.vim","AutomaticLaTeXPlugin","AGTD","bvemu.vim","GoogleSuggest-Complete","The-Max-Impact-Experiment","cflow-output-colorful","SaneCL","c-standard-functions-highlight","Wavefronts-obj","hypergit.vim","hex.vim","csp.vim","load_template","emoticon.vim","emoticon.vim","bisect","groovyindent","liftweb.vim","line-number-yank","neutron.vim","SyntaxMotion.vim","Doxia-APT","daemon_saver.vim","ikiwiki-nav","ucf.vim","ISBN-10-to-EAN-13-converter","sha1.vim","hmac.vim","cucumber.zip","mrkn256.vim","fugitive.vim","blowfish.vim","underwater","trogdor","Parameter-Text-Objects","php-doc-upgrade","ZenCoding.vim","jumphl.vim","qmake--syntax.vim","R-syntax-highlighting","BUGS-language","AddCppClass","loadtags","OpenCL-C-syntax-highlighting","pummode","stickykey","rcom","SaveSigns","ywtxt","Rackup","colorselector","TranslateEnToCn","utlx_interwiki.vim","BackgroundColor.vim","django-template-textobjects","html-advanced-text-objects","candyman.vim","tag_in_new_tab","indentpython","vxfold.vim","simplecommenter","CSSMinister","Twee-Integration-for-Vim","httplog","treemenu.vim","delete-surround-html","tumblr.vim","vspec","tcommand","ColorX","alex.vim","happy.vim","Cppcheck-compiler","vim-addon-completion","spin.vim","EasyOpts","Find-files","Bookmarking","tslime.vim","vimake","Command-T","PickAColor.vim","grsecurity","rename.vim","tex-turkce","motpat.vim","orange","Mahewincs","Vim-Title-Formatter","syntaxhaskell.vim","tesla","XTermEsc","vim-indent-object","noweb.vim","vimgdb","cmd.vim","RST-Tables","css3","clevercss.vim","compilerpython.vim","cmakeref","operator-camelize","scalacommenter.vim","vicom","acomment","smartmove.vim","vimform","changesPlugin","Maynard","Otter.vim","ciscoasa.vim","translit3","vimsizer","tex_mini.vim","lastpos.vim","Manuals","VxLib","256-grayvim","mdark.vim","aftersyntaxc.vim","mayansmoke","repeater.vim","ref.vim","recover.vim","Slidedown-Syntax","ShowMultiBase","reimin","self.vim","kiss.vim","Trac-Wikimarkup","NrrwRgn","ego.vim","Delphi-7-2010","CodeFactory","JavaScript-Indent","tagmaster","qiushibaike","dc.vim","tf2.vim","glyph.vim","OutlookVim","GetFile","vimtl","RTL","Sessions","autocomp.vim","TortoiseTyping","syntax-codecsconf","cvsdiff.vim","yaifa.vim","Silence","PNote","mflrename","nevfn","Tumble","vplinst","tony_light","pyref.vim","legiblelight","truebasic.vim","writebackupToAdjacentDir","GUI-Box","LaTeX-Box","mdx.vim","leglight2","RemoveFile.vim","formatvim","easytags.vim","SingleCompile","CFWheels-Dictionary","fu","skk.vim","tcbuild.vim","grails-vim","django_templates.vim","PySuite","shell.vim","vim-addon-sbt","PIV","xpcomplete","gams","Search-in-Addressbook","teraterm","CountJump","darkBlue","underwater-mod","open-browser.vim","rvm.vim","Vim-Script-Updater","beluga-syntax","tac-syntax","datascript.vim","phd","obsidian","ez_scroll","vim-snipplr","vim-haxe","hgrev","zetavim","quickrun.vim","wmgraphviz","reload.vim","Smooth-Center","session.vim","pytestator","sablecc.vim","CSS-one-line--multi-line-folding","vorax","slang_syntax","ikiwiki-syntax","opencl.vim","gitview","ekini-dark-colorscheme","pep8","pyflakes","tabops","endline","pythondo","obviously-insert","toggle_mouse","regbuf.vim","mojo.vim","luainspect.vim","pw","phpcomplete.vim","SyntaxComplete","vimgcwsyntax","JsLint-Helper","Haskell-Highlight-Enhanced","typeredeemer","BusierBee","Shapley-Values","help_movement","diff_movement","fortunes_movement","mail_movement","CSS3-Highlights","vimpluginloader","jsonvim","vimstuff","vimargumentchec","vimcompcrtr","vimoop","yamlvim","DokuVimKi","jade.vim","v4daemon","ovim","Starting-.vimrc","gedim","current-func-info.vim","undofile.vim","vim-addon-ocaml","Haskell-Conceal","trailing-whitespace","rdark-terminal","mantip","htip","python_showpydoc.vim","tangoshady","bundler","cHiTags","Quotes","Smart-Parentheses","operator-reverse","python_showpydoc","rslTools","presets","View-Ports","Replay.vim","qnamebuf","processing-snipmate","ProjectTag","Better-CSS-Syntax-for-Vim","indexer.tar.gz","285colors-with-az-menu","LanguageTool","VIM-Color-Picker","Flex-4","lodestone","Simple-Javascript-Indenter","porter-stem","stem-search","TeX-PDF","PyInteractive","HTML5-Syntax-File","VimgrepBuffer","ToggleLineNumberMode","showcolor.vim","html5.vim","blockinsert","LimitWindowSize","minibufexplorerpp","tdvim_FoldDigest","bufsurf","Open-associated-programs","aspnetide.vim","Timer-routine","Heliotrope","CaptureClipboard","Shades-of-Amber","Zephyr-Color-Scheme","Jasmine-snippets-for-snipMate","swap","RubyProxy","L9","makesd.vim","ora-workbench","sequence","phaver","Say-Time","pyunit","clang","Son-of-Obisidian","Selenitic","diff-fold.vim","Bird-Syntax","Vimtodo","cSyntaxAfter","Code.Blocks-Dark","omnetpp","command-list","open_file_from_clip_board","CommandWithMutableRange","RangeMacro","tchaba","kirikiri.vim","Liquid-Carbon","actionscript.vim","ProjectCTags","Python-2.x-Standard-Library-Reference","Python-3.x-Standard-Library-Reference","ProjectParse","Tabbi","run_python_tests","eregex.vim","OMNeTpp4.x-NED-Syntax-file","Quotes","looks","Lite-Tab-Page","Show-mandictperldocpydocphpdoc-use-K","newsprint.vim","pf_earth.vim","RevealExtends","openurl.vim","southernlights","numbered.vim","grass.vim","toggle_option","idp.vim","sjump.vim","vim_faq","Sorcerer","up.vim","TrimBlank","clang-complete","smartbd","Gundo","altera_sta.vim","altera.vim","vim-addon-async","vim-refact","vydark","gdb4vim","savemap.vim","operator-html-escape","Mizore","maxivim","vim-addon-json-encoding","tohtml_wincp","vim-addon-signs","unite-colorscheme","unite-font","vim-addon-xdebug","VimCoder.jar","FTPDEV","lilypink","js-mask","vim-fileutils","stakeholders","PyScratch","Blueshift","VimCalc","unite-locate","lua_omni","verilog_systemverilog_fix","mheg","void","VIP","Smart-Home-Key","tracwiki","newspaper.vim","rdist-syntax","zenesque.vim","auto","VimOrganizer","stackoverflow.vim","preview","inccomplete","screen_line_jumper","chance-of-storm","unite-gem","devbox-dark-256","lastchange.vim","qthelp","auto_mkdir","jbosslog","wesnothcfg.vim","UnconditionalPaste","unite-yarm","NERD_Tree-and-ack","tabpagecolorscheme","Figlet.vim","Peasy","Indent-Guides","janitor.vim","southwest-fog","Ceasy","txt.vim","Shebang","vimblogger_ft","List-File","softbluev2","eteSkeleton","hdl_plugin","blockle.vim","ColorSelect","notes.vim","FanVim","Vimblr","vcslogdiff","JumpNextLongLine","vimorator","emacsmodeline.vim","textobj-rubyblock","StatusLineHighlight","shadow.vim","csc.vim","JumpToLastOccurrence","perfect.vim","polytonic.utf-8.spl","opencl.vim","iim.vim","line-based_jump_memory.vim","hdl_plugin","localrc.vim","BOOKMARKS--Mark-and-Highlight-Full-Lines","chapa","unite.vim","neverland.vim--All-colorschemes-suck","fokus","phpunit","vim-creole","Search-Google","mophiaSmoke","mophiaDark","Google-translator","auto-kk","update_perl_line_directives","headerGatesAdd.vim","JellyX","HJKL","nclipper.vim","syntax_check_embedded_perl.vim","xterm-color-table.vim","zazen","bocau","supp.vim","w3cvalidator","toner.vim","QCL-syntax-hilighting","kkruby.vim","hdl_plugin","Mind_syntax","Comment-Squawk","neco-ghc","pytest.vim","Enhanced-Javascript-syntax","LispXp","Nazca","obsidian2.vim","vim-addon-sml","pep8","AsyncCommand","lazysnipmate","Biorhythm","IniParser","codepath.vim","twilight256.vim","PreciseJump","cscope_plus.vim","Cobaltish","neco-look","XFST-syntax-file","Royal-Colorschemes","pbcopy.vim","golded.vim","Getafe","ParseJSON","activity-log","File-Case-Enforcer","Microchip-Linker-Script-syntax-file","RST-Tables-works-with-non-english-langu","lexctwolc-Syntax-Highlighter","mxl.vim","fecompressor.vim","Flog","Headlights","Chess-files-.pgn-extension","vim-paint","vundle","funprototypes.vim","SVF-syntax","indentpython.vim","Compile","dragon","Tabular","Tagbar","vimake-vim-programmers-ide","align","windows-sif-syntax","csc.snippets","tidydiff","latte","thermometer","Clean","Neopro","Vim-Blog","bitly.vim","bad-apple","robokai","makebg","asp.net","Atom","vim-remote","IPC-syntax-highlight","PyREPL.vim","phrase.vim","virtualenv.vim","reporoot.vim","rebar","urilib","visualctrlg","textmanip.vim","compilerg95.vim","Risto-Color-Scheme","underlinetag","paper","compilergfortran.vim","compilerifort.vim","Scala-argument-formatter","FindEverything","vim_etx","emacs-like-macro-recorder","To-Upper-case-case-changer","vim-erlang-skeleteons","taglist-plus","PasteBin.vim","compilerpcc.vim","scrnpipe.vim","TeX-9","extradite.vim","VimRepress","text-object-left-and-right","Scala-Java-Edit","vim-stylus","vim-activator","VimOutliner","avr8bit.vim","iconv","accentuate.vim","Solarized","Gravity","SAS-Syntax","gem.vim","vim-scala","Rename","EasyMotion","boost.vim","ciscoacl.vim","Distinguished","mush.vim","cmdline-completion","UltraBlog","GetFilePlus","strange","vim-task","Tab-Manager","XPath-Search","plantuml-syntax","rvmprompt.vim","Save-Current-Font","fatrat.vim","Sesiones.vim","opener.vim","cascading.vim","Google-Translate","molly.vim","jianfan","Dagon","plexer","vim-online","gsearch","Message-Formatter","sudoku_game","emacscommandline","fso","openscad.vim","editqf","visual-increment","gtrans.vim","PairTools","Table-Helper","DayTimeColorer","Amethyst","hier","Javascript-OmniCompletion-with-YUI-and-j","m2sh.vim","colorizer","Tabs-only-for-indentation","modelica","terse","dogmatic.vim","ro-when-swapfound","quit-another-window","gitv","Enter-Indent","jshint.vim","pacmanlog.vim","lastmod.vim","ignore-me","vim-textobj-quoted","simplenote.vim","Comceal","checklist.vim","typofree.vim","Redhawk-Vim-Plugin","vim-soy","Find-XML-Tags","cake.vim","vim-coffee-script","browserprint","jovial.vim","pdub","ucompleteme","ethna-switch","Fanfou.vim","colorv.vim","Advancer-Abbreviation","Auto-Pairs","octave.vim","cmdline-insertdatetime","reorder-columns","calm","nicer-vim-regexps","listtag","Diablo3","vim_django","nautilus-py-vim","IDLE","operator-star","XQuery-indentomnicompleteftplugin","browsereload-mac.vim","splitjoin.vim","vimshell-ssh","ShowMarks7","warez-colorscheme","Quicksilver.vim","wikilink","Buffergator","Buffersaurus","ri-viewer","beautiful-pastebin","chef.vim","indsas","lua.vim","AutoSaveSetting","resizewin","cpp_gnuchlog.vim","tangolight","IDSearch","frawor","git_patch_tags.vim","snipmate-snippets","widl.vim","WinFastFind","ReplaceFile","gUnit-syntax","Handlebars","svnst.vim","The-Old-Ones","Atomic-Save","vim-orgmode","Vimper-IDE","vimgtd","gnupg.vim","Filesearch","VimLite","AutoCpp","simpleRGB","cakephp.vim","googleclosurevim","vim-task-org","brep","vrackets","xorium.vim","transpose-words","Powershell-FTDetect","LycosaExplorer","ldap_schema.vim","Lookup","Intelligent-Tags","lemon.vim","SnipMgr","repeat-motion","skyWeb","Toxic","sgmlendtag","rake.vim","orangeocean256","cdevframework","textgenshi.vim","aldmeris","univresal-blue-scheme","cab.vim","copy-as-rtf","baobaozhu","rfc5424","saturn.vim","tablistlite.vim","functionlist.vim","hints_opengl.vim","wikiatovimhelp","ctags_cache","werks.vim","RegImap","Calm-Breeze","Rst-edit-block-in-tab","Ambient-Color-Scheme","golden-ratio","annotatedmarks","quickhl.vim","FixCSS.vim","enablelvimrc.vim","commentary.vim","prefixer.vim","cssbaseline.vim","html_emogrifier.vim","Premailer.vim","tryit.vim","fthook.vim","sql.vim","zim-syntax","Transcription-Name-Helper","Rcode","obvious-resize","lemon256","swapcol.vim","vim-ipython","EasyPeasy","chinachess.vim","tabpage.vim","tabasco","light2011","numlist.vim","fuzzee.vim","SnippetySnip","melt-syntax","diffwindow_movement","noweboutline.vim","Threesome","quickfixstatus.vim","SimpylFold","indent-motion","mcabberlog.vim","easychair","right_align","galaxy.vim","vim-pandoc","putcmd.vim","vim-rpsl","olga_key","statusline.vim","bad-whitespace","ctrlp.vim","sexy-railscasts","TagmaTips","blue_sky","gccsingle.vim","kiwi.vim","mediawiki","Vimerl","MarkdownFootnotes","linediff.vim","watchdog.vim","syntaxdosini.vim","pylint-mode","NagelfarVim","TclShell","google_prettify.vim","Vimpy","vim-pad","baancomplete","racket.vim","scribble.vim","racket-auto-keywords.vim","Ambient-Theme","White","vim-dokuwiki","slide-show","Speech","vim-google-scribe","fcitx.vim","TagmaTasks","vimroom.vim","MapFinder","mappingmanager","ahkcomplete","Python-mode-klen","tagfinder.vim","rainbow_parentheses.vim","Lyrics","abbott.vim","wiki.vim","todotxt.vim","RST-Tables-CJK","utags","mango.vim","indentfolds","Twilight-for-python","Python-Syntax","vim-json-bundle","VIM-Metaprogramming","statline","SonicTemplate.vim","vim-mnml","Tagma-Buffer-Manager","desert-warm-256","html-source-explorer","codepaper","php-doc","Cpp11-Syntax-Support","node.js","Cleanroom","anwolib","fontforge_script.vim","prop.vim","vim-symbols-strings","vim-diff","openrel.vim","apg.vim","TFS","ipi","RSTO","project.vim","tex_AutoKeymap","log.vim","mirodark","vim-kickstart","MatchTag","Lisper.vim","Dart","vim-ocaml-conceal","csslint.vim","nu42dark-color-scheme","Colour-theme-neon-pk","simple_bookmarks.vim","modeleasy-vim-plugin","aurum","inline_edit.vim","better-snipmate-snippet","LastBuf.vim","SchemeXp","TVO--The-Vim-Outliner-with-asciidoc-supp","yankstack","vim-octopress","ChickenMetaXp","ChickenSetupXp","nscripter.vim","weibo.vim","vim-python-virtualenv","vim-django-support","nose.vim","nodeunit.vim","SpellCheck","lrc.vim","cue.vim","visualrepeat","git-time-lapse","boolpat.vim","Mark-Ring","Festoon","dokuwiki","unite-scriptenames","ide","tocdown","Word-Fuzzy-Completion","rmvim","Xoria256m","shelp","Lawrencium","grads.vim","epegzz.vim","Eddie.vim","behat.zip","phidgets.vim","gtags-multiwindow-browsing","lightdiff","vm.vim","SmartusLine","vimprj","turbux.vim","html-xml-tag-matcher","git-diff","ft_improved","nerdtree-ack","ambicmd.vim","fountain.vim","Powerline","EasyDigraph.vim","autosess","DfrankUtil","ruscmd","textobj-line","Independence","qtpy.vim","switch-buffer-quickly","simple-dark","gf-user","gf-diff","viewdoc","Limbo-syntax","rhinestones","buffet.vim","pwdstatus.vim","gtk-mode","indentjava.vim","coffee-check.vim-B","coffee-check.vim","compot","xsnippet","nsl.vim","vombato-colorscheme","ocamlMultiAnnot","mozpp.vim","mozjs.vim","e2.lua","gmlua.vim","vim-punto-switcher","toggle_comment","CapsulaPigmentorum.vim","CompleteHelper","CamelCaseComplete","vim-addon-haskell","tagport","cd-hook","pfldap.vim","WhiteWash","TagmaLast","Gummybears","taskmanagementvim","flymaker","ditaa","lout.vim","vim-flake8","phpcs.vim","badwolf","jbi.vim","Vim-Support","murphi.vim","argumentative.vim","editorconfig-vim","thinkpad.vim","Coverity-compiler-plugin","vim-wmfs","Trailer-Trash","ipyqtmacvim.vim","writebackupAutomator","CodeCommenter","sandbox_hg","pdv-standalone","Yii-API-manual-for-Vim","fountainwiki.vim","hop-language-syntax-highlight","Skittles-Berry","django.vim","pyunit.vim","EasyColour","tmpclip.vim","Improved-paragraph-motion","tortex","Add-to-Word-Search","fwk-notes","calendar.vim","mystatusinfo.vim","workflowish","tabman.vim","flashdevelop.vim","hammer.vim","Colorizer--Brabandt","less-syntax","DynamicSigns","ShowTrailingWhitespace","DeleteTrailingWhitespace","JumpToTrailingWhitespace","source.vim","mediawiki.vim","regexroute.vim","css3-syntax-plus","diff-toggle","showmarks2","Finder-for-vim","vim-human-dates","vim-addon-commenting","cudajinja.vim","vim-pomodoro","phpqa","TaskMotions","ConflictMotions","Sauce","gitvimrc.vim","instant-markdown.vim","vroom","portmon","spacebox.vim","paredit.vim","Ayumi","Clam","vim_movement","vbs_movement","dosbatch_movement","TextTransform","HyperList","python-imports.vim","youdao.dict","XDebug-DBGp-client-for-PHP","Vim-Gromacs","vimux","Vimpy--Stoner","readnovel","Vitality","close-duplicate-tabs","StripWhiteSpaces","vim-jsbeautify","clean_imports","WebAPI.vim","flipwords.vim","restore_view.vim","SpaceBetween","autolink","vim-addon-rdebug","DBGp-X-client","Splice","vim-htmldjango_omnicomplete","vim-addon-ruby-debug-ide","a-new-txt2tags-syntax","vim-cpp-auto-include","rstatusline","muxmate","vim4rally","SAS-Indent","modx","ucpp-vim-syntax","bestfriend.vim","vim-dasm","evervim","Fortune-vimtips","VDBI.vim","Ideone.vim","neocomplcache-snippets_complete","RbREPL.vim","AmbiCompletion","london.vim","jsruntime.vim","maven-plugin","vim-mou","Transpose","PHPUnit-QF","TimeTap","jsoncodecs.vim","jsflakes.vim","jsflakes","DBGPavim","nosyntaxwords","mathematic.vim","vtimer.vim","_jsbeautify","license-loader","cmdpathup","matchindent.vim","automatic-for-Verilog--guo","lingodirector.vim--Pawlik","Ubloh-Color-Scheme","html_FileCompletion","PyChimp","sonoma.vim","highlights-for-radiologist","Xdebug","burnttoast256","vmark.vim--Visual-Bookmarking","gprof.vim","jshint.vim--Stelmach","sourcebeautify.vim","HgCi","EscapeBchars","cscope.vim","php-cs-fixer","cst","OnSyntaxChange","python_fold_compact","EditPlus"]zhimakaimen:/bundle/.vundle/script-names.vim-scripts.org.json
*~
*.swp
tags
zhimakaimen:/bundle/nerdcommenter/.gitignore
# Installation  

_\*For simplicity, let's use **[VIM_ROOT]** which will mean ~/.vim (\*nix) or ~/vimfiles (Windows)_

The NERD Commenter requires Vim 7 or higher is comprised of 2 files:  

    plugin/NERD_commenter.vim  
    doc/NERD_commenter.txt 

### Classic Install

1. Extract the plugin files into your **[VIM_ROOT]**/plugin and **[VIM_ROOT]**/doc folders respectively.
2. Finish the install by updating your help files.  Run:

<pre><code>:helptags [VIM_ROOT]/doc</code></pre>

See **|add-local-help|** for more details. 

### Pathogen Install
1. Navigate to your **[VIM_ROOT]/bundle** directory in your local Vim setup
2. git clone https://github.com/scrooloose/nerdcommenter.git

### Post Install  
After the **'Classic'** or **'Pathogen'** install, make sure that you have filetype plugins enabled, as the script makes use of 
**|'commentstring'|** where possible (which is usually set in a filetype plugin). 
See **|filetype-plugin-on|** for details, but basically, stick this in your vimrc:

    filetype plugin on

# Usage  

The following key mappings are provided by default (there is also a menu 
provided that contains menu items corresponding to all the below mappings): 

Most of the following mappings are for normal/visual mode only. The |NERDComInsertComment| mapping is for insert mode only. 

**[count]\<leader\>cc |NERDComComment|**  
Comment out the current line or text selected in visual mode. 


**[count]\<leader\>cn |NERDComNestedComment|**  
Same as \<leader\>cc but forces nesting. 


**[count]\<leader\>c<space> |NERDComToggleComment|**  
Toggles the comment state of the selected line(s). If the topmost selected 
line is commented, all selected lines are uncommented and vice versa. 


**[count]\<leader\>cm |NERDComMinimalComment|**  
Comments the given lines using only one set of multipart delimiters. 


**[count]\<leader\>ci |NERDComInvertComment|**  
Toggles the comment state of the selected line(s) individually. 


**[count]\<leader\>cs |NERDComSexyComment|**  
Comments out the selected lines ``sexily'' 


**[count]\<leader\>cy |NERDComYankComment|**  
Same as \<leader\>cc except that the commented line(s) are yanked first. 


**\<leader\>c$ |NERDComEOLComment|**  
Comments the current line from the cursor to the end of line. 


**\<leader\>cA |NERDComAppendComment|**  
Adds comment delimiters to the end of line and goes into insert mode between 
them. 


**|NERDComInsertComment|**  
Adds comment delimiters at the current cursor position and inserts between. 
Disabled by default. 


**\<leader\>ca |NERDComAltDelim|**  
Switches to the alternative set of delimiters. 


**[count]\<leader\>cl**  
**[count]\<leader\>cb    |NERDComAlignedComment|**  
Same as |NERDComComment| except that the delimiters are aligned down the 
left side (\<leader\>cl) or both sides (\<leader\>cb). 


**[count]\<leader\>cu |NERDComUncommentLine|**  
Uncomments the selected line(s). 
zhimakaimen:/bundle/nerdcommenter/README.md
# written by travis jeffery <travisjeffery@gmail.com>
# contributions by scrooloose <github:scrooloose>

require 'rake'
require 'find'
require 'pathname'

IGNORE = [/\.gitignore$/, /Rakefile$/]

files = `git ls-files`.split("\n")
files.reject! { |f| IGNORE.any? { |re| f.match(re) } }

desc 'Zip up the project files'
task :zip do
  zip_name = File.basename(File.dirname(__FILE__))
  zip_name.gsub!(/ /, '_')
  zip_name = "#{zip_name}.zip"

  if File.exist?(zip_name)
    abort("Zip file #{zip_name} already exists. Remove it first.")
  end

  puts "Creating zip file: #{zip_name}"
  system("zip #{zip_name} #{files.join(" ")}")
end

desc 'Install plugin and documentation'
task :install do
  vimfiles = if ENV['VIMFILES']
               ENV['VIMFILES']
             elsif RUBY_PLATFORM =~ /(win|w)32$/
               File.expand_path("~/vimfiles")
             else
               File.expand_path("~/.vim")
             end
  files.each do |file|
    target_file = File.join(vimfiles, file)
    FileUtils.mkdir_p File.dirname(target_file)
    FileUtils.cp file, target_file

    puts "Installed #{file} to #{target_file}"
  end

end

desc 'Pulls from origin'
task :pull do
  puts "Updating local repo..."
  system("cd " << Dir.new(File.dirname(__FILE__)).path << " && git pull")
end

desc 'Calls pull task and then install task'
task :update => ['pull', 'install'] do
  puts "Update of vim script complete."
end

desc 'Uninstall plugin and documentation'
task :uninstall do
  vimfiles = if ENV['VIMFILES']
               ENV['VIMFILES']
             elsif RUBY_PLATFORM =~ /(win|w)32$/
               File.expand_path("~/vimfiles")
             else
               File.expand_path("~/.vim")
             end
  files.each do |file|
    target_file = File.join(vimfiles, file)
    FileUtils.rm target_file

    puts "Uninstalled #{target_file}"
  end

end

task :default => ['update']

zhimakaimen:/bundle/nerdcommenter/Rakefile
" ============================================================================
" File:        NERD_commenter.vim
" Description: vim global plugin that provides easy code commenting
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Version:     2.3.0
" Last Change: Wed Dec 14 08:00 AM 2011 EST
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================

" Section: script init stuff {{{1
if exists("loaded_nerd_comments")
    finish
endif
if v:version < 700
    echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_comments = 1

" Function: s:InitVariable() function {{{2
" This function is used to initialise a given variable to a given value. The
" variable is only initialised if it does not exist prior
"
" Args:
"   -var: the name of the var to be initialised
"   -value: the value to initialise var to
"
" Returns:
"   1 if the var is set, 0 otherwise
function s:InitVariable(var, value)
    if !exists(a:var)
        execute 'let ' . a:var . ' = ' . "'" . a:value . "'"
        return 1
    endif
    return 0
endfunction

" Section: space string init{{{2
" When putting spaces after the left delim and before the right we use
" s:spaceStr for the space char. This way we can make it add anything after
" the left and before the right by modifying this variable
let s:spaceStr = ' '
let s:lenSpaceStr = strlen(s:spaceStr)

" Section: variable initialization {{{2
call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)
call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)
call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)
call s:InitVariable("g:NERDCompactSexyComs", 0)
call s:InitVariable("g:NERDCreateDefaultMappings", 1)
call s:InitVariable("g:NERDDefaultNesting", 1)
call s:InitVariable("g:NERDMenuMode", 3)
call s:InitVariable("g:NERDLPlace", "[>")
call s:InitVariable("g:NERDUsePlaceHolders", 1)
call s:InitVariable("g:NERDRemoveAltComs", 1)
call s:InitVariable("g:NERDRemoveExtraSpaces", 0)
call s:InitVariable("g:NERDRPlace", "<]")
call s:InitVariable("g:NERDSpaceDelims", 0)

let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"

let s:delimiterMap = {
    \ 'aap': { 'left': '#' },
    \ 'abc': { 'left': '%' },
    \ 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ada': { 'left': '--', 'leftAlt': '--  ' },
    \ 'ahdl': { 'left': '--' },
    \ 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'amiga': { 'left': ';' },
    \ 'aml': { 'left': '/*' },
    \ 'ampl': { 'left': '#' },
    \ 'apache': { 'left': '#' },
    \ 'apachestyle': { 'left': '#' },
    \ 'asciidoc': { 'left': '//' },
    \ 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'armasm': { 'left': ';' },
    \ 'asm68k': { 'left': ';' },
    \ 'asm': { 'left': ';', 'leftAlt': '#' },
    \ 'asn': { 'left': '--' },
    \ 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'asterisk': { 'left': ';' },
    \ 'asy': { 'left': '//' },
    \ 'atlas': { 'left': 'C', 'right': '$' },
    \ 'autohotkey': { 'left': ';' },
    \ 'autoit': { 'left': ';' },
    \ 'ave': { 'left': "'" },
    \ 'awk': { 'left': '#' },
    \ 'basic': { 'left': "'", 'leftAlt': 'REM ' },
    \ 'bbx': { 'left': '%' },
    \ 'bc': { 'left': '#' },
    \ 'bib': { 'left': '%' },
    \ 'bindzone': { 'left': ';' },
    \ 'bst': { 'left': '%' },
    \ 'btm': { 'left': '::' },
    \ 'cabal': { 'left': '--' },
    \ 'caos': { 'left': '*' },
    \ 'calibre': { 'left': '//' },
    \ 'catalog': { 'left': '--', 'right': '--' },
    \ 'c': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'cf': { 'left': '<!---', 'right': '--->' },
    \ 'cfg': { 'left': '#' },
    \ 'cg': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ch': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cl': { 'left': '#' },
    \ 'clean': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clipper': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'clojure': { 'left': ';' },
    \ 'cmake': { 'left': '#' },
    \ 'coffee': { 'left': '#' },
    \ 'conkyrc': { 'left': '#' },
    \ 'context': { 'left': '%', 'leftAlt': '--' },
    \ 'cpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'cuda': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'crontab': { 'left': '#' },
    \ 'cs': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'csp': { 'left': '--' },
    \ 'cterm': { 'left': '*' },
    \ 'cucumber': { 'left': '#' },
    \ 'cvs': { 'left': 'CVS:' },
    \ 'd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dcl': { 'left': '$!' },
    \ 'dakota': { 'left': '#' },
    \ 'debcontrol': { 'left': '#' },
    \ 'debsources': { 'left': '#' },
    \ 'def': { 'left': ';' },
    \ 'desktop': { 'left': '#' },
    \ 'dhcpd': { 'left': '#' },
    \ 'diff': { 'left': '#' },
    \ 'django': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'docbk': { 'left': '<!--', 'right': '-->' },
    \ 'dns': { 'left': ';' },
    \ 'dosbatch': { 'left': 'REM ', 'leftAlt': '::' },
    \ 'dosini': { 'left': ';' },
    \ 'dot': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'dracula': { 'left': ';' },
    \ 'dsl': { 'left': ';' },
    \ 'dtml': { 'left': '<dtml-comment>', 'right': '</dtml-comment>' },
    \ 'dylan': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ebuild': { 'left': '#' },
    \ 'ecd': { 'left': '#' },
    \ 'eclass': { 'left': '#' },
    \ 'eiffel': { 'left': '--' },
    \ 'elf': { 'left': "'" },
    \ 'elmfilt': { 'left': '#' },
    \ 'erlang': { 'left': '%', 'leftAlt': '%%' },
    \ 'eruby': { 'left': '<%#', 'right': '%>', 'leftAlt': '<!--', 'rightAlt': '-->' },
    \ 'expect': { 'left': '#' },
    \ 'exports': { 'left': '#' },
    \ 'fancy': { 'left': '#' },
    \ 'factor': { 'left': '! ', 'leftAlt': '!# ' },
    \ 'fgl': { 'left': '#' },
    \ 'focexec': { 'left': '-*' },
    \ 'form': { 'left': '*' },
    \ 'foxpro': { 'left': '*' },
    \ 'fsharp': { 'left': '(*', 'right': '*)', 'leftAlt': '//' },
    \ 'fstab': { 'left': '#' },
    \ 'fvwm': { 'left': '#' },
    \ 'fx': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gams': { 'left': '*' },
    \ 'gdb': { 'left': '#' },
    \ 'gdmo': { 'left': '--' },
    \ 'geek': { 'left': 'GEEK_COMMENT:' },
    \ 'genshi': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'gentoo-conf-d': { 'left': '#' },
    \ 'gentoo-env-d': { 'left': '#' },
    \ 'gentoo-init-d': { 'left': '#' },
    \ 'gentoo-make-conf': { 'left': '#' },
    \ 'gentoo-package-keywords': { 'left': '#' },
    \ 'gentoo-package-mask': { 'left': '#' },
    \ 'gentoo-package-use': { 'left': '#' },
    \ 'gitcommit': { 'left': '#' },
    \ 'gitconfig': { 'left': ';' },
    \ 'gitrebase': { 'left': '#' },
    \ 'gnuplot': { 'left': '#' },
    \ 'go': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'groovy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'gsp': { 'left': '<%--', 'right': '--%>', 'leftAlt': '<!--','rightAlt': '-->'},
    \ 'gtkrc': { 'left': '#' },
    \ 'haskell': { 'left': '{-','right': '-}', 'leftAlt': '--' },
    \ 'hb': { 'left': '#' },
    \ 'h': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'haml': { 'left': '-#', 'leftAlt': '/' },
    \ 'haxe': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hercules': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'hog': { 'left': '#' },
    \ 'hostsaccess': { 'left': '#' },
    \ 'htmlcheetah': { 'left': '##' },
    \ 'htmldjango': { 'left': '<!--','right': '-->', 'leftAlt': '{#', 'rightAlt': '#}' },
    \ 'htmlos': { 'left': '#', 'right': '/#' },
    \ 'hxml': { 'left': '#' },
    \ 'ia64': { 'left': '#' },
    \ 'icon': { 'left': '#' },
    \ 'idlang': { 'left': ';' },
    \ 'idl': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'inform': { 'left': '!' },
    \ 'inittab': { 'left': '#' },
    \ 'ishd': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'iss': { 'left': ';' },
    \ 'ist': { 'left': '%' },
    \ 'jade': { 'left': '//-', 'leftAlt': '//' },
    \ 'java': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javacc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'javascript.jquery': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'jess': { 'left': ';' },
    \ 'jgraph': { 'left': '(*', 'right': '*)' },
    \ 'jproperties': { 'left': '#' },
    \ 'jsp': { 'left': '<%--', 'right': '--%>' },
    \ 'kix': { 'left': ';' },
    \ 'kscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'lace': { 'left': '--' },
    \ 'ldif': { 'left': '#' },
    \ 'less': { 'left': '/*','right': '*/' },
    \ 'lhaskell': { 'left': '>{-','right': '-}', 'leftAlt': '>-- ' },
    \ 'lilo': { 'left': '#' },
    \ 'lilypond': { 'left': '%' },
    \ 'liquid': { 'left': '{% comment %}', 'right': '{% endcomment %}' },
    \ 'lisp': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'llvm': { 'left': ';' },
    \ 'lotos': { 'left': '(*', 'right': '*)' },
    \ 'lout': { 'left': '#' },
    \ 'lprolog': { 'left': '%' },
    \ 'lscript': { 'left': "'" },
    \ 'lss': { 'left': '#' },
    \ 'lua': { 'left': '--', 'leftAlt': '--[[', 'rightAlt': ']]' },
    \ 'lynx': { 'left': '#' },
    \ 'lytex': { 'left': '%' },
    \ 'mail': { 'left': '> ' },
    \ 'mako': { 'left': '##' },
    \ 'man': { 'left': '."' },
    \ 'map': { 'left': '%' },
    \ 'maple': { 'left': '#' },
    \ 'markdown': { 'left': '<!--', 'right': '-->' },
    \ 'masm': { 'left': ';' },
    \ 'mason': { 'left': '<% #', 'right': '%>' },
    \ 'master': { 'left': '$' },
    \ 'matlab': { 'left': '%' },
    \ 'mel': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'mib': { 'left': '--' },
    \ 'mirah': {'left': '#'},
    \ 'mkd': { 'left': '>' },
    \ 'mma': { 'left': '(*', 'right': '*)' },
    \ 'model': { 'left': '$', 'right': '$' },
    \ 'moduala.': { 'left': '(*', 'right': '*)' },
    \ 'modula2': { 'left': '(*', 'right': '*)' },
    \ 'modula3': { 'left': '(*', 'right': '*)' },
    \ 'monk': { 'left': ';' },
    \ 'mush': { 'left': '#' },
    \ 'mustache': { 'left': '{{!', 'right': '}}' },
    \ 'named': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'nasm': { 'left': ';' },
    \ 'nastran': { 'left': '$' },
    \ 'natural': { 'left': '/*' },
    \ 'ncf': { 'left': ';' },
    \ 'newlisp': { 'left': ';' },
    \ 'nginx': { 'left': '#' },
    \ 'nimrod': { 'left': '#' },
    \ 'nroff': { 'left': '\"' },
    \ 'nsis': { 'left': '#' },
    \ 'ntp': { 'left': '#' },
    \ 'objc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objcpp': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'objj': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ocaml': { 'left': '(*', 'right': '*)' },
    \ 'occam': { 'left': '--' },
    \ 'octave': { 'left': '%', 'leftAlt': '#' },
    \ 'omlet': { 'left': '(*', 'right': '*)' },
    \ 'omnimark': { 'left': ';' },
    \ 'ooc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'openroad': { 'left': '//' },
    \ 'opl': { 'left': "REM" },
    \ 'ora': { 'left': '#' },
    \ 'ox': { 'left': '//' },
    \ 'pascal': { 'left': '{','right': '}', 'leftAlt': '(*', 'rightAlt': '*)' },
    \ 'patran': { 'left': '$', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pcap': { 'left': '#' },
    \ 'pccts': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pdf': { 'left': '%' },
    \ 'perl': { 'left': '#' },
    \ 'pfmain': { 'left': '//' },
    \ 'php': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pic': { 'left': ';' },
    \ 'pike': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pilrc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'pine': { 'left': '#' },
    \ 'plm': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'plsql': { 'left': '-- ', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'po': { 'left': '#' },
    \ 'postscr': { 'left': '%' },
    \ 'pov': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'povini': { 'left': ';' },
    \ 'ppd': { 'left': '%' },
    \ 'ppwiz': { 'left': ';;' },
    \ 'processing': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'prolog': { 'left': '%', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'ps1': { 'left': '#' },
    \ 'psf': { 'left': '#' },
    \ 'ptcap': { 'left': '#' },
    \ 'puppet': { 'left': '#' },
    \ 'python': { 'left': '#' },
    \ 'radiance': { 'left': '#' },
    \ 'ratpoison': { 'left': '#' },
    \ 'r': { 'left': '#' },
    \ 'rc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'rebol': { 'left': ';' },
    \ 'registry': { 'left': ';' },
    \ 'remind': { 'left': '#' },
    \ 'resolv': { 'left': '#' },
    \ 'rgb': { 'left': '!' },
    \ 'rib': { 'left': '#' },
    \ 'robots': { 'left': '#' },
    \ 'rspec': { 'left': '#' },
    \ 'ruby': { 'left': '#' },
    \ 'sa': { 'left': '--' },
    \ 'samba': { 'left': ';', 'leftAlt': '#' },
    \ 'sass': { 'left': '//', 'leftAlt': '/*' },
    \ 'sather': { 'left': '--' },
    \ 'scala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'scons': { 'left': '#' },
    \ 'scheme': { 'left': ';', 'leftAlt': '#|', 'rightAlt': '|#' },
    \ 'scilab': { 'left': '//' },
    \ 'scsh': { 'left': ';' },
    \ 'scss': { 'left': '/*', 'right': '*/', 'leftAlt': '//' },
    \ 'sed': { 'left': '#' },
    \ 'sgmldecl': { 'left': '--', 'right': '--' },
    \ 'sgmllnx': { 'left': '<!--', 'right': '-->' },
    \ 'sh': { 'left': '#' },
    \ 'sicad': { 'left': '*' },
    \ 'simula': { 'left': '%', 'leftAlt': '--' },
    \ 'sinda': { 'left': '$' },
    \ 'skill': { 'left': ';' },
    \ 'slang': { 'left': '%' },
    \ 'slice': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'slim': { 'left': '/', 'leftAlt': '/!' },
    \ 'slrnrc': { 'left': '%' },
    \ 'sm': { 'left': '#' },
    \ 'smarty': { 'left': '{*', 'right': '*}' },
    \ 'smil': { 'left': '<!', 'right': '>' },
    \ 'smith': { 'left': ';' },
    \ 'sml': { 'left': '(*', 'right': '*)' },
    \ 'snnsnet': { 'left': '#' },
    \ 'snnspat': { 'left': '#' },
    \ 'snnsres': { 'left': '#' },
    \ 'snobol4': { 'left': '*' },
    \ 'spec': { 'left': '#' },
    \ 'specman': { 'left': '//' },
    \ 'spectre': { 'left': '//', 'leftAlt': '*' },
    \ 'spice': { 'left': '$' },
    \ 'sql': { 'left': '-- ' },
    \ 'sqlforms': { 'left': '-- ' },
    \ 'sqlj': { 'left': '-- ' },
    \ 'sqr': { 'left': '!' },
    \ 'squid': { 'left': '#' },
    \ 'st': { 'left': '"' },
    \ 'stp': { 'left': '--' },
    \ 'supercollider': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tads': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tags': { 'left': ';' },
    \ 'tak': { 'left': '$' },
    \ 'tasm': { 'left': ';' },
    \ 'tcl': { 'left': '#' },
    \ 'texinfo': { 'left': "@c " },
    \ 'texmf': { 'left': '%' },
    \ 'tf': { 'left': ';' },
    \ 'tidy': { 'left': '#' },
    \ 'tli': { 'left': '#' },
    \ 'tmux': { 'left': '#' },
    \ 'trasys': { 'left': "$" },
    \ 'tsalt': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'tsscl': { 'left': '#' },
    \ 'tssgm': { 'left': "comment = '", 'right': "'" },
    \ 'txt2tags': { 'left': '%' },
    \ 'twig': { 'left': '{#', 'right': '#}' },
    \ 'uc': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'uil': { 'left': '!' },
    \ 'vala': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vb': { 'left': "'" },
    \ 'velocity': { 'left': "##", 'right': "", 'leftAlt': '#*', 'rightAlt': '*#' },
    \ 'vera': { 'left': '/*','right': '*/', 'leftAlt': '//' },
    \ 'verilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'verilog_systemverilog': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
    \ 'vgrindefs': { 'left': '#' },
    \ 'vhdl': { 'left': '--' },
    \ 'vimperator': { 'left': '"' },
    \ 'virata': { 'left': '%' },
    \ 'vrml': { 'left': '#' },
    \ 'vsejcl': { 'left': '/*' },
    \ 'webmacro': { 'left': '##' },
    \ 'wget': { 'left': '#' },
    \ 'Wikipedia': { 'left': '<!--', 'right': '-->' },
    \ 'winbatch': { 'left': ';' },
    \ 'wml': { 'left': '#' },
    \ 'wvdial': { 'left': ';' },
    \ 'xdefaults': { 'left': '!' },
    \ 'xkb': { 'left': '//' },
    \ 'xmath': { 'left': '#' },
    \ 'xpm2': { 'left': '!' },
    \ 'xquery': { 'left': '(:', 'right': ':)' },
    \ 'z8a': { 'left': ';' }
    \ }

if exists("g:NERDCustomDelimiters")
    call extend(s:delimiterMap, g:NERDCustomDelimiters)
endif

" Section: Comment mapping functions, autocommands and commands {{{1
" ============================================================================
" Section: Comment enabler autocommands {{{2
" ============================================================================

augroup NERDCommenter

    "if the user enters a buffer or reads a buffer then we gotta set up
    "the comment delimiters for that new filetype
    autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)

    "if the filetype of a buffer changes, force the script to reset the
    "delims for the buffer
    autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)
augroup END


" Function: s:SetUpForNewFiletype(filetype) function {{{2
" This function is responsible for setting up buffer scoped variables for the
" given filetype.
"
" Args:
"   -filetype: the filetype to set delimiters for
"   -forceReset: 1 if the delimiters should be reset if they have already be
"    set for this buffer.
"
function s:SetUpForNewFiletype(filetype, forceReset)
    let ft = a:filetype

    "for compound filetypes, if we dont know how to handle the full filetype
    "then break it down and use the first part that we know how to handle
    if ft =~ '\.' && !has_key(s:delimiterMap, ft)
        let filetypes = split(a:filetype, '\.')
        for i in filetypes
            if has_key(s:delimiterMap, i)
                let ft = i
                break
            endif
        endfor
    endif

    let b:NERDSexyComMarker = ''

    if has_key(s:delimiterMap, ft)
        let b:NERDCommenterDelims = s:delimiterMap[ft]
        for i in ['left', 'leftAlt', 'right', 'rightAlt']
            if !has_key(b:NERDCommenterDelims, i)
                let b:NERDCommenterDelims[i] = ''
            endif
        endfor
    else
        let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    endif

endfunction

function s:CreateDelimMapFromCms()
    return {
        \ 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''),
        \ 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'),
        \ 'leftAlt': '',
        \ 'rightAlt': '' }
endfunction

" Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2
" This function is used to swap the delimiters that are being used to the
" alternative delimiters for that filetype. For example, if a c++ file is
" being edited and // comments are being used, after this function is called
" /**/ comments will be used.
"
" Args:
"   -printMsgs: if this is 1 then a message is echoed to the user telling them
"    if this function changed the delimiters or not
function s:SwitchToAlternativeDelimiters(printMsgs)
    "if both of the alternative delimiters are empty then there is no
    "alternative comment style so bail out
    if b:NERDCommenterDelims['leftAlt'] == '' && b:NERDCommenterDelims['rightAlt'] == ''
        if a:printMsgs
            call s:NerdEcho("Cannot use alternative delimiters, none are specified", 0)
        endif
        return 0
    endif

    "save the current delimiters
    let tempLeft = s:Left()
    let tempRight = s:Right()

    "swap current delimiters for alternative
    let b:NERDCommenterDelims['left'] = b:NERDCommenterDelims['leftAlt']
    let b:NERDCommenterDelims['right'] = b:NERDCommenterDelims['rightAlt']

    "set the previously current delimiters to be the new alternative ones
    let b:NERDCommenterDelims['leftAlt'] = tempLeft
    let b:NERDCommenterDelims['rightAlt'] = tempRight

    "tell the user what comment delimiters they are now using
    if a:printMsgs
        call s:NerdEcho("Now using " . s:Left() . " " . s:Right() . " to delimit comments", 1)
    endif

    return 1
endfunction

" Section: Comment delimiter add/removal functions {{{1
" ============================================================================
" Function: s:AppendCommentToLine(){{{2
" This function appends comment delimiters at the EOL and places the cursor in
" position to start typing the comment
function s:AppendCommentToLine()
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    " get the len of the right delim
    let lenRight = strlen(right)

    let isLineEmpty = strlen(getline(".")) == 0
    let insOrApp = (isLineEmpty==1 ? 'i' : 'A')

    "stick the delimiters down at the end of the line. We have to format the
    "comment with spaces as appropriate
    execute ":normal! " . insOrApp . (isLineEmpty ? '' : ' ') . left . right . " "

    " if there is a right delimiter then we gotta move the cursor left
    " by the len of the right delimiter so we insert between the delimiters
    if lenRight > 0
        let leftMoveAmount = lenRight
        execute ":normal! " . leftMoveAmount . "h"
    endif
    startinsert
endfunction

" Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2
" This function is used to comment out a region of code. This region is
" specified as a bounding box by arguments to the function.
"
" Args:
"   -top: the line number for the top line of code in the region
"   -bottom: the line number for the bottom line of code in the region
"   -lSide: the column number for the left most column in the region
"   -rSide: the column number for the right most column in the region
"   -forceNested: a flag indicating whether comments should be nested
function s:CommentBlock(top, bottom, lSide, rSide, forceNested )
    " we need to create local copies of these arguments so we can modify them
    let top = a:top
    let bottom = a:bottom
    let lSide = a:lSide
    let rSide = a:rSide

    "if the top or bottom line starts with tabs we have to adjust the left and
    "right boundaries so that they are set as though the tabs were spaces
    let topline = getline(top)
    let bottomline = getline(bottom)
    if s:HasLeadingTabs(topline, bottomline)

        "find out how many tabs are in the top line and adjust the left
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(topline)
        if lSide < numTabs
            let lSide = &ts * lSide
        else
            let lSide = (lSide - numTabs) + (&ts * numTabs)
        endif

        "find out how many tabs are in the bottom line and adjust the right
        "boundary accordingly
        let numTabs = s:NumberOfLeadingTabs(bottomline)
        let rSide = (rSide - numTabs) + (&ts * numTabs)
    endif

    "we must check that bottom IS actually below top, if it is not then we
    "swap top and bottom. Similarly for left and right.
    if bottom < top
        let temp = top
        let top = bottom
        let bottom = top
    endif
    if rSide < lSide
        let temp = lSide
        let lSide = rSide
        let rSide = temp
    endif

    "if the current delimiters arent multipart then we will switch to the
    "alternative delims (if THEY are) as the comment will be better and more
    "accurate with multipart delims
    let switchedDelims = 0
    if !s:Multipart() && g:NERDAllowAnyVisualDelims && s:AltMultipart()
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "start the commenting from the top and keep commenting till we reach the
    "bottom
    let currentLine=top
    while currentLine <= bottom

        "check if we are allowed to comment this line
        if s:CanCommentLine(a:forceNested, currentLine)

            "convert the leading tabs into spaces
            let theLine = getline(currentLine)
            let lineHasLeadTabs = s:HasLeadingTabs(theLine)
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif

            "dont comment lines that begin after the right boundary of the
            "block unless the user has specified to do so
            if theLine !~ '^ \{' . rSide . '\}' || !g:NERDBlockComIgnoreEmpty

                "attempt to place the cursor in on the left of the boundary box,
                "then check if we were successful, if not then we cant comment this
                "line
                call setline(currentLine, theLine)
                if s:CanPlaceCursor(currentLine, lSide)

                    let leftSpaced = s:Left({'space': 1})
                    let rightSpaced = s:Right({'space': 1})

                    "stick the left delimiter down
                    let theLine = strpart(theLine, 0, lSide-1) . leftSpaced . strpart(theLine, lSide-1)

                    if s:Multipart()
                        "stick the right delimiter down
                        let theLine = strpart(theLine, 0, rSide+strlen(leftSpaced)) . rightSpaced . strpart(theLine, rSide+strlen(leftSpaced))

                        let firstLeftDelim = s:FindDelimiterIndex(s:Left(), theLine)
                        let lastRightDelim = s:LastIndexOfDelim(s:Right(), theLine)

                        if firstLeftDelim != -1 && lastRightDelim != -1
                            let searchStr = strpart(theLine, 0, lastRightDelim)
                            let searchStr = strpart(searchStr, firstLeftDelim+strlen(s:Left()))

                            "replace the outter most delims in searchStr with
                            "place-holders
                            let theLineWithPlaceHolders = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, searchStr)

                            "add the right delimiter onto the line
                            let theLine = strpart(theLine, 0, firstLeftDelim+strlen(s:Left())) . theLineWithPlaceHolders . strpart(theLine, lastRightDelim)
                        endif
                    endif
                endif
            endif

            "restore tabs if needed
            if lineHasLeadTabs
                let theLine = s:ConvertLeadingSpacesToTabs(theLine)
            endif

            call setline(currentLine, theLine)
        endif

        let currentLine = currentLine + 1
    endwhile

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif
endfunction

" Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2
" This function comments a range of lines.
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -align: should be "left" or "both" or "none"
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLines(forceNested, align, firstLine, lastLine)
    " we need to get the left and right indexes of the leftmost char in the
    " block of of lines and the right most char so that we can do alignment of
    " the delimiters if the user has specified
    let leftAlignIndx = s:LeftMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)
    let rightAlignIndx = s:RightMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)

    " gotta add the length of the left delimiter onto the rightAlignIndx cos
    " we'll be adding a left delim to the line
    let rightAlignIndx = rightAlignIndx + strlen(s:Left({'space': 1}))

    " now we actually comment the lines. Do it line by line
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanCommentLine(a:forceNested, currentLine)
            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if a:forceNested && g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            " find out if the line is commented using normal delims and/or
            " alternate ones
            let isCommented = s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)

            " check if we can comment this line
            if !isCommented || g:NERDUsePlaceHolders || s:Multipart()
                if a:align == "left" || a:align == "both"
                    let theLine = s:AddLeftDelimAligned(s:Left({'space': 1}), theLine, leftAlignIndx)
                else
                    let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
                endif
                if a:align == "both"
                    let theLine = s:AddRightDelimAligned(s:Right({'space': 1}), theLine, rightAlignIndx)
                else
                    let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
                endif
            endif
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2
" This function comments a range of lines in a minimal style. I
"
" Args:
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesMinimal(firstLine, lastLine)
    "check that minimal comments can be done on this filetype
    if !s:HasMultipartDelims()
        throw 'NERDCommenter.Delimiters exception: Minimal comments can only be used for filetypes that have multipart delimiters'
    endif

    "if we need to use place holders for the comment, make sure they are
    "enabled for this filetype
    if !g:NERDUsePlaceHolders && s:DoesBlockHaveMultipartDelim(a:firstLine, a:lastLine)
        throw 'NERDCommenter.Settings exception: Place holders are required but disabled.'
    endif

    "get the left and right delims to smack on
    let left = s:GetSexyComLeft(g:NERDSpaceDelims,0)
    let right = s:GetSexyComRight(g:NERDSpaceDelims,0)

    "make sure all multipart delims on the lines are replaced with
    "placeholders to prevent illegal syntax
    let currentLine = a:firstLine
    while(currentLine <= a:lastLine)
        let theLine = getline(currentLine)
        let theLine = s:ReplaceDelims(left, right, g:NERDLPlace, g:NERDRPlace, theLine)
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    "add the delim to the top line
    let theLine = getline(a:firstLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddLeftDelim(left, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:firstLine, theLine)

    "add the delim to the bottom line
    let theLine = getline(a:lastLine)
    let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
    let theLine = s:ConvertLeadingTabsToSpaces(theLine)
    let theLine = s:AddRightDelim(right, theLine)
    if lineHasLeadingTabs
        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
    endif
    call setline(a:lastLine, theLine)
endfunction

" Function: s:CommentLinesSexy(topline, bottomline) function {{{2
" This function is used to comment lines in the 'Sexy' style. eg in c:
" /*
"  * This is a sexy comment
"  */
" Args:
"   -topline: the line num of the top line in the sexy comment
"   -bottomline: the line num of the bottom line in the sexy comment
function s:CommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0, 0)
    let right = s:GetSexyComRight(0, 0)

    "check if we can do a sexy comment with the available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot perform sexy comments with available delimiters.'
    endif

    "make sure the lines arent already commented sexually
    if !s:CanSexyCommentLines(a:topline, a:bottomline)
        throw 'NERDCommenter.Nesting exception: cannot nest sexy comments'
    endif


    let sexyComMarker = s:GetSexyComMarker(0,0)
    let sexyComMarkerSpaced = s:GetSexyComMarker(1,0)


    " we jam the comment as far to the right as possible
    let leftAlignIndx = s:LeftMostIndx(1, 1, a:topline, a:bottomline)

    "check if we should use the compact style i.e that the left/right
    "delimiters should appear on the first and last lines of the code and not
    "on separate lines above/below the first/last lines of code
    if g:NERDCompactSexyComs
        let spaceString = (g:NERDSpaceDelims ? s:spaceStr : '')

        "comment the top line
        let theLine = getline(a:topline)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif
        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        let theLine = s:AddLeftDelimAligned(left . spaceString, theLine, leftAlignIndx)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        "comment the bottom line
        if a:bottomline != a:topline
            let theLine = getline(a:bottomline)
            let lineHasTabs = s:HasLeadingTabs(theLine)
            if lineHasTabs
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
            endif
            let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
        endif
        let theLine = s:AddRightDelim(spaceString . right, theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline, theLine)
    else

        " add the left delimiter one line above the lines that are to be commented
        call cursor(a:topline, 1)
        execute 'normal! O'
        let theLine = repeat(' ', leftAlignIndx) . left

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:topline, theLine)

        " add the right delimiter after bottom line (we have to add 1 cos we moved
        " the lines down when we added the left delim
        call cursor(a:bottomline+1, 1)
        execute 'normal! o'
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . right

        " Make sure tabs are respected
        if !&expandtab
           let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif
        call setline(a:bottomline+2, theLine)

    endif

    " go thru each line adding the sexyComMarker marker to the start of each
    " line in the appropriate place to align them with the comment delims
    let currentLine = a:topline+1
    while currentLine <= a:bottomline + !g:NERDCompactSexyComs
        " get the line and convert the tabs to spaces
        let theLine = getline(currentLine)
        let lineHasTabs = s:HasLeadingTabs(theLine)
        if lineHasTabs
            let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        endif

        let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)

        " add the sexyComMarker
        let theLine = repeat(' ', leftAlignIndx) . repeat(' ', strlen(left)-strlen(sexyComMarker)) . sexyComMarkerSpaced . strpart(theLine, leftAlignIndx)

        if lineHasTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif


        " set the line and move onto the next one
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2
" Applies "toggle" commenting to the given range of lines
"
" Args:
"   -forceNested: a flag indicating whether the called is requesting the comment
"    to be nested if need be
"   -firstLine/lastLine: the top and bottom lines to comment
function s:CommentLinesToggle(forceNested, firstLine, lastLine)
    let currentLine = a:firstLine
    while currentLine <= a:lastLine

        " get the next line, check commentability and convert spaces to tabs
        let theLine = getline(currentLine)
        let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
        let theLine = s:ConvertLeadingTabsToSpaces(theLine)
        if s:CanToggleCommentLine(a:forceNested, currentLine)

            "if the user has specified forceNesting then we check to see if we
            "need to switch delimiters for place-holders
            if g:NERDUsePlaceHolders
                let theLine = s:SwapOutterMultiPartDelimsForPlaceHolders(theLine)
            endif

            let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
            let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
        endif

        " restore leading tabs if appropriate
        if lineHasLeadingTabs
            let theLine = s:ConvertLeadingSpacesToTabs(theLine)
        endif

        " we are done with this line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

endfunction

" Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2
" This function comments chunks of text selected in visual mode.
" It will comment exactly the text that they have selected.
" Args:
"   -topLine: the line num of the top line in the sexy comment
"   -topCol: top left col for this comment
"   -bottomline: the line num of the bottom line in the sexy comment
"   -bottomCol: the bottom right col for this comment
"   -forceNested: whether the caller wants comments to be nested if the
"    line(s) are already commented
function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)

    "switch delims (if we can) if the current set isnt multipart
    let switchedDelims = 0
    if !s:Multipart() && s:AltMultipart() && !g:NERDAllowAnyVisualDelims
        let switchedDelims = 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

    "if there is only one line in the comment then just do it
    if a:topLine == a:bottomLine
        call s:CommentBlock(a:topLine, a:bottomLine, a:topCol, a:bottomCol, a:forceNested)

    "there are multiple lines in the comment
    else
        "comment the top line
        call s:CommentBlock(a:topLine, a:topLine, a:topCol, strlen(getline(a:topLine)), a:forceNested)

        "comment out all the lines in the middle of the comment
        let topOfRange = a:topLine+1
        let bottomOfRange = a:bottomLine-1
        if topOfRange <= bottomOfRange
            call s:CommentLines(a:forceNested, "none", topOfRange, bottomOfRange)
        endif

        "comment the bottom line
        let bottom = getline(a:bottomLine)
        let numLeadingSpacesTabs = strlen(substitute(bottom, '^\([ \t]*\).*$', '\1', ''))
        call s:CommentBlock(a:bottomLine, a:bottomLine, numLeadingSpacesTabs+1, a:bottomCol, a:forceNested)

    endif

    "stick the cursor back on the char it was on before the comment
    call cursor(a:topLine, a:topCol + strlen(s:Left()) + g:NERDSpaceDelims)

    "if we switched delims then we gotta go back to what they were before
    if switchedDelims == 1
        call s:SwitchToAlternativeDelimiters(0)
    endif

endfunction

" Function: s:InvertComment(firstLine, lastLine) function {{{2
" Inverts the comments on the lines between and including the given line
" numbers i.e all commented lines are uncommented and vice versa
" Args:
"   -firstLine: the top of the range of lines to be inverted
"   -lastLine: the bottom of the range of lines to be inverted
function s:InvertComment(firstLine, lastLine)

    " go thru all lines in the given range
    let currentLine = a:firstLine
    while currentLine <= a:lastLine
        let theLine = getline(currentLine)

        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)

        " if the line is commented normally, uncomment it
        if s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(currentLine, currentLine)
            let currentLine = currentLine + 1

        " check if the line is commented sexually
        elseif !empty(sexyComBounds)
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()
            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let currentLine = sexyComBounds[1] - (numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved) + 1

        " the line isnt commented
        else
            call s:CommentLinesToggle(1, currentLine, currentLine)
            let currentLine = currentLine + 1
        endif

    endwhile
endfunction

" Function: NERDComment(mode, type) function {{{2
" This function is a Wrapper for the main commenting functions
"
" Args:
"   -mode: a character indicating the mode in which the comment is requested:
"   'n' for Normal mode, 'x' for Visual mode
"   -type: the type of commenting requested. Can be 'Sexy', 'Invert',
"    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',
"    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'
function! NERDComment(mode, type) range
    let isVisual = a:mode =~ '[vsx]'
    " we want case sensitivity when commenting
    let oldIgnoreCase = &ignorecase
    set noignorecase

    if !exists("g:did_load_ftplugin") || g:did_load_ftplugin != 1
        call s:NerdEcho("filetype plugins should be enabled. See :help NERDComInstallation and :help :filetype-plugin-on", 0)
    endif

    if isVisual
        let firstLine = line("'<")
        let lastLine = line("'>")
        let firstCol = col("'<")
        let lastCol = col("'>") - (&selection == 'exclusive' ? 1 : 0)
    else
        let firstLine = a:firstline
        let lastLine = a:lastline
    endif

    let countWasGiven = (!isVisual && firstLine != lastLine)

    let forceNested = (a:type ==? 'Nested' || g:NERDDefaultNesting)

    if a:type ==? 'Comment' || a:type ==? 'Nested'
        if isVisual && visualmode() == "\<C-V>"
            call s:CommentBlock(firstLine, lastLine, firstCol, lastCol, forceNested)
        elseif isVisual && visualmode() == "v" && (g:NERDCommentWholeLinesInVMode==0 || (g:NERDCommentWholeLinesInVMode==2 && s:HasMultipartDelims()))
            call s:CommentRegion(firstLine, firstCol, lastLine, lastCol, forceNested)
        else
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        endif

    elseif a:type ==? 'AlignLeft' || a:type ==? 'AlignBoth'
        let align = "none"
        if a:type ==? "AlignLeft"
            let align = "left"
        elseif a:type ==? "AlignBoth"
            let align = "both"
        endif
        call s:CommentLines(forceNested, align, firstLine, lastLine)

    elseif a:type ==? 'Invert'
        call s:InvertComment(firstLine, lastLine)

    elseif a:type ==? 'Sexy'
        try
            call s:CommentLinesSexy(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:CommentLines(forceNested, "none", firstLine, lastLine)
        catch /NERDCommenter.Nesting/
            call s:NerdEcho("Sexy comment aborted. Nested sexy cannot be nested", 0)
        endtry

    elseif a:type ==? 'Toggle'
        let theLine = getline(firstLine)

        if s:IsInSexyComment(firstLine) || s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
            call s:UncommentLines(firstLine, lastLine)
        else
            call s:CommentLinesToggle(forceNested, firstLine, lastLine)
        endif

    elseif a:type ==? 'Minimal'
        try
            call s:CommentLinesMinimal(firstLine, lastLine)
        catch /NERDCommenter.Delimiters/
            call s:NerdEcho("Minimal comments can only be used for filetypes that have multipart delimiters.", 0)
        catch /NERDCommenter.Settings/
            call s:NerdEcho("Place holders are required but disabled.", 0)
        endtry

    elseif a:type ==? 'ToEOL'
        call s:SaveScreenState()
        call s:CommentBlock(firstLine, firstLine, col("."), col("$")-1, 1)
        call s:RestoreScreenState()

    elseif a:type ==? 'Append'
        call s:AppendCommentToLine()

    elseif a:type ==? 'Insert'
        call s:PlaceDelimitersAndInsBetween()

    elseif a:type ==? 'Uncomment'
        call s:UncommentLines(firstLine, lastLine)

    elseif a:type ==? 'Yank'
        if isVisual
            normal! gvy
        elseif countWasGiven
            execute firstLine .','. lastLine .'yank'
        else
            normal! yy
        endif
        execute firstLine .','. lastLine .'call NERDComment("'. a:mode .'", "Comment")'
    endif

    let &ignorecase = oldIgnoreCase

    if isVisual
        let nlines = lastLine - firstLine
        silent! call repeat#set("V" . nlines . "jo" . "\<Plug>NERDCommenter". a:type)
    else
        silent! call repeat#set("\<Plug>NERDCommenter". a:type)
    endif
endfunction

" Function: s:PlaceDelimitersAndInsBetween() function {{{2
" This is function is called to place comment delimiters down and place the
" cursor between them
function s:PlaceDelimitersAndInsBetween()
    " get the left and right delimiters without any escape chars in them
    let left = s:Left({'space': 1})
    let right = s:Right({'space': 1})

    let theLine = getline(".")
    let lineHasLeadTabs = s:HasLeadingTabs(theLine) || (theLine =~ '^ *$' && !&expandtab)

    "convert tabs to spaces and adjust the cursors column to take this into
    "account
    let untabbedCol = s:UntabbedCol(theLine, col("."))
    call setline(line("."), s:ConvertLeadingTabsToSpaces(theLine))
    call cursor(line("."), untabbedCol)

    " get the len of the right delim
    let lenRight = strlen(right)

    let isDelimOnEOL = col(".") >= strlen(getline("."))

    " if the cursor is in the first col then we gotta insert rather than
    " append the comment delimiters here
    let insOrApp = (col(".")==1 ? 'i' : 'a')

    " place the delimiters down. We do it differently depending on whether
    " there is a left AND right delimiter
    if lenRight > 0
        execute ":normal! " . insOrApp . left . right
        execute ":normal! " . lenRight . "h"
    else
        execute ":normal! " . insOrApp . left
    endif
    silent! normal! l

    "if needed convert spaces back to tabs and adjust the cursors col
    "accordingly
    if lineHasLeadTabs
        let tabbedCol = s:TabbedCol(getline("."), col("."))
        call setline(line("."), s:ConvertLeadingSpacesToTabs(getline(".")))
        call cursor(line("."), tabbedCol)
    endif

    if isDelimOnEOL && lenRight == 0
        startinsert!
    else
        startinsert
    endif
endfunction

" Function: s:RemoveDelimiters(left, right, line) {{{2
" this function is called to remove the first left comment delimiter and the
" last right delimiter of the given line.
"
" The args left and right must be strings. If there is no right delimiter (as
" is the case for e.g vim file comments) them the arg right should be ""
"
" Args:
"   -left: the left comment delimiter
"   -right: the right comment delimiter
"   -line: the line to remove the delimiters from
function s:RemoveDelimiters(left, right, line)

    let l:left = a:left
    let l:right = a:right
    let lenLeft = strlen(left)
    let lenRight = strlen(right)

    let delimsSpaced = (g:NERDSpaceDelims || g:NERDRemoveExtraSpaces)

    let line = a:line

    "look for the left delimiter, if we find it, remove it.
    let leftIndx = s:FindDelimiterIndex(a:left, line)
    if leftIndx != -1
        let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+lenLeft)

        "if the user has specified that there is a space after the left delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, leftIndx, s:lenSpaceStr) == s:spaceStr
            let line = strpart(line, 0, leftIndx) . strpart(line, leftIndx+s:lenSpaceStr)
        endif
    endif

    "look for the right delimiter, if we find it, remove it
    let rightIndx = s:FindDelimiterIndex(a:right, line)
    if rightIndx != -1
        let line = strpart(line, 0, rightIndx) . strpart(line, rightIndx+lenRight)

        "if the user has specified that there is a space before the right delim
        "then check for the space and remove it if it is there
        if delimsSpaced && strpart(line, rightIndx-s:lenSpaceStr, s:lenSpaceStr) == s:spaceStr && s:Multipart()
            let line = strpart(line, 0, rightIndx-s:lenSpaceStr) . strpart(line, rightIndx)
        endif
    endif

    return line
endfunction

" Function: s:UncommentLines(topLine, bottomLine) {{{2
" This function uncomments the given lines
"
" Args:
" topLine: the top line of the visual selection to uncomment
" bottomLine: the bottom line of the visual selection to uncomment
function s:UncommentLines(topLine, bottomLine)
    "make local copies of a:firstline and a:lastline and, if need be, swap
    "them around if the top line is below the bottom
    let l:firstline = a:topLine
    let l:lastline = a:bottomLine
    if firstline > lastline
        let firstline = lastline
        let lastline = a:topLine
    endif

    "go thru each line uncommenting each line removing sexy comments
    let currentLine = firstline
    while currentLine <= lastline

        "check the current line to see if it is part of a sexy comment
        let sexyComBounds = s:FindBoundingLinesOfSexyCom(currentLine)
        if !empty(sexyComBounds)

            "we need to store the num lines in the buf before the comment is
            "removed so we know how many lines were removed when the sexy com
            "was removed
            let numLinesBeforeSexyComRemoved = s:NumLinesInBuf()

            call s:UncommentLinesSexy(sexyComBounds[0], sexyComBounds[1])

            "move to the line after last line of the sexy comment
            let numLinesAfterSexyComRemoved = s:NumLinesInBuf()
            let numLinesRemoved = numLinesBeforeSexyComRemoved - numLinesAfterSexyComRemoved
            let currentLine = sexyComBounds[1] - numLinesRemoved + 1
            let lastline = lastline - numLinesRemoved

        "no sexy com was detected so uncomment the line as normal
        else
            call s:UncommentLinesNormal(currentLine, currentLine)
            let currentLine = currentLine + 1
        endif
    endwhile

endfunction

" Function: s:UncommentLinesSexy(topline, bottomline) {{{2
" This function removes all the comment characters associated with the sexy
" comment spanning the given lines
" Args:
"   -topline/bottomline: the top/bottom lines of the sexy comment
function s:UncommentLinesSexy(topline, bottomline)
    let left = s:GetSexyComLeft(0,1)
    let right = s:GetSexyComRight(0,1)


    "check if it is even possible for sexy comments to exist with the
    "available delimiters
    if left == -1 || right == -1
        throw 'NERDCommenter.Delimiters exception: cannot uncomment sexy comments with available delimiters.'
    endif

    let leftUnEsc = s:GetSexyComLeft(0,0)
    let rightUnEsc = s:GetSexyComRight(0,0)

    let sexyComMarker = s:GetSexyComMarker(0, 1)
    let sexyComMarkerUnEsc = s:GetSexyComMarker(0, 0)

    "the markerOffset is how far right we need to move the sexyComMarker to
    "line it up with the end of the left delim
    let markerOffset = strlen(leftUnEsc)-strlen(sexyComMarkerUnEsc)

    " go thru the intermediate lines of the sexy comment and remove the
    " sexy comment markers (eg the '*'s on the start of line in a c sexy
    " comment)
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        " remove the sexy comment marker from the line. We also remove the
        " space after it if there is one and if appropriate options are set
        let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
        if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)

        let theLine = s:ConvertLeadingWhiteSpace(theLine)

        " move onto the next line
        call setline(currentLine, theLine)
        let currentLine = currentLine + 1
    endwhile

    " gotta make a copy of a:bottomline cos we modify the position of the
    " last line  it if we remove the topline
    let bottomline = a:bottomline

    " get the first line so we can remove the left delim from it
    let theLine = getline(a:topline)

    " if the first line contains only the left delim then just delete it
    if theLine =~ '^[ \t]*' . left . '[ \t]*$' && !g:NERDCompactSexyComs
        call cursor(a:topline, 1)
        normal! dd
        let bottomline = bottomline - 1

    " topline contains more than just the left delim
    else

        " remove the delim. If there is a space after it
        " then remove this too if appropriate
        let delimIndx = stridx(theLine, leftUnEsc)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(leftUnEsc))
        endif
        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(a:topline, theLine)
    endif

    " get the last line so we can remove the right delim
    let theLine = getline(bottomline)

    " if the bottomline contains only the right delim then just delete it
    if theLine =~ '^[ \t]*' . right . '[ \t]*$'
        call cursor(bottomline, 1)
        normal! dd

    " the last line contains more than the right delim
    else
        " remove the right delim. If there is a space after it and
        " if the appropriate options are set then remove this too.
        let delimIndx = s:LastIndexOfDelim(rightUnEsc, theLine)
        if strpart(theLine, delimIndx+strlen(leftUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc)+s:lenSpaceStr)
        else
            let theLine = strpart(theLine, 0, delimIndx) . strpart(theLine, delimIndx+strlen(rightUnEsc))
        endif

        " if the last line also starts with a sexy comment marker then we
        " remove this as well
        if theLine =~ '^[ \t]*' . sexyComMarker

            " remove the sexyComMarker. If there is a space after it then
            " remove that too
            let sexyComMarkerIndx = stridx(theLine, sexyComMarkerUnEsc)
            if strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc), s:lenSpaceStr) == s:spaceStr  && g:NERDSpaceDelims
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc)+s:lenSpaceStr)
            else
                let theLine = strpart(theLine, 0, sexyComMarkerIndx - markerOffset ) . strpart(theLine, sexyComMarkerIndx+strlen(sexyComMarkerUnEsc))
            endif
        endif

        let theLine = s:SwapOutterPlaceHoldersForMultiPartDelims(theLine)
        call setline(bottomline, theLine)
    endif
endfunction

" Function: s:UncommentLineNormal(line) {{{2
" uncomments the given line and returns the result
" Args:
"   -line: the line to uncomment
function s:UncommentLineNormal(line)
    let line = a:line

    "get the positions of all delim types on the line
    let indxLeft = s:FindDelimiterIndex(s:Left(), line)
    let indxLeftAlt = s:FindDelimiterIndex(s:Left({'alt': 1}), line)
    let indxRight = s:FindDelimiterIndex(s:Right(), line)
    let indxRightAlt = s:FindDelimiterIndex(s:Right({'alt': 1}), line)

    "get the comment status on the line so we know how it is commented
    let lineCommentStatus =  s:IsCommentedOuttermost(s:Left(), s:Right(), s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is commented with s:Left() and s:Right() so remove these delims
    if lineCommentStatus == 1
        let line = s:RemoveDelimiters(s:Left(), s:Right(), line)

    "it is commented with s:Left({'alt': 1}) and s:Right({'alt': 1}) so remove these delims
    elseif lineCommentStatus == 2 && g:NERDRemoveAltComs
        let line = s:RemoveDelimiters(s:Left({'alt': 1}), s:Right({'alt': 1}), line)

    "it is not properly commented with any delims so we check if it has
    "any random left or right delims on it and remove the outtermost ones
    else
        "remove the outter most left comment delim
        if indxLeft != -1 && (indxLeft < indxLeftAlt || indxLeftAlt == -1)
            let line = s:RemoveDelimiters(s:Left(), '', line)
        elseif indxLeftAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters(s:Left({'alt': 1}), '', line)
        endif

        "remove the outter most right comment delim
        if indxRight != -1 && (indxRight < indxRightAlt || indxRightAlt == -1)
            let line = s:RemoveDelimiters('', s:Right(), line)
        elseif indxRightAlt != -1 && g:NERDRemoveAltComs
            let line = s:RemoveDelimiters('', s:Right({'alt': 1}), line)
        endif
    endif


    let indxLeftPlace = s:FindDelimiterIndex(g:NERDLPlace, line)
    let indxRightPlace = s:FindDelimiterIndex(g:NERDRPlace, line)

    let right = s:Right()
    let left = s:Left()
    if !s:Multipart()
        let right = s:Right({'alt': 1})
        let left = s:Left({'alt': 1})
    endif


    "if there are place-holders on the line then we check to see if they are
    "the outtermost delimiters on the line. If so then we replace them with
    "real delimiters
    if indxLeftPlace != -1
        if (indxLeftPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif
    elseif indxRightPlace != -1
        if (indxRightPlace < indxLeft || indxLeft==-1) && (indxLeftPlace < indxLeftAlt || indxLeftAlt==-1)
            let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, line)
        endif

    endif

    let line = s:ConvertLeadingWhiteSpace(line)

    return line
endfunction

" Function: s:UncommentLinesNormal(topline, bottomline) {{{2
" This function is called to uncomment lines that arent a sexy comment
" Args:
"   -topline/bottomline: the top/bottom line numbers of the comment
function s:UncommentLinesNormal(topline, bottomline)
    let currentLine = a:topline
    while currentLine <= a:bottomline
        let line = getline(currentLine)
        call setline(currentLine, s:UncommentLineNormal(line))
        let currentLine = currentLine + 1
    endwhile
endfunction


" Section: Other helper functions {{{1
" ============================================================================

" Function: s:AddLeftDelim(delim, theLine) {{{2
" Args:
function s:AddLeftDelim(delim, theLine)
    return substitute(a:theLine, '^\([ \t]*\)', '\1' . a:delim, '')
endfunction

" Function: s:AddLeftDelimAligned(delim, theLine) {{{2
" Args:
function s:AddLeftDelimAligned(delim, theLine, alignIndx)

    "if the line is not long enough then bung some extra spaces on the front
    "so we can align the delim properly
    let theLine = a:theLine
    if strlen(theLine) < a:alignIndx
        let theLine = repeat(' ', a:alignIndx - strlen(theLine))
    endif

    return strpart(theLine, 0, a:alignIndx) . a:delim . strpart(theLine, a:alignIndx)
endfunction

" Function: s:AddRightDelim(delim, theLine) {{{2
" Args:
function s:AddRightDelim(delim, theLine)
    if a:delim == ''
        return a:theLine
    else
        return substitute(a:theLine, '$', a:delim, '')
    endif
endfunction

" Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2
" Args:
function s:AddRightDelimAligned(delim, theLine, alignIndx)
    if a:delim == ""
        return a:theLine
    else

        " when we align the right delim we are just adding spaces
        " so we get a string containing the needed spaces (it
        " could be empty)
        let extraSpaces = ''
        let extraSpaces = repeat(' ', a:alignIndx-strlen(a:theLine))

        " add the right delim
        return substitute(a:theLine, '$', extraSpaces . a:delim, '')
    endif
endfunction

" Function: s:AltMultipart() {{{2
" returns 1 if the alternative delims are multipart
function s:AltMultipart()
    return b:NERDCommenterDelims['rightAlt'] != ''
endfunction

" Function: s:CanCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -forceNested: a flag indicating whether the caller wants comments to be nested
"    if the current line is already commented
"   -lineNum: the line num of the line to check for commentability
function s:CanCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    let isCommented = s:IsCommentedNormOrSexy(a:lineNum)

    "if the line isnt commented return true
    if !isCommented
        return 1
    endif

    "if the line is commented but nesting is allowed then return true
    if a:forceNested && (!s:Multipart() || g:NERDUsePlaceHolders)
        return 1
    endif

    return 0
endfunction

" Function: s:CanPlaceCursor(line, col) {{{2
" returns 1 if the cursor can be placed exactly in the given position
function s:CanPlaceCursor(line, col)
    let c = col(".")
    let l = line(".")
    call cursor(a:line, a:col)
    let success = (line(".") == a:line && col(".") == a:col)
    call cursor(l,c)
    return success
endfunction

" Function: s:CanSexyCommentLines(topline, bottomline) {{{2
" Return: 1 if the given lines can be commented sexually, 0 otherwise
function s:CanSexyCommentLines(topline, bottomline)
    " see if the selected regions have any sexy comments
    let currentLine = a:topline
    while(currentLine <= a:bottomline)
        if s:IsInSexyComment(currentLine)
            return 0
        endif
        let currentLine = currentLine + 1
    endwhile
    return 1
endfunction
" Function: s:CanToggleCommentLine(forceNested, line) {{{2
"This function is used to determine whether the given line can be toggle commented.
"It returns 1 if it can be and 0 otherwise
"
" Args:
"   -lineNum: the line num of the line to check for commentability
function s:CanToggleCommentLine(forceNested, lineNum)
    let theLine = getline(a:lineNum)
    if (s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)) && !a:forceNested
        return 0
    endif

    " make sure we don't comment lines that are just spaces or tabs or empty.
    if theLine =~ "^[ \t]*$"
        return 0
    endif

    "if the line is part of a sexy comment then just flag it...
    if s:IsInSexyComment(a:lineNum)
        return 0
    endif

    return 1
endfunction

" Function: s:ConvertLeadingSpacesToTabs(line) {{{2
" This function takes a line and converts all leading tabs on that line into
" spaces
"
" Args:
"   -line: the line whose leading tabs will be converted
function s:ConvertLeadingSpacesToTabs(line)
    let toReturn  = a:line
    while toReturn =~ '^\t*' . s:TabSpace() . '\(.*\)$'
        let toReturn = substitute(toReturn, '^\(\t*\)' . s:TabSpace() . '\(.*\)$'  ,  '\1\t\2' , "")
    endwhile

    return toReturn
endfunction


" Function: s:ConvertLeadingTabsToSpaces(line) {{{2
" This function takes a line and converts all leading spaces on that line into
" tabs
"
" Args:
"   -line: the line whose leading spaces will be converted
function s:ConvertLeadingTabsToSpaces(line)
    let toReturn  = a:line
    while toReturn =~ '^\( *\)\t'
        let toReturn = substitute(toReturn, '^\( *\)\t',  '\1' . s:TabSpace() , "")
    endwhile

    return toReturn
endfunction

" Function: s:ConvertLeadingWhiteSpace(line) {{{2
" Converts the leading white space to tabs/spaces depending on &ts
"
" Args:
"   -line: the line to convert
function s:ConvertLeadingWhiteSpace(line)
    let toReturn = a:line
    while toReturn =~ '^ *\t'
        let toReturn = substitute(toReturn, '^ *\zs\t\ze', s:TabSpace(), "g")
    endwhile

    if !&expandtab
        let toReturn = s:ConvertLeadingSpacesToTabs(toReturn)
    endif

    return toReturn
endfunction


" Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2
" This function counts the number of substrings contained in another string.
" These substrings are only counted if they are not escaped with escChar
" Args:
"   -str: the string to look for searchstr in
"   -searchstr: the substring to search for in str
"   -escChar: the escape character which, when preceding an instance of
"    searchstr, will cause it not to be counted
function s:CountNonESCedOccurances(str, searchstr, escChar)
    "get the index of the first occurrence of searchstr
    let indx = stridx(a:str, a:searchstr)

    "if there is an instance of searchstr in str process it
    if indx != -1
        "get the remainder of str after this instance of searchstr is removed
        let lensearchstr = strlen(a:searchstr)
        let strLeft = strpart(a:str, indx+lensearchstr)

        "if this instance of searchstr is not escaped, add one to the count
        "and recurse. If it is escaped, just recurse
        if !s:IsEscaped(a:str, indx, a:escChar)
            return 1 + s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        else
            return s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
        endif
    endif
endfunction
" Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2
" Returns 1 if the given block of lines has a delimiter (a:delim) in it
" Args:
"   -delim: the comment delimiter to check the block for
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveDelim(delim, top, bottom)
    let currentLine = a:top
    while currentLine < a:bottom
        let theline = getline(currentLine)
        if s:FindDelimiterIndex(a:delim, theline) != -1
            return 1
        endif
        let currentLine = currentLine + 1
    endwhile
    return 0
endfunction

" Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2
" Returns 1 if the given block has a >= 1 multipart delimiter in it
" Args:
"   -top: the top line number of the block
"   -bottom: the bottom line number of the block
function s:DoesBlockHaveMultipartDelim(top, bottom)
    if s:HasMultipartDelims()
        if s:Multipart()
            return s:DoesBlockHaveDelim(s:Left(), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right(), a:top, a:bottom)
        else
            return s:DoesBlockHaveDelim(s:Left({'alt': 1}), a:top, a:bottom) || s:DoesBlockHaveDelim(s:Right({'alt': 1}), a:top, a:bottom)
        endif
    endif
    return 0
endfunction


" Function: s:Esc(str) {{{2
" Escapes all the tricky chars in the given string
function s:Esc(str)
    let charsToEsc = '*/\."&$+'
    return escape(a:str, charsToEsc)
endfunction

" Function: s:FindDelimiterIndex(delimiter, line) {{{2
" This function is used to get the string index of the input comment delimiter
" on the input line. If no valid comment delimiter is found in the line then
" -1 is returned
" Args:
"   -delimiter: the delimiter we are looking to find the index of
"   -line: the line we are looking for delimiter on
function s:FindDelimiterIndex(delimiter, line)

    "make sure the delimiter isnt empty otherwise we go into an infinite loop.
    if a:delimiter == ""
        return -1
    endif


    let l:delimiter = a:delimiter
    let lenDel = strlen(l:delimiter)

    "get the index of the first occurrence of the delimiter
    let delIndx = stridx(a:line, l:delimiter)

    "keep looping thru the line till we either find a real comment delimiter
    "or run off the EOL
    while delIndx != -1

        "if we are not off the EOL get the str before the possible delimiter
        "in question and check if it really is a delimiter. If it is, return
        "its position
        if delIndx != -1
            if s:IsDelimValid(l:delimiter, delIndx, a:line)
                return delIndx
            endif
        endif

        "we have not yet found a real comment delimiter so move past the
        "current one we are lookin at
        let restOfLine = strpart(a:line, delIndx + lenDel)
        let distToNextDelim = stridx(restOfLine , l:delimiter)

        "if distToNextDelim is -1 then there is no more potential delimiters
        "on the line so set delIndx to -1. Otherwise, move along the line by
        "distToNextDelim
        if distToNextDelim == -1
            let delIndx = -1
        else
            let delIndx = delIndx + lenDel + distToNextDelim
        endif
    endwhile

    "there is no comment delimiter on this line
    return -1
endfunction

" Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2
" This function takes in a line number and tests whether this line number is
" the top/bottom/middle line of a sexy comment. If it is then the top/bottom
" lines of the sexy comment are returned
" Args:
"   -lineNum: the line number that is to be tested whether it is the
"    top/bottom/middle line of a sexy com
" Returns:
"   A string that has the top/bottom lines of the sexy comment encoded in it.
"   The format is 'topline,bottomline'. If a:lineNum turns out not to be the
"   top/bottom/middle of a sexy comment then -1 is returned
function s:FindBoundingLinesOfSexyCom(lineNum)

    "find which delimiters to look for as the start/end delims of the comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left({'esc': 1})
        let right = s:Right({'esc': 1})
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1, 'esc': 1})
        let right = s:Right({'alt': 1, 'esc': 1})
    else
        return []
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "initialise the top/bottom line numbers of the sexy comment to -1
    let top = -1
    let bottom = -1

    let currentLine = a:lineNum
    while top == -1 || bottom == -1
        let theLine = getline(currentLine)

        "check if the current line is the top of the sexy comment
        if currentLine <= a:lineNum && theLine =~ '^[ \t]*' . left && theLine !~ '.*' . right && currentLine < s:NumLinesInBuf()
            let top = currentLine
            let currentLine = a:lineNum

        "check if the current line is the bottom of the sexy comment
        elseif theLine =~ '^[ \t]*' . right && theLine !~ '.*' . left && currentLine > 1
            let bottom = currentLine

        "the right delimiter is on the same line as the last sexyComMarker
        elseif theLine =~ '^[ \t]*' . sexyComMarker . '.*' . right
            let bottom = currentLine

        "we have not found the top or bottom line so we assume currentLine is an
        "intermediate line and look to prove otherwise
        else

            "if the line doesnt start with a sexyComMarker then it is not a sexy
            "comment
            if theLine !~ '^[ \t]*' . sexyComMarker
                return []
            endif

        endif

        "if top is -1 then we havent found the top yet so keep looking up
        if top == -1
            let currentLine = currentLine - 1
        "if we have found the top line then go down looking for the bottom
        else
            let currentLine = currentLine + 1
        endif

    endwhile

    return [top, bottom]
endfunction


" Function: s:GetSexyComMarker() {{{2
" Returns the sexy comment marker for the current filetype.
"
" C style sexy comments are assumed if possible. If not then the sexy comment
" marker is the last char of the delimiter pair that has both left and right
" delims and has the longest left delim
"
" Args:
"   -space: specifies whether the marker is to have a space string after it
"    (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the marker are to be ESCed
function s:GetSexyComMarker(space, esc)
    let sexyComMarker = b:NERDSexyComMarker

    "if there is no hardcoded marker then we find one
    if sexyComMarker == ''

        "if the filetype has c style comments then use standard c sexy
        "comments
        if s:HasCStyleComments()
            let sexyComMarker = '*'
        else
            "find a comment marker by getting the longest available left delim
            "(that has a corresponding right delim) and taking the last char
            let lenLeft = strlen(s:Left())
            let lenLeftAlt = strlen(s:Left({'alt': 1}))
            let left = ''
            let right = ''
            if s:Multipart() && lenLeft >= lenLeftAlt
                let left = s:Left()
            elseif s:AltMultipart()
                let left = s:Left({'alt': 1})
            else
                return -1
            endif

            "get the last char of left
            let sexyComMarker = strpart(left, strlen(left)-1)
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let sexyComMarker = sexyComMarker . s:spaceStr
    endif

    if a:esc
        let sexyComMarker = s:Esc(sexyComMarker)
    endif

    return sexyComMarker
endfunction

" Function: s:GetSexyComLeft(space, esc) {{{2
" Returns the left delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible
" Args:
"   -space: specifies if the delim has a space string on the end
"   (the space string will only be added if NERDSpaceDelims is set)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComLeft(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let left = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let left = '/*'
    else
        "grab the longest left delim that has a right
        if s:Multipart() && lenLeft >= lenLeftAlt
            let left = s:Left()
        elseif s:AltMultipart()
            let left = s:Left({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let left = left . s:spaceStr
    endif

    if a:esc
        let left = s:Esc(left)
    endif

    return left
endfunction

" Function: s:GetSexyComRight(space, esc) {{{2
" Returns the right delimiter for sexy comments for this filetype or -1 if
" there is none. C style sexy comments are used if possible.
" Args:
"   -space: specifies if the delim has a space string on the start
"   (the space string will only be added if NERDSpaceDelims
"   is specified for the current filetype)
"   -esc: specifies whether the tricky chars in the string are ESCed
function s:GetSexyComRight(space, esc)
    let lenLeft = strlen(s:Left())
    let lenLeftAlt = strlen(s:Left({'alt': 1}))
    let right = ''

    "assume c style sexy comments if possible
    if s:HasCStyleComments()
        let right = '*/'
    else
        "grab the right delim that pairs with the longest left delim
        if s:Multipart() && lenLeft >= lenLeftAlt
            let right = s:Right()
        elseif s:AltMultipart()
            let right = s:Right({'alt': 1})
        else
            return -1
        endif
    endif

    if a:space && g:NERDSpaceDelims
        let right = s:spaceStr . right
    endif

    if a:esc
        let right = s:Esc(right)
    endif

    return right
endfunction

" Function: s:HasMultipartDelims() {{{2
" Returns 1 iff the current filetype has at least one set of multipart delims
function s:HasMultipartDelims()
    return s:Multipart() || s:AltMultipart()
endfunction

" Function: s:HasLeadingTabs(...) {{{2
" Returns 1 if any of the given strings have leading tabs
function s:HasLeadingTabs(...)
    for s in a:000
        if s =~ '^\t.*'
            return 1
        end
    endfor
    return 0
endfunction
" Function: s:HasCStyleComments() {{{2
" Returns 1 iff the current filetype has c style comment delimiters
function s:HasCStyleComments()
    return (s:Left() == '/*' && s:Right() == '*/') || (s:Left({'alt': 1}) == '/*' && s:Right({'alt': 1}) == '*/')
endfunction

" Function: s:IsCommentedNormOrSexy(lineNum) {{{2
"This function is used to determine whether the given line is commented with
"either set of delimiters or if it is part of a sexy comment
"
" Args:
"   -lineNum: the line number of the line to check
function s:IsCommentedNormOrSexy(lineNum)
    let theLine = getline(a:lineNum)

    "if the line is commented normally return 1
    if s:IsCommented(s:Left(), s:Right(), theLine) || s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine)
        return 1
    endif

    "if the line is part of a sexy comment return 1
    if s:IsInSexyComment(a:lineNum)
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommented(left, right, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters
"
" Args:
"   -line: the line that to check if commented
"   -left/right: the left and right delimiters to check for
function s:IsCommented(left, right, line)
    "if the line isnt commented return true
    if s:FindDelimiterIndex(a:left, a:line) != -1 && (s:FindDelimiterIndex(a:right, a:line) != -1 || !s:Multipart())
        return 1
    endif
    return 0
endfunction

" Function: s:IsCommentedFromStartOfLine(left, line) {{{2
"This function is used to determine whether the given line is commented with
"the given delimiters at the start of the line i.e the left delimiter is the
"first thing on the line (apart from spaces\tabs)
"
" Args:
"   -line: the line that to check if commented
"   -left: the left delimiter to check for
function s:IsCommentedFromStartOfLine(left, line)
    let theLine = s:ConvertLeadingTabsToSpaces(a:line)
    let numSpaces = strlen(substitute(theLine, '^\( *\).*$', '\1', ''))
    let delimIndx = s:FindDelimiterIndex(a:left, theLine)
    return delimIndx == numSpaces
endfunction

" Function: s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line) {{{2
" Finds the type of the outtermost delims on the line
"
" Args:
"   -line: the line that to check if the outtermost comments on it are
"    left/right
"   -left/right: the left and right delimiters to check for
"   -leftAlt/rightAlt: the left and right alternative delimiters to check for
"
" Returns:
"   0 if the line is not commented with either set of delims
"   1 if the line is commented with the left/right delim set
"   2 if the line is commented with the leftAlt/rightAlt delim set
function s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line)
    "get the first positions of the left delims and the last positions of the
    "right delims
    let indxLeft = s:FindDelimiterIndex(a:left, a:line)
    let indxLeftAlt = s:FindDelimiterIndex(a:leftAlt, a:line)
    let indxRight = s:LastIndexOfDelim(a:right, a:line)
    let indxRightAlt = s:LastIndexOfDelim(a:rightAlt, a:line)

    "check if the line has a left delim before a leftAlt delim
    if (indxLeft <= indxLeftAlt || indxLeftAlt == -1) && indxLeft != -1
        "check if the line has a right delim after any rightAlt delim
        if (indxRight > indxRightAlt && indxRight > indxLeft) || !s:Multipart()
            return 1
        endif

        "check if the line has a leftAlt delim before a left delim
    elseif (indxLeftAlt <= indxLeft || indxLeft == -1) && indxLeftAlt != -1
        "check if the line has a rightAlt delim after any right delim
        if (indxRightAlt > indxRight && indxRightAlt > indxLeftAlt) || !s:AltMultipart()
            return 2
        endif
    else
        return 0
    endif

    return 0

endfunction


" Function: s:IsDelimValid(delimiter, delIndx, line) {{{2
" This function is responsible for determining whether a given instance of a
" comment delimiter is a real delimiter or not. For example, in java the
" // string is a comment delimiter but in the line:
"               System.out.println("//");
" it does not count as a comment delimiter. This function is responsible for
" distinguishing between such cases. It does so by applying a set of
" heuristics that are not fool proof but should work most of the time.
"
" Args:
"   -delimiter: the delimiter we are validating
"   -delIndx: the position of delimiter in line
"   -line: the line that delimiter occurs in
"
" Returns:
" 0 if the given delimiter is not a real delimiter (as far as we can tell) ,
" 1 otherwise
function s:IsDelimValid(delimiter, delIndx, line)
    "get the delimiter without the escchars
    let l:delimiter = a:delimiter

    "get the strings before and after the delimiter
    let preComStr = strpart(a:line, 0, a:delIndx)
    let postComStr = strpart(a:line, a:delIndx+strlen(delimiter))

    "to check if the delimiter is real, make sure it isnt preceded by
    "an odd number of quotes and followed by the same (which would indicate
    "that it is part of a string and therefore is not a comment)
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, '"', "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "'", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "'", "\\"))
        return 0
    endif
    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "`", "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "`", "\\"))
        return 0
    endif


    "if the comment delimiter is escaped, assume it isnt a real delimiter
    if s:IsEscaped(a:line, a:delIndx, "\\")
        return 0
    endif

    "vim comments are so fuckin stupid!! Why the hell do they have comment
    "delimiters that are used elsewhere in the syntax?!?! We need to check
    "some conditions especially for vim
    if &filetype == "vim"
        if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\"))
            return 0
        endif

        "if the delimiter is on the very first char of the line or is the
        "first non-tab/space char on the line then it is a valid comment delimiter
        if a:delIndx == 0 || a:line =~ "^[ \t]\\{" . a:delIndx . "\\}\".*$"
            return 1
        endif

        let numLeftParen =s:CountNonESCedOccurances(preComStr, "(", "\\")
        let numRightParen =s:CountNonESCedOccurances(preComStr, ")", "\\")

        "if the quote is inside brackets then assume it isnt a comment
        if numLeftParen > numRightParen
            return 0
        endif

        "if the line has an even num of unescaped "'s then we can assume that
        "any given " is not a comment delimiter
        if s:IsNumEven(s:CountNonESCedOccurances(a:line, "\"", "\\"))
            return 0
        endif
    endif

    return 1

endfunction

" Function: s:IsNumEven(num) {{{2
" A small function the returns 1 if the input number is even and 0 otherwise
" Args:
"   -num: the number to check
function s:IsNumEven(num)
    return (a:num % 2) == 0
endfunction

" Function: s:IsEscaped(str, indx, escChar) {{{2
" This function takes a string, an index into that string and an esc char and
" returns 1 if the char at the index is escaped (i.e if it is preceded by an
" odd number of esc chars)
" Args:
"   -str: the string to check
"   -indx: the index into str that we want to check
"   -escChar: the escape char the char at indx may be ESCed with
function s:IsEscaped(str, indx, escChar)
    "initialise numEscChars to 0 and look at the char before indx
    let numEscChars = 0
    let curIndx = a:indx-1

    "keep going back thru str until we either reach the start of the str or
    "run out of esc chars
    while curIndx >= 0 && strpart(a:str, curIndx, 1) == a:escChar

        "we have found another esc char so add one to the count and move left
        "one char
        let numEscChars  = numEscChars + 1
        let curIndx = curIndx - 1

    endwhile

    "if there is an odd num of esc chars directly before the char at indx then
    "the char at indx is escaped
    return !s:IsNumEven(numEscChars)
endfunction

" Function: s:IsInSexyComment(line) {{{2
" returns 1 if the given line number is part of a sexy comment
function s:IsInSexyComment(line)
    return !empty(s:FindBoundingLinesOfSexyCom(a:line))
endfunction

" Function: s:IsSexyComment(topline, bottomline) {{{2
" This function takes in 2 line numbers and returns 1 if the lines between and
" including the given line numbers are a sexy comment. It returns 0 otherwise.
" Args:
"   -topline: the line that the possible sexy comment starts on
"   -bottomline: the line that the possible sexy comment stops on
function s:IsSexyComment(topline, bottomline)

    "get the delim set that would be used for a sexy comment
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    else
        return 0
    endif

    "swap the top and bottom line numbers around if need be
    let topline = a:topline
    let bottomline = a:bottomline
    if bottomline < topline
        topline = bottomline
        bottomline = a:topline
    endif

    "if there is < 2 lines in the comment it cannot be sexy
    if (bottomline - topline) <= 0
        return 0
    endif

    "if the top line doesnt begin with a left delim then the comment isnt sexy
    if getline(a:topline) !~ '^[ \t]*' . left
        return 0
    endif

    "if there is a right delim on the top line then this isnt a sexy comment
    if s:FindDelimiterIndex(right, getline(a:topline)) != -1
        return 0
    endif

    "if there is a left delim on the bottom line then this isnt a sexy comment
    if s:FindDelimiterIndex(left, getline(a:bottomline)) != -1
        return 0
    endif

    "if the bottom line doesnt begin with a right delim then the comment isnt
    "sexy
    if getline(a:bottomline) !~ '^.*' . right . '$'
        return 0
    endif

    let sexyComMarker = s:GetSexyComMarker(0, 1)

    "check each of the intermediate lines to make sure they start with a
    "sexyComMarker
    let currentLine = a:topline+1
    while currentLine < a:bottomline
        let theLine = getline(currentLine)

        if theLine !~ '^[ \t]*' . sexyComMarker
            return 0
        endif

        "if there is a right delim in an intermediate line then the block isnt
        "a sexy comment
        if s:FindDelimiterIndex(right, theLine) != -1
            return 0
        endif

        let currentLine = currentLine + 1
    endwhile

    "we have not found anything to suggest that this isnt a sexy comment so
    return 1

endfunction

" Function: s:LastIndexOfDelim(delim, str) {{{2
" This function takes a string and a delimiter and returns the last index of
" that delimiter in string
" Args:
"   -delim: the delimiter to look for
"   -str: the string to look for delim in
function s:LastIndexOfDelim(delim, str)
    let delim = a:delim
    let lenDelim = strlen(delim)

    "set index to the first occurrence of delim. If there is no occurrence then
    "bail
    let indx = s:FindDelimiterIndex(delim, a:str)
    if indx == -1
        return -1
    endif

    "keep moving to the next instance of delim in str till there is none left
    while 1

        "search for the next delim after the previous one
        let searchStr = strpart(a:str, indx+lenDelim)
        let indx2 = s:FindDelimiterIndex(delim, searchStr)

        "if we find a delim update indx to record the position of it, if we
        "dont find another delim then indx is the last one so break out of
        "this loop
        if indx2 != -1
            let indx = indx + indx2 + lenDelim
        else
            break
        endif
    endwhile

    return indx

endfunction

" Function: s:Left(...) {{{2
" returns left delimiter data
function s:Left(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['leftAlt'] : b:NERDCommenterDelims['left'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = delim . s:spaceStr
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the left most
" char (that is not a space or a tab) on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)

    " declare the left most index as an extreme value
    let leftMostIndx = 1000

    " go thru the block line by line updating leftMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and if it is allowed to be commented, or is not
        " commented, check it
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'
            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))
                " convert spaces to tabs and get the number of leading spaces for
                " this line and update leftMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let leadSpaceOfLine = strlen( substitute(theLine, '\(^[ \t]*\).*$','\1','') )
                if leadSpaceOfLine < leftMostIndx
                    let leftMostIndx = leadSpaceOfLine
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    if leftMostIndx == 1000
        return 0
    else
        return leftMostIndx
    endif
endfunction

" Function: s:Multipart() {{{2
" returns 1 if the current delims are multipart
function s:Multipart()
    return s:Right() != ''
endfunction

" Function: s:NerdEcho(msg, typeOfMsg) {{{2
" Args:
"   -msg: the message to echo
"   -typeOfMsg: 0 = warning message
"               1 = normal message
function s:NerdEcho(msg, typeOfMsg)
    if a:typeOfMsg == 0
        echohl WarningMsg
        echom 'NERDCommenter:' . a:msg
        echohl None
    elseif a:typeOfMsg == 1
        echom 'NERDCommenter:' . a:msg
    endif
endfunction

" Function: s:NumberOfLeadingTabs(s) {{{2
" returns the number of leading tabs in the given string
function s:NumberOfLeadingTabs(s)
    return strlen(substitute(a:s, '^\(\t*\).*$', '\1', ""))
endfunction

" Function: s:NumLinesInBuf() {{{2
" Returns the number of lines in the current buffer
function s:NumLinesInBuf()
    return line('$')
endfunction

" Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2
" This function takes in a string, 2 delimiters in that string and 2 strings
" to replace these delimiters with.
"
" Args:
"   -toReplace1: the first delimiter to replace
"   -toReplace2: the second delimiter to replace
"   -replacor1: the string to replace toReplace1 with
"   -replacor2: the string to replace toReplace2 with
"   -str: the string that the delimiters to be replaced are in
function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)
    let line = s:ReplaceLeftMostDelim(a:toReplace1, a:replacor1, a:str)
    let line = s:ReplaceRightMostDelim(a:toReplace2, a:replacor2, line)
    return line
endfunction

" Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the left most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
function s:ReplaceLeftMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    "get the left most occurrence of toReplace
    let indxToReplace = s:FindDelimiterIndex(toReplace, a:str)

    "if there IS an occurrence of toReplace in str then replace it and return
    "the resulting string
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
        return line
    endif

    return a:str
endfunction

" Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2
" This function takes a string and a delimiter and replaces the right most
" occurrence of this delimiter in the string with a given string
"
" Args:
"   -toReplace: the delimiter in str that is to be replaced
"   -replacor: the string to replace toReplace with
"   -str: the string that contains toReplace
"
function s:ReplaceRightMostDelim(toReplace, replacor, str)
    let toReplace = a:toReplace
    let replacor = a:replacor
    let lenToReplace = strlen(toReplace)

    "get the index of the last delim in str
    let indxToReplace = s:LastIndexOfDelim(toReplace, a:str)

    "if there IS a delimiter in str, replace it and return the result
    let line = a:str
    if indxToReplace != -1
        let line = strpart(a:str, 0, indxToReplace) . replacor . strpart(a:str, indxToReplace+strlen(toReplace))
    endif
    return line
endfunction

"FUNCTION: s:RestoreScreenState() {{{2
"
"Sets the screen state back to what it was when s:SaveScreenState was last
"called.
"
function s:RestoreScreenState()
    if !exists("t:NERDComOldTopLine") || !exists("t:NERDComOldPos")
        throw 'NERDCommenter exception: cannot restore screen'
    endif

    call cursor(t:NERDComOldTopLine, 0)
    normal! zt
    call setpos(".", t:NERDComOldPos)
endfunction

" Function: s:Right(...) {{{2
" returns right delimiter data
function s:Right(...)
    let params = a:0 ? a:1 : {}

    let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['rightAlt'] : b:NERDCommenterDelims['right'] 

    if delim == ''
        return ''
    endif

    if has_key(params, 'space') && g:NERDSpaceDelims
        let delim = s:spaceStr . delim
    endif

    if has_key(params, 'esc')
        let delim = s:Esc(delim)
    endif

    return delim
endfunction

" Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2
" This function takes in 2 line numbers and returns the index of the right most
" char on all of these lines.
" Args:
"   -countCommentedLines: 1 if lines that are commented are to be checked as
"    well. 0 otherwise
"   -countEmptyLines: 1 if empty lines are to be counted in the search
"   -topline: the top line to be checked
"   -bottomline: the bottom line to be checked
function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)
    let rightMostIndx = -1

    " go thru the block line by line updating rightMostIndx
    let currentLine = a:topline
    while currentLine <= a:bottomline

        " get the next line and see if it is commentable, otherwise it doesnt
        " count
        let theLine = getline(currentLine)
        if a:countEmptyLines || theLine !~ '^[ \t]*$'

            if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))

                " update rightMostIndx if need be
                let theLine = s:ConvertLeadingTabsToSpaces(theLine)
                let lineLen = strlen(theLine)
                if lineLen > rightMostIndx
                    let rightMostIndx = lineLen
                endif
            endif
        endif

        " move on to the next line
        let currentLine = currentLine + 1
    endwhile

    return rightMostIndx
endfunction

"FUNCTION: s:SaveScreenState() {{{2
"Saves the current cursor position in the current buffer and the window
"scroll position
function s:SaveScreenState()
    let t:NERDComOldPos = getpos(".")
    let t:NERDComOldTopLine = line("w0")
endfunction

" Function: s:SwapOutterMultiPartDelimsForPlaceHolders(line) {{{2
" This function takes a line and swaps the outter most multi-part delims for
" place holders
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterMultiPartDelimsForPlaceHolders(line)
    " find out if the line is commented using normal delims and/or
    " alternate ones
    let isCommented = s:IsCommented(s:Left(), s:Right(), a:line)
    let isCommentedAlt = s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), a:line)

    let line2 = a:line

    "if the line is commented and there is a right delimiter, replace
    "the delims with place-holders
    if isCommented && s:Multipart()
        let line2 = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, a:line)

    "similarly if the line is commented with the alternative
    "delimiters
    elseif isCommentedAlt && s:AltMultipart()
        let line2 = s:ReplaceDelims(s:Left({'alt': 1}), s:Right({'alt': 1}), g:NERDLPlace, g:NERDRPlace, a:line)
    endif

    return line2
endfunction

" Function: s:SwapOutterPlaceHoldersForMultiPartDelims(line) {{{2
" This function takes a line and swaps the outtermost place holders for
" multi-part delims
" Args:
"   -line: the line to swap the delims in
"
function s:SwapOutterPlaceHoldersForMultiPartDelims(line)
    let left = ''
    let right = ''
    if s:Multipart()
        let left = s:Left()
        let right = s:Right()
    elseif s:AltMultipart()
        let left = s:Left({'alt': 1})
        let right = s:Right({'alt': 1})
    endif

    let line = s:ReplaceDelims(g:NERDLPlace, g:NERDRPlace, left, right, a:line)
    return line
endfunction
" Function: s:TabbedCol(line, col) {{{2
" Gets the col number for given line and existing col number. The new col
" number is the col number when all leading spaces are converted to tabs
" Args:
"   -line:the line to get the rel col for
"   -col: the abs col
function s:TabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineSpacesToTabs = substitute(lineTruncated, s:TabSpace(), '\t', 'g')
    return strlen(lineSpacesToTabs)
endfunction
"FUNCTION: s:TabSpace() {{{2
"returns a string of spaces equal in length to &tabstop
function s:TabSpace()
    let tabSpace = ""
    let spacesPerTab = &tabstop
    while spacesPerTab > 0
        let tabSpace = tabSpace . " "
        let spacesPerTab = spacesPerTab - 1
    endwhile
    return tabSpace
endfunction

" Function: s:UnEsc(str, escChar) {{{2
" This function removes all the escape chars from a string
" Args:
"   -str: the string to remove esc chars from
"   -escChar: the escape char to be removed
function s:UnEsc(str, escChar)
    return substitute(a:str, a:escChar, "", "g")
endfunction

" Function: s:UntabbedCol(line, col) {{{2
" Takes a line and a col and returns the absolute column of col taking into
" account that a tab is worth 3 or 4 (or whatever) spaces.
" Args:
"   -line:the line to get the abs col for
"   -col: the col that doesnt take into account tabs
function s:UntabbedCol(line, col)
    let lineTruncated = strpart(a:line, 0, a:col)
    let lineTabsToSpaces = substitute(lineTruncated, '\t', s:TabSpace(), 'g')
    return strlen(lineTabsToSpaces)
endfunction
" Section: Comment mapping and menu item setup {{{1
" ===========================================================================

" Create menu items for the specified modes.  If a:combo is not empty, then
" also define mappings and show a:combo in the menu items.
function! s:CreateMaps(modes, target, desc, combo)
    " Build up a map command like
    " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'
    let plug = '<plug>NERDCommenter' . a:target
    let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'
    let plug_end = '", "' . a:target . '")<cr>'
    " Build up a menu command like
    " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'
    let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'],
                \ g:NERDMenuMode, '')
    let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
    if strlen(a:combo)
        let leader = exists('g:mapleader') ? g:mapleader : '\'
        let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
    endif
    let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
    " Execute the commands built above for each requested mode.
    for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')
        if strlen(a:combo)
            execute mode . plug_start . mode . plug_end
            if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                execute mode . 'map <leader>' . a:combo . ' ' . plug
            endif
        endif
        " Check if the user wants the menu to be displayed.
        if g:NERDMenuMode != 0
            execute mode . menu_command
        endif
    endfor
endfunction
call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')
call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
call s:CreateMaps('n',  'Append',     'Append', 'cA')
call s:CreateMaps('',   ':',          '-Sep-', '')
call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
call s:CreateMaps('',   ':',          '-Sep2-', '')
call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
call s:CreateMaps('',   ':',          '-Sep3-', '')
call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')

inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>

" switch to/from alternative delimiters (does not use wrapper function)
nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>
" vim: set foldmethod=marker :
zhimakaimen:/bundle/nerdcommenter/plugin/NERD_commenter.vim
*~
*.swp
tags
zhimakaimen:/bundle/nerdtree/.gitignore
The NERD Tree
=============

Intro
-----

The NERD tree allows you to explore your filesystem and to open files and
directories. It presents the filesystem to you in the form of a tree which you
manipulate with the keyboard and/or mouse. It also allows you to perform
simple filesystem operations.

The following features and functionality are provided by the NERD tree:

  * Files and directories are displayed in a hierarchical tree structure
  * Different highlighting is provided for the following types of nodes:
    * files
    * directories
    * sym-links
    * windows .lnk files
    * read-only files
    * executable files
  * Many (customisable) mappings are provided to manipulate the tree:
    * Mappings to open/close/explore directory nodes
    * Mappings to open files in new/existing windows/tabs
    * Mappings to change the current root of the tree
    * Mappings to navigate around the tree
    * ...
  * Directories and files can be bookmarked.
  * Most NERD tree navigation can also be done with the mouse
  * Filtering of tree content (can be toggled at runtime)
    * custom file filters to prevent e.g. vim backup files being displayed
    * optional displaying of hidden files (. files)
    * files can be "turned off" so that only directories are displayed
  * The position and size of the NERD tree window can be customised
  * The order in which the nodes in the tree are listed can be customised.
  * A model of your filesystem is created/maintained as you explore it. This
    has several advantages:
    * All filesystem information is cached and is only re-read on demand
    * If you revisit a part of the tree that you left earlier in your
      session, the directory nodes will be opened/closed as you left them
  * The script remembers the cursor position and window position in the NERD
    tree so you can toggle it off (or just close the tree window) and then
    reopen it (with NERDTreeToggle) the NERD tree window will appear exactly
    as you left it
  * You can have a separate NERD tree for each tab, share trees across tabs,
    or a mix of both.
  * By default the script overrides the default file browser (netrw), so if
    you :edit a directory a (slightly modified) NERD tree will appear in the
    current window
  * A programmable menu system is provided (simulates right clicking on a node)
    * one default menu plugin is provided to perform basic filesystem
      operations (create/delete/move/copy files/directories)
  * There's an API for adding your own keymappings

Installation
------------

[pathogen.vim](https://github.com/tpope/vim-pathogen) is the recommended way to install nerdtree.

    cd ~/.vim/bundle
    git clone https://github.com/scrooloose/nerdtree.git

Then reload vim, run `:helptags`, and check out `:help NERD_tree.txt`.


Faq
---

__Q. Can I have the nerdtree on every tab automatically?__

A. Nope. If this is something you want then chances are you aren't using tabs
   and buffers as they were intended to be used. Read this
   http://stackoverflow.com/questions/102384/using-vims-tabs-like-buffers

   If you are interested in this behaviour then consider [vim-nerdtree-tabs](https://github.com/jistr/vim-nerdtree-tabs)

__Q. How can I open a NERDTree automatically when vim starts up?__

A. Stick this in your vimrc: `autocmd vimenter * NERDTree`

__Q. How can I open a NERDTree automatically when vim starts up if no files were specified?__

A. Stick this in your vimrc `autocmd vimenter * if !argc() | NERDTree | endif`

__Q. How can I map a specific key or shortcut to open NERDTree?__

A. Stick this in your vimrc to open NERDTree with `Ctrl+n` (you can set whatever key you want): `map <C-n> :NERDTreeToggle<CR>`

__Q. How can I close vim if the only window left open is a NERDTree?__

A. Stick this in your vimrc:

   `autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif`


Changelog
---------

4.2.0 (2011-12-28)

 * Add NERDTreeDirArrows option to make the UI use pretty arrow chars instead of the old +~| chars to define the tree structure (sickill)
 * shift the syntax highlighting out into its own syntax file (gnap) * add some mac specific options to the filesystem menu - for macvim only (andersonfreitas)
 * Add NERDTreeMinimalUI option to remove some non functional parts of the nerdtree ui (camthompson)
 * tweak the behaviour of :NERDTreeFind - see :help :NERDTreeFind for the new behaviour (benjamingeiger)
 * if no name is given to :Bookmark, make it default to the name of the target file/dir (minyoung)
 * use 'file' completion when doing copying, create, and move operations (EvanDotPro)
 * lots of misc bug fixes (paddyoloughlin, sdewald, camthompson, Vitaly Bogdanov, AndrewRadev, mathias, scottstvnsn, kml, wycats, me RAWR!)

zhimakaimen:/bundle/nerdtree/README.markdown
" ============================================================================
" File:        NERD_tree.vim
" Description: vim global plugin that provides a nice tree explorer
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 28 December, 2011
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
"
" SECTION: Script init stuff {{{1
"============================================================
if exists("loaded_nerd_tree")
    finish
endif
if v:version < 700
    echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
    finish
endif
let loaded_nerd_tree = 1

"for line continuation - i.e dont want C in &cpo
let s:old_cpo = &cpo
set cpo&vim

"Function: s:initVariable() function {{{2
"This function is used to initialise a given variable to a given value. The
"variable is only initialised if it does not exist prior
"
"Args:
"var: the name of the var to be initialised
"value: the value to initialise var to
"
"Returns:
"1 if the var is set, 0 otherwise
function! s:initVariable(var, value)
    if !exists(a:var)
        exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
        return 1
    endif
    return 0
endfunction

"SECTION: Init variable calls and other random constants {{{2
call s:initVariable("g:NERDChristmasTree", 1)
call s:initVariable("g:NERDTreeAutoCenter", 1)
call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
call s:initVariable("g:NERDTreeChDirMode", 0)
call s:initVariable("g:NERDTreeMinimalUI", 0)
if !exists("g:NERDTreeIgnore")
    let g:NERDTreeIgnore = ['\~$']
endif
call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
call s:initVariable("g:NERDTreeHighlightCursorline", 1)
call s:initVariable("g:NERDTreeHijackNetrw", 1)
call s:initVariable("g:NERDTreeMouseMode", 1)
call s:initVariable("g:NERDTreeNotificationThreshold", 100)
call s:initVariable("g:NERDTreeQuitOnOpen", 0)
call s:initVariable("g:NERDTreeShowBookmarks", 0)
call s:initVariable("g:NERDTreeShowFiles", 1)
call s:initVariable("g:NERDTreeShowHidden", 0)
call s:initVariable("g:NERDTreeShowLineNumbers", 0)
call s:initVariable("g:NERDTreeSortDirs", 1)
call s:initVariable("g:NERDTreeDirArrows", !nerdtree#runningWindows())
call s:initVariable("g:NERDTreeCasadeOpenSingleChildDir", 1)

if !exists("g:NERDTreeSortOrder")
    let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
else
    "if there isnt a * in the sort sequence then add one
    if count(g:NERDTreeSortOrder, '*') < 1
        call add(g:NERDTreeSortOrder, '*')
    endif
endif

if !exists('g:NERDTreeStatusline')

    "the exists() crap here is a hack to stop vim spazzing out when
    "loading a session that was created with an open nerd tree. It spazzes
    "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)
    let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"

endif
call s:initVariable("g:NERDTreeWinPos", "left")
call s:initVariable("g:NERDTreeWinSize", 31)

"init the shell commands that will be used to copy nodes, and remove dir trees
"
"Note: the space after the command is important
if nerdtree#runningWindows()
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
else
    call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
    call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
endif


"SECTION: Init variable calls for key mappings {{{2
call s:initVariable("g:NERDTreeMapActivateNode", "o")
call s:initVariable("g:NERDTreeMapChangeRoot", "C")
call s:initVariable("g:NERDTreeMapChdir", "cd")
call s:initVariable("g:NERDTreeMapCloseChildren", "X")
call s:initVariable("g:NERDTreeMapCloseDir", "x")
call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
call s:initVariable("g:NERDTreeMapMenu", "m")
call s:initVariable("g:NERDTreeMapHelp", "?")
call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
call s:initVariable("g:NERDTreeMapJumpParent", "p")
call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
call s:initVariable("g:NERDTreeMapJumpRoot", "P")
call s:initVariable("g:NERDTreeMapOpenExpl", "e")
call s:initVariable("g:NERDTreeMapOpenInTab", "t")
call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
call s:initVariable("g:NERDTreeMapOpenSplit", "i")
call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
call s:initVariable("g:NERDTreeMapQuit", "q")
call s:initVariable("g:NERDTreeMapRefresh", "r")
call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
call s:initVariable("g:NERDTreeMapToggleFiles", "F")
call s:initVariable("g:NERDTreeMapToggleFilters", "f")
call s:initVariable("g:NERDTreeMapToggleHidden", "I")
call s:initVariable("g:NERDTreeMapToggleZoom", "A")
call s:initVariable("g:NERDTreeMapUpdir", "u")
call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
call s:initVariable("g:NERDTreeMapCWD", "CD")

"SECTION: Load class files{{{2
call nerdtree#loadClassFiles()

" SECTION: Commands {{{1
"============================================================
"init the command that users start the nerd tree with
command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.TogglePrimary('<args>')
command! -n=0 -bar NERDTreeClose :call nerdtree#closeTreeIfOpen()
command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreatePrimary('<args>')
command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
command! -n=0 -bar NERDTreeFind call nerdtree#findAndRevealPath()
command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
" SECTION: Auto commands {{{1
"============================================================
augroup NERDTree
    "Save the cursor position whenever we close the nerd tree
    exec "autocmd BufWinLeave ". g:NERDTreeCreator.BufNamePrefix() ."* call nerdtree#saveScreenState()"

    "disallow insert mode in the NERDTree
    exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
augroup END

if g:NERDTreeHijackNetrw
    augroup NERDTreeHijackNetrw
        autocmd VimEnter * silent! autocmd! FileExplorer
        au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
    augroup END
endif

" SECTION: Public API {{{1
"============================================================
function! NERDTreeAddMenuItem(options)
    call g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddMenuSeparator(...)
    let opts = a:0 ? a:1 : {}
    call g:NERDTreeMenuItem.CreateSeparator(opts)
endfunction

function! NERDTreeAddSubmenu(options)
    return g:NERDTreeMenuItem.Create(a:options)
endfunction

function! NERDTreeAddKeyMap(options)
    call g:NERDTreeKeyMap.Create(a:options)
endfunction

function! NERDTreeRender()
    call nerdtree#renderView()
endfunction

function! NERDTreeFocus()
    if nerdtree#isTreeOpen()
        call nerdtree#putCursorInTreeWin()
    else
        call g:NERDTreeCreator.TogglePrimary("")
    endif
endfunction

function! NERDTreeCWD()
    call NERDTreeFocus()
    call nerdtree#chRootCwd()
endfunction
" SECTION: Post Source Actions {{{1
call nerdtree#postSourceActions()

"reset &cpo back to users setting
let &cpo = s:old_cpo

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/plugin/NERD_tree.vim
let s:tree_up_dir_line = '.. (up a dir)'
"NERDTreeFlags are syntax items that should be invisible, but give clues as to
"how things should be highlighted
syn match NERDTreeFlag #\~#
syn match NERDTreeFlag #\[RO\]#

"highlighting for the .. (up dir) line at the top of the tree
execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"

"highlighting for the ~/+ symbols for the directory nodes
syn match NERDTreeClosable #\~\<#
syn match NERDTreeClosable #\~\.#
syn match NERDTreeOpenable #+\<#
syn match NERDTreeOpenable #+\.#he=e-1

"highlighting for the tree structural parts
syn match NERDTreePart #|#
syn match NERDTreePart #`#
syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart

"quickhelp syntax elements
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#hs=s+2,he=e-1
syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#hs=s+2,he=e-1
syn match NERDTreeHelpTitle #" .*\~#hs=s+2,he=e-1 contains=NERDTreeFlag
syn match NERDTreeToggleOn #".*(on)#hs=e-2,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeToggleOff #".*(off)#hs=e-3,he=e-1 contains=NERDTreeHelpKey
syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeFlag,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand

"highlighting for readonly files
syn match NERDTreeRO #.*\[RO\]#hs=s+2 contains=NERDTreeFlag,NERDTreeBookmark,NERDTreePart,NERDTreePartFile

"highlighting for sym links
syn match NERDTreeLink #[^-| `].* -> # contains=NERDTreeBookmark,NERDTreeOpenable,NERDTreeClosable,NERDTreeDirSlash

"highlighing for directory nodes and file nodes
syn match NERDTreeDirSlash #/#
syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeDirSlash,NERDTreeOpenable,NERDTreeClosable
syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark
syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
syn match NERDTreeCWD #^[</].*$#

"highlighting for bookmarks
syn match NERDTreeBookmark # {.*}#hs=s+1

"highlighting for the bookmarks table
syn match NERDTreeBookmarksLeader #^>#
syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader

if exists("g:NERDChristmasTree") && g:NERDChristmasTree
    hi def link NERDTreePart Special
    hi def link NERDTreePartFile Type
    hi def link NERDTreeFile Normal
    hi def link NERDTreeExecFile Title
    hi def link NERDTreeDirSlash Identifier
    hi def link NERDTreeClosable Type
else
    hi def link NERDTreePart Normal
    hi def link NERDTreePartFile Normal
    hi def link NERDTreeFile Normal
    hi def link NERDTreeClosable Title
endif

hi def link NERDTreeBookmarksHeader statement
hi def link NERDTreeBookmarksLeader ignore
hi def link NERDTreeBookmarkName Identifier
hi def link NERDTreeBookmark normal

hi def link NERDTreeHelp String
hi def link NERDTreeHelpKey Identifier
hi def link NERDTreeHelpCommand Identifier
hi def link NERDTreeHelpTitle Macro
hi def link NERDTreeToggleOn Question
hi def link NERDTreeToggleOff WarningMsg

hi def link NERDTreeDir Directory
hi def link NERDTreeUp Directory
hi def link NERDTreeCWD Statement
hi def link NERDTreeLink Macro
hi def link NERDTreeOpenable Title
hi def link NERDTreeFlag ignore
hi def link NERDTreeRO WarningMsg
hi def link NERDTreeBookmark Statement

hi def link NERDTreeCurrentNode Search
zhimakaimen:/bundle/nerdtree/syntax/nerdtree.vim
"CLASS: Creator
"Creates primary/secondary/mirror nerdtree windows. Sets up all the window and
"buffer options and key mappings etc.
"============================================================
let s:Creator = {}
let g:NERDTreeCreator = s:Creator

"FUNCTION: s:Creator._bindMappings() {{{1
function! s:Creator._bindMappings()
    "make <cr> do the same as the default 'o' mapping
    exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"

    call g:NERDTreeKeyMap.BindAll()

    command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
    command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
    command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: s:Creator._broadcastInitEvent() {{{1
function! s:Creator._broadcastInitEvent()
    silent doautocmd User NERDTreeInit
endfunction

" FUNCTION: s:Creator.BufNamePrefix() {{{2
function! s:Creator.BufNamePrefix()
    return 'NERD_tree_'
endfunction

"FUNCTION: s:Creator.CreatePrimary(a:name) {{{1
function! s:Creator.CreatePrimary(name)
    let creator = s:Creator.New()
    call creator.createPrimary(a:name)
endfunction

"FUNCTION: s:Creator.createPrimary(a:name) {{{1
"name: the name of a bookmark or a directory
function! s:Creator.createPrimary(name)
    let path = self._pathForString(a:name)

    "if instructed to, then change the vim CWD to the dir the NERDTree is
    "inited in
    if g:NERDTreeChDirMode != 0
        call path.changeToDir()
    endif

    if nerdtree#treeExistsForTab()
        if nerdtree#isTreeOpen()
            call nerdtree#closeTree()
        endif
        unlet t:NERDTreeBufName
    endif

    let newRoot = g:NERDTreeDirNode.New(path)
    call newRoot.open()

    call self._createTreeWin()
    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    let b:NERDTreeRoot = newRoot
    let b:NERDTreeType = "primary"

    call nerdtree#renderView()
    call b:NERDTreeRoot.putCursorHere(0, 0)

    call self._broadcastInitEvent()
endfunction

"FUNCTION: s:Creator.CreateSecondary(dir) {{{1
function! s:Creator.CreateSecondary(dir)
    let creator = s:Creator.New()
    call creator.createSecondary(a:dir)
endfunction

"FUNCTION: s:Creator.createSecondary(dir) {{{1
function! s:Creator.createSecondary(dir)
    try
        let path = g:NERDTreePath.New(a:dir)
    catch /^NERDTree.InvalidArgumentsError/
        call nerdtree#echo("Invalid directory name:" . a:name)
        return
    endtry

    "we want the directory buffer to disappear when we do the :edit below
    setlocal bufhidden=wipe

    let previousBuf = expand("#")

    "we need a unique name for each secondary tree buffer to ensure they are
    "all independent
    exec "silent edit " . self._nextBufferName()

    let b:NERDTreePreviousBuf = bufnr(previousBuf)

    let b:NERDTreeRoot = g:NERDTreeDirNode.New(path)
    call b:NERDTreeRoot.open()

    call self._setCommonBufOptions()
    let b:NERDTreeType = "secondary"

    call nerdtree#renderView()

    call self._broadcastInitEvent()
endfunction

" FUNCTION: s:Creator.CreateMirror() {{{1
function! s:Creator.CreateMirror()
    let creator = s:Creator.New()
    call creator.createMirror()
endfunction

" FUNCTION: s:Creator.createMirror() {{{1
function! s:Creator.createMirror()
    "get the names off all the nerd tree buffers
    let treeBufNames = []
    for i in range(1, tabpagenr("$"))
        let nextName = nerdtree#tabpagevar(i, 'NERDTreeBufName')
        if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
            call add(treeBufNames, nextName)
        endif
    endfor
    let treeBufNames = nerdtree#unique(treeBufNames)

    "map the option names (that the user will be prompted with) to the nerd
    "tree buffer names
    let options = {}
    let i = 0
    while i < len(treeBufNames)
        let bufName = treeBufNames[i]
        let treeRoot = getbufvar(bufName, "NERDTreeRoot")
        let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
        let i = i + 1
    endwhile

    "work out which tree to mirror, if there is more than 1 then ask the user
    let bufferName = ''
    if len(keys(options)) > 1
        let choices = ["Choose a tree to mirror"]
        let choices = extend(choices, sort(keys(options)))
        let choice = inputlist(choices)
        if choice < 1 || choice > len(options) || choice ==# ''
            return
        endif

        let bufferName = options[sort(keys(options))[choice-1]]
    elseif len(keys(options)) ==# 1
        let bufferName = values(options)[0]
    else
        call nerdtree#echo("No trees to mirror")
        return
    endif

    if nerdtree#treeExistsForTab() && nerdtree#isTreeOpen()
        call nerdtree#closeTree()
    endif

    let t:NERDTreeBufName = bufferName
    call self._createTreeWin()
    exec 'buffer ' .  bufferName
    if !&hidden
        call nerdtree#renderView()
    endif
endfunction

"FUNCTION: s:Creator._createTreeWin() {{{1
"Inits the NERD tree window. ie. opens it, sizes it, sets all the local
"options etc
function! s:Creator._createTreeWin()
    "create the nerd tree window
    let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    let splitSize = g:NERDTreeWinSize

    if !exists('t:NERDTreeBufName')
        let t:NERDTreeBufName = self._nextBufferName()
        silent! exec splitLocation . 'vertical ' . splitSize . ' new'
        silent! exec "edit " . t:NERDTreeBufName
    else
        silent! exec splitLocation . 'vertical ' . splitSize . ' split'
        silent! exec "buffer " . t:NERDTreeBufName
    endif

    setlocal winfixwidth
    call self._setCommonBufOptions()
endfunction

"FUNCTION: s:Creator.New() {{{1
function! s:Creator.New()
    let newCreator = copy(self)
    return newCreator
endfunction

" FUNCTION: s:Creator._nextBufferName() {{{2
" returns the buffer name for the next nerd tree
function! s:Creator._nextBufferName()
    let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    return name
endfunction

" FUNCTION: s:Creator._nextBufferNumber() {{{2
" the number to add to the nerd tree buffer name to make the buf name unique
function! s:Creator._nextBufferNumber()
    if !exists("s:Creator._NextBufNum")
        let s:Creator._NextBufNum = 1
    else
        let s:Creator._NextBufNum += 1
    endif

    return s:Creator._NextBufNum
endfunction

"FUNCTION: s:Creator._pathForString(str) {{{1
"find a bookmark or adirectory for the given string
function! s:Creator._pathForString(str)
    let path = {}
    if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
        let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    else
        let dir = a:str ==# '' ? getcwd() : a:str

        "hack to get an absolute path if a relative path is given
        if dir =~# '^\.'
            let dir = getcwd() . g:NERDTreePath.Slash() . dir
        endif
        let dir = g:NERDTreePath.Resolve(dir)

        try
            let path = g:NERDTreePath.New(dir)
        catch /^NERDTree.InvalidArgumentsError/
            call nerdtree#echo("No bookmark or directory found for: " . a:str)
            return
        endtry
    endif
    if !path.isDirectory
        let path = path.getParent()
    endif

    return path
endfunction

"FUNCTION: s:Creator._setCommonBufOptions() {{{1
function! s:Creator._setCommonBufOptions()
    "throwaway buffer options
    setlocal noswapfile
    setlocal buftype=nofile
    setlocal bufhidden=hide
    setlocal nowrap
    setlocal foldcolumn=0
    setlocal foldmethod=manual
    setlocal nofoldenable
    setlocal nobuflisted
    setlocal nospell
    if g:NERDTreeShowLineNumbers
        setlocal nu
    else
        setlocal nonu
        if v:version >= 703
            setlocal nornu
        endif
    endif

    iabc <buffer>

    if g:NERDTreeHighlightCursorline
        setlocal cursorline
    endif

    call self._setupStatusline()

    let b:treeShowHelp = 0
    let b:NERDTreeIgnoreEnabled = 1
    let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    setfiletype nerdtree
    call self._bindMappings()
endfunction

"FUNCTION: s:Creator._setupStatusline() {{{1
function! s:Creator._setupStatusline()
    if g:NERDTreeStatusline != -1
        let &l:statusline = g:NERDTreeStatusline
    endif
endfunction

"FUNCTION: s:Creator.TogglePrimary(dir) {{{1
function! s:Creator.TogglePrimary(dir)
    let creator = s:Creator.New()
    call creator.togglePrimary(a:dir)
endfunction

"FUNCTION: s:Creator.togglePrimary(dir) {{{1
"Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
"closed it is restored or initialized (if it doesnt exist)
"
"Args:
"dir: the full path for the root node (is only used if the NERD tree is being
"initialized.
function! s:Creator.togglePrimary(dir)
    if nerdtree#treeExistsForTab()
        if !nerdtree#isTreeOpen()
            call self._createTreeWin()
            if !&hidden
                call nerdtree#renderView()
            endif
            call nerdtree#restoreScreenState()
        else
            call nerdtree#closeTree()
        endif
    else
        call self.createPrimary(a:dir)
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/creator.vim
"CLASS: KeyMap
"============================================================
let s:KeyMap = {}
let g:NERDTreeKeyMap = s:KeyMap

"FUNCTION: KeyMap.All() {{{1
function! s:KeyMap.All()
    if !exists("s:keyMaps")
        let s:keyMaps = []
    endif
    return s:keyMaps
endfunction

"FUNCTION: KeyMap.FindFor(key, scope) {{{1
function! s:KeyMap.FindFor(key, scope)
    for i in s:KeyMap.All()
         if i.key ==# a:key && i.scope ==# a:scope
            return i
        endif
    endfor
    return {}
endfunction

"FUNCTION: KeyMap.BindAll() {{{1
function! s:KeyMap.BindAll()
    for i in s:KeyMap.All()
        call i.bind()
    endfor
endfunction

"FUNCTION: KeyMap.bind() {{{1
function! s:KeyMap.bind()
    " If the key sequence we're trying to map contains any '<>' notation, we
    " must replace each of the '<' characters with '<lt>' to ensure the string
    " is not translated into its corresponding keycode during the later part
    " of the map command below
    " :he <>
    let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
    if self.key =~# specialNotationRegex
        let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
    else
        let keymapInvokeString = self.key
    endif

    let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "

    exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'
endfunction

"FUNCTION: KeyMap.Remove(key, scope) {{{1
function! s:KeyMap.Remove(key, scope)
    let maps = s:KeyMap.All()
    for i in range(len(maps))
         if maps[i].key ==# a:key && maps[i].scope ==# a:scope
            return remove(maps, i)
        endif
    endfor
endfunction

"FUNCTION: KeyMap.invoke() {{{1
"Call the KeyMaps callback function
function! s:KeyMap.invoke(...)
    let Callback = function(self.callback)
    if a:0
        call Callback(a:1)
    else
        call Callback()
    endif
endfunction

"FUNCTION: KeyMap.Invoke() {{{1
"Find a keymapping for a:key and the current scope invoke it.
"
"Scope is determined as follows:
"   * if the cursor is on a dir node then "DirNode"
"   * if the cursor is on a file node then "FileNode"
"   * if the cursor is on a bookmark then "Bookmark"
"
"If a keymap has the scope of "all" then it will be called if no other keymap
"is found for a:key and the scope.
function! s:KeyMap.Invoke(key)
    let node = g:NERDTreeFileNode.GetSelected()
    if !empty(node)

        "try file node
        if !node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "FileNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try dir node
        if node.path.isDirectory
            let km = s:KeyMap.FindFor(a:key, "DirNode")
            if !empty(km)
                return km.invoke(node)
            endif
        endif

        "try generic node
        let km = s:KeyMap.FindFor(a:key, "Node")
        if !empty(km)
            return km.invoke(node)
        endif

    endif

    "try bookmark
    let bm = g:NERDTreeBookmark.GetSelected()
    if !empty(bm)
        let km = s:KeyMap.FindFor(a:key, "Bookmark")
        if !empty(km)
            return km.invoke(bm)
        endif
    endif

    "try all
    let km = s:KeyMap.FindFor(a:key, "all")
    if !empty(km)
        return km.invoke()
    endif
endfunction

"FUNCTION: KeyMap.Create(options) {{{1
function! s:KeyMap.Create(options)
    let newKeyMap = copy(self)
    let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
    let newKeyMap.key = opts['key']
    let newKeyMap.quickhelpText = opts['quickhelpText']
    let newKeyMap.callback = opts['callback']
    let newKeyMap.scope = opts['scope']

    call s:KeyMap.Add(newKeyMap)
endfunction

"FUNCTION: KeyMap.Add(keymap) {{{1
function! s:KeyMap.Add(keymap)
    call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
    call add(s:KeyMap.All(), a:keymap)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/key_map.vim
"CLASS: MenuController
"============================================================
let s:MenuController = {}
let g:NERDTreeMenuController = s:MenuController

"FUNCTION: MenuController.New(menuItems) {{{1
"create a new menu controller that operates on the given menu items
function! s:MenuController.New(menuItems)
    let newMenuController =  copy(self)
    if a:menuItems[0].isSeparator()
        let newMenuController.menuItems = a:menuItems[1:-1]
    else
        let newMenuController.menuItems = a:menuItems
    endif
    return newMenuController
endfunction

"FUNCTION: MenuController.showMenu() {{{1
"start the main loop of the menu and get the user to choose/execute a menu
"item
function! s:MenuController.showMenu()
    call self._saveOptions()

    try
        let self.selection = 0

        let done = 0
        while !done
            redraw!
            call self._echoPrompt()
            let key = nr2char(getchar())
            let done = self._handleKeypress(key)
        endwhile
    finally
        call self._restoreOptions()
    endtry

    if self.selection != -1
        let m = self._current()
        call m.execute()
    endif
endfunction

"FUNCTION: MenuController._echoPrompt() {{{1
function! s:MenuController._echoPrompt()
    echo "NERDTree Menu. Use j/k/enter and the shortcuts indicated"
    echo "=========================================================="

    for i in range(0, len(self.menuItems)-1)
        if self.selection == i
            echo "> " . self.menuItems[i].text
        else
            echo "  " . self.menuItems[i].text
        endif
    endfor
endfunction

"FUNCTION: MenuController._current(key) {{{1
"get the MenuItem that is currently selected
function! s:MenuController._current()
    return self.menuItems[self.selection]
endfunction

"FUNCTION: MenuController._handleKeypress(key) {{{1
"change the selection (if appropriate) and return 1 if the user has made
"their choice, 0 otherwise
function! s:MenuController._handleKeypress(key)
    if a:key == 'j'
        call self._cursorDown()
    elseif a:key == 'k'
        call self._cursorUp()
    elseif a:key == nr2char(27) "escape
        let self.selection = -1
        return 1
    elseif a:key == "\r" || a:key == "\n" "enter and ctrl-j
        return 1
    else
        let index = self._nextIndexFor(a:key)
        if index != -1
            let self.selection = index
            if len(self._allIndexesFor(a:key)) == 1
                return 1
            endif
        endif
    endif

    return 0
endfunction

"FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
"get indexes to all menu items with the given shortcut
function! s:MenuController._allIndexesFor(shortcut)
    let toReturn = []

    for i in range(0, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            call add(toReturn, i)
        endif
    endfor

    return toReturn
endfunction

"FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
"get the index to the next menu item with the given shortcut, starts from the
"current cursor location and wraps around to the top again if need be
function! s:MenuController._nextIndexFor(shortcut)
    for i in range(self.selection+1, len(self.menuItems)-1)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    for i in range(0, self.selection)
        if self.menuItems[i].shortcut == a:shortcut
            return i
        endif
    endfor

    return -1
endfunction

"FUNCTION: MenuController._setCmdheight() {{{1
"sets &cmdheight to whatever is needed to display the menu
function! s:MenuController._setCmdheight()
    let &cmdheight = len(self.menuItems) + 3
endfunction

"FUNCTION: MenuController._saveOptions() {{{1
"set any vim options that are required to make the menu work (saving their old
"values)
function! s:MenuController._saveOptions()
    let self._oldLazyredraw = &lazyredraw
    let self._oldCmdheight = &cmdheight
    set nolazyredraw
    call self._setCmdheight()
endfunction

"FUNCTION: MenuController._restoreOptions() {{{1
"restore the options we saved in _saveOptions()
function! s:MenuController._restoreOptions()
    let &cmdheight = self._oldCmdheight
    let &lazyredraw = self._oldLazyredraw
endfunction

"FUNCTION: MenuController._cursorDown() {{{1
"move the cursor to the next menu item, skipping separators
function! s:MenuController._cursorDown()
    let done = 0
    while !done
        if self.selection < len(self.menuItems)-1
            let self.selection += 1
        else
            let self.selection = 0
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

"FUNCTION: MenuController._cursorUp() {{{1
"move the cursor to the previous menu item, skipping separators
function! s:MenuController._cursorUp()
    let done = 0
    while !done
        if self.selection > 0
            let self.selection -= 1
        else
            let self.selection = len(self.menuItems)-1
        endif

        if !self._current().isSeparator()
            let done = 1
        endif
    endwhile
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/menu_controller.vim
"CLASS: Bookmark
"============================================================
let s:Bookmark = {}
let g:NERDTreeBookmark = s:Bookmark

" FUNCTION: Bookmark.activate() {{{1
function! s:Bookmark.activate(...)
    call self.open(a:0 ? a:1 : {})
endfunction

" FUNCTION: Bookmark.AddBookmark(name, path) {{{1
" Class method to add a new bookmark to the list, if a previous bookmark exists
" with the same name, just update the path for that bookmark
function! s:Bookmark.AddBookmark(name, path)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            let i.path = a:path
            return
        endif
    endfor
    call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
    call s:Bookmark.Sort()
endfunction

" FUNCTION: Bookmark.Bookmarks()   {{{1
" Class method to get all bookmarks. Lazily initializes the bookmarks global
" variable
function! s:Bookmark.Bookmarks()
    if !exists("g:NERDTreeBookmarks")
        let g:NERDTreeBookmarks = []
    endif
    return g:NERDTreeBookmarks
endfunction

" FUNCTION: Bookmark.BookmarkExistsFor(name)   {{{1
" class method that returns 1 if a bookmark with the given name is found, 0
" otherwise
function! s:Bookmark.BookmarkExistsFor(name)
    try
        call s:Bookmark.BookmarkFor(a:name)
        return 1
    catch /^NERDTree.BookmarkNotFoundError/
        return 0
    endtry
endfunction

" FUNCTION: Bookmark.BookmarkFor(name)   {{{1
" Class method to get the bookmark that has the given name. {} is return if no
" bookmark is found
function! s:Bookmark.BookmarkFor(name)
    for i in s:Bookmark.Bookmarks()
        if i.name ==# a:name
            return i
        endif
    endfor
    throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'
endfunction

" FUNCTION: Bookmark.BookmarkNames()   {{{1
" Class method to return an array of all bookmark names
function! s:Bookmark.BookmarkNames()
    let names = []
    for i in s:Bookmark.Bookmarks()
        call add(names, i.name)
    endfor
    return names
endfunction

" FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
" Class method to read all bookmarks from the bookmarks file initialize
" bookmark objects for each one.
"
" Args:
" silent - dont echo an error msg if invalid bookmarks are found
function! s:Bookmark.CacheBookmarks(silent)
    if filereadable(g:NERDTreeBookmarksFile)
        let g:NERDTreeBookmarks = []
        let g:NERDTreeInvalidBookmarks = []
        let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
        let invalidBookmarksFound = 0
        for i in bookmarkStrings

            "ignore blank lines
            if i != ''

                let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')

                try
                    let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                    call add(g:NERDTreeBookmarks, bookmark)
                catch /^NERDTree.InvalidArgumentsError/
                    call add(g:NERDTreeInvalidBookmarks, i)
                    let invalidBookmarksFound += 1
                endtry
            endif
        endfor
        if invalidBookmarksFound
            call s:Bookmark.Write()
            if !a:silent
                call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
            endif
        endif
        call s:Bookmark.Sort()
    endif
endfunction

" FUNCTION: Bookmark.compareTo(otherbookmark) {{{1
" Compare these two bookmarks for sorting purposes
function! s:Bookmark.compareTo(otherbookmark)
    return a:otherbookmark.name < self.name
endfunction
" FUNCTION: Bookmark.ClearAll() {{{1
" Class method to delete all bookmarks.
function! s:Bookmark.ClearAll()
    for i in s:Bookmark.Bookmarks()
        call i.delete()
    endfor
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.delete() {{{1
" Delete this bookmark. If the node for this bookmark is under the current
" root, then recache bookmarks for its Path object
function! s:Bookmark.delete()
    let node = {}
    try
        let node = self.getNode(1)
    catch /^NERDTree.BookmarkedNodeNotFoundError/
    endtry
    call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
    if !empty(node)
        call node.path.cacheDisplayString()
    endif
    call s:Bookmark.Write()
endfunction

" FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{1
" Gets the treenode for this bookmark
"
" Args:
" searchFromAbsoluteRoot: specifies whether we should search from the current
" tree root, or the highest cached node
function! s:Bookmark.getNode(searchFromAbsoluteRoot)
    let searchRoot = a:searchFromAbsoluteRoot ? g:NERDTreeDirNode.AbsoluteTreeRoot() : b:NERDTreeRoot
    let targetNode = searchRoot.findNode(self.path)
    if empty(targetNode)
        throw "NERDTree.BookmarkedNodeNotFoundError: no node was found for bookmark: " . self.name
    endif
    return targetNode
endfunction

" FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{1
" Class method that finds the bookmark with the given name and returns the
" treenode for it.
function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    return bookmark.getNode(a:searchFromAbsoluteRoot)
endfunction

" FUNCTION: Bookmark.GetSelected() {{{1
" returns the Bookmark the cursor is over, or {}
function! s:Bookmark.GetSelected()
    let line = getline(".")
    let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    if name != line
        try
            return s:Bookmark.BookmarkFor(name)
        catch /^NERDTree.BookmarkNotFoundError/
            return {}
        endtry
    endif
    return {}
endfunction

" FUNCTION: Bookmark.InvalidBookmarks()   {{{1
" Class method to get all invalid bookmark strings read from the bookmarks
" file
function! s:Bookmark.InvalidBookmarks()
    if !exists("g:NERDTreeInvalidBookmarks")
        let g:NERDTreeInvalidBookmarks = []
    endif
    return g:NERDTreeInvalidBookmarks
endfunction

" FUNCTION: Bookmark.mustExist() {{{1
function! s:Bookmark.mustExist()
    if !self.path.exists()
        call s:Bookmark.CacheBookmarks(1)
        throw "NERDTree.BookmarkPointsToInvalidLocationError: the bookmark \"".
            \ self.name ."\" points to a non existing location: \"". self.path.str()
    endif
endfunction

" FUNCTION: Bookmark.New(name, path) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.New(name, path)
    if a:name =~# ' '
        throw "NERDTree.IllegalBookmarkNameError: illegal name:" . a:name
    endif

    let newBookmark = copy(self)
    let newBookmark.name = a:name
    let newBookmark.path = a:path
    return newBookmark
endfunction

" FUNCTION: Bookmark.open([options]) {{{1
"Args:
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' (vertical split), 'h'
"           (horizontal split), 't' (new tab) or 'p' (previous window).
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
"
function! s:Bookmark.open(...)
    let opts = a:0 ? a:1 : {}

    if self.path.isDirectory && !has_key(opts, 'where')
        call self.toRoot()
    else
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    endif
endfunction

" FUNCTION: Bookmark.openInNewTab(options) {{{1
" Create a new bookmark object with the given name and path object
function! s:Bookmark.openInNewTab(options)
    call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
    call self.open(a:options)
endfunction

" FUNCTION: Bookmark.setPath(path)   {{{1
" makes this bookmark point to the given path
function! s:Bookmark.setPath(path)
    let self.path = a:path
endfunction

" FUNCTION: Bookmark.Sort()   {{{1
" Class method that sorts all bookmarks
function! s:Bookmark.Sort()
    let CompareFunc = function("nerdtree#compareBookmarks")
    call sort(s:Bookmark.Bookmarks(), CompareFunc)
endfunction

" FUNCTION: Bookmark.str()   {{{1
" Get the string that should be rendered in the view for this bookmark
function! s:Bookmark.str()
    let pathStrMaxLen = winwidth(nerdtree#getTreeWinNum()) - 4 - len(self.name)
    if &nu
        let pathStrMaxLen = pathStrMaxLen - &numberwidth
    endif

    let pathStr = self.path.str({'format': 'UI'})
    if len(pathStr) > pathStrMaxLen
        let pathStr = '<' . strpart(pathStr, len(pathStr) - pathStrMaxLen)
    endif
    return '>' . self.name . ' ' . pathStr
endfunction

" FUNCTION: Bookmark.toRoot() {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.toRoot()
    if self.validate()
        try
            let targetNode = self.getNode(1)
        catch /^NERDTree.BookmarkedNodeNotFoundError/
            let targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path)
        endtry
        call targetNode.makeRoot()
        call nerdtree#renderView()
        call targetNode.putCursorHere(0, 0)
    endif
endfunction

" FUNCTION: Bookmark.ToRoot(name) {{{1
" Make the node for this bookmark the new tree root
function! s:Bookmark.ToRoot(name)
    let bookmark = s:Bookmark.BookmarkFor(a:name)
    call bookmark.toRoot()
endfunction

" FUNCTION: Bookmark.validate() {{{1
function! s:Bookmark.validate()
    if self.path.exists()
        return 1
    else
        call s:Bookmark.CacheBookmarks(1)
        call nerdtree#renderView()
        call nerdtree#echo(self.name . "now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.")
        return 0
    endif
endfunction

" FUNCTION: Bookmark.Write()   {{{1
" Class method to write all bookmarks to the bookmarks file
function! s:Bookmark.Write()
    let bookmarkStrings = []
    for i in s:Bookmark.Bookmarks()
        call add(bookmarkStrings, i.name . ' ' . i.path.str())
    endfor

    "add a blank line before the invalid ones
    call add(bookmarkStrings, "")

    for j in s:Bookmark.InvalidBookmarks()
        call add(bookmarkStrings, j)
    endfor
    call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/bookmark.vim
"we need to use this number many times for sorting... so we calculate it only
"once here
let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')

"CLASS: Path
"============================================================
let s:Path = {}
let g:NERDTreePath = s:Path

"FUNCTION: Path.AbsolutePathFor(str) {{{1
function! s:Path.AbsolutePathFor(str)
    let prependCWD = 0
    if nerdtree#runningWindows()
        let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
    else
        let prependCWD = a:str !~# '^/'
    endif

    let toReturn = a:str
    if prependCWD
        let toReturn = getcwd() . s:Path.Slash() . a:str
    endif

    return toReturn
endfunction

"FUNCTION: Path.bookmarkNames() {{{1
function! s:Path.bookmarkNames()
    if !exists("self._bookmarkNames")
        call self.cacheDisplayString()
    endif
    return self._bookmarkNames
endfunction

"FUNCTION: Path.cacheDisplayString() {{{1
function! s:Path.cacheDisplayString()
    let self.cachedDisplayString = self.getLastPathComponent(1)

    if self.isExecutable
        let self.cachedDisplayString = self.cachedDisplayString . '*'
    endif

    let self._bookmarkNames = []
    for i in g:NERDTreeBookmark.Bookmarks()
        if i.path.equals(self)
            call add(self._bookmarkNames, i.name)
        endif
    endfor
    if !empty(self._bookmarkNames)
        let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
    endif

    if self.isSymLink
        let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
    endif

    if self.isReadOnly
        let self.cachedDisplayString .=  ' [RO]'
    endif
endfunction

"FUNCTION: Path.changeToDir() {{{1
function! s:Path.changeToDir()
    let dir = self.str({'format': 'Cd'})
    if self.isDirectory ==# 0
        let dir = self.getParent().str({'format': 'Cd'})
    endif

    try
        execute "cd " . dir
        call nerdtree#echo("CWD is now: " . getcwd())
    catch
        throw "NERDTree.PathChangeError: cannot change CWD to " . dir
    endtry
endfunction

"FUNCTION: Path.compareTo() {{{1
"
"Compares this Path to the given path and returns 0 if they are equal, -1 if
"this Path is "less than" the given path, or 1 if it is "greater".
"
"Args:
"path: the path object to compare this to
"
"Return:
"1, -1 or 0
function! s:Path.compareTo(path)
    let thisPath = self.getLastPathComponent(1)
    let thatPath = a:path.getLastPathComponent(1)

    "if the paths are the same then clearly we return 0
    if thisPath ==# thatPath
        return 0
    endif

    let thisSS = self.getSortOrderIndex()
    let thatSS = a:path.getSortOrderIndex()

    "compare the sort sequences, if they are different then the return
    "value is easy
    if thisSS < thatSS
        return -1
    elseif thisSS > thatSS
        return 1
    else
        "if the sort sequences are the same then compare the paths
        "alphabetically
        let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
        if pathCompare
            return -1
        else
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.Create(fullpath) {{{1
"
"Factory method.
"
"Creates a path object with the given path. The path is also created on the
"filesystem. If the path already exists, a NERDTree.Path.Exists exception is
"thrown. If any other errors occur, a NERDTree.Path exception is thrown.
"
"Args:
"fullpath: the full filesystem path to the file/dir to create
function! s:Path.Create(fullpath)
    "bail if the a:fullpath already exists
    if isdirectory(a:fullpath) || filereadable(a:fullpath)
        throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
    endif

    try

        "if it ends with a slash, assume its a dir create it
        if a:fullpath =~# '\(\\\|\/\)$'
            "whack the trailing slash off the end if it exists
            let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')

            call mkdir(fullpath, 'p')

        "assume its a file and create
        else
            call writefile([], a:fullpath)
        endif
    catch
        throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
    endtry

    return s:Path.New(a:fullpath)
endfunction

"FUNCTION: Path.copy(dest) {{{1
"
"Copies the file/dir represented by this Path to the given location
"
"Args:
"dest: the location to copy this dir/file to
function! s:Path.copy(dest)
    if !s:Path.CopyingSupported()
        throw "NERDTree.CopyingNotSupportedError: Copying is not supported on this OS"
    endif

    let dest = s:Path.WinToUnixPath(a:dest)

    let cmd = g:NERDTreeCopyCmd . " " . escape(self.str(), nerdtree#escChars()) . " " . escape(dest, nerdtree#escChars())
    let success = system(cmd)
    if success != 0
        throw "NERDTree.CopyError: Could not copy ''". self.str() ."'' to: '" . a:dest . "'"
    endif
endfunction

"FUNCTION: Path.CopyingSupported() {{{1
"
"returns 1 if copying is supported for this OS
function! s:Path.CopyingSupported()
    return exists('g:NERDTreeCopyCmd')
endfunction

"FUNCTION: Path.copyingWillOverwrite(dest) {{{1
"
"returns 1 if copy this path to the given location will cause files to
"overwritten
"
"Args:
"dest: the location this path will be copied to
function! s:Path.copyingWillOverwrite(dest)
    if filereadable(a:dest)
        return 1
    endif

    if isdirectory(a:dest)
        let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
        if filereadable(path)
            return 1
        endif
    endif
endfunction

"FUNCTION: Path.delete() {{{1
"
"Deletes the file represented by this path.
"Deletion of directories is not supported
"
"Throws NERDTree.Path.Deletion exceptions
function! s:Path.delete()
    if self.isDirectory

        let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
        let success = system(cmd)

        if v:shell_error != 0
            throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
        endif
    else
        let success = delete(self.str())
        if success != 0
            throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
        endif
    endif

    "delete all bookmarks for this path
    for i in self.bookmarkNames()
        let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
        call bookmark.delete()
    endfor
endfunction

"FUNCTION: Path.displayString() {{{1
"
"Returns a string that specifies how the path should be represented as a
"string
function! s:Path.displayString()
    if self.cachedDisplayString ==# ""
        call self.cacheDisplayString()
    endif

    return self.cachedDisplayString
endfunction

"FUNCTION: Path.edit() {{{1
function! s:Path.edit()
    exec "edit " . self.str({'format': 'Edit'})
endfunction

"FUNCTION: Path.extractDriveLetter(fullpath) {{{1
"
"If running windows, cache the drive letter for this path
function! s:Path.extractDriveLetter(fullpath)
    if nerdtree#runningWindows()
        if a:fullpath =~ '^\(\\\\\|\/\/\)'
            "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
            let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
            let self.drive = substitute(self.drive, '/', '\', "g")
        else
            let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
        endif
    else
        let self.drive = ''
    endif

endfunction

"FUNCTION: Path.exists() {{{1
"return 1 if this path points to a location that is readable or is a directory
function! s:Path.exists()
    let p = self.str()
    return filereadable(p) || isdirectory(p)
endfunction

"FUNCTION: Path.getDir() {{{1
"
"Returns this path if it is a directory, else this paths parent.
"
"Return:
"a Path object
function! s:Path.getDir()
    if self.isDirectory
        return self
    else
        return self.getParent()
    endif
endfunction

"FUNCTION: Path.getParent() {{{1
"
"Returns a new path object for this paths parent
"
"Return:
"a new Path object
function! s:Path.getParent()
    if nerdtree#runningWindows()
        let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    else
        let path = '/'. join(self.pathSegments[0:-2], '/')
    endif

    return s:Path.New(path)
endfunction

"FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
"
"Gets the last part of this path.
"
"Args:
"dirSlash: if 1 then a trailing slash will be added to the returned value for
"directory nodes.
function! s:Path.getLastPathComponent(dirSlash)
    if empty(self.pathSegments)
        return ''
    endif
    let toReturn = self.pathSegments[-1]
    if a:dirSlash && self.isDirectory
        let toReturn = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path.getSortOrderIndex() {{{1
"returns the index of the pattern in g:NERDTreeSortOrder that this path matches
function! s:Path.getSortOrderIndex()
    let i = 0
    while i < len(g:NERDTreeSortOrder)
        if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
            return i
        endif
        let i = i + 1
    endwhile
    return s:NERDTreeSortStarIndex
endfunction

"FUNCTION: Path.isUnixHiddenFile() {{{1
"check for unix hidden files
function! s:Path.isUnixHiddenFile()
    return self.getLastPathComponent(0) =~# '^\.'
endfunction

"FUNCTION: Path.isUnixHiddenPath() {{{1
"check for unix path with hidden components
function! s:Path.isUnixHiddenPath()
    if self.getLastPathComponent(0) =~# '^\.'
        return 1
    else
        for segment in self.pathSegments
            if segment =~# '^\.'
                return 1
            endif
        endfor
        return 0
    endif
endfunction

"FUNCTION: Path.ignore() {{{1
"returns true if this path should be ignored
function! s:Path.ignore()
    "filter out the user specified paths to ignore
    if b:NERDTreeIgnoreEnabled
        for i in g:NERDTreeIgnore
            if self._ignorePatternMatches(i)
                return 1
            endif
        endfor
    endif

    "dont show hidden files unless instructed to
    if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
        return 1
    endif

    if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
        return 1
    endif

    if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
        return 1
    endif

    return 0
endfunction

"FUNCTION: Path._ignorePatternMatches(pattern) {{{1
"returns true if this path matches the given ignore pattern
function! s:Path._ignorePatternMatches(pattern)
    let pat = a:pattern
    if strpart(pat,len(pat)-7) == '[[dir]]'
        if !self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-7)
    elseif strpart(pat,len(pat)-8) == '[[file]]'
        if self.isDirectory
            return 0
        endif
        let pat = strpart(pat,0, len(pat)-8)
    endif

    return self.getLastPathComponent(0) =~# pat
endfunction

"FUNCTION: Path.isUnder(path) {{{1
"return 1 if this path is somewhere under the given path in the filesystem.
"
"a:path should be a dir
function! s:Path.isUnder(path)
    if a:path.isDirectory == 0
        return 0
    endif

    let this = self.str()
    let that = a:path.str()
    return stridx(this, that . s:Path.Slash()) == 0
endfunction

"FUNCTION: Path.JoinPathStrings(...) {{{1
function! s:Path.JoinPathStrings(...)
    let components = []
    for i in a:000
        let components = extend(components, split(i, '/'))
    endfor
    return '/' . join(components, '/')
endfunction

"FUNCTION: Path.equals() {{{1
"
"Determines whether 2 path objects are "equal".
"They are equal if the paths they represent are the same
"
"Args:
"path: the other path obj to compare this with
function! s:Path.equals(path)
    return self.str() ==# a:path.str()
endfunction

"FUNCTION: Path.New() {{{1
"The Constructor for the Path object
function! s:Path.New(path)
    let newPath = copy(self)

    call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))

    let newPath.cachedDisplayString = ""

    return newPath
endfunction

"FUNCTION: Path.Slash() {{{1
"return the slash to use for the current OS
function! s:Path.Slash()
    return nerdtree#runningWindows() ? '\' : '/'
endfunction

"FUNCTION: Path.Resolve() {{{1
"Invoke the vim resolve() function and return the result
"This is necessary because in some versions of vim resolve() removes trailing
"slashes while in other versions it doesn't.  This always removes the trailing
"slash
function! s:Path.Resolve(path)
    let tmp = resolve(a:path)
    return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
endfunction

"FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
"
"
"Throws NERDTree.Path.InvalidArguments exception.
function! s:Path.readInfoFromDisk(fullpath)
    call self.extractDriveLetter(a:fullpath)

    let fullpath = s:Path.WinToUnixPath(a:fullpath)

    if getftype(fullpath) ==# "fifo"
        throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
    endif

    let self.pathSegments = split(fullpath, '/')

    let self.isReadOnly = 0
    if isdirectory(a:fullpath)
        let self.isDirectory = 1
    elseif filereadable(a:fullpath)
        let self.isDirectory = 0
        let self.isReadOnly = filewritable(a:fullpath) ==# 0
    else
        throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
    endif

    let self.isExecutable = 0
    if !self.isDirectory
        let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    endif

    "grab the last part of the path (minus the trailing slash)
    let lastPathComponent = self.getLastPathComponent(0)

    "get the path to the new node with the parent dir fully resolved
    let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent

    "if  the last part of the path is a symlink then flag it as such
    let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    if self.isSymLink
        let self.symLinkDest = s:Path.Resolve(fullpath)

        "if the link is a dir then slap a / on the end of its dest
        if isdirectory(self.symLinkDest)

            "we always wanna treat MS windows shortcuts as files for
            "simplicity
            if hardPath !~# '\.lnk$'

                let self.symLinkDest = self.symLinkDest . '/'
            endif
        endif
    endif
endfunction

"FUNCTION: Path.refresh() {{{1
function! s:Path.refresh()
    call self.readInfoFromDisk(self.str())
    call self.cacheDisplayString()
endfunction

"FUNCTION: Path.rename() {{{1
"
"Renames this node on the filesystem
function! s:Path.rename(newPath)
    if a:newPath ==# ''
        throw "NERDTree.InvalidArgumentsError: Invalid newPath for renaming = ". a:newPath
    endif

    let success =  rename(self.str(), a:newPath)
    if success != 0
        throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
    endif
    call self.readInfoFromDisk(a:newPath)

    for i in self.bookmarkNames()
        let b = g:NERDTreeBookmark.BookmarkFor(i)
        call b.setPath(copy(self))
    endfor
    call g:NERDTreeBookmark.Write()
endfunction

"FUNCTION: Path.str() {{{1
"
"Returns a string representation of this Path
"
"Takes an optional dictionary param to specify how the output should be
"formatted.
"
"The dict may have the following keys:
"  'format'
"  'escape'
"  'truncateTo'
"
"The 'format' key may have a value of:
"  'Cd' - a string to be used with the :cd command
"  'Edit' - a string to be used with :e :sp :new :tabedit etc
"  'UI' - a string used in the NERD tree UI
"
"The 'escape' key, if specified will cause the output to be escaped with
"shellescape()
"
"The 'truncateTo' key causes the resulting string to be truncated to the value
"'truncateTo' maps to. A '<' char will be prepended.
function! s:Path.str(...)
    let options = a:0 ? a:1 : {}
    let toReturn = ""

    if has_key(options, 'format')
        let format = options['format']
        if has_key(self, '_strFor' . format)
            exec 'let toReturn = self._strFor' . format . '()'
        else
            raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
        endif
    else
        let toReturn = self._str()
    endif

    if nerdtree#has_opt(options, 'escape')
        let toReturn = shellescape(toReturn)
    endif

    if has_key(options, 'truncateTo')
        let limit = options['truncateTo']
        if len(toReturn) > limit
            let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
        endif
    endif

    return toReturn
endfunction

"FUNCTION: Path._strForUI() {{{1
function! s:Path._strForUI()
    let toReturn = '/' . join(self.pathSegments, '/')
    if self.isDirectory && toReturn != '/'
        let toReturn  = toReturn . '/'
    endif
    return toReturn
endfunction

"FUNCTION: Path._strForCd() {{{1
"
" returns a string that can be used with :cd
function! s:Path._strForCd()
    return escape(self.str(), nerdtree#escChars())
endfunction

"FUNCTION: Path._strForEdit() {{{1
"
"Return: the string for this path that is suitable to be used with the :edit
"command
function! s:Path._strForEdit()
    let p = escape(self.str({'format': 'UI'}), nerdtree#escChars())
    let cwd = getcwd() . s:Path.Slash()

    "return a relative path if we can
    let isRelative = 0
    if nerdtree#runningWindows()
        let isRelative = stridx(tolower(p), tolower(cwd)) == 0
    else
        let isRelative = stridx(p, cwd) == 0
    endif

    if isRelative
        let p = strpart(p, strlen(cwd))

        "handle the edge case where the file begins with a + (vim interprets
        "the +foo in `:e +foo` as an option to :edit)
        if p[0] == "+"
            let p = '\' . p
        endif
    endif

    if p ==# ''
        let p = '.'
    endif

    return p
endfunction

"FUNCTION: Path._strForGlob() {{{1
function! s:Path._strForGlob()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    let toReturn = lead . join(self.pathSegments, s:Path.Slash())

    if !nerdtree#runningWindows()
        let toReturn = escape(toReturn, nerdtree#escChars())
    endif
    return toReturn
endfunction

"FUNCTION: Path._str() {{{1
"
"Gets the string path for this path object that is appropriate for the OS.
"EG, in windows c:\foo\bar
"    in *nix  /foo/bar
function! s:Path._str()
    let lead = s:Path.Slash()

    "if we are running windows then slap a drive letter on the front
    if nerdtree#runningWindows()
        let lead = self.drive . '\'
    endif

    return lead . join(self.pathSegments, s:Path.Slash())
endfunction

"FUNCTION: Path.strTrunk() {{{1
"Gets the path without the last segment on the end.
function! s:Path.strTrunk()
    return self.drive . '/' . join(self.pathSegments[0:-2], '/')
endfunction

" FUNCTION: Path.tabnr() {{{1
" return the number of the first tab that is displaying this file
"
" return 0 if no tab was found
function! s:Path.tabnr()
    let str = self.str()
    for t in range(tabpagenr('$'))
        for b in tabpagebuflist(t+1)
            if str == expand('#' . b . ':p')
                return t+1
            endif
        endfor
    endfor
    return 0
endfunction

"FUNCTION: Path.WinToUnixPath(pathstr){{{1
"Takes in a windows path and returns the unix equiv
"
"A class level method
"
"Args:
"pathstr: the windows path to convert
function! s:Path.WinToUnixPath(pathstr)
    if !nerdtree#runningWindows()
        return a:pathstr
    endif

    let toReturn = a:pathstr

    "remove the x:\ of the front
    let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")

    "remove the \\ network share from the front
    let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")

    "convert all \ chars to /
    let toReturn = substitute(toReturn, '\', '/', "g")

    return toReturn
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/path.vim
"CLASS: TreeDirNode
"A subclass of NERDTreeFileNode.
"
"The 'composite' part of the file/dir composite.
"============================================================
let s:TreeDirNode = copy(g:NERDTreeFileNode)
let g:NERDTreeDirNode = s:TreeDirNode

"FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
"class method that returns the highest cached ancestor of the current root
function! s:TreeDirNode.AbsoluteTreeRoot()
    let currentNode = b:NERDTreeRoot
    while currentNode.parent != {}
        let currentNode = currentNode.parent
    endwhile
    return currentNode
endfunction

"FUNCTION: TreeDirNode.activate([options]) {{{1
unlet s:TreeDirNode.activate
function! s:TreeDirNode.activate(...)
    let opts = a:0 ? a:1 : {}
    call self.toggleOpen(opts)
    call nerdtree#renderView()
    call self.putCursorHere(0, 0)
endfunction

"FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
"Adds the given treenode to the list of children for this node
"
"Args:
"-treenode: the node to add
"-inOrder: 1 if the new node should be inserted in sorted order
function! s:TreeDirNode.addChild(treenode, inOrder)
    call add(self.children, a:treenode)
    let a:treenode.parent = self

    if a:inOrder
        call self.sortChildren()
    endif
endfunction

"FUNCTION: TreeDirNode.close() {{{1
"Closes this directory
function! s:TreeDirNode.close()
    let self.isOpen = 0
endfunction

"FUNCTION: TreeDirNode.closeChildren() {{{1
"Closes all the child dir nodes of this node
function! s:TreeDirNode.closeChildren()
    for i in self.children
        if i.path.isDirectory
            call i.close()
            call i.closeChildren()
        endif
    endfor
endfunction

"FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
"Instantiates a new child node for this node with the given path. The new
"nodes parent is set to this node.
"
"Args:
"path: a Path object that this node will represent/contain
"inOrder: 1 if the new node should be inserted in sorted order
"
"Returns:
"the newly created node
function! s:TreeDirNode.createChild(path, inOrder)
    let newTreeNode = g:NERDTreeFileNode.New(a:path)
    call self.addChild(newTreeNode, a:inOrder)
    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.findNode(path) {{{1
"Will find one of the children (recursively) that has the given path
"
"Args:
"path: a path object
unlet s:TreeDirNode.findNode
function! s:TreeDirNode.findNode(path)
    if a:path.equals(self.path)
        return self
    endif
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    if self.path.isDirectory
        for i in self.children
            let retVal = i.findNode(a:path)
            if retVal != {}
                return retVal
            endif
        endfor
    endif
    return {}
endfunction

"FUNCTION: TreeDirNode.getChildCount() {{{1
"Returns the number of children this node has
function! s:TreeDirNode.getChildCount()
    return len(self.children)
endfunction

"FUNCTION: TreeDirNode.getChild(path) {{{1
"Returns child node of this node that has the given path or {} if no such node
"exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChild(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return {}
    endif

    let index = self.getChildIndex(a:path)
    if index ==# -1
        return {}
    else
        return self.children[index]
    endif

endfunction

"FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
"returns the child at the given index
"Args:
"indx: the index to get the child from
"visible: 1 if only the visible children array should be used, 0 if all the
"children should be searched.
function! s:TreeDirNode.getChildByIndex(indx, visible)
    let array_to_search = a:visible? self.getVisibleChildren() : self.children
    if a:indx > len(array_to_search)
        throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
    endif
    return array_to_search[a:indx]
endfunction

"FUNCTION: TreeDirNode.getChildIndex(path) {{{1
"Returns the index of the child node of this node that has the given path or
"-1 if no such node exists.
"
"This function doesnt not recurse into child dir nodes
"
"Args:
"path: a path object
function! s:TreeDirNode.getChildIndex(path)
    if stridx(a:path.str(), self.path.str(), 0) ==# -1
        return -1
    endif

    "do a binary search for the child
    let a = 0
    let z = self.getChildCount()
    while a < z
        let mid = (a+z)/2
        let diff = a:path.compareTo(self.children[mid].path)

        if diff ==# -1
            let z = mid
        elseif diff ==# 1
            let a = mid+1
        else
            return mid
        endif
    endwhile
    return -1
endfunction

"FUNCTION: TreeDirNode.GetSelected() {{{1
"Returns the current node if it is a dir node, or else returns the current
"nodes parent
unlet s:TreeDirNode.GetSelected
function! s:TreeDirNode.GetSelected()
    let currentDir = g:NERDTreeFileNode.GetSelected()
    if currentDir != {} && !currentDir.isRoot()
        if currentDir.path.isDirectory ==# 0
            let currentDir = currentDir.parent
        endif
    endif
    return currentDir
endfunction

"FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
"Returns the number of visible children this node has
function! s:TreeDirNode.getVisibleChildCount()
    return len(self.getVisibleChildren())
endfunction

"FUNCTION: TreeDirNode.getVisibleChildren() {{{1
"Returns a list of children to display for this node, in the correct order
"
"Return:
"an array of treenodes
function! s:TreeDirNode.getVisibleChildren()
    let toReturn = []
    for i in self.children
        if i.path.ignore() ==# 0
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
"returns 1 if this node has any childre, 0 otherwise..
function! s:TreeDirNode.hasVisibleChildren()
    return self.getVisibleChildCount() != 0
endfunction

"FUNCTION: TreeDirNode._initChildren() {{{1
"Removes all childen from this node and re-reads them
"
"Args:
"silent: 1 if the function should not echo any "please wait" messages for
"large directories
"
"Return: the number of child nodes read
function! s:TreeDirNode._initChildren(silent)
    "remove all the current child nodes
    let self.children = []

    "get an array of all the files in the nodes dir
    let dir = self.path
    let globDir = dir.str({'format': 'Glob'})

    if version >= 703
        let filesStr = globpath(globDir, '*', 1) . "\n" . globpath(globDir, '.*', 1)
    else
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
    endif

    let files = split(filesStr, "\n")

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ...")
    endif

    let invalidFilesFound = 0
    for i in files

        "filter out the .. and . directories
        "Note: we must match .. AND ../ cos sometimes the globpath returns
        "../ for path with strange chars (eg $)
        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

            "put the next file in a new node and attach it
            try
                let path = g:NERDTreePath.New(i)
                call self.createChild(path, 0)
            catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                let invalidFilesFound += 1
            endtry
        endif
    endfor

    call self.sortChildren()

    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
        call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
    endif

    if invalidFilesFound
        call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
    endif
    return self.getChildCount()
endfunction

"FUNCTION: TreeDirNode.New(path) {{{1
"Returns a new TreeNode object with the given path and parent
"
"Args:
"path: a path object representing the full filesystem path to the file/dir that the node represents
unlet s:TreeDirNode.New
function! s:TreeDirNode.New(path)
    if a:path.isDirectory != 1
        throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
    endif

    let newTreeNode = copy(self)
    let newTreeNode.path = a:path

    let newTreeNode.isOpen = 0
    let newTreeNode.children = []

    let newTreeNode.parent = {}

    return newTreeNode
endfunction

"FUNCTION: TreeDirNode.open([opts]) {{{1
"Open the dir in the current tree or in a new tree elsewhere.
"
"If opening in the current tree, return the number of cached nodes.
unlet s:TreeDirNode.open
function! s:TreeDirNode.open(...)
    let opts = a:0 ? a:1 : {}

    if has_key(opts, 'where') && !empty(opts['where'])
        let opener = g:NERDTreeOpener.New(self.path, opts)
        call opener.open(self)
    else
        let self.isOpen = 1
        if self.children ==# []
            return self._initChildren(0)
        else
            return 0
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.openAlong([opts]) {{{1
"recursive open the dir if it has only one directory child.
"
"return the level of opened directories.
function! s:TreeDirNode.openAlong(...)
    let opts = a:0 ? a:1 : {}
    let level = 0

    let node = self
    while node.path.isDirectory
        call node.open(opts)
        let level += 1
        if node.getVisibleChildCount() == 1
            let node = node.getChildByIndex(0, 1)
        else
            break
        endif
    endwhile
    return level
endfunction

" FUNCTION: TreeDirNode.openExplorer() {{{1
" opens an explorer window for this node in the previous window (could be a
" nerd tree or a netrw)
function! s:TreeDirNode.openExplorer()
    call self.open({'where': 'p'})
endfunction

"FUNCTION: TreeDirNode.openInNewTab(options) {{{1
unlet s:TreeDirNode.openInNewTab
function! s:TreeDirNode.openInNewTab(options)
    call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
    call self.open({'where': 't'})
endfunction

"FUNCTION: TreeDirNode._openInNewTab() {{{1
function! s:TreeDirNode._openInNewTab()
    tabnew
    call g:NERDTreeCreator.CreatePrimary(self.path.str())
endfunction

"FUNCTION: TreeDirNode.openRecursively() {{{1
"Opens this treenode and all of its children whose paths arent 'ignored'
"because of the file filters.
"
"This method is actually a wrapper for the OpenRecursively2 method which does
"the work.
function! s:TreeDirNode.openRecursively()
    call self._openRecursively2(1)
endfunction

"FUNCTION: TreeDirNode._openRecursively2() {{{1
"Opens this all children of this treenode recursively if either:
"   *they arent filtered by file filters
"   *a:forceOpen is 1
"
"Args:
"forceOpen: 1 if this node should be opened regardless of file filters
function! s:TreeDirNode._openRecursively2(forceOpen)
    if self.path.ignore() ==# 0 || a:forceOpen
        let self.isOpen = 1
        if self.children ==# []
            call self._initChildren(1)
        endif

        for i in self.children
            if i.path.isDirectory ==# 1
                call i._openRecursively2(0)
            endif
        endfor
    endif
endfunction

"FUNCTION: TreeDirNode.refresh() {{{1
unlet s:TreeDirNode.refresh
function! s:TreeDirNode.refresh()
    call self.path.refresh()

    "if this node was ever opened, refresh its children
    if self.isOpen || !empty(self.children)
        "go thru all the files/dirs under this node
        let newChildNodes = []
        let invalidFilesFound = 0
        let dir = self.path
        let globDir = dir.str({'format': 'Glob'})
        let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
        let files = split(filesStr, "\n")
        for i in files
            "filter out the .. and . directories
            "Note: we must match .. AND ../ cos sometimes the globpath returns
            "../ for path with strange chars (eg $)
            if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'

                try
                    "create a new path and see if it exists in this nodes children
                    let path = g:NERDTreePath.New(i)
                    let newNode = self.getChild(path)
                    if newNode != {}
                        call newNode.refresh()
                        call add(newChildNodes, newNode)

                    "the node doesnt exist so create it
                    else
                        let newNode = g:NERDTreeFileNode.New(path)
                        let newNode.parent = self
                        call add(newChildNodes, newNode)
                    endif


                catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                    let invalidFilesFound = 1
                endtry
            endif
        endfor

        "swap this nodes children out for the children we just read/refreshed
        let self.children = newChildNodes
        call self.sortChildren()

        if invalidFilesFound
            call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.reveal(path) {{{1
"reveal the given path, i.e. cache and open all treenodes needed to display it
"in the UI
function! s:TreeDirNode.reveal(path)
    if !a:path.isUnder(self.path)
        throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
    endif

    call self.open()

    if self.path.equals(a:path.getParent())
        let n = self.findNode(a:path)
        call nerdtree#renderView()
        call n.putCursorHere(1,0)
        return
    endif

    let p = a:path
    while !p.getParent().equals(self.path)
        let p = p.getParent()
    endwhile

    let n = self.findNode(p)
    call n.reveal(a:path)
endfunction

"FUNCTION: TreeDirNode.removeChild(treenode) {{{1
"
"Removes the given treenode from this nodes set of children
"
"Args:
"treenode: the node to remove
"
"Throws a NERDTree.ChildNotFoundError if the given treenode is not found
function! s:TreeDirNode.removeChild(treenode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:treenode)
            call remove(self.children, i)
            return
        endif
    endfor

    throw "NERDTree.ChildNotFoundError: child node was not found"
endfunction

"FUNCTION: TreeDirNode.sortChildren() {{{1
"
"Sorts the children of this node according to alphabetical order and the
"directory priority.
"
function! s:TreeDirNode.sortChildren()
    let CompareFunc = function("nerdtree#compareNodes")
    call sort(self.children, CompareFunc)
endfunction

"FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
"Opens this directory if it is closed and vice versa
function! s:TreeDirNode.toggleOpen(...)
    let opts = a:0 ? a:1 : {}
    if self.isOpen ==# 1
        call self.close()
    else
        if g:NERDTreeCasadeOpenSingleChildDir == 0
            call self.open(opts)
        else
            call self.openAlong(opts)
        endif
    endif
endfunction

"FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
"Replaces the child of this with the given node (where the child node's full
"path matches a:newNode's fullpath). The search for the matching node is
"non-recursive
"
"Arg:
"newNode: the node to graft into the tree
function! s:TreeDirNode.transplantChild(newNode)
    for i in range(0, self.getChildCount()-1)
        if self.children[i].equals(a:newNode)
            let self.children[i] = a:newNode
            let a:newNode.parent = self
            break
        endif
    endfor
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
"CLASS: Opener
"============================================================
let s:Opener = {}
let g:NERDTreeOpener = s:Opener

"FUNCTION: Opener._checkToCloseTree(newtab) {{{1
"Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
"if the tree should be closed now.
"
"Args:
"a:newtab - boolean. If set, only close the tree now if we are opening the
"target in a new tab. This is needed because we have to close tree before we
"leave the tab
function! s:Opener._checkToCloseTree(newtab)
    if self._keepopen
        return
    endif

    if (a:newtab && self._where == 't') || !a:newtab
        call nerdtree#closeTreeIfQuitOnOpen()
    endif
endfunction

"FUNCTION: Opener._gotoTargetWin() {{{1
function! s:Opener._gotoTargetWin()
    if b:NERDTreeType ==# "secondary"
        if self._where == 'v'
            vsplit
        elseif self._where == 'h'
            split
        elseif self._where == 't'
            tabnew
        endif
    else
        call self._checkToCloseTree(1)

        if self._where == 'v'
            call self._newVSplit()
        elseif self._where == 'h'
            call self._newSplit()
        elseif self._where == 't'
            tabnew
        elseif self._where == 'p'
            call self._previousWindow()
        endif

        call self._checkToCloseTree(0)
    endif
endfunction

"FUNCTION: Opener.New(path, opts) {{{1
"Args:
"
"a:path: The path object that is to be opened.
"
"a:opts:
"
"A dictionary containing the following keys (all optional):
"  'where': Specifies whether the node should be opened in new split/tab or in
"           the previous window. Can be either 'v' or 'h' or 't' (for open in
"           new tab)
"  'reuse': if a window is displaying the file then jump the cursor there
"  'keepopen': dont close the tree window
"  'stay': open the file, but keep the cursor in the tree win
function! s:Opener.New(path, opts)
    let newObj = copy(self)

    let newObj._path = a:path
    let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
    let newObj._reuse = nerdtree#has_opt(a:opts, 'reuse')
    let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    let newObj._treetype = b:NERDTreeType
    call newObj._saveCursorPos()

    return newObj
endfunction

"FUNCTION: Opener._newSplit() {{{1
function! s:Opener._newSplit()
    " Save the user's settings for splitbelow and splitright
    let savesplitbelow=&splitbelow
    let savesplitright=&splitright

    " 'there' will be set to a command to move from the split window
    " back to the explorer window
    "
    " 'back' will be set to a command to move from the explorer window
    " back to the newly split window
    "
    " 'right' and 'below' will be set to the settings needed for
    " splitbelow and splitright IF the explorer is the only window.
    "
    let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
    let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
    let right= g:NERDTreeWinPos ==# "left"
    let below=0

    " Attempt to go to adjacent window
    call nerdtree#exec(back)

    let onlyOneWin = (winnr("$") ==# 1)

    " If no adjacent window, set splitright and splitbelow appropriately
    if onlyOneWin
        let &splitright=right
        let &splitbelow=below
    else
        " found adjacent window - invert split direction
        let &splitright=!right
        let &splitbelow=!below
    endif

    let splitMode = onlyOneWin ? "vertical" : ""

    " Open the new window
    try
        exec(splitMode." sp ")
    catch /^Vim\%((\a\+)\)\=:E37/
        call nerdtree#putCursorInTreeWin()
        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
    catch /^Vim\%((\a\+)\)\=:/
        "do nothing
    endtry

    "resize the tree window if no other window was open before
    if onlyOneWin
        let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
        call nerdtree#exec(there)
        exec("silent ". splitMode ." resize ". size)
        call nerdtree#exec('wincmd p')
    endif

    " Restore splitmode settings
    let &splitbelow=savesplitbelow
    let &splitright=savesplitright
endfunction

"FUNCTION: Opener._newVSplit() {{{1
function! s:Opener._newVSplit()
    let winwidth = winwidth(".")
    if winnr("$")==#1
        let winwidth = g:NERDTreeWinSize
    endif

    call nerdtree#exec("wincmd p")
    vnew

    "resize the nerd tree back to the original size
    call nerdtree#putCursorInTreeWin()
    exec("silent vertical resize ". winwidth)
    call nerdtree#exec('wincmd p')
endfunction

"FUNCTION: Opener.open(target) {{{1
function! s:Opener.open(target)
    if self._path.isDirectory
        call self._openDirectory(a:target)
    else
        call self._openFile()
    endif
endfunction

"FUNCTION: Opener._openFile() {{{1
function! s:Opener._openFile()
    if self._reuse && self._reuseWindow()
        return
    endif

    call self._gotoTargetWin()

    if self._treetype ==# "secondary"
        call self._path.edit()
    else
        call self._path.edit()


        if self._stay
            call self._restoreCursorPos()
        endif
    endif
endfunction

"FUNCTION: Opener._openDirectory(node) {{{1
function! s:Opener._openDirectory(node)
    if self._treetype ==# "secondary"
        call self._gotoTargetWin()
        call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
    else
        call self._gotoTargetWin()
        if empty(self._where)
            call a:node.makeRoot()
            call nerdtree#renderView()
            call a:node.putCursorHere(0, 0)
        elseif self._where == 't'
            call g:NERDTreeCreator.CreatePrimary(a:node.path.str())
        else
            call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
        endif
    endif

    if self._stay
        call self._restoreCursorPos()
    endif
endfunction

"FUNCTION: Opener._previousWindow() {{{1
function! s:Opener._previousWindow()
    if !nerdtree#isWindowUsable(winnr("#")) && nerdtree#firstUsableWindow() ==# -1
        call self._newSplit()
    else
        try
            if !nerdtree#isWindowUsable(winnr("#"))
                call nerdtree#exec(nerdtree#firstUsableWindow() . "wincmd w")
            else
                call nerdtree#exec('wincmd p')
            endif
        catch /^Vim\%((\a\+)\)\=:E37/
            call nerdtree#putCursorInTreeWin()
            throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
        catch /^Vim\%((\a\+)\)\=:/
            echo v:exception
        endtry
    endif
endfunction

"FUNCTION: Opener._restoreCursorPos(){{{1
function! s:Opener._restoreCursorPos()
    call nerdtree#exec('normal ' . self._tabnr . 'gt')
    call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w')
endfunction

"FUNCTION: Opener._reuseWindow(){{{1
"put the cursor in the first window we find for this file
"
"return 1 if we were successful
function! s:Opener._reuseWindow()
    "check the current tab for the window
    let winnr = bufwinnr('^' . self._path.str() . '$')
    if winnr != -1
        call nerdtree#exec(winnr . "wincmd w")
        call self._checkToCloseTree(0)
        return 1
    else
        "check other tabs
        let tabnr = self._path.tabnr()
        if tabnr
            call self._checkToCloseTree(1)
            call nerdtree#exec('normal! ' . tabnr . 'gt')
            let winnr = bufwinnr('^' . self._path.str() . '$')
            call nerdtree#exec(winnr . "wincmd w")
            return 1
        endif
    endif
    return 0
endfunction

"FUNCTION: Opener._saveCursorPos(){{{1
function! s:Opener._saveCursorPos()
    let self._bufnr = bufnr("")
    let self._tabnr = tabpagenr()
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/opener.vim
"CLASS: MenuItem
"============================================================
let s:MenuItem = {}
let g:NERDTreeMenuItem = s:MenuItem

"FUNCTION: MenuItem.All() {{{1
"get all top level menu items
function! s:MenuItem.All()
    if !exists("s:menuItems")
        let s:menuItems = []
    endif
    return s:menuItems
endfunction

"FUNCTION: MenuItem.AllEnabled() {{{1
"get all top level menu items that are currently enabled
function! s:MenuItem.AllEnabled()
    let toReturn = []
    for i in s:MenuItem.All()
        if i.enabled()
            call add(toReturn, i)
        endif
    endfor
    return toReturn
endfunction

"FUNCTION: MenuItem.Create(options) {{{1
"make a new menu item and add it to the global list
function! s:MenuItem.Create(options)
    let newMenuItem = copy(self)

    let newMenuItem.text = a:options['text']
    let newMenuItem.shortcut = a:options['shortcut']
    let newMenuItem.children = []

    let newMenuItem.isActiveCallback = -1
    if has_key(a:options, 'isActiveCallback')
        let newMenuItem.isActiveCallback = a:options['isActiveCallback']
    endif

    let newMenuItem.callback = -1
    if has_key(a:options, 'callback')
        let newMenuItem.callback = a:options['callback']
    endif

    if has_key(a:options, 'parent')
        call add(a:options['parent'].children, newMenuItem)
    else
        call add(s:MenuItem.All(), newMenuItem)
    endif

    return newMenuItem
endfunction

"FUNCTION: MenuItem.CreateSeparator(options) {{{1
"make a new separator menu item and add it to the global list
function! s:MenuItem.CreateSeparator(options)
    let standard_options = { 'text': '--------------------',
                \ 'shortcut': -1,
                \ 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.CreateSubmenu(options) {{{1
"make a new submenu and add it to global list
function! s:MenuItem.CreateSubmenu(options)
    let standard_options = { 'callback': -1 }
    let options = extend(a:options, standard_options, "force")

    return s:MenuItem.Create(options)
endfunction

"FUNCTION: MenuItem.enabled() {{{1
"return 1 if this menu item should be displayed
"
"delegates off to the isActiveCallback, and defaults to 1 if no callback was
"specified
function! s:MenuItem.enabled()
    if self.isActiveCallback != -1
        return {self.isActiveCallback}()
    endif
    return 1
endfunction

"FUNCTION: MenuItem.execute() {{{1
"perform the action behind this menu item, if this menuitem has children then
"display a new menu for them, otherwise deletegate off to the menuitem's
"callback
function! s:MenuItem.execute()
    if len(self.children)
        let mc = s:MenuController.New(self.children)
        call mc.showMenu()
    else
        if self.callback != -1
            call {self.callback}()
        endif
    endif
endfunction

"FUNCTION: MenuItem.isSeparator() {{{1
"return 1 if this menuitem is a separator
function! s:MenuItem.isSeparator()
    return self.callback == -1 && self.children == []
endfunction

"FUNCTION: MenuItem.isSubmenu() {{{1
"return 1 if this menuitem is a submenu
function! s:MenuItem.isSubmenu()
    return self.callback == -1 && !empty(self.children)
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/lib/nerdtree/menu_item.vim
" ============================================================================
" File:        fs_menu.vim
" Description: plugin for the NERD Tree that provides a file system menu
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 17 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_fs_menu")
    finish
endif
let g:loaded_nerdtree_fs_menu = 1

"Automatically delete the buffer after deleting or renaming a file
if !exists("g:NERDTreeAutoDeleteBuffer")
    let g:NERDTreeAutoDeleteBuffer = 0
endif

call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})

if has("gui_mac") || has("gui_macvim") 
    call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
    call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
endif

if g:NERDTreePath.CopyingSupported()
    call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
endif

"FUNCTION: s:echo(msg){{{1
function! s:echo(msg)
    redraw
    echomsg "NERDTree: " . a:msg
endfunction

"FUNCTION: s:echoWarning(msg){{{1
function! s:echoWarning(msg)
    echohl warningmsg
    call s:echo(a:msg)
    echohl normal
endfunction

"FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is deleted
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToDelBuffer(bufnum, msg)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that all windows which display the just deleted filename
        " now display an empty buffer (so a layout is preserved).
        " Is not it better to close single tabs with this file only ?
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':enew! ' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction

"FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
"prints out the given msg and, if the user responds by pushing 'y' then the
"buffer with the given bufnum is replaced with a new one
"
"Args:
"bufnum: the buffer that may be deleted
"msg: a message that will be echoed to the user asking them if they wish to
"     del the buffer
function! s:promptToRenameBuffer(bufnum, msg, newFileName)
    echo a:msg
    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
        " 1. ensure that a new buffer is loaded
        exec "badd " . a:newFileName
        " 2. ensure that all windows which display the just deleted filename
        " display a buffer for a new filename. 
        let s:originalTabNumber = tabpagenr()
        let s:originalWindowNumber = winnr()
        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':e! " . a:newFileName . "' | endif"
        exec "tabnext " . s:originalTabNumber
        exec s:originalWindowNumber . "wincmd w"
        " 3. We don't need a previous buffer anymore
        exec "bwipeout! " . a:bufnum
    endif
endfunction
"FUNCTION: NERDTreeAddNode(){{{1
function! NERDTreeAddNode()
    let curDirNode = g:NERDTreeDirNode.GetSelected()

    let newNodeName = input("Add a childnode\n".
                          \ "==========================================================\n".
                          \ "Enter the dir/file name to be created. Dirs end with a '/'\n" .
                          \ "", curDirNode.path.str() . g:NERDTreePath.Slash(), "file")

    if newNodeName ==# ''
        call s:echo("Node Creation Aborted.")
        return
    endif

    try
        let newPath = g:NERDTreePath.Create(newNodeName)
        let parentNode = b:NERDTreeRoot.findNode(newPath.getParent())

        let newTreeNode = g:NERDTreeFileNode.New(newPath)
        if parentNode.isOpen || !empty(parentNode.children)
            call parentNode.addChild(newTreeNode, 1)
            call NERDTreeRender()
            call newTreeNode.putCursorHere(1, 0)
        endif
    catch /^NERDTree/
        call s:echoWarning("Node Not Created.")
    endtry
endfunction

"FUNCTION: NERDTreeMoveNode(){{{1
function! NERDTreeMoveNode()
    let curNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Rename the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path for the node:                          \n" .
                          \ "", curNode.path.str(), "file")

    if newNodePath ==# ''
        call s:echo("Node Renaming Aborted.")
        return
    endif

    try
        let bufnum = bufnr(curNode.path.str())

        call curNode.rename(newNodePath)
        call NERDTreeRender()

        "if the node is open in a buffer, ask the user if they want to
        "close that buffer
        if bufnum != -1
            let prompt = "\nNode renamed.\n\nThe old file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Replace this buffer with a new file? (yN)"
            call s:promptToRenameBuffer(bufnum,  prompt, newNodePath)
        endif

        call curNode.putCursorHere(1, 0)

        redraw
    catch /^NERDTree/
        call s:echoWarning("Node Not Renamed.")
    endtry
endfunction

" FUNCTION: NERDTreeDeleteNode() {{{1
function! NERDTreeDeleteNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let confirmed = 0

    if currentNode.path.isDirectory
        let choice =input("Delete the current node\n" .
                         \ "==========================================================\n" .
                         \ "STOP! To delete this entire directory, type 'yes'\n" .
                         \ "" . currentNode.path.str() . ": ")
        let confirmed = choice ==# 'yes'
    else
        echo "Delete the current node\n" .
           \ "==========================================================\n".
           \ "Are you sure you wish to delete the node:\n" .
           \ "" . currentNode.path.str() . " (yN):"
        let choice = nr2char(getchar())
        let confirmed = choice ==# 'y'
    endif


    if confirmed
        try
            call currentNode.delete()
            call NERDTreeRender()

            "if the node is open in a buffer, ask the user if they want to
            "close that buffer
            let bufnum = bufnr(currentNode.path.str())
            if buflisted(bufnum)
                let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Delete this buffer? (yN)"
                call s:promptToDelBuffer(bufnum, prompt)
            endif

            redraw
        catch /^NERDTree/
            call s:echoWarning("Could not remove node")
        endtry
    else
        call s:echo("delete aborted")
    endif

endfunction

" FUNCTION: NERDTreeCopyNode() {{{1
function! NERDTreeCopyNode()
    let currentNode = g:NERDTreeFileNode.GetSelected()
    let newNodePath = input("Copy the current node\n" .
                          \ "==========================================================\n" .
                          \ "Enter the new path to copy the node to:                   \n" .
                          \ "", currentNode.path.str(), "file")

    if newNodePath != ""
        "strip trailing slash
        let newNodePath = substitute(newNodePath, '\/$', '', '')

        let confirmed = 1
        if currentNode.path.copyingWillOverwrite(newNodePath)
            call s:echo("Warning: copying may overwrite files! Continue? (yN)")
            let choice = nr2char(getchar())
            let confirmed = choice ==# 'y'
        endif

        if confirmed
            try
                let newNode = currentNode.copy(newNodePath)
                if !empty(newNode)
                    call NERDTreeRender()
                    call newNode.putCursorHere(0, 0)
                endif
            catch /^NERDTree/
                call s:echoWarning("Could not copy node")
            endtry
        endif
    else
        call s:echo("Copy aborted.")
    endif
    redraw
endfunction

function! NERDTreeQuickLook()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        call system("qlmanage -p 2>/dev/null '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeRevealInFinder()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open -R '" . treenode.path.str() . "'")
    endif
endfunction

function! NERDTreeExecuteFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    if treenode != {}
        let x = system("open '" . treenode.path.str() . "'")
    endif
endfunction

" vim: set sw=4 sts=4 et fdm=marker:
zhimakaimen:/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
" ============================================================================
" File:        exec_menuitem.vim
" Description: plugin for NERD Tree that provides an execute file menu item
" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
" Last Change: 22 July, 2009
" License:     This program is free software. It comes without any warranty,
"              to the extent permitted by applicable law. You can redistribute
"              it and/or modify it under the terms of the Do What The Fuck You
"              Want To Public License, Version 2, as published by Sam Hocevar.
"              See http://sam.zoy.org/wtfpl/COPYING for more details.
"
" ============================================================================
if exists("g:loaded_nerdtree_exec_menuitem")
    finish
endif
let g:loaded_nerdtree_exec_menuitem = 1

call NERDTreeAddMenuItem({
            \ 'text': '(!)Execute file',
            \ 'shortcut': '!',
            \ 'callback': 'NERDTreeExecFile',
            \ 'isActiveCallback': 'NERDTreeExecFileActive' })

function! NERDTreeExecFileActive()
    let node = g:NERDTreeFileNode.GetSelected()
    return !node.path.isDirectory && node.path.isExecutable
endfunction

function! NERDTreeExecFile()
    let treenode = g:NERDTreeFileNode.GetSelected()
    echo "==========================================================\n"
    echo "Complete the command to execute (add arguments etc):\n"
    let cmd = treenode.path.str({'escape': 1})
    let cmd = input(':!', cmd . ' ')

    if cmd != ''
        exec ':!' . cmd
    else
        echo "Aborted"
    endif
endfunction
zhimakaimen:/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
fun! Filename(...)
	let filename = expand('%:t:r')
	if filename == '' | return a:0 == 2 ? a:2 : '' | endif
	return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
endf

fun s:RemoveSnippet()
	unl! g:snipPos s:curPos s:snipLen s:endCol s:endLine s:prevLen
	     \ s:lastBuf s:oldWord
	if exists('s:update')
		unl s:startCol s:origWordLen s:update
		if exists('s:oldVars') | unl s:oldVars s:oldEndCol | endif
	endif
	aug! snipMateAutocmds
endf

fun snipMate#expandSnip(snip, col)
	let lnum = line('.') | let col = a:col

	let snippet = s:ProcessSnippet(a:snip)
	" Avoid error if eval evaluates to nothing
	if snippet == '' | return '' | endif

	" Expand snippet onto current position with the tab stops removed
	let snipLines = split(substitute(snippet, '$\d\+\|${\d\+.\{-}}', '', 'g'), "\n", 1)

	let line = getline(lnum)
	let afterCursor = strpart(line, col - 1)
	" Keep text after the cursor
	if afterCursor != "\t" && afterCursor != ' '
		let line = strpart(line, 0, col - 1)
		let snipLines[-1] .= afterCursor
	else
		let afterCursor = ''
		" For some reason the cursor needs to move one right after this
		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
			let col += 1
		endif
	endif

	call setline(lnum, line.snipLines[0])

	" Autoindent snippet according to previous indentation
	let indent = matchend(line, '^.\{-}\ze\(\S\|$\)') + 1
	call append(lnum, map(snipLines[1:], "'".strpart(line, 0, indent - 1)."'.v:val"))

	" Open any folds snippet expands into
	if &fen | sil! exe lnum.','.(lnum + len(snipLines) - 1).'foldopen' | endif

	let [g:snipPos, s:snipLen] = s:BuildTabStops(snippet, lnum, col - indent, indent)

	if s:snipLen
		aug snipMateAutocmds
			au CursorMovedI * call s:UpdateChangedSnip(0)
			au InsertEnter * call s:UpdateChangedSnip(1)
		aug END
		let s:lastBuf = bufnr(0) " Only expand snippet while in current buffer
		let s:curPos = 0
		let s:endCol = g:snipPos[s:curPos][1]
		let s:endLine = g:snipPos[s:curPos][0]

		call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])
		let s:prevLen = [line('$'), col('$')]
		if g:snipPos[s:curPos][2] != -1 | return s:SelectWord() | endif
	else
		unl g:snipPos s:snipLen
		" Place cursor at end of snippet if no tab stop is given
		let newlines = len(snipLines) - 1
		call cursor(lnum + newlines, indent + len(snipLines[-1]) - len(afterCursor)
					\ + (newlines ? 0: col - 1))
	endif
	return ''
endf

" Prepare snippet to be processed by s:BuildTabStops
fun s:ProcessSnippet(snip)
	let snippet = a:snip
	" Evaluate eval (`...`) expressions.
	" Backquotes prefixed with a backslash "\" are ignored.
	" Using a loop here instead of a regex fixes a bug with nested "\=".
	if stridx(snippet, '`') != -1
		while match(snippet, '\(^\|[^\\]\)`.\{-}[^\\]`') != -1
			let snippet = substitute(snippet, '\(^\|[^\\]\)\zs`.\{-}[^\\]`\ze',
		                \ substitute(eval(matchstr(snippet, '\(^\|[^\\]\)`\zs.\{-}[^\\]\ze`')),
		                \ "\n\\%$", '', ''), '')
		endw
		let snippet = substitute(snippet, "\r", "\n", 'g')
		let snippet = substitute(snippet, '\\`', '`', 'g')
	endif

	" Place all text after a colon in a tab stop after the tab stop
	" (e.g. "${#:foo}" becomes "${:foo}foo").
	" This helps tell the position of the tab stops later.
	let snippet = substitute(snippet, '${\d\+:\(.\{-}\)}', '&\1', 'g')

	" Update the a:snip so that all the $# become the text after
	" the colon in their associated ${#}.
	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
	let i = 1
	while stridx(snippet, '${'.i) != -1
		let s = matchstr(snippet, '${'.i.':\zs.\{-}\ze}')
		if s != ''
			let snippet = substitute(snippet, '$'.i, s.'&', 'g')
		endif
		let i += 1
	endw

	if &et " Expand tabs to spaces if 'expandtab' is set.
		return substitute(snippet, '\t', repeat(' ', &sts ? &sts : &sw), 'g')
	endif
	return snippet
endf

" Counts occurences of haystack in needle
fun s:Count(haystack, needle)
	let counter = 0
	let index = stridx(a:haystack, a:needle)
	while index != -1
		let index = stridx(a:haystack, a:needle, index+1)
		let counter += 1
	endw
	return counter
endf

" Builds a list of a list of each tab stop in the snippet containing:
" 1.) The tab stop's line number.
" 2.) The tab stop's column number
"     (by getting the length of the string between the last "\n" and the
"     tab stop).
" 3.) The length of the text after the colon for the current tab stop
"     (e.g. "${1:foo}" would return 3). If there is no text, -1 is returned.
" 4.) If the "${#:}" construct is given, another list containing all
"     the matches of "$#", to be replaced with the placeholder. This list is
"     composed the same way as the parent; the first item is the line number,
"     and the second is the column.
fun s:BuildTabStops(snip, lnum, col, indent)
	let snipPos = []
	let i = 1
	let withoutVars = substitute(a:snip, '$\d\+', '', 'g')
	while stridx(a:snip, '${'.i) != -1
		let beforeTabStop = matchstr(withoutVars, '^.*\ze${'.i.'\D')
		let withoutOthers = substitute(withoutVars, '${\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')

		let j = i - 1
		call add(snipPos, [0, 0, -1])
		let snipPos[j][0] = a:lnum + s:Count(beforeTabStop, "\n")
		let snipPos[j][1] = a:indent + len(matchstr(withoutOthers, '.*\(\n\|^\)\zs.*\ze${'.i.'\D'))
		if snipPos[j][0] == a:lnum | let snipPos[j][1] += a:col | endif

		" Get all $# matches in another list, if ${#:name} is given
		if stridx(withoutVars, '${'.i.':') != -1
			let snipPos[j][2] = len(matchstr(withoutVars, '${'.i.':\zs.\{-}\ze}'))
			let dots = repeat('.', snipPos[j][2])
			call add(snipPos[j], [])
			let withoutOthers = substitute(a:snip, '${\d\+.\{-}}\|$'.i.'\@!\d\+', '', 'g')
			while match(withoutOthers, '$'.i.'\(\D\|$\)') != -1
				let beforeMark = matchstr(withoutOthers, '^.\{-}\ze'.dots.'$'.i.'\(\D\|$\)')
				call add(snipPos[j][3], [0, 0])
				let snipPos[j][3][-1][0] = a:lnum + s:Count(beforeMark, "\n")
				let snipPos[j][3][-1][1] = a:indent + (snipPos[j][3][-1][0] > a:lnum
				                           \ ? len(matchstr(beforeMark, '.*\n\zs.*'))
				                           \ : a:col + len(beforeMark))
				let withoutOthers = substitute(withoutOthers, '$'.i.'\ze\(\D\|$\)', '', '')
			endw
		endif
		let i += 1
	endw
	return [snipPos, i - 1]
endf

fun snipMate#jumpTabStop(backwards)
	let leftPlaceholder = exists('s:origWordLen')
	                      \ && s:origWordLen != g:snipPos[s:curPos][2]
	if leftPlaceholder && exists('s:oldEndCol')
		let startPlaceholder = s:oldEndCol + 1
	endif

	if exists('s:update')
		call s:UpdatePlaceholderTabStops()
	else
		call s:UpdateTabStops()
	endif

	" Don't reselect placeholder if it has been modified
	if leftPlaceholder && g:snipPos[s:curPos][2] != -1
		if exists('startPlaceholder')
			let g:snipPos[s:curPos][1] = startPlaceholder
		else
			let g:snipPos[s:curPos][1] = col('.')
			let g:snipPos[s:curPos][2] = 0
		endif
	endif

	let s:curPos += a:backwards ? -1 : 1
	" Loop over the snippet when going backwards from the beginning
	if s:curPos < 0 | let s:curPos = s:snipLen - 1 | endif

	if s:curPos == s:snipLen
		let sMode = s:endCol == g:snipPos[s:curPos-1][1]+g:snipPos[s:curPos-1][2]
		call s:RemoveSnippet()
		return sMode ? "\<tab>" : TriggerSnippet()
	endif

	call cursor(g:snipPos[s:curPos][0], g:snipPos[s:curPos][1])

	let s:endLine = g:snipPos[s:curPos][0]
	let s:endCol = g:snipPos[s:curPos][1]
	let s:prevLen = [line('$'), col('$')]

	return g:snipPos[s:curPos][2] == -1 ? '' : s:SelectWord()
endf

fun s:UpdatePlaceholderTabStops()
	let changeLen = s:origWordLen - g:snipPos[s:curPos][2]
	unl s:startCol s:origWordLen s:update
	if !exists('s:oldVars') | return | endif
	" Update tab stops in snippet if text has been added via "$#"
	" (e.g., in "${1:foo}bar$1${2}").
	if changeLen != 0
		let curLine = line('.')

		for pos in g:snipPos
			if pos == g:snipPos[s:curPos] | continue | endif
			let changed = pos[0] == curLine && pos[1] > s:oldEndCol
			let changedVars = 0
			let endPlaceholder = pos[2] - 1 + pos[1]
			" Subtract changeLen from each tab stop that was after any of
			" the current tab stop's placeholders.
			for [lnum, col] in s:oldVars
				if lnum > pos[0] | break | endif
				if pos[0] == lnum
					if pos[1] > col || (pos[2] == -1 && pos[1] == col)
						let changed += 1
					elseif col < endPlaceholder
						let changedVars += 1
					endif
				endif
			endfor
			let pos[1] -= changeLen * changed
			let pos[2] -= changeLen * changedVars " Parse variables within placeholders
                                                  " e.g., "${1:foo} ${2:$1bar}"

			if pos[2] == -1 | continue | endif
			" Do the same to any placeholders in the other tab stops.
			for nPos in pos[3]
				let changed = nPos[0] == curLine && nPos[1] > s:oldEndCol
				for [lnum, col] in s:oldVars
					if lnum > nPos[0] | break | endif
					if nPos[0] == lnum && nPos[1] > col
						let changed += 1
					endif
				endfor
				let nPos[1] -= changeLen * changed
			endfor
		endfor
	endif
	unl s:endCol s:oldVars s:oldEndCol
endf

fun s:UpdateTabStops()
	let changeLine = s:endLine - g:snipPos[s:curPos][0]
	let changeCol = s:endCol - g:snipPos[s:curPos][1]
	if exists('s:origWordLen')
		let changeCol -= s:origWordLen
		unl s:origWordLen
	endif
	let lnum = g:snipPos[s:curPos][0]
	let col = g:snipPos[s:curPos][1]
	" Update the line number of all proceeding tab stops if <cr> has
	" been inserted.
	if changeLine != 0
		let changeLine -= 1
		for pos in g:snipPos
			if pos[0] >= lnum
				if pos[0] == lnum | let pos[1] += changeCol | endif
				let pos[0] += changeLine
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] >= lnum
					if nPos[0] == lnum | let nPos[1] += changeCol | endif
					let nPos[0] += changeLine
				endif
			endfor
		endfor
	elseif changeCol != 0
		" Update the column of all proceeding tab stops if text has
		" been inserted/deleted in the current line.
		for pos in g:snipPos
			if pos[1] >= col && pos[0] == lnum
				let pos[1] += changeCol
			endif
			if pos[2] == -1 | continue | endif
			for nPos in pos[3]
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] >= col
					let nPos[1] += changeCol
				endif
			endfor
		endfor
	endif
endf

fun s:SelectWord()
	let s:origWordLen = g:snipPos[s:curPos][2]
	let s:oldWord = strpart(getline('.'), g:snipPos[s:curPos][1] - 1,
				\ s:origWordLen)
	let s:prevLen[1] -= s:origWordLen
	if !empty(g:snipPos[s:curPos][3])
		let s:update = 1
		let s:endCol = -1
		let s:startCol = g:snipPos[s:curPos][1] - 1
	endif
	if !s:origWordLen | return '' | endif
	let l = col('.') != 1 ? 'l' : ''
	if &sel == 'exclusive'
		return "\<esc>".l.'v'.s:origWordLen."l\<c-g>"
	endif
	return s:origWordLen == 1 ? "\<esc>".l.'gh'
							\ : "\<esc>".l.'v'.(s:origWordLen - 1)."l\<c-g>"
endf

" This updates the snippet as you type when text needs to be inserted
" into multiple places (e.g. in "${1:default text}foo$1bar$1",
" "default text" would be highlighted, and if the user types something,
" UpdateChangedSnip() would be called so that the text after "foo" & "bar"
" are updated accordingly)
"
" It also automatically quits the snippet if the cursor is moved out of it
" while in insert mode.
fun s:UpdateChangedSnip(entering)
	if exists('g:snipPos') && bufnr(0) != s:lastBuf
		call s:RemoveSnippet()
	elseif exists('s:update') " If modifying a placeholder
		if !exists('s:oldVars') && s:curPos + 1 < s:snipLen
			" Save the old snippet & word length before it's updated
			" s:startCol must be saved too, in case text is added
			" before the snippet (e.g. in "foo$1${2}bar${1:foo}").
			let s:oldEndCol = s:startCol
			let s:oldVars = deepcopy(g:snipPos[s:curPos][3])
		endif
		let col = col('.') - 1

		if s:endCol != -1
			let changeLen = col('$') - s:prevLen[1]
			let s:endCol += changeLen
		else " When being updated the first time, after leaving select mode
			if a:entering | return | endif
			let s:endCol = col - 1
		endif

		" If the cursor moves outside the snippet, quit it
		if line('.') != g:snipPos[s:curPos][0] || col < s:startCol ||
					\ col - 1 > s:endCol
			unl! s:startCol s:origWordLen s:oldVars s:update
			return s:RemoveSnippet()
		endif

		call s:UpdateVars()
		let s:prevLen[1] = col('$')
	elseif exists('g:snipPos')
		if !a:entering && g:snipPos[s:curPos][2] != -1
			let g:snipPos[s:curPos][2] = -2
		endif

		let col = col('.')
		let lnum = line('.')
		let changeLine = line('$') - s:prevLen[0]

		if lnum == s:endLine
			let s:endCol += col('$') - s:prevLen[1]
			let s:prevLen = [line('$'), col('$')]
		endif
		if changeLine != 0
			let s:endLine += changeLine
			let s:endCol = col
		endif

		" Delete snippet if cursor moves out of it in insert mode
		if (lnum == s:endLine && (col > s:endCol || col < g:snipPos[s:curPos][1]))
			\ || lnum > s:endLine || lnum < g:snipPos[s:curPos][0]
			call s:RemoveSnippet()
		endif
	endif
endf

" This updates the variables in a snippet when a placeholder has been edited.
" (e.g., each "$1" in "${1:foo} $1bar $1bar")
fun s:UpdateVars()
	let newWordLen = s:endCol - s:startCol + 1
	let newWord = strpart(getline('.'), s:startCol, newWordLen)
	if newWord == s:oldWord || empty(g:snipPos[s:curPos][3])
		return
	endif

	let changeLen = g:snipPos[s:curPos][2] - newWordLen
	let curLine = line('.')
	let startCol = col('.')
	let oldStartSnip = s:startCol
	let updateTabStops = changeLen != 0
	let i = 0

	for [lnum, col] in g:snipPos[s:curPos][3]
		if updateTabStops
			let start = s:startCol
			if lnum == curLine && col <= start
				let s:startCol -= changeLen
				let s:endCol -= changeLen
			endif
			for nPos in g:snipPos[s:curPos][3][(i):]
				" This list is in ascending order, so quit if we've gone too far.
				if nPos[0] > lnum | break | endif
				if nPos[0] == lnum && nPos[1] > col
					let nPos[1] -= changeLen
				endif
			endfor
			if lnum == curLine && col > start
				let col -= changeLen
				let g:snipPos[s:curPos][3][i][1] = col
			endif
			let i += 1
		endif

		" "Very nomagic" is used here to allow special characters.
		call setline(lnum, substitute(getline(lnum), '\%'.col.'c\V'.
						\ escape(s:oldWord, '\'), escape(newWord, '\&'), ''))
	endfor
	if oldStartSnip != s:startCol
		call cursor(0, startCol + s:startCol - oldStartSnip)
	endif

	let s:oldWord = newWord
	let g:snipPos[s:curPos][2] = newWordLen
endf
" vim:noet:sw=4:ts=4:ft=vim
zhimakaimen:/autoload/snipMate.vim
" Helper function for (x)html snippets
if exists('s:did_snip_helper') || &cp || !exists('loaded_snips')
	finish
endif
let s:did_snip_helper = 1

" Automatically closes tag if in xhtml
fun! Close()
	return stridx(&ft, 'xhtml') == -1 ? '' : ' /'
endf
zhimakaimen:/ftplugin/html_snip_helper.vim
" Vim filetype plugin file
" Language:	SystemVerilog
" Maintainer:	WeiChung Wu <exelion04 at gmail dot com>
" Last Change:	Thu Jan 13 13:05:54 CST 2011

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Undo the plugin effect
let b:undo_ftplugin = "setlocal fo< com< tw<"
    \ . "| unlet! b:browsefilter b:match_ignorecase b:match_words"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croqlm1

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Format comments to be up to 78 characters long
"if &textwidth == 0 
"  setlocal tw=78
"endif

set cpo-=C

" Win32 can filter files in the browse dialog
"if has("gui_win32") && !exists("b:browsefilter")
"  let b:browsefilter = "Verilog Source Files (*.v)\t*.v\n" .
"	\ "All Files (*.*)\t*.*\n"
"endif

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase=0
  let b:match_words=
    \ '\<begin\>:\<end\>,' .
    \ '\<if\>:\<else\>,' .
    \ '`if\%[n]def\>:`else\>:`endif\>,' .
    \ '\<case\%[xz]\>\|\<randcase\>:\<endcase\>,' .
    \ '\%(disable\s\+\)\@<!\<fork\>:\<\%(join\|join_any\|join_none\)\>,' .
    \ '\<module\>:\<endmodule\>,' .
    \ '\<function\>:\<return\>:\<endfunction\>,' .
    \ '\<task\>:\<endtask\>,' .
    \ '\<program\>:\<endprogram\>,' .
    \ '\<package\>:\<endpackage\>,' .
    \ '\<class\>:\<endclass\>,' .
    \ '\<covergroup\>:\<endgroup\>,' .
    \ '\<packet\>:\<endpacket\>,' .
    \ '\<interface\>:\<endinterface\>,' .
    \ '\<clocking\>:\<endclocking\>,' .
    \ '\<randsequence\>:\<endsequence\>,' .
    \ '\<specify\>:\<endspecify\>,' .
    \ '`uvm_object\%(_param\)\=_utils_begin\>:`uvm_object_utils_end\>,' .
    \ '`uvm_component\%(_param\)\=_utils_begin\>:`uvm_component_utils_end\>'
endif
zhimakaimen:/ftplugin/systemverilog.vim
" Language:     SystemVerilog
" Maintainer:   WeiChung Wu <exelion04 at gmail dot com>
" Last Change:  Thu Aug 22 18:53:42 CST 2011
"
" Credits:
"   Originally created by
"       Chih-Tsun Huang <cthuang@larc.ee.nthu.edu.tw>
"       http://larc.ee.nthu.edu.tw/~cthuang/vim/indent/verilog.vim
"
" Buffer Variables:
"     b:sv_indent_modules : indenting after the declaration
"                                of module blocks
"     b:sv_indent_width   : indenting width
"     b:sv_indent_verbose : verbose to each indenting
"
" Revision Comments:
"

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetSystemVerilogIndent()
setlocal indentkeys=!^F,o,O,0),0},=begin,=end,=join,=endcase,=join_any,=join_none
setlocal indentkeys+==endmodule,=endfunction,=endtask,=endspecify
setlocal indentkeys+==endclass,=endpackage,=endsequence,=endclocking
setlocal indentkeys+==endinterface,=endgroup,=endprogram,=endproperty
setlocal indentkeys+==`else,=`endif

" Only define the function once.
if exists("*GetSystemVerilogIndent")
  finish
endif

set cpo-=C

" Check if the column is a comment
function s:IsSVColComment(lnum, cnum)
  let rc = synIDattr(synID(a:lnum, a:cnum, 0), "name") =~? 'comment\|string'
  return rc
endfunction

" Check if the line is a fully comment, or part of comment
function s:IsSVLineComment(lnum)
  let line = getline(a:lnum)
  let rc = (line =~ '^\s*\/\/' ||
   \        ( s:IsSVColComment(a:lnum, match(line,'\S')+1) && 
   \         ((line !~ '\*\/\s*\S') ||
   \          (line =~ '\*\/\s*\S' && s:IsSVColComment(a:lnum, matchend(line,'\*\/\s*\S'))) 
   \         ) 
   \        )) ? 1: 0
  return rc
endfunction

function s:PrevNonBlankNonComment(lnum)
  let lnum = prevnonblank(a:lnum)
  while lnum > 0
    if 0 == s:IsSVLineComment(lnum)
      break
    endif
    let lnum = prevnonblank(lnum - 1)
  endwhile
  return lnum
endfunction

function s:RemoveSVComment(line)
  let myline = substitute(a:line,'\%(\/\/.*\|\/\*.*\*\/\s*\)',"","g")
  let myline = substitute(myline,'\%(^.*\*\/\|\/\*.*$\)',"","g")
  let myline = substitute(myline,'^\s*',"","")
  "let myline = substitute(myline,'\s*\/\s*$',"","") "remove \
  return myline
endfunction

function s:GetSVBlockStart(keyword, curr_lnum, mode)
  let lnum  = a:curr_lnum
  let pmid = ''
  if a:keyword =~ '\<end\>'
    let pend   = '\<end\>'
    let pstart = '\<begin\>'
  elseif a:keyword =~ '`\@<!\<else\>'
    let pend   = '\<else\>'
    let pstart = '\<if\>'
  elseif a:keyword =~ 'join'
    let pend   = '\<\%(join\|join_any\|join_none\)\>'
    let pstart = '\%(disable\s\+\)\@<!\<fork\>'
  elseif a:keyword =~ ')'
    let pend   = ')'
    let pstart = '('
  elseif a:keyword =~ '}'
    let pend   = '}'
    let pstart = '{'
  elseif a:keyword =~ '\<endcase\>'
    let pend   = '\<endcase\>'
    let pstart = '\<\%(case\%[zx]\|randcase\)\>'
  elseif a:keyword =~ '\<endgroup\>'
    let pend   = '\<endgroup\>'
    let pstart = '\<covergroup\>'
  elseif a:keyword =~ '\<endsequence\>'
    let pend   = '\<endsequence\>'
    let pstart = '\<randsequence\>'
  elseif a:keyword =~ '`else'
    let pend   = '`else'
    let pstart = '`if\%[n]def'
  elseif a:keyword =~ '`endif'
    let pend   = '`endif'
    let pstart = '`if\%[n]def'
    let pmid   = '`else'
  elseif a:keyword =~ '`uvm_object_utils_end\>'
    let pend   = '`uvm_object_utils_end\>'
    let pstart = '`uvm_object\%(_param\)\=_utils_begin\>'
  elseif a:keyword =~ '`uvm_component_utils_end\>'
    let pend   = '`uvm_component_utils_end\>'
    let pstart = '`uvm_component\%(_param\)\=_utils_begin\>'
  else
    let pend = '\<' . a:keyword . '\>'
    "let pstart = '\<' . substitute(a:keyword,'^end','','') . '\>'
    let pstart = '\<' . strpart(a:keyword,3) . '\>'
  endif
  let skip = "s:IsSVColComment(line('.'),col('.'))"
  call cursor(lnum, 1)
  let m_lnum = searchpair(pstart, pmid, pend, 'bW', skip)
  let ind = m_lnum > 0 && m_lnum < lnum ?
           \ indent(m_lnum) : indent(lnum)
  let result = a:mode=='line'   ?  m_lnum :
             \ a:mode=='indent' ?  ind : 0
  if exists('b:sv_indent_verbose')
    echo pend . ' ' . pstart . ' m:' . m_lnum . ' c:' . lnum . ' i:' . ind . "\n"
  endif
  return result
endfunction

function GetSystemVerilogIndent()

  if exists('b:sv_indent_width')
    let offset = b:sv_indent_width
  else
    let offset = &sw
  endif
  if exists('b:sv_indent_modules')
    let indent_modules = offset
  else
    let indent_modules = 0
  endif

  " Find a non-blank, non-comment line above the current line.
  let lnum = s:PrevNonBlankNonComment(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  let lnum2 = s:PrevNonBlankNonComment(lnum - 1)
  let curr_line  = s:RemoveSVComment(getline(v:lnum))
  let last_line  = s:RemoveSVComment(getline(lnum))
  let last_line2 = s:RemoveSVComment(getline(lnum2))
  let ind  = indent(lnum)
  let offset_comment1 = 1
  " Define the condition of an open statement
  "   Exclude the match of //, /* or */
  let sv_openstat = '\%(\<or\>\|\%([*/]\)\@<![*(,{><+-/%^&|!=?:]\%([*/]\)\@!\)'
  " Define the condition when the statement ends with a one-line comment
  let sv_comment = '\%(\/\/.*\|\/\*.*\*\/\s*\)'
  let sv_block1_statement = '\%(`\@<!\<\%(if\|else\)\>\)\|' .
        \ '\%(^\s*\<\%(for\|case\%[zx]\|do\|foreach\|randcase\|randsequence' .
        \ '\|initial\|forever\|fork\|final\|specify' .
        \ '\|always\|always_comb\|always_ff\|always_latch\)\>\)'
  let sv_block2_statement = '^\s*\%(' .
        \ '\%(\<\%(clocking\|interface\|package' .
        \ '\|property\|program\|sequence\)\>\)\|' .
        \ '\%(\%(\<virtual\>\s*\)\=\<class\>\)\|' .
        \ '\%(\%(\<\S\+\s\+\)*\<\%(function\|task\)\>\)\|' .
        \ '\%(\%(\w\+\s*:\)\=\s*\<covergroup\>\)' .
        \ '\)'
  let sv_oneline_statement = '\<\%(' .
        \ '`\@<!if\|`\@<!else\|for\|always\|initial\|do\|foreach\|final' .
        \ '\)\>'
  let sv_end_statement = '\%(\<\%(' . 
        \ 'endclocking\|endinterface\|endpackage\|' .
        \ 'endproperty\|endprogram\|endsequence\|' .
        \ 'endclass\|endfunction\|endtask\|endgroup' .
        \ '\)\>\)'
  let sv_end_match = '\<\%(' .
        \ 'end\|else\|' . 
        \ 'end\%(case\|task\|function\|clocking\|interface\|program\|' .
        \ 'module\|class\|specify\|package\|sequence\|group\|property\)\|' . 
        \ 'join\|join_any\|join_none\)\>\|' .
        \ '[})]\|' .
        \ '`\<\%(else\|endif\)\>\|' .
        \ '`\<\%(uvm_\%(object\|component\)_utils_end\)\>'
       

  if exists('b:sv_indent_verbose')
    let vverb_str = 'INDENT VERBOSE:'
    let vverb = 1
  else
    let vverb = 0
  endif

  if last_line2 =~ sv_openstat . '\s*' . sv_comment . '*$'
    if vverb
      echo "last_line2 is open statement!\n"
    endif
  endif

  " Indent comment accoding to last line
  " End of multiple-line comment TODO
  if last_line =~ '\*/\s*$' && last_line !~ '/\*.\{-}\*/'
    let ind = ind - offset_comment1
    if vverb
      echo vverb_str "De-indent after a multiple-line comment.\n"
    endif

  " bypass single comment
  elseif last_line =~ '^\s*' . sv_comment
      if vverb | echo vverb_str "Skip Indent after a comment.\n" | endif

  endif

  " Indent accoding to last line
  " Indent after if/else/for/case/always/initial/specify/fork blocks
  if last_line =~ sv_block1_statement
    if last_line !~ '\%([;}]\|\<\%(end\|endcase\|endspecify\)\>\)\s*$'
      let ind = ind + offset
      if vverb | echo vverb_str "Indent after a if/else/for block statement.\n" | endif
    else
      if vverb | echo vverb_str "Fail Indent after a if/else/for block statement.\n" | endif
    endif
    
  " Indent after function/task/class/package/sequence/clocking/
  " interface/covergroup/property/program blocks
  elseif last_line =~ sv_block2_statement
    if last_line !~ sv_end_statement . '\s*$' &&
     \ last_line !~ '^\s*\<extern\>.*;\s*$'
      let ind = ind + offset
      if vverb
        echo vverb_str "Indent after function/task/class block statement.\n"
      endif
    else
      if vverb | echo vverb_str "Fail Indent after a function/task/class block statement.\n" | endif
    endif

  " Indent after multiple-line function/task stand-alone ');'
  elseif last_line =~ '^\s*)\s*;\s*$'
    let m_lnum  = s:GetSVBlockStart(')', lnum, 'line')
    if s:RemoveSVComment(getline(m_lnum)) =~ '\%(\%(\<\S\+\s\+\)*\<\%(function\|task\)\>\)' &&
     \ s:RemoveSVComment(getline(m_lnum)) !~ '^\s*\<\%(extern\|import\)\>'
      let ind = ind + offset
      if vverb
        echo vverb_str "Indent after a multiple-line function/task\n"
      endif
    endif

  " Indent after module blocks
  elseif last_line =~ '^\s*\%(\<extern\>\s*\)\=\<module\>'
    let ind = ind + indent_modules
    if vverb && indent_modules
      echo vverb_str "Indent after module statement.\n"
    endif
    if last_line =~ '[(,]\s*$'
      let ind = ind + offset
      if vverb
        echo vverb_str "Indent after a multiple-line module statement.\n"
      endif
    endif

  " Indent after a 'begin' statement
  elseif last_line =~ '\%(\<begin\>\)\%(\s*:\s*\S\+\)*\s*$' &&
    \ ( last_line2 !~ sv_openstat . '\s*$' ||
    \   last_line2 =~ '^\s*[^=!]\+\s*:\s*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after begin statement.\n" | endif

  " Indent after a '{' or a '('
  elseif last_line =~ '[{(]\s*$' &&
    \ ( last_line2 !~ sv_openstat . '\s*$' ||
    \   last_line2 =~ '^\s*[^=!]\+\s*:\s*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after {( statement.\n" | endif

  " Indent after a '`uvm_*_utils_begin'
  elseif last_line =~ '`uvm_\%(object\|component\)_utils_begin\>' &&
    \ ( last_line2 !~ sv_openstat . '\s*$' ||
    \   last_line2 =~ '^\s*[^=!]\+\s*:\s*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after uvm_utils_begin statement.\n" | endif

  " De-indent for the end of one-line block
  elseif ( last_line !~ '\<\%(begin\|else\)\>' &&
    \ last_line =~ ';\s*$' ) &&
    \ ( last_line2 =~ sv_oneline_statement . '.*$' &&
    \ last_line2 !~ sv_openstat . '\s*$' &&
    \ last_line2 !~  ';\s*$' &&
    \ last_line2 !~ '\<begin\>' ) 
    let ind = ind - offset
    if vverb
      echo vverb_str "De-indent after the end of one-line statement.\n"
    endif

  " Multiple-line statement (including case statement)
  " Open statement
  "   Ident the first open line
  elseif last_line =~ sv_openstat . '\s*$' &&
    \ last_line2 !~ sv_openstat . '\s*$'
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after an open statement.\n" | endif

  " Indent for `ifdef `else block
  elseif last_line =~ '^\s*`\<\%(ifdef\|else\)\>'
    let ind = ind + offset
    if vverb
      echo vverb_str "Indent after a `ifdef or `else statement.\n"
    endif

  endif

  " Re-indent current line

  " bypass single comment
  if s:IsSVLineComment(v:lnum)
      if getline(v:lnum) =~ '^\s*' . sv_comment &&
        \ last_line !~ sv_openstat . '\s*$' && last_line =~ ';\s*$' &&
        \ last_line2 =~ sv_openstat . '\s*$' && last_line2 !~ '[{]\s*$'
        let ind = ind - offset
        if vverb | echo vverb_str "De-indent Comment the end of a multiple statement.\n" | endif
      else
        if vverb | echo vverb_str "Skip De-Indent comment line.\n" | endif
      endif

  " De-indent on the end of the block
  " join/end/endcase/endfunction/endtask/endspecify
  " m_lnum : line of BlockStart
  " m_lnum2: previous line number of m_lnum
  elseif curr_line =~ '^\s*\%(' . sv_end_match . '\)' &&
      \ ( curr_line !~ '^\s*\<else\>' || last_line !~ '^\s*\%(\<end\>\|}[^;]\)' )
    let block_end = matchstr(curr_line, sv_end_match)
    let ind = s:GetSVBlockStart(block_end, v:lnum, 'indent')
    let m_lnum  = s:GetSVBlockStart(block_end, v:lnum, 'line')
    let m_lnum2 = s:PrevNonBlankNonComment(m_lnum-1)
    if s:RemoveSVComment(getline(m_lnum2)) =~ sv_openstat . '\s*$' &&
      \ s:RemoveSVComment(getline(m_lnum2)) !~ '[:{]\s*$'
      let ind = ind - offset
      if vverb | echo vverb_str "De-indent the end of a block(multiple statement).\n" | endif
    else
      if vverb | echo vverb_str "De-indent the end of a block.\n" | endif
    endif

  elseif curr_line =~ '^\s*\<endmodule\>'
    let ind = ind - indent_modules
    if vverb && indent_modules
      echo vverb_str "De-indent the end of a module.\n"
    endif

  " De-indent on a stand-alone 'begin'
  elseif curr_line =~ '^\s*\<begin\>' &&
       \ last_line !~ '\<begin\>'
    call cursor(v:lnum,1)
    let m_lnum = search('^\s*\%(\<\%(end\|if\|else\|for\|foreach\|' .
       \ 'always\|initial\|final\|fork\|repeat\|while\)\>\|'.
       \ '\%(\S\+::\)\=\%(\S\+\):\)' , 'bnW')
    let sb_lnum = search('\%(' . sv_block2_statement . '\)'
       \ , 'bnW', m_lnum)
    let ind = m_lnum>0 && m_lnum<v:lnum && sb_lnum==0 ? indent(m_lnum) : indent(lnum)
    if vverb
      echo vverb_str "De-indent a stand alone begin statement.\n" 'l:' lnum ',m:' m_lnum ',m2:' sb_lnum
    endif
 
  " De-indent on a stand-alone '{'
  elseif curr_line =~ '^\s*[{]' &&
       \ last_line !~ '[{]'
    call cursor(v:lnum,1)
    let m_lnum = search('^\s*\%(\<\%(if\|else\|foreach' .
       \ '\)\>\|' .
       \ '\%(`\<uvm_do\)\)' , 'bnW')
    let ind = m_lnum>0 && m_lnum<v:lnum ? indent(m_lnum) : indent(lnum)
    if vverb
      echo vverb_str "De-indent a stand alone { statement.\n" 'l:' lnum ',m:' m_lnum
    endif

  " ? TODO
  elseif curr_line =~ '^\s*`\<if\%[n]def\>'
    let ind  = indent(lnum)
    if vverb
      echo vverb_str "Indent after a `ifdef or `else statement.\n"
    endif

  " De-indent after the end of multiple-line statement
  "   excluding function/task/expression =
  elseif curr_line =~ '\S\+\s*$'
    if last_line !~ sv_openstat . '\s*$' && last_line =~ ';\s*$' &&
     \ last_line2 =~ sv_openstat . '\s*$' && last_line2 !~ '[{]\s*$'
      if last_line !~ ')\s*;\s*$'
        let ind = ind - offset
        if vverb | echo vverb_str "De-indent the end of a multiple statement.\n" | endif
      else
        let m_lnum  = s:GetSVBlockStart(')', lnum, 'line')
        if s:RemoveSVComment(getline(m_lnum)) !~ '\%(\%(\<\S\+\s\+\)*\<\%(function\|task\)\>\)\|' .
           \ '\%(\".\{-}\)\@<!\%([=]\)'
          let ind = ind - offset
          if vverb | echo vverb_str "De-indent the end of a multiple statement. with );\n" | endif
        else
          if vverb | echo vverb_str "Not De-indent the end of a multiple statement.\n" | endif
        endif
      endif
    endif

  endif

  " Return the indention
  return ind
endfunction

" vim:sw=2
zhimakaimen:/indent/systemverilog.vim
